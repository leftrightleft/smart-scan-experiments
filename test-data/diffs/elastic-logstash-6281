diff --git a/Gemfile.jruby-1.9.lock b/Gemfile.jruby-1.9.lock
new file mode 100644
index 00000000000..cf29142672f
--- /dev/null
+++ b/Gemfile.jruby-1.9.lock
@@ -0,0 +1,722 @@
+PATH
+  remote: ./logstash-core
+  specs:
+    logstash-core (6.0.0.pre.alpha1-java)
+      chronic_duration (= 0.10.6)
+      clamp (~> 0.6.5)
+      concurrent-ruby (= 1.0.0)
+      filesize (= 0.0.4)
+      gems (~> 0.8.3)
+      i18n (= 0.6.9)
+      jar-dependencies (~> 0.3.4)
+      jrjackson (~> 0.4.0)
+      jrmonitor (~> 0.4.2)
+      jruby-openssl (= 0.9.16)
+      logstash-core-event-java (= 6.0.0.pre.alpha1)
+      minitar (~> 0.5.4)
+      pry (~> 0.10.1)
+      puma (~> 2.16)
+      rubyzip (~> 1.1.7)
+      sinatra (~> 1.4, >= 1.4.6)
+      stud (~> 0.0.19)
+      thread_safe (~> 0.3.5)
+      treetop (< 1.5.0)
+
+PATH
+  remote: ./logstash-core-event-java
+  specs:
+    logstash-core-event-java (6.0.0.pre.alpha1-java)
+      jar-dependencies
+      ruby-maven (~> 3.3.9)
+
+PATH
+  remote: ./logstash-core-plugin-api
+  specs:
+    logstash-core-plugin-api (2.1.16-java)
+      logstash-core (= 6.0.0.pre.alpha1)
+
+GEM
+  remote: https://rubygems.org/
+  specs:
+    addressable (2.3.8)
+    arr-pm (0.0.10)
+      cabin (> 0)
+    atomic (1.1.99-java)
+    avl_tree (1.2.1)
+      atomic (~> 1.1)
+    awesome_print (1.7.0)
+    aws-sdk (2.3.22)
+      aws-sdk-resources (= 2.3.22)
+    aws-sdk-core (2.3.22)
+      jmespath (~> 1.0)
+    aws-sdk-resources (2.3.22)
+      aws-sdk-core (= 2.3.22)
+    aws-sdk-v1 (1.66.0)
+      json (~> 1.4)
+      nokogiri (>= 1.4.4)
+    backports (3.6.8)
+    benchmark-ips (2.7.2)
+    bindata (2.3.3)
+    buftok (0.2.0)
+    builder (3.2.2)
+    cabin (0.9.0)
+    childprocess (0.5.9)
+      ffi (~> 1.0, >= 1.0.11)
+    chronic_duration (0.10.6)
+      numerizer (~> 0.1.1)
+    ci_reporter (2.0.0)
+      builder (>= 2.1.2)
+    ci_reporter_rspec (1.0.0)
+      ci_reporter (~> 2.0)
+      rspec (>= 2.14, < 4)
+    cinch (2.3.2)
+    clamp (0.6.5)
+    coderay (1.1.1)
+    concurrent-ruby (1.0.0-java)
+    coveralls (0.8.15)
+      json (>= 1.8, < 3)
+      simplecov (~> 0.12.0)
+      term-ansicolor (~> 1.3)
+      thor (~> 0.19.1)
+      tins (>= 1.6.0, < 2)
+    diff-lcs (1.2.5)
+    docile (1.1.5)
+    domain_name (0.5.20160826)
+      unf (>= 0.0.5, < 1.0.0)
+    edn (1.1.1)
+    elasticsearch (1.1.0)
+      elasticsearch-api (= 1.1.0)
+      elasticsearch-transport (= 1.1.0)
+    elasticsearch-api (1.1.0)
+      multi_json
+    elasticsearch-transport (1.1.0)
+      faraday
+      multi_json
+    equalizer (0.0.10)
+    faraday (0.9.2)
+      multipart-post (>= 1.2, < 3)
+    ffi (1.9.14-java)
+    file-dependencies (0.1.6)
+      minitar
+    filesize (0.0.4)
+    filewatch (0.9.0)
+    fivemat (1.3.2)
+    flores (0.0.6)
+    fpm (1.3.3)
+      arr-pm (~> 0.0.9)
+      backports (>= 2.6.2)
+      cabin (>= 0.6.0)
+      childprocess
+      clamp (~> 0.6)
+      ffi
+      json (>= 1.7.7)
+    gelfd (0.2.0)
+    gem_publisher (1.5.0)
+    gems (0.8.3)
+    hitimes (1.2.4-java)
+    http (0.9.9)
+      addressable (~> 2.3)
+      http-cookie (~> 1.0)
+      http-form_data (~> 1.0.1)
+      http_parser.rb (~> 0.6.0)
+    http-cookie (1.0.2)
+      domain_name (~> 0.5)
+    http-form_data (1.0.1)
+    http_parser.rb (0.6.0-java)
+    i18n (0.6.9)
+    insist (1.0.0)
+    jar-dependencies (0.3.5)
+    jls-grok (0.11.3)
+      cabin (>= 0.6.0)
+    jls-lumberjack (0.0.26)
+      concurrent-ruby
+    jmespath (1.3.1)
+    jrjackson (0.4.0-java)
+    jrmonitor (0.4.2)
+    jruby-openssl (0.9.16-java)
+    jruby-stdin-channel (0.2.0-java)
+    json (1.8.3-java)
+    kramdown (1.12.0)
+    logstash-codec-collectd (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-dots (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-edn (3.0.2)
+      edn
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-edn_lines (3.0.2)
+      edn
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-es_bulk (3.0.2)
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-fluent (3.0.2-java)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      msgpack-jruby
+    logstash-codec-graphite (3.0.2)
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-json (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-json_lines (3.0.2)
+      logstash-codec-line (>= 2.1.0)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-line (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-msgpack (3.0.2-java)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      msgpack-jruby
+    logstash-codec-multiline (3.0.2)
+      jls-grok (~> 0.11.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-patterns-core
+    logstash-codec-netflow (3.1.2)
+      bindata (>= 1.5.0)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-plain (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-rubydebug (3.0.2)
+      awesome_print
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-devutils (1.1.0-java)
+      fivemat
+      gem_publisher
+      insist (= 1.0.0)
+      kramdown
+      logstash-core-plugin-api (~> 2.0)
+      minitar
+      rake
+      rspec (~> 3.0)
+      rspec-wait
+      stud (>= 0.0.20)
+    logstash-filter-clone (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-csv (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-date (3.0.3)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-dns (3.0.3)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      lru_redux (~> 1.1.0)
+    logstash-filter-drop (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-fingerprint (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      murmurhash3
+    logstash-filter-geoip (4.0.3-java)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-grok (3.2.1)
+      jls-grok (~> 0.11.3)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-patterns-core
+    logstash-filter-json (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-kv (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-metrics (4.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      metriks
+      thread_safe
+    logstash-filter-mutate (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-ruby (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-filter-date
+    logstash-filter-sleep (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-split (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-syslog_pri (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-throttle (4.0.0)
+      atomic
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      thread_safe
+    logstash-filter-urldecode (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-useragent (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      lru_redux (~> 1.1.0)
+      user_agent_parser (>= 2.0.0)
+    logstash-filter-uuid (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-xml (4.0.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      nokogiri
+      xml-simple
+    logstash-input-beats (3.1.3-java)
+      concurrent-ruby (>= 0.9.2, <= 1.0.0)
+      jar-dependencies (~> 0.3.4)
+      logstash-codec-multiline (>= 2.0.5)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      thread_safe (~> 0.3.5)
+    logstash-input-couchdb_changes (3.0.2)
+      json
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (>= 0.0.22)
+    logstash-input-elasticsearch (3.0.2)
+      elasticsearch (~> 1.0, >= 1.0.6)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-exec (3.1.1)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-file (3.1.1)
+      addressable
+      filewatch (~> 0.8, >= 0.8.1)
+      logstash-codec-multiline (~> 3.0)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-ganglia (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-gelf (3.0.2)
+      gelfd (= 0.2.0)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-generator (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-graphite (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-input-tcp
+    logstash-input-heartbeat (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud
+    logstash-input-http (3.0.3)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      puma (~> 2.16, >= 2.16.0)
+      rack (~> 1)
+      stud
+    logstash-input-http_poller (3.1.0)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-http_client (>= 2.2.4, < 5.0.0)
+      rufus-scheduler (~> 3.0.9)
+      stud (~> 0.0.22)
+    logstash-input-imap (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      mail (~> 2.6.3)
+      mime-types (= 2.6.2)
+      stud (~> 0.0.22)
+    logstash-input-irc (3.0.2)
+      cinch
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-jdbc (4.1.1)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      rufus-scheduler
+      sequel
+      tzinfo
+      tzinfo-data
+    logstash-input-kafka (5.0.4)
+      logstash-codec-json
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (>= 0.0.22, < 0.1.0)
+    logstash-input-log4j (3.0.3-java)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-lumberjack (3.1.1)
+      concurrent-ruby
+      jls-lumberjack (~> 0.0.26)
+      logstash-codec-multiline (~> 3.0)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-pipe (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-rabbitmq (5.1.1)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-rabbitmq_connection (>= 4.1.1, < 5.0.0)
+    logstash-input-redis (3.1.1)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      redis
+    logstash-input-s3 (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws
+      stud (~> 0.0.18)
+    logstash-input-snmptrap (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      snmp
+    logstash-input-sqs (3.0.2)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws (>= 1.0.0)
+    logstash-input-stdin (3.2.0)
+      concurrent-ruby
+      jruby-stdin-channel
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-syslog (3.0.2)
+      concurrent-ruby
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-filter-date
+      logstash-filter-grok
+      stud (>= 0.0.22, < 0.1.0)
+      thread_safe
+    logstash-input-tcp (4.0.3)
+      logstash-codec-json
+      logstash-codec-json_lines
+      logstash-codec-line
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-twitter (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (>= 0.0.22, < 0.1)
+      twitter (= 5.15.0)
+    logstash-input-udp (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-unix (3.0.2)
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-xmpp (3.1.1)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      xmpp4r (= 0.5)
+    logstash-mixin-aws (4.2.0)
+      aws-sdk (~> 2.3.0)
+      aws-sdk-v1 (>= 1.61.0)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-mixin-http_client (4.0.3)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      manticore (>= 0.5.2, < 1.0.0)
+    logstash-mixin-rabbitmq_connection (4.1.2-java)
+      march_hare (~> 2.15.0)
+      stud (~> 0.0.22)
+    logstash-output-cloudwatch (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws (>= 1.0.0)
+      rufus-scheduler (~> 3.0.9)
+    logstash-output-csv (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-filter-json
+      logstash-input-generator
+      logstash-output-file
+    logstash-output-elasticsearch (5.1.1-java)
+      cabin (~> 0.6)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      manticore (>= 0.5.4, < 1.0.0)
+      stud (~> 0.0, >= 0.0.17)
+    logstash-output-file (4.0.0)
+      logstash-codec-json_lines
+      logstash-codec-line
+      logstash-core-plugin-api (>= 2.0.0, < 2.99)
+    logstash-output-graphite (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-http (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-http_client (>= 2.2.1, < 5.0.0)
+    logstash-output-irc (3.0.2)
+      cinch
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-kafka (5.0.4)
+      logstash-codec-json
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-nagios (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-null (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-pagerduty (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-pipe (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-rabbitmq (4.0.4-java)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-rabbitmq_connection (>= 4.1.1, < 5.0.0)
+    logstash-output-redis (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      redis
+      stud
+    logstash-output-s3 (3.2.0)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws
+      stud (~> 0.0.22)
+    logstash-output-sns (4.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws (>= 1.0.0)
+    logstash-output-sqs (3.0.2)
+      aws-sdk
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws (>= 1.0.0)
+      stud
+    logstash-output-statsd (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-input-generator
+      statsd-ruby (= 1.2.0)
+    logstash-output-stdout (3.1.0)
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60.1, < 2.99)
+    logstash-output-tcp (4.0.0)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud
+    logstash-output-udp (3.0.2)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-webhdfs (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      snappy (= 0.0.12)
+      webhdfs
+    logstash-output-xmpp (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      xmpp4r (= 0.5)
+    logstash-patterns-core (4.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    lru_redux (1.1.0)
+    mail (2.6.4)
+      mime-types (>= 1.16, < 4)
+    manticore (0.6.0-java)
+    march_hare (2.15.0-java)
+    memoizable (0.4.2)
+      thread_safe (~> 0.3, >= 0.3.1)
+    method_source (0.8.2)
+    metriks (0.9.9.7)
+      atomic (~> 1.0)
+      avl_tree (~> 1.2.0)
+      hitimes (~> 1.1)
+    mime-types (2.6.2)
+    minitar (0.5.4)
+    msgpack-jruby (1.4.1-java)
+    multi_json (1.12.1)
+    multipart-post (2.0.0)
+    murmurhash3 (0.1.6-java)
+    mustache (0.99.8)
+    naught (1.1.0)
+    nokogiri (1.6.8-java)
+    numerizer (0.1.1)
+    octokit (3.8.0)
+      sawyer (~> 0.6.0, >= 0.5.3)
+    pleaserun (0.0.24)
+      cabin (> 0)
+      clamp
+      insist
+      mustache (= 0.99.8)
+      stud
+    polyglot (0.3.5)
+    pry (0.10.4-java)
+      coderay (~> 1.1.0)
+      method_source (~> 0.8.1)
+      slop (~> 3.4)
+      spoon (~> 0.0)
+    puma (2.16.0-java)
+    rack (1.6.4)
+    rack-protection (1.5.3)
+      rack
+    rack-test (0.6.3)
+      rack (>= 1.0)
+    rake (11.2.2)
+    redis (3.3.1)
+    rspec (3.1.0)
+      rspec-core (~> 3.1.0)
+      rspec-expectations (~> 3.1.0)
+      rspec-mocks (~> 3.1.0)
+    rspec-core (3.1.7)
+      rspec-support (~> 3.1.0)
+    rspec-expectations (3.1.2)
+      diff-lcs (>= 1.2.0, < 2.0)
+      rspec-support (~> 3.1.0)
+    rspec-mocks (3.1.3)
+      rspec-support (~> 3.1.0)
+    rspec-support (3.1.2)
+    rspec-wait (0.0.9)
+      rspec (>= 3, < 4)
+    ruby-maven (3.3.12)
+      ruby-maven-libs (~> 3.3.9)
+    ruby-maven-libs (3.3.9)
+    rubyzip (1.1.7)
+    rufus-scheduler (3.0.9)
+      tzinfo
+    sawyer (0.6.0)
+      addressable (~> 2.3.5)
+      faraday (~> 0.8, < 0.10)
+    sequel (4.38.0)
+    simple_oauth (0.3.1)
+    simplecov (0.12.0)
+      docile (~> 1.1.0)
+      json (>= 1.8, < 3)
+      simplecov-html (~> 0.10.0)
+    simplecov-html (0.10.0)
+    sinatra (1.4.7)
+      rack (~> 1.5)
+      rack-protection (~> 1.4)
+      tilt (>= 1.3, < 3)
+    slop (3.6.0)
+    snappy (0.0.12-java)
+      snappy-jars (~> 1.1.0)
+    snappy-jars (1.1.0.1.2-java)
+    snmp (1.2.0)
+    spoon (0.0.6)
+      ffi
+    statsd-ruby (1.2.0)
+    stud (0.0.22)
+    term-ansicolor (1.3.2)
+      tins (~> 1.0)
+    thor (0.19.1)
+    thread_safe (0.3.5-java)
+    tilt (2.0.5)
+    tins (1.6.0)
+    treetop (1.4.15)
+      polyglot
+      polyglot (>= 0.3.1)
+    twitter (5.15.0)
+      addressable (~> 2.3)
+      buftok (~> 0.2.0)
+      equalizer (= 0.0.10)
+      faraday (~> 0.9.0)
+      http (>= 0.4, < 0.10)
+      http_parser.rb (~> 0.6.0)
+      json (~> 1.8)
+      memoizable (~> 0.4.0)
+      naught (~> 1.0)
+      simple_oauth (~> 0.3.0)
+    tzinfo (1.2.2)
+      thread_safe (~> 0.1)
+    tzinfo-data (1.2016.6)
+      tzinfo (>= 1.0.0)
+    unf (0.1.4-java)
+    user_agent_parser (2.3.0)
+    webhdfs (0.8.0)
+      addressable
+    xml-simple (1.1.5)
+    xmpp4r (0.5)
+
+PLATFORMS
+  java
+
+DEPENDENCIES
+  benchmark-ips
+  ci_reporter_rspec (= 1.0.0)
+  coveralls
+  file-dependencies (= 0.1.6)
+  flores (~> 0.0.6)
+  fpm (~> 1.3.3)
+  gems (~> 0.8.3)
+  logstash-codec-collectd
+  logstash-codec-dots
+  logstash-codec-edn
+  logstash-codec-edn_lines
+  logstash-codec-es_bulk
+  logstash-codec-fluent
+  logstash-codec-graphite
+  logstash-codec-json
+  logstash-codec-json_lines
+  logstash-codec-line
+  logstash-codec-msgpack
+  logstash-codec-multiline
+  logstash-codec-netflow
+  logstash-codec-plain
+  logstash-codec-rubydebug
+  logstash-core!
+  logstash-core-event-java!
+  logstash-core-plugin-api!
+  logstash-devutils (~> 1.1)
+  logstash-filter-clone
+  logstash-filter-csv
+  logstash-filter-date
+  logstash-filter-dns
+  logstash-filter-drop
+  logstash-filter-fingerprint
+  logstash-filter-geoip
+  logstash-filter-grok
+  logstash-filter-json
+  logstash-filter-kv
+  logstash-filter-metrics
+  logstash-filter-mutate
+  logstash-filter-ruby
+  logstash-filter-sleep
+  logstash-filter-split
+  logstash-filter-syslog_pri
+  logstash-filter-throttle
+  logstash-filter-urldecode
+  logstash-filter-useragent
+  logstash-filter-uuid
+  logstash-filter-xml
+  logstash-input-beats
+  logstash-input-couchdb_changes
+  logstash-input-elasticsearch
+  logstash-input-exec
+  logstash-input-file
+  logstash-input-ganglia
+  logstash-input-gelf
+  logstash-input-generator
+  logstash-input-graphite
+  logstash-input-heartbeat
+  logstash-input-http
+  logstash-input-http_poller
+  logstash-input-imap
+  logstash-input-irc
+  logstash-input-jdbc
+  logstash-input-kafka
+  logstash-input-log4j
+  logstash-input-lumberjack
+  logstash-input-pipe
+  logstash-input-rabbitmq
+  logstash-input-redis
+  logstash-input-s3
+  logstash-input-snmptrap
+  logstash-input-sqs
+  logstash-input-stdin
+  logstash-input-syslog
+  logstash-input-tcp
+  logstash-input-twitter
+  logstash-input-udp
+  logstash-input-unix
+  logstash-input-xmpp
+  logstash-output-cloudwatch
+  logstash-output-csv
+  logstash-output-elasticsearch
+  logstash-output-file
+  logstash-output-graphite
+  logstash-output-http
+  logstash-output-irc
+  logstash-output-kafka
+  logstash-output-nagios
+  logstash-output-null
+  logstash-output-pagerduty
+  logstash-output-pipe
+  logstash-output-rabbitmq
+  logstash-output-redis
+  logstash-output-s3
+  logstash-output-sns
+  logstash-output-sqs
+  logstash-output-statsd
+  logstash-output-stdout
+  logstash-output-tcp
+  logstash-output-udp
+  logstash-output-webhdfs
+  logstash-output-xmpp
+  octokit (= 3.8.0)
+  pleaserun
+  rack-test
+  rspec (~> 3.1.0)
+  rubyzip (~> 1.1.7)
+  simplecov
+  stud (~> 0.0.22)
+  tins (= 1.6)
diff --git a/Gemfile.lock b/Gemfile.lock
new file mode 100644
index 00000000000..47685567665
--- /dev/null
+++ b/Gemfile.lock
@@ -0,0 +1,726 @@
+PATH
+  remote: ./logstash-core-event-java
+  specs:
+    logstash-core-event-java (6.0.0.pre.alpha1-java)
+      jar-dependencies
+      ruby-maven (~> 3.3.9)
+
+PATH
+  remote: ./logstash-core-plugin-api
+  specs:
+    logstash-core-plugin-api (2.1.16-java)
+      logstash-core (= 6.0.0.pre.alpha1)
+
+PATH
+  remote: ./logstash-core
+  specs:
+    logstash-core (6.0.0.pre.alpha1-java)
+      chronic_duration (= 0.10.6)
+      clamp (~> 0.6.5)
+      concurrent-ruby (= 1.0.0)
+      filesize (= 0.0.4)
+      gems (~> 0.8.3)
+      i18n (= 0.6.9)
+      jar-dependencies (~> 0.3.4)
+      jrjackson (~> 0.4.0)
+      jrmonitor (~> 0.4.2)
+      jruby-openssl (= 0.9.16)
+      logstash-core-event-java (= 6.0.0.pre.alpha1)
+      minitar (~> 0.5.4)
+      pry (~> 0.10.1)
+      puma (~> 2.16)
+      rubyzip (~> 1.1.7)
+      sinatra (~> 1.4, >= 1.4.6)
+      stud (~> 0.0.19)
+      term-ansicolor (~> 1.3.2)
+      thread_safe (~> 0.3.5)
+      treetop (< 1.5.0)
+
+GEM
+  remote: https://rubygems.org/
+  specs:
+    addressable (2.3.8)
+    arr-pm (0.0.10)
+      cabin (> 0)
+    atomic (1.1.99-java)
+    avl_tree (1.2.1)
+      atomic (~> 1.1)
+    awesome_print (1.7.0)
+    aws-sdk (2.3.22)
+      aws-sdk-resources (= 2.3.22)
+    aws-sdk-core (2.3.22)
+      jmespath (~> 1.0)
+    aws-sdk-resources (2.3.22)
+      aws-sdk-core (= 2.3.22)
+    aws-sdk-v1 (1.66.0)
+      json (~> 1.4)
+      nokogiri (>= 1.4.4)
+    backports (3.6.8)
+    benchmark-ips (2.7.2)
+    bindata (2.3.3)
+    buftok (0.2.0)
+    builder (3.2.2)
+    cabin (0.9.0)
+    childprocess (0.5.9)
+      ffi (~> 1.0, >= 1.0.11)
+    chronic_duration (0.10.6)
+      numerizer (~> 0.1.1)
+    ci_reporter (2.0.0)
+      builder (>= 2.1.2)
+    ci_reporter_rspec (1.0.0)
+      ci_reporter (~> 2.0)
+      rspec (>= 2.14, < 4)
+    cinch (2.3.2)
+    clamp (0.6.5)
+    coderay (1.1.1)
+    concurrent-ruby (1.0.0-java)
+    coveralls (0.8.15)
+      json (>= 1.8, < 3)
+      simplecov (~> 0.12.0)
+      term-ansicolor (~> 1.3)
+      thor (~> 0.19.1)
+      tins (>= 1.6.0, < 2)
+    diff-lcs (1.2.5)
+    docile (1.1.5)
+    domain_name (0.5.20160826)
+      unf (>= 0.0.5, < 1.0.0)
+    edn (1.1.1)
+    elasticsearch (1.1.0)
+      elasticsearch-api (= 1.1.0)
+      elasticsearch-transport (= 1.1.0)
+    elasticsearch-api (1.1.0)
+      multi_json
+    elasticsearch-transport (1.1.0)
+      faraday
+      multi_json
+    equalizer (0.0.10)
+    faraday (0.9.2)
+      multipart-post (>= 1.2, < 3)
+    ffi (1.9.14-java)
+    file-dependencies (0.1.6)
+      minitar
+    filesize (0.0.4)
+    filewatch (0.9.0)
+    fivemat (1.3.2)
+    flores (0.0.6)
+    fpm (1.3.3)
+      arr-pm (~> 0.0.9)
+      backports (>= 2.6.2)
+      cabin (>= 0.6.0)
+      childprocess
+      clamp (~> 0.6)
+      ffi
+      json (>= 1.7.7)
+    gelfd (0.2.0)
+    gem_publisher (1.5.0)
+    gems (0.8.3)
+    hitimes (1.2.4-java)
+    http (0.9.9)
+      addressable (~> 2.3)
+      http-cookie (~> 1.0)
+      http-form_data (~> 1.0.1)
+      http_parser.rb (~> 0.6.0)
+    http-cookie (1.0.2)
+      domain_name (~> 0.5)
+    http-form_data (1.0.1)
+    http_parser.rb (0.6.0-java)
+    i18n (0.6.9)
+    insist (1.0.0)
+    jar-dependencies (0.3.5)
+    jls-grok (0.11.4)
+      cabin (>= 0.6.0)
+    jls-lumberjack (0.0.26)
+      concurrent-ruby
+    jmespath (1.3.1)
+    jrjackson (0.4.0-java)
+    jrmonitor (0.4.2)
+    jruby-openssl (0.9.16-java)
+    jruby-stdin-channel (0.2.0-java)
+    json (1.8.3-java)
+    kramdown (1.12.0)
+    logstash-codec-collectd (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-dots (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-edn (3.0.2)
+      edn
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-edn_lines (3.0.2)
+      edn
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-es_bulk (3.0.2)
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-fluent (3.0.2-java)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      msgpack-jruby
+    logstash-codec-graphite (3.0.2)
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-json (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-json_lines (3.0.2)
+      logstash-codec-line (>= 2.1.0)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-line (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-msgpack (3.0.2-java)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      msgpack-jruby
+    logstash-codec-multiline (3.0.3)
+      jls-grok (~> 0.11.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-patterns-core
+    logstash-codec-netflow (3.1.2)
+      bindata (>= 1.5.0)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-plain (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-codec-rubydebug (3.0.2)
+      awesome_print
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-devutils (1.1.0-java)
+      fivemat
+      gem_publisher
+      insist (= 1.0.0)
+      kramdown
+      logstash-core-plugin-api (~> 2.0)
+      minitar
+      rake
+      rspec (~> 3.0)
+      rspec-wait
+      stud (>= 0.0.20)
+    logstash-filter-clone (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-csv (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-date (3.0.3)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-dns (3.0.3)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      lru_redux (~> 1.1.0)
+    logstash-filter-drop (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-fingerprint (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      murmurhash3
+    logstash-filter-geoip (4.0.3-java)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-grok (3.2.2)
+      jls-grok (~> 0.11.3)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-patterns-core
+    logstash-filter-json (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-kv (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-metrics (4.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      metriks
+      thread_safe
+    logstash-filter-mutate (3.1.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-ruby (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-filter-date
+    logstash-filter-sleep (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-split (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-syslog_pri (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-throttle (4.0.1)
+      atomic
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      thread_safe
+    logstash-filter-urldecode (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-useragent (3.0.3)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      lru_redux (~> 1.1.0)
+      user_agent_parser (>= 2.0.0)
+    logstash-filter-uuid (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-filter-xml (4.0.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      nokogiri
+      xml-simple
+    logstash-input-beats (3.1.6-java)
+      concurrent-ruby (>= 0.9.2, <= 1.0.0)
+      jar-dependencies (~> 0.3.4)
+      logstash-codec-multiline (>= 2.0.5)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      thread_safe (~> 0.3.5)
+    logstash-input-couchdb_changes (3.0.2)
+      json
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (>= 0.0.22)
+    logstash-input-elasticsearch (3.0.2)
+      elasticsearch (~> 1.0, >= 1.0.6)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-exec (3.1.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-file (3.1.2)
+      addressable
+      filewatch (~> 0.8, >= 0.8.1)
+      logstash-codec-multiline (~> 3.0)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-ganglia (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-gelf (3.0.2)
+      gelfd (= 0.2.0)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-generator (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-graphite (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-input-tcp
+    logstash-input-heartbeat (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud
+    logstash-input-http (3.0.3)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      puma (~> 2.16, >= 2.16.0)
+      rack (~> 1)
+      stud
+    logstash-input-http_poller (3.1.0)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-http_client (>= 2.2.4, < 5.0.0)
+      rufus-scheduler (~> 3.0.9)
+      stud (~> 0.0.22)
+    logstash-input-imap (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      mail (~> 2.6.3)
+      mime-types (= 2.6.2)
+      stud (~> 0.0.22)
+    logstash-input-irc (3.0.2)
+      cinch
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-jdbc (4.1.1)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      rufus-scheduler
+      sequel
+      tzinfo
+      tzinfo-data
+    logstash-input-kafka (5.0.5)
+      logstash-codec-json
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (>= 0.0.22, < 0.1.0)
+    logstash-input-log4j (3.0.3-java)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-lumberjack (3.1.1)
+      concurrent-ruby
+      jls-lumberjack (~> 0.0.26)
+      logstash-codec-multiline (~> 3.0)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-pipe (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-rabbitmq (5.1.1)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-rabbitmq_connection (>= 4.1.1, < 5.0.0)
+    logstash-input-redis (3.1.1)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      redis
+    logstash-input-s3 (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws
+      stud (~> 0.0.18)
+    logstash-input-snmptrap (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      snmp
+    logstash-input-sqs (3.0.2)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws (>= 1.0.0)
+    logstash-input-stdin (3.2.0)
+      concurrent-ruby
+      jruby-stdin-channel
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-syslog (3.1.1)
+      concurrent-ruby
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-filter-date
+      logstash-filter-grok
+      stud (>= 0.0.22, < 0.1.0)
+      thread_safe
+    logstash-input-tcp (4.0.3)
+      logstash-codec-json
+      logstash-codec-json_lines
+      logstash-codec-line
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-twitter (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (>= 0.0.22, < 0.1)
+      twitter (= 5.15.0)
+    logstash-input-udp (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud (~> 0.0.22)
+    logstash-input-unix (3.0.2)
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-input-xmpp (3.1.1)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      xmpp4r (= 0.5)
+    logstash-mixin-aws (4.2.0)
+      aws-sdk (~> 2.3.0)
+      aws-sdk-v1 (>= 1.61.0)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-mixin-http_client (4.0.3)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      manticore (>= 0.5.2, < 1.0.0)
+    logstash-mixin-rabbitmq_connection (4.1.2-java)
+      march_hare (~> 2.15.0)
+      stud (~> 0.0.22)
+    logstash-output-cloudwatch (3.0.3)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws (>= 1.0.0)
+      rufus-scheduler (~> 3.0.9)
+    logstash-output-csv (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-filter-json
+      logstash-input-generator
+      logstash-output-file
+    logstash-output-elasticsearch (5.1.1-java)
+      cabin (~> 0.6)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      manticore (>= 0.5.4, < 1.0.0)
+      stud (~> 0.0, >= 0.0.17)
+    logstash-output-file (4.0.1)
+      logstash-codec-json_lines
+      logstash-codec-line
+      logstash-core-plugin-api (>= 2.0.0, < 2.99)
+    logstash-output-graphite (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-http (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-http_client (>= 2.2.1, < 5.0.0)
+    logstash-output-irc (3.0.2)
+      cinch
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-kafka (5.0.4)
+      logstash-codec-json
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-nagios (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-null (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-pagerduty (3.0.3)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-pipe (3.0.2)
+      logstash-codec-plain
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-rabbitmq (4.0.4-java)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-rabbitmq_connection (>= 4.1.1, < 5.0.0)
+    logstash-output-redis (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      redis
+      stud
+    logstash-output-s3 (3.2.0)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws
+      stud (~> 0.0.22)
+    logstash-output-sns (4.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws (>= 1.0.0)
+    logstash-output-sqs (3.0.2)
+      aws-sdk
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-mixin-aws (>= 1.0.0)
+      stud
+    logstash-output-statsd (3.1.1)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      logstash-input-generator
+      statsd-ruby (= 1.2.0)
+    logstash-output-stdout (3.1.0)
+      logstash-codec-line
+      logstash-core-plugin-api (>= 1.60.1, < 2.99)
+    logstash-output-tcp (4.0.0)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      stud
+    logstash-output-udp (3.0.2)
+      logstash-codec-json
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    logstash-output-webhdfs (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      snappy (= 0.0.12)
+      webhdfs
+    logstash-output-xmpp (3.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+      xmpp4r (= 0.5)
+    logstash-patterns-core (4.0.2)
+      logstash-core-plugin-api (>= 1.60, <= 2.99)
+    lru_redux (1.1.0)
+    mail (2.6.4)
+      mime-types (>= 1.16, < 4)
+    manticore (0.6.0-java)
+    march_hare (2.15.0-java)
+    memoizable (0.4.2)
+      thread_safe (~> 0.3, >= 0.3.1)
+    method_source (0.8.2)
+    metriks (0.9.9.7)
+      atomic (~> 1.0)
+      avl_tree (~> 1.2.0)
+      hitimes (~> 1.1)
+    mime-types (2.6.2)
+    minitar (0.5.4)
+    msgpack-jruby (1.4.1-java)
+    multi_json (1.12.1)
+    multipart-post (2.0.0)
+    murmurhash3 (0.1.6-java)
+    mustache (0.99.8)
+    naught (1.1.0)
+    nokogiri (1.6.8-java)
+    numerizer (0.1.1)
+    octokit (3.8.0)
+      sawyer (~> 0.6.0, >= 0.5.3)
+    pleaserun (0.0.24)
+      cabin (> 0)
+      clamp
+      insist
+      mustache (= 0.99.8)
+      stud
+    polyglot (0.3.5)
+    pry (0.10.4-java)
+      coderay (~> 1.1.0)
+      method_source (~> 0.8.1)
+      slop (~> 3.4)
+      spoon (~> 0.0)
+    puma (2.16.0-java)
+    rack (1.6.4)
+    rack-protection (1.5.3)
+      rack
+    rack-test (0.6.3)
+      rack (>= 1.0)
+    rake (11.3.0)
+    redis (3.3.1)
+    rspec (3.1.0)
+      rspec-core (~> 3.1.0)
+      rspec-expectations (~> 3.1.0)
+      rspec-mocks (~> 3.1.0)
+    rspec-core (3.1.7)
+      rspec-support (~> 3.1.0)
+    rspec-expectations (3.1.2)
+      diff-lcs (>= 1.2.0, < 2.0)
+      rspec-support (~> 3.1.0)
+    rspec-mocks (3.1.3)
+      rspec-support (~> 3.1.0)
+    rspec-support (3.1.2)
+    rspec-wait (0.0.9)
+      rspec (>= 3, < 4)
+    ruby-maven (3.3.12)
+      ruby-maven-libs (~> 3.3.9)
+    ruby-maven-libs (3.3.9)
+    rubyzip (1.1.7)
+    rufus-scheduler (3.0.9)
+      tzinfo
+    sawyer (0.6.0)
+      addressable (~> 2.3.5)
+      faraday (~> 0.8, < 0.10)
+    sequel (4.38.0)
+    simple_oauth (0.3.1)
+    simplecov (0.12.0)
+      docile (~> 1.1.0)
+      json (>= 1.8, < 3)
+      simplecov-html (~> 0.10.0)
+    simplecov-html (0.10.0)
+    sinatra (1.4.7)
+      rack (~> 1.5)
+      rack-protection (~> 1.4)
+      tilt (>= 1.3, < 3)
+    slop (3.6.0)
+    snappy (0.0.12-java)
+      snappy-jars (~> 1.1.0)
+    snappy-jars (1.1.0.1.2-java)
+    snmp (1.2.0)
+    spoon (0.0.6)
+      ffi
+    statsd-ruby (1.2.0)
+    stud (0.0.22)
+    term-ansicolor (1.3.2)
+      tins (~> 1.0)
+    thor (0.19.1)
+    thread_safe (0.3.5-java)
+    tilt (2.0.5)
+    tins (1.6.0)
+    treetop (1.4.15)
+      polyglot
+      polyglot (>= 0.3.1)
+    twitter (5.15.0)
+      addressable (~> 2.3)
+      buftok (~> 0.2.0)
+      equalizer (= 0.0.10)
+      faraday (~> 0.9.0)
+      http (>= 0.4, < 0.10)
+      http_parser.rb (~> 0.6.0)
+      json (~> 1.8)
+      memoizable (~> 0.4.0)
+      naught (~> 1.0)
+      simple_oauth (~> 0.3.0)
+    tzinfo (1.2.2)
+      thread_safe (~> 0.1)
+    tzinfo-data (1.2016.7)
+      tzinfo (>= 1.0.0)
+    unf (0.1.4-java)
+    user_agent_parser (2.3.0)
+    webhdfs (0.8.0)
+      addressable
+    xml-simple (1.1.5)
+    xmpp4r (0.5)
+
+PLATFORMS
+  java
+
+DEPENDENCIES
+  benchmark-ips
+  ci_reporter_rspec (= 1.0.0)
+  coveralls
+  file-dependencies (= 0.1.6)
+  flores (~> 0.0.6)
+  fpm (~> 1.3.3)
+  gems (~> 0.8.3)
+  logstash-codec-collectd
+  logstash-codec-dots
+  logstash-codec-edn
+  logstash-codec-edn_lines
+  logstash-codec-es_bulk
+  logstash-codec-fluent
+  logstash-codec-graphite
+  logstash-codec-json
+  logstash-codec-json_lines
+  logstash-codec-line
+  logstash-codec-msgpack
+  logstash-codec-multiline
+  logstash-codec-netflow
+  logstash-codec-plain
+  logstash-codec-rubydebug
+  logstash-core!
+  logstash-core-event-java!
+  logstash-core-plugin-api!
+  logstash-devutils (~> 1.1)
+  logstash-filter-clone
+  logstash-filter-csv
+  logstash-filter-date
+  logstash-filter-dns
+  logstash-filter-drop
+  logstash-filter-fingerprint
+  logstash-filter-geoip
+  logstash-filter-grok
+  logstash-filter-json
+  logstash-filter-kv
+  logstash-filter-metrics
+  logstash-filter-mutate
+  logstash-filter-ruby
+  logstash-filter-sleep
+  logstash-filter-split
+  logstash-filter-syslog_pri
+  logstash-filter-throttle
+  logstash-filter-urldecode
+  logstash-filter-useragent
+  logstash-filter-uuid
+  logstash-filter-xml
+  logstash-input-beats
+  logstash-input-couchdb_changes
+  logstash-input-elasticsearch
+  logstash-input-exec
+  logstash-input-file
+  logstash-input-ganglia
+  logstash-input-gelf
+  logstash-input-generator
+  logstash-input-graphite
+  logstash-input-heartbeat
+  logstash-input-http
+  logstash-input-http_poller
+  logstash-input-imap
+  logstash-input-irc
+  logstash-input-jdbc
+  logstash-input-kafka
+  logstash-input-log4j
+  logstash-input-lumberjack
+  logstash-input-pipe
+  logstash-input-rabbitmq
+  logstash-input-redis
+  logstash-input-s3
+  logstash-input-snmptrap
+  logstash-input-sqs
+  logstash-input-stdin
+  logstash-input-syslog
+  logstash-input-tcp
+  logstash-input-twitter
+  logstash-input-udp
+  logstash-input-unix
+  logstash-input-xmpp
+  logstash-output-cloudwatch
+  logstash-output-csv
+  logstash-output-elasticsearch
+  logstash-output-file
+  logstash-output-graphite
+  logstash-output-http
+  logstash-output-irc
+  logstash-output-kafka
+  logstash-output-nagios
+  logstash-output-null
+  logstash-output-pagerduty
+  logstash-output-pipe
+  logstash-output-rabbitmq
+  logstash-output-redis
+  logstash-output-s3
+  logstash-output-sns
+  logstash-output-sqs
+  logstash-output-statsd
+  logstash-output-stdout
+  logstash-output-tcp
+  logstash-output-udp
+  logstash-output-webhdfs
+  logstash-output-xmpp
+  octokit (= 3.8.0)
+  pleaserun
+  rack-test
+  rspec (~> 3.1.0)
+  rubyzip (~> 1.1.7)
+  simplecov
+  stud (~> 0.0.22)
+  tins (= 1.6)
+
+BUNDLED WITH
+   1.12.5
diff --git a/logstash-core/lib/logstash/compiler.rb b/logstash-core/lib/logstash/compiler.rb
new file mode 100644
index 00000000000..de5d4e29f91
--- /dev/null
+++ b/logstash-core/lib/logstash/compiler.rb
@@ -0,0 +1,200 @@
+require 'logstash/util/loggable'
+require 'logstash/output_delegator_strategy_registry'
+
+java_import org.logstash.config.ir.Pipeline
+java_import org.logstash.config.pipeline.PipelineRunner;
+java_import org.logstash.config.pipeline.pipette.PipetteExecutionException;
+java_import org.logstash.config.pipeline.pipette.PipetteSourceEmitter;
+java_import org.logstash.config.ir.graph.Graph;
+java_import org.logstash.config.ir.graph.PluginVertex;
+java_import java.util.concurrent.SynchronousQueue;
+java_import org.logstash.config.compiler.RubyExpressionCompiler;
+java_import org.logstash.config.pipeline.pipette.PipetteSourceEmitter
+
+module LogStash; class Compiler
+  include ::LogStash::Util::Loggable
+
+  class CompiledRubyInput
+    include org.logstash.config.compiler.compiled.ICompiledInputPlugin
+
+    class QueueEmitterAdapter
+      def initialize(emitter)
+        @emitter = emitter
+      end
+
+      def push(event)
+        push_batch([event])
+      end
+      alias_method(:<<, :push)
+
+      def push_batch(events)
+        @emitter.emit(events)
+      end
+    end
+
+    def initialize(plugin, vertex)
+      @plugin = plugin
+      @vertex = vertex
+    end
+
+    def register
+      @plugin.register
+    end
+
+    def start
+      if @emitter.nil?
+        raise "Could not start! Emitter not defined! #{self}"
+      end
+      @plugin.run(QueueEmitterAdapter.new(@emitter))
+    end
+
+    def stop
+      @plugin.do_stop
+    end
+
+    def onEvents(emitter)
+      @emitter = emitter
+    end
+  end
+
+  class CompiledRubyProcessor
+    include org.logstash.config.compiler.compiled.ICompiledProcessor
+
+    def initialize(plugin, vertex)
+      @plugin = plugin
+      @vertex = vertex
+      # We run this a lot, so it's easier to just clone this on every
+      # Invocation rather than worry about jruby efficiently invoking this method
+      @outgoing_edges = vertex.getOutgoingEdges()
+    end
+
+    def register
+      @plugin.register
+    end
+
+    def stop
+      @plugin.do_close
+    end
+
+    def map_processed(processed)
+      result_map = {}
+      @outgoing_edges.each {|edge| result_map[edge] = processed}
+      result_map
+    end
+  end
+
+  class CompiledRubyFilter < CompiledRubyProcessor
+    def process(events)
+      map_processed(@plugin.multi_filter(events))
+    end
+  end
+
+  class CompiledRubyOutput < CompiledRubyProcessor
+    def process(events)
+      map_processed(@plugin.multi_receive(events))
+    end
+  end
+
+  class StandardPluginCompiler
+    include ::LogStash::Util::Loggable
+    include org.logstash.config.compiler.IPluginCompiler;
+
+    attr_reader :pipeline_id, :pipeline_metric
+
+    def initialize(pipeline_id, pipeline_metric)
+      @pipeline_id = pipeline_id
+      @pipeline_metric = pipeline_metric
+    end
+
+    def compileInput(vertex)
+      definition = vertex.getPluginDefinition
+      klass = lookup_plugin_class(definition)
+
+      input_plugin = klass.new(definition.getArguments)
+      input_plugin.metric = plugin_scoped_metric(definition)
+
+      CompiledRubyInput.new(input_plugin, vertex)
+    end
+
+    def compileFilter(vertex)
+      definition = vertex.getPluginDefinition
+      klass = lookup_plugin_class(definition)
+      delegator = FilterDelegator.new(logger, klass, plugin_scoped_metric(definition), definition.getArguments)
+      CompiledRubyFilter.new(delegator, vertex)
+    end
+
+    def compileOutput(vertex)
+      definition = vertex.getPluginDefinition
+      klass = lookup_plugin_class(definition)
+      delegator = OutputDelegator.new(logger, klass, plugin_scoped_metric(definition),
+                                      OutputDelegatorStrategyRegistry.instance,
+                                      definition.getArguments)
+      CompiledRubyOutput.new(delegator, vertex)
+    end
+
+    def plugin_scoped_metric(definition)
+      pipeline_metric.namespace([(definition_type_string(definition) + "s").to_sym,
+                                  definition.getId()])
+    end
+
+
+    def lookup_plugin_class(definition)
+      Plugin.lookup(definition_type_string(definition), definition.getName)
+    end
+
+    def definition_type_string(definition)
+      definition.getType.to_s.downcase
+    end
+  end
+
+
+  def self.compile(config_str, source_file=nil, pipeline_id=nil, metric=nil)
+    pipeline_id ||= :main
+    metric ||= LogStash::Instrument::NullMetric.new
+
+    pipeline = compile_pipeline(config_str, source_file)
+    pipeline_metric = metric.namespace([:stats, :pipelines, pipeline_id.to_s.to_sym, :plugins])
+    plugin_compiler = StandardPluginCompiler.new(pipeline_id, pipeline_metric)
+
+    runner = org.logstash.config.pipeline.PipelineRunner.new(
+      pipeline, queue, expression_compiler, plugin_compiler, nil
+    )
+  end
+
+  def self.compile_pipeline(config_str, source_file=nil)
+    graph_sections = self.compile_graph(config_str, source_file)
+    pipeline = org.logstash.config.ir.Pipeline.new(
+      graph_sections[:input],
+      graph_sections[:filter],
+      graph_sections[:output]
+    )
+  end
+
+  def self.queue
+    queue = java.util.concurrent.SynchronousQueue.new
+  end
+
+  def self.expression_compiler
+    org.logstash.config.compiler.RubyExpressionCompiler.new
+  end
+
+
+  def self.compile_ast(config_str, source_file=nil)
+    grammar = LogStashConfigParser.new
+    config = grammar.parse(config_str)
+
+    if config.nil?
+      raise ConfigurationError, grammar.failure_reason
+    end
+
+    config
+  end
+
+  def self.compile_imperative(config_str, source_file=nil)
+    compile_ast(config_str, source_file).compile(source_file)
+  end
+
+  def self.compile_graph(config_str, source_file=nil)
+    Hash[compile_imperative(config_str, source_file).map {|section,icompiled| [section, icompiled.toGraph]}]
+  end
+end; end
diff --git a/logstash-core/lib/logstash/config/config_ast.rb b/logstash-core/lib/logstash/config/config_ast.rb
index ce6295a6933..15b6f135eaa 100644
--- a/logstash-core/lib/logstash/config/config_ast.rb
+++ b/logstash-core/lib/logstash/config/config_ast.rb
@@ -1,15 +1,61 @@
 # encoding: utf-8
 require 'logstash/errors'
 require "treetop"
+java_import Java::OrgLogstashConfigIr::DSL
+java_import Java::OrgLogstashConfigIr::SourceMetadata
 
-class Treetop::Runtime::SyntaxNode
+module LogStash; module Config; module AST
+  module JDSL
+    attr_writer :source_file
+    def source_meta
+      line, column = line_and_column
+      Java::OrgLogstashConfigIr::SourceMetadata.new(source_file, line, column, self.text_value)
+    end
+
+    def source_file
+      return @source_file if @source_file
+      return self.parent.source_file if self.parent
+      nil
+    end
+
+    def compose(*statements)
+      compose_for(section_type.to_sym).call(source_meta, *statements)
+    end
+
+    def compose_for(section_sym)
+      if section_sym == :filter
+        jdsl.method(:iComposeSequence)
+      else
+        jdsl.method(:iComposeParallel)
+      end
+    end
+
+    def line_and_column
+      start = self.interval.first
+      [self.input.line_of(start), self.input.column_of(start)]
+    end
+
+    def empty_source_meta()
+      Java::OrgLogstashConfigIr::SourceMetadata.new()
+    end
+
+    def jdsl
+      Java::OrgLogstashConfigIr::DSL
+    end
 
-  def compile
-    return "" if elements.nil?
-    return elements.collect(&:compile).reject(&:empty?).join("")
+    def self.jdsl
+      Java::OrgLogstashConfigIr::DSL
+    end
+
+    AND_METHOD = jdsl.method(:eAnd)
+    OR_METHOD = jdsl.method(:eOr)
   end
+end; end; end
+
+class Treetop::Runtime::SyntaxNode
+  include LogStash::Config::AST::JDSL
 
-  # Traverse the syntax tree recursively.
+  # Traverse the sourceComponent tree recursively.
   # The order should respect the order of the configuration file as it is read
   # and written by humans (and the order in which it is parsed).
   def recurse(e, depth=0, &block)
@@ -37,8 +83,20 @@ def recursive_inject(results=[], &block)
   # Some of theses node will point to our concrete class.
   # To fetch a specific types of object we need to follow each branch
   # and ignore the empty nodes.
-  def recursive_select(klass)
-    return recursive_inject { |e| e.is_a?(klass) }
+  def recursive_select(*klasses)
+    return recursive_inject { |e| klasses.any? {|k| e.is_a?(k)} }
+  end
+
+  def recursive_select_expr_parts
+    parts = [
+      LogStash::Config::AST::Selector,
+      LogStash::Config::AST::Expression,
+      LogStash::Config::AST::BooleanOperator,
+      LogStash::Config::AST::ComparisonOperator,
+      LogStash::Config::AST::Number,
+      LogStash::Config::AST::String
+    ]
+    lval, comparison_method, rval = self.recursive_select(*parts).map(&:expr)
   end
 
   def recursive_inject_parent(results=[], &block)
@@ -59,296 +117,150 @@ def recursive_select_parent(results=[], klass)
 
 
 module LogStash; module Config; module AST
-
-  def self.defered_conditionals=(val)
-    @defered_conditionals = val
-  end
-
-  def self.defered_conditionals
-    @defered_conditionals
-  end
-
-  def self.defered_conditionals_index
-    @defered_conditionals_index
-  end
-
-  def self.defered_conditionals_index=(val)
-    @defered_conditionals_index = val
-  end
-
-  def self.plugin_instance_index
-    @plugin_instance_index
-  end
-
-  def self.plugin_instance_index=(val)
-    @plugin_instance_index = val
-  end
-
   class Node < Treetop::Runtime::SyntaxNode
-    def text_value_for_comments
-      text_value.gsub(/[\r\n]/, " ")
+    def section_type
+      if recursive_select_parent(Plugin).any?
+        return "codec"
+      else
+        section = recursive_select_parent(PluginSection)
+        return section.first.plugin_type.text_value
+      end
     end
   end
 
   class Config < Node
-    def compile
-      LogStash::Config::AST.defered_conditionals = []
-      LogStash::Config::AST.defered_conditionals_index = 0
-      LogStash::Config::AST.plugin_instance_index = 0
-      code = []
-
-      code << <<-CODE
-        @inputs = []
-        @filters = []
-        @outputs = []
-        @periodic_flushers = []
-        @shutdown_flushers = []
-        @generated_objects = {}
-      CODE
+    def compile(source_file=nil)
+      # There is no way to move vars across nodes in treetop :(
+      self.source_file = source_file
 
       sections = recursive_select(LogStash::Config::AST::PluginSection)
-      sections.each do |s|
-        code << s.compile_initializer
-      end
-
-      # start inputs
-      definitions = []
-
-      ["filter", "output"].each do |type|
-        # defines @filter_func and @output_func
-
-        # This need to be defined as a singleton method
-        # so each instance of the pipeline has his own implementation
-        # of the output/filter function
-        definitions << "define_singleton_method :#{type}_func do |event|"
-        definitions << "  targeted_outputs = []" if type == "output"
-        definitions << "  events = [event]" if type == "filter"
-        definitions << "  @logger.debug? && @logger.debug(\"#{type} received\", \"event\" => event.to_hash)"
 
-        sections.select { |s| s.plugin_type.text_value == type }.each do |s|
-          definitions << s.compile.split("\n", -1).map { |e| "  #{e}" }
+      section_map = {
+        :input  => [],
+        :filter => [],
+        :output => []
+      }
+
+      sections.each do |section|
+        section_name = section.plugin_type.text_value.to_sym
+        section_expr = section.expr
+        raise "Unknown section name #{section_name}!" if ![:input, :output, :filter].include?(section_name)
+        # Don't include nil section exprs!
+        ::Array[section_expr].each do |se|
+          section_map[section_name].concat se
         end
-
-        definitions << "  events" if type == "filter"
-        definitions << "  targeted_outputs" if type == "output"
-        definitions << "end"
       end
 
-      code += definitions.join("\n").split("\n", -1).collect { |l| "  #{l}" }
-
-      code += LogStash::Config::AST.defered_conditionals
+      # Represent filter / output blocks as a single composed statement
+      section_map.keys.each do |key|
+        section_map[key] = compose_for(key).call(empty_source_meta, *section_map[key])
+      end
 
-      return code.join("\n")
+      section_map
     end
   end
 
-  class Comment < Node; end
-  class Whitespace < Node; end
-  class PluginSection < Node
-    # Global plugin numbering for the janky instance variable naming we use
-    # like @filter_<name>_1
-    def initialize(*args)
-      super(*args)
+  class Comment < Node
+    def significant
+      false
     end
 
-    # Generate ruby code to initialize all the plugins.
-    def compile_initializer
-      generate_variables
-      code = []
-      @variables.each do |plugin, name|
-
-
-        code << <<-CODE
-          @generated_objects[:#{name}] = #{plugin.compile_initializer}
-          @#{plugin.plugin_type}s << @generated_objects[:#{name}]
-        CODE
-
-        # The flush method for this filter.
-        if plugin.plugin_type == "filter"
-
-          code << <<-CODE
-            @generated_objects[:#{name}_flush] = lambda do |options, &block|
-              @logger.debug? && @logger.debug(\"Flushing\", :plugin => @generated_objects[:#{name}])
-
-              events = @generated_objects[:#{name}].flush(options)
-
-              return if events.nil? || events.empty?
-
-              @logger.debug? && @logger.debug(\"Flushing\", :plugin => @generated_objects[:#{name}], :events => events.map { |x| x.to_hash  })
-
-              #{plugin.compile_starting_here.gsub(/^/, "  ")}
-
-              events.each{|e| block.call(e)}
-            end
-
-            if @generated_objects[:#{name}].respond_to?(:flush)
-              @periodic_flushers << @generated_objects[:#{name}_flush] if @generated_objects[:#{name}].periodic_flush
-              @shutdown_flushers << @generated_objects[:#{name}_flush]
-            end
-          CODE
-
-        end
-      end
-      return code.join("\n")
-    end
+  end
 
-    def variable(object)
-      generate_variables
-      return @variables[object]
+  class Whitespace < Node
+    def significant
+      false
     end
-
-    def generate_variables
-      return if !@variables.nil?
-      @variables = {}
-      plugins = recursive_select(Plugin)
-
-      plugins.each do |plugin|
-        # Unique number for every plugin.
-        LogStash::Config::AST.plugin_instance_index += 1
-        # store things as ivars, like @filter_grok_3
-        var = :"#{plugin.plugin_type}_#{plugin.plugin_name}_#{LogStash::Config::AST.plugin_instance_index}"
-        # puts("var=#{var.inspect}")
-        @variables[plugin] = var
-      end
-      return @variables
+  end
+  class PluginSection < Node
+    # Global plugin numbering for the janky instance variable naming we use
+    # like @filter_<name>_1
+    def expr
+      [*recursive_select(Branch, Plugin).map(&:expr)]
     end
-
   end
 
   class Plugins < Node; end
   class Plugin < Node
-    def plugin_type
-      if recursive_select_parent(Plugin).any?
-        return "codec"
-      else
-        return recursive_select_parent(PluginSection).first.plugin_type.text_value
-      end
-    end
-
-    def plugin_name
-      return name.text_value
-    end
-
-    def variable_name
-      return recursive_select_parent(PluginSection).first.variable(self)
-    end
-
-    def compile_initializer
-      # If any parent is a Plugin, this must be a codec.
-
-      if attributes.elements.nil?
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect})" << (plugin_type == "codec" ? "" : "\n")
-      else
-        settings = attributes.recursive_select(Attribute).collect(&:compile).reject(&:empty?)
-
-        attributes_code = "LogStash::Util.hash_merge_many(#{settings.map { |c| "{ #{c} }" }.join(", ")})"
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, #{attributes_code})" << (plugin_type == "codec" ? "" : "\n")
-      end
+    def expr
+      jdsl.iPlugin(source_meta, plugin_type_enum, self.plugin_name, self.expr_attributes)
     end
 
-    def compile
-      case plugin_type
+    def plugin_type_enum
+      case section_type
       when "input"
-        return "start_input(@generated_objects[:#{variable_name}])"
+        Java::OrgLogstashConfigIr::PluginDefinition::Type::INPUT
+      when "codec"
+        Java::OrgLogstashConfigIr::PluginDefinition::Type::CODEC
       when "filter"
-        return <<-CODE
-          events = @generated_objects[:#{variable_name}].multi_filter(events)
-        CODE
+        Java::OrgLogstashConfigIr::PluginDefinition::Type::FILTER
       when "output"
-        return "targeted_outputs << @generated_objects[:#{variable_name}]\n"
-      when "codec"
-        settings = attributes.recursive_select(Attribute).collect(&:compile).reject(&:empty?)
-        attributes_code = "LogStash::Util.hash_merge_many(#{settings.map { |c| "{ #{c} }" }.join(", ")})"
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, #{attributes_code})"
+        Java::OrgLogstashConfigIr::PluginDefinition::Type::OUTPUT
       end
     end
 
-    def compile_starting_here
-      return unless plugin_type == "filter" # only filter supported.
-
-      expressions = [
-        LogStash::Config::AST::Branch,
-        LogStash::Config::AST::Plugin
-      ]
-      code = []
-
-      # Find the branch we are in, if any (the 'if' statement, etc)
-      self_branch = recursive_select_parent(LogStash::Config::AST::BranchEntry).first
 
-      # Find any siblings to our branch so we can skip them later.  For example,
-      # if we are in an 'else if' we want to skip any sibling 'else if' or
-      # 'else' blocks.
-      branch_siblings = []
-      if self_branch
-        branch_siblings = recursive_select_parent(LogStash::Config::AST::Branch).first \
-          .recursive_select(LogStash::Config::AST::BranchEntry) \
-          .reject { |b| b == self_branch }
-      end
+    def plugin_name
+      return name.text_value
+    end
 
-      #ast = recursive_select_parent(LogStash::Config::AST::PluginSection).first
-      ast = recursive_select_parent(LogStash::Config::AST::Config).first
+    def variable_name
+      return recursive_select_parent(PluginSection).first.variable(self)
+    end
 
-      found = false
-      recurse(ast) do |element, depth|
-        next false if element.is_a?(LogStash::Config::AST::PluginSection) && element.plugin_type.text_value != "filter"
-        if element == self
-          found = true
-          next false
-        end
-        if found && expressions.include?(element.class)
-          code << element.compile
-          next false
+    def expr_attributes
+      # Turn attributes into a hash map
+      self.attributes.recursive_select(Attribute).map(&:expr).map {|k,v|
+        if v.java_kind_of?(Java::OrgLogstashConfigIrExpression::ValueExpression)
+          [k, v.get]
+        else
+          [k,v]
         end
-        next false if branch_siblings.include?(element)
-        next true
+      }.reduce({}) do |hash,kv|
+        k,v = kv
+        hash[k] = v
+        hash
       end
 
-      return code.collect { |l| "#{l}\n" }.join("")
-    end # def compile_starting_here
+    end
   end
 
   class Name < Node
-    def compile
-      return text_value.inspect
+    def expr
+      return text_value
     end
   end
   class Attribute < Node
-    def compile
-      return %Q(#{name.compile} => #{value.compile})
+    def expr
+      [name.text_value, value.expr]
     end
   end
   class RValue < Node; end
   class Value < RValue; end
 
-  module Unicode
-    def self.wrap(text)
-      return "(" + text.force_encoding(Encoding::UTF_8).inspect + ")"
-    end
-  end
-
   class Bareword < Value
-    def compile
-      return Unicode.wrap(text_value)
+    def expr
+      jdsl.eValue(source_meta, text_value)
     end
   end
   class String < Value
-    def compile
-      return Unicode.wrap(text_value[1...-1])
+    def expr
+      jdsl.eValue(source_meta, text_value[1...-1])
     end
   end
   class RegExp < Value
-    def compile
-      return "Regexp.new(" + Unicode.wrap(text_value[1...-1]) + ")"
+    def expr
+      jdsl.eRegex(text_value[1..-2])
     end
   end
   class Number < Value
-    def compile
-      return text_value
+    def expr
+      jdsl.eValue(source_meta, text_value.include?(".") ? text_value.to_f : text_value.to_i)
     end
   end
   class Array < Value
-    def compile
-      return "[" << recursive_select(Value).collect(&:compile).reject(&:empty?).join(", ") << "]"
+    def expr
+      jdsl.eValue(source_meta, recursive_select(Value).map(&:expr).map(&:get))
     end
   end
   class Hash < Value
@@ -373,9 +285,9 @@ def find_duplicate_keys
       values.find_all { |v| values.count(v) > 1 }.uniq
     end
 
-    def compile
+    def expr
       validate!
-      return "{" << recursive_select(HashEntry).collect(&:compile).reject(&:empty?).join(", ") << "}"
+      ::Hash[recursive_select(HashEntry).map(&:expr)]
     end
   end
 
@@ -383,111 +295,267 @@ class HashEntries < Node
   end
 
   class HashEntry < Node
-    def compile
-      return %Q(#{name.compile} => #{value.compile})
+    def expr
+      return [name.expr.get, value.expr.get()]
     end
   end
 
-  class BranchOrPlugin < Node; end
-
   class Branch < Node
-    def compile
-
-      # this construct is non obvious. we need to loop through each event and apply the conditional.
-      # each branch of a conditional will contain a construct (a filter for example) that also loops through
-      # the events variable so we have to initialize it to [event] for the branch code.
-      # at the end, events is returned to handle the case where no branch match and no branch code is executed
-      # so we must make sure to return the current event.
-
-      type = recursive_select_parent(PluginSection).first.plugin_type.text_value
-
-      if type == "filter"
-        i = LogStash::Config::AST.defered_conditionals_index += 1
-        source = <<-CODE
-          @generated_objects[:cond_func_#{i}] = lambda do |input_events|
-            result = []
-            input_events.each do |event|
-              events = [event]
-              #{super}
-              end
-              result += events
-            end
-            result
-          end
-        CODE
-        LogStash::Config::AST.defered_conditionals << source
-
-        <<-CODE
-          events = @generated_objects[:cond_func_#{i}].call(events)
-        CODE
-      else # Output
-        <<-CODE
-          #{super}
+    def expr
+      # Build this stuff as s-expressions for convenience at first (they're mutable)
+
+      exprs = []
+      else_stack = [] # For turning if / elsif / else into nested ifs
+
+      self.recursive_select(Plugin, If, Elsif, Else).each do |node|
+        if node.is_a?(If)
+          exprs << :if
+          exprs << expr_cond(node)
+          exprs << expr_body(node)
+        elsif node.is_a?(Elsif)
+          condition = expr_cond(node)
+          body = expr_body(node)
+
+          else_stack << [:if, condition, body]
+        elsif node.is_a?(Else)
+          body = expr_body(node)
+          if else_stack.size >= 1
+            else_stack.last << body
+          else
+            exprs << body
           end
-        CODE
+        end
+      end
+
+      else_stack.reverse.each_cons(2) do |cons|
+        later,earlier = cons
+        earlier << later
+      end
+      exprs << else_stack.first
+
+      # Then convert to the imperative java IR
+      javaify_sexpr(exprs)
+    end
+
+    def javaify_sexpr(sexpr)
+      return nil if sexpr.nil?
+
+      head, tail = sexpr.first
+      tail = sexpr[1..-1]
+
+      if head == :if
+        condition, t_branch, f_branch = tail
+
+        java_t_branch = t_branch && javaify_sexpr(t_branch)
+        java_f_branch = f_branch && javaify_sexpr(f_branch)
+
+        if java_t_branch || java_f_branch
+          # Invert the expression and make the f_branch the t_branch
+
+          begin
+          jdsl.iIf(condition, java_t_branch || jdsl.noop, java_f_branch || jdsl.noop)
+        rescue => e
+          require 'pry'; binding.pry
+        end
+        else
+          jdsl.noop()
+        end
+      elsif head == :compose
+        tail && tail.size > 0 ? compose(*tail) : jdsl.noop
+      else
+        raise "Unknown expression #{head}!"
       end
     end
+
+    def expr_cond(node)
+      node.elements.find {|e| e.is_a?(Condition)}.expr
+    end
+
+    def expr_body(node)
+      [:compose, *node.recursive_select(Plugin, Branch).map(&:expr)]
+    end
   end
 
   class BranchEntry < Node; end
 
   class If < BranchEntry
-    def compile
-      children = recursive_inject { |e| e.is_a?(Branch) || e.is_a?(Plugin) }
-      return "if #{condition.compile} # if #{condition.text_value_for_comments}\n" \
-        << children.collect(&:compile).map { |s| s.split("\n", -1).map { |l| "  " + l }.join("\n") }.join("") << "\n"
-    end
   end
   class Elsif < BranchEntry
-    def compile
-      children = recursive_inject { |e| e.is_a?(Branch) || e.is_a?(Plugin) }
-      return "elsif #{condition.compile} # else if #{condition.text_value_for_comments}\n" \
-        << children.collect(&:compile).map { |s| s.split("\n", -1).map { |l| "  " + l }.join("\n") }.join("") << "\n"
-    end
   end
   class Else < BranchEntry
-    def compile
-      children = recursive_inject { |e| e.is_a?(Branch) || e.is_a?(Plugin) }
-      return "else\n" \
-        << children.collect(&:compile).map { |s| s.split("\n", -1).map { |l| "  " + l }.join("\n") }.join("") << "\n"
-    end
   end
 
   class Condition < Node
-    def compile
-      return "(#{super})"
+    def expr
+      first_element = elements.first
+      rest_elements = elements.size > 1 ? elements[1].recursive_select(BooleanOperator, Expression, SelectorElement) : []
+
+      all_elements = [first_element, *rest_elements]
+
+      if all_elements.size == 1
+        elem = all_elements.first
+        if elem.is_a?(Selector)
+          eventValue = elem.recursive_select(SelectorElement).first.expr
+          jdsl.eTruthy(eventValue)
+        elsif elem.is_a?(RegexpExpression)
+          elem.expr
+        else
+          join_conditions(all_elements)
+        end
+      else
+
+        join_conditions(all_elements) # Is this necessary?
+      end
+    end
+
+    def precedence(op)
+      #  Believe this is right for logstash?
+      case op
+      when ::LogStash::Config::AST::JDSL::AND_METHOD
+        2
+      when ::LogStash::Config::AST::JDSL::OR_METHOD
+        1
+      else
+        raise ArgumentError, "Unexpected operator #{op}"
+      end
+    end
+
+    def jconvert(sexpr)
+      raise "jconvert cannot handle nils!" if sexpr.nil?
+
+      if sexpr.java_kind_of?(Java::OrgLogstashConfigIrExpression::Expression)
+        return sexpr
+      end
+
+      op, left, right = sexpr
+
+      left_c = jconvert(left)
+      right_c = jconvert(right)
+
+       case op
+       when :and
+         return jdsl.eAnd(left, right);
+       when :or
+         return jdsl.eOr(left, right);
+       else
+         raise "Unknown op #{jop}"
+       end
+    end
+
+    def join_conditions(all_elements)
+      # Use Dijkstra's shunting yard algorithm
+      out = []
+      operators = []
+
+      all_elements.each do |e|
+        e_exp = e.expr
+
+        if e.is_a?(BooleanOperator)
+          if operators.last && precedence(operators.last) > precedence(e_exp)
+            out << operators.pop
+          end
+          operators << e_exp
+        else
+          out << e_exp
+        end
+      end
+      operators.reverse.each {|o| out << o}
+
+      stack = []
+      expr = []
+      out.each do |e|
+        if e.is_a?(Symbol)
+          rval, lval = stack.pop, stack.pop
+          stack << jconvert([e, lval, rval])
+        elsif e.nil?
+          raise "Nil expr encountered!"
+        else
+          stack << e
+        end
+      end
+
+      stack_to_expr(stack)
+    end
+
+    def stack_to_expr(stack)
+      raise "Got an empty stack!" if stack.empty?
+      stack = stack.reverse
+
+      working_stack = []
+      while elem = stack.pop
+        if elem.is_a?(::Method)
+          right, left = working_stack.pop, working_stack.pop
+          working_stack << elem.call(left, right)
+        else
+          working_stack << elem
+        end
+      end
+
+      raise "Invariant violated! Stack size > 1" if working_stack.size > 1
+
+      working_stack.first
+    end
+
+    def dslify_stack(stack)
+      dslify_stack()
     end
   end
 
   module Expression
-    def compile
-      return "(#{super})"
+    def expr
+      if defined?(super)
+        return super
+      end
+
+      exprs = self.recursive_select(Condition, Selector).map(&:expr)
+
+      require 'pry'; binding.pry if exprs.size != 1
+      raise "Exprs should only have one part!" if exprs.size != 1
+      exprs.first
     end
   end
 
   module NegativeExpression
-    def compile
-      return "!(#{super})"
+    include JDSL
+
+    def expr
+      exprs = self.recursive_select(Condition, Selector).map(&:expr)
+      raise "Negative exprs should only have one part!" if exprs.size != 1
+      jdsl.eNot(source_meta, exprs.first)
+    rescue => e
+      require 'pry'; binding.pry
     end
   end
 
-  module ComparisonExpression; end
+  module ComparisonExpression
+    include JDSL
+
+    def expr
+      lval, comparison_method, rval = self.recursive_select(Selector, Expression, ComparisonOperator, Number, String).map(&:expr)
+      comparison_method.call(source_meta, lval, rval)
+    end
+  end
 
   module InExpression
-    def compile
+    include JDSL
+
+    def expr # Because this is somehow higher up the inheritance chain than Expression
       item, list = recursive_select(LogStash::Config::AST::RValue)
-      return "(x = #{list.compile}; x.respond_to?(:include?) && x.include?(#{item.compile}))"
+      jdsl.eIn(source_meta, item.expr, list.expr)
     end
   end
 
   module NotInExpression
-    def compile
+    include JDSL
+
+    def expr
       item, list = recursive_select(LogStash::Config::AST::RValue)
-      return "(x = #{list.compile}; !x.respond_to?(:include?) || !x.include?(#{item.compile}))"
+      jdsl.eNot(source_meta, jdsl.eIn(item.expr, list.expr))
     end
   end
 
   class MethodCall < Node
+    # TBD: Can we delete this? Who uses the method call syntax?
     def compile
       arguments = recursive_inject { |e| [String, Number, Selector, Array, MethodCall].any? { |c| e.is_a?(c) } }
       return "#{method.text_value}(" << arguments.collect(&:compile).join(", ") << ")"
@@ -495,40 +563,74 @@ def compile
   end
 
   class RegexpExpression < Node
-    def compile
-      operator = recursive_select(LogStash::Config::AST::RegExpOperator).first.text_value
-      item, regexp = recursive_select(LogStash::Config::AST::RValue)
-      # Compile strings to regexp's
-      if regexp.is_a?(LogStash::Config::AST::String)
-        regexp = "/#{regexp.text_value[1..-2]}/"
-      else
-        regexp = regexp.compile
-      end
-      return "(#{item.compile} #{operator} #{regexp})"
+    def expr
+      selector, operator_method, regexp = recursive_select(Selector, LogStash::Config::AST::RegExpOperator, LogStash::Config::AST::RegExp).map(&:expr)
+
+      raise "Expected a selector #{text_value}!" unless selector
+      raise "Expected a regexp #{text_value}!" unless regexp
+
+
+      operator_method.call(source_meta, selector, regexp);
     end
   end
 
+  module BranchOrPlugin; end
+
   module ComparisonOperator
-    def compile
-      return " #{text_value} "
+    include JDSL
+
+    def expr
+      case self.text_value
+      when "=="
+        jdsl.method(:eEq)
+      when "!="
+        jdsl.method(:eNeq)
+      when ">"
+        jdsl.method(:eGt)
+      when "<"
+        jdsl.method(:eLt)
+      when ">="
+        jdsl.method(:eGte)
+      when "<="
+        jdsl.method(:eLte)
+      else
+        raise "Unknown operator #{self.text_value}"
+      end
     end
   end
   module RegExpOperator
-    def compile
-      return " #{text_value} "
+    def expr
+      if self.text_value == '!~'
+        jdsl.method(:eRegexNeq)
+      elsif self.text_value == '=~'
+        jdsl.method(:eRegexEq)
+      else
+        raise "Unknown regex operator #{self.text_value}"
+      end
     end
   end
   module BooleanOperator
-    def compile
-      return " #{text_value} "
+    def expr
+      case self.text_value
+      when "and"
+        ::LogStash::Config::AST::JDSL::AND_METHOD
+      when "or"
+        ::LogStash::Config::AST::JDSL::OR_METHOD
+      else
+        raise "Unknown operator #{self.text_value}"
+      end
     end
   end
   class Selector < RValue
-    def compile
-      return "event.get(#{text_value.inspect})"
+    def expr
+      jdsl.eEventValue(source_meta, text_value)
+    end
+  end
+  class SelectorElement < Node;
+    def expr
+      jdsl.eEventValue(source_meta, text_value)
     end
   end
-  class SelectorElement < Node; end
 end; end; end
 
 
diff --git a/logstash-core/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
index efb03d838b0..34c9f6c3ca3 100644
--- a/logstash-core/lib/logstash/pipeline.rb
+++ b/logstash-core/lib/logstash/pipeline.rb
@@ -21,6 +21,7 @@
 require "logstash/instrument/collector"
 require "logstash/output_delegator"
 require "logstash/filter_delegator"
+require "logstash/compiler"
 
 module LogStash; class Pipeline
   include LogStash::Util::Loggable
@@ -325,7 +326,7 @@ def output_batch(batch)
     output_events_map.each do |output, events|
       output.multi_receive(events)
     end
-    
+
     @filter_queue_client.add_output_metrics(batch)
   end
 
@@ -436,7 +437,7 @@ def plugin(plugin_type, name, *args)
          end
 
     raise ConfigurationError, "Two plugins have the id '#{id}', please fix this conflict" if @plugins_by_id[id]
-    
+
     pipeline_scoped_metric = metric.namespace([:stats, :pipelines, pipeline_id.to_s.to_sym, :plugins])
 
     klass = Plugin.lookup(plugin_type, name)
@@ -454,7 +455,7 @@ def plugin(plugin_type, name, *args)
                input_plugin.metric = type_scoped_metric.namespace(id)
                input_plugin
              end
-    
+
     @plugins_by_id[id] = plugin
   end
 
diff --git a/logstash-core/locales/en.yml b/logstash-core/locales/en.yml
index d1c31e51006..f67ed5489c2 100644
--- a/logstash-core/locales/en.yml
+++ b/logstash-core/locales/en.yml
@@ -187,7 +187,7 @@ en:
         http_host: Web API binding host
         http_port: Web API http port
         pipeline-workers: |+
-          Sets the number of pipeline workers to run.
+          Sets the number of pipeline workers to start.
         pipeline-batch-size: |+
           Size of batches the pipeline is to work in.
         pipeline-batch-delay: |+
@@ -256,7 +256,7 @@ en:
           WARNING: This will include any 'password' options passed to plugin configs as plaintext, and may result
           in plaintext passwords appearing in your logs!
         log_format: |+
-          Specify if Logstash should write its own logs in JSON form (one
+          Specify if Logstash should emit its own logs in JSON form (one
           event per line) or in plain text (using Ruby's Object#inspect)
         debug: |+
           Set the log level to debug.
diff --git a/logstash-core/logstash-core.iml b/logstash-core/logstash-core.iml
new file mode 100644
index 00000000000..b700df706c5
--- /dev/null
+++ b/logstash-core/logstash-core.iml
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id="logstash-core" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="org.logstash" external.system.module.version="6.0.0-alpha1" type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/classes/main" />
+    <output-test url="file://$MODULE_DIR$/build/classes/test" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+      <excludeFolder url="file://$MODULE_DIR$/build" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.jruby:jruby-core:1.7.25" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.ow2.asm:asm:5.0.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.ow2.asm:asm-commons:5.0.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.ow2.asm:asm-analysis:5.0.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.ow2.asm:asm-util:5.0.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.jruby.joni:joni:2.1.10" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-netdb:1.1.2" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-enxio:0.12" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-x86asm:1.0.2" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-unixsocket:0.12" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-posix:3.0.29" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.jruby.extras:bytelist:1.0.11" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-constants:0.9.1" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.jruby.jcodings:jcodings:1.0.16" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-ffi:2.0.9" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jffi:1.2.11" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jffi:1.2.11:native" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.yaml:snakeyaml:1.13" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.jcraft:jzlib:1.1.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.headius:invokebinder:1.2" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.martiansoftware:nailgun-server:0.9.1" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.jruby:yecht:1.1:jruby" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: joda-time:joda-time:2.8.2" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.headius:options:1.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.ow2.asm:asm-tree:5.0.3" level="project" />
+    <orderEntry type="library" name="Gradle: org.apache.logging.log4j:log4j-api:2.6.2" level="project" />
+    <orderEntry type="library" name="Gradle: org.apache.logging.log4j:log4j-core:2.6.2" level="project" />
+    <orderEntry type="library" name="Gradle: com.fasterxml.jackson.core:jackson-core:2.7.4" level="project" />
+    <orderEntry type="library" name="Gradle: com.fasterxml.jackson.core:jackson-databind:2.7.4" level="project" />
+    <orderEntry type="library" name="Gradle: com.fasterxml.jackson.core:jackson-annotations:2.7.0" level="project" />
+    <orderEntry type="library" scope="RUNTIME" name="Gradle: org.apache.logging.log4j:log4j-1.2-api:2.6.2" level="project" />
+    <orderEntry type="library" scope="TEST" name="Gradle: org.apache.logging.log4j:log4j-api:2.6.2:tests" level="project" />
+    <orderEntry type="library" scope="TEST" name="Gradle: org.apache.logging.log4j:log4j-core:2.6.2:tests" level="project" />
+    <orderEntry type="library" scope="TEST" name="Gradle: junit:junit:4.12" level="project" />
+    <orderEntry type="library" scope="TEST" name="Gradle: org.hamcrest:hamcrest-core:1.3" level="project" />
+    <orderEntry type="module-library">
+      <library name="Gradle: logstash-core-event-java">
+        <CLASSES>
+          <root url="jar://$MODULE_DIR$/../logstash-core-event-java/build/libs/logstash-core-event-java.jar!/" />
+        </CLASSES>
+        <JAVADOC />
+        <SOURCES />
+      </library>
+    </orderEntry>
+  </component>
+</module>
\ No newline at end of file
diff --git a/logstash-core/spec/logstash/compiler/compiler_spec.rb b/logstash-core/spec/logstash/compiler/compiler_spec.rb
new file mode 100644
index 00000000000..11ab7d2f8b3
--- /dev/null
+++ b/logstash-core/spec/logstash/compiler/compiler_spec.rb
@@ -0,0 +1,733 @@
+require "spec_helper"
+java_import Java::OrgLogstashConfigIr::DSL
+
+describe LogStash::Compiler do
+  def j
+    Java::OrgLogstashConfigIr::DSL
+  end
+
+  # Static import of these useful enums
+  INPUT = Java::OrgLogstashConfigIr::PluginDefinition::Type::INPUT
+  FILTER = Java::OrgLogstashConfigIr::PluginDefinition::Type::FILTER
+  OUTPUT = Java::OrgLogstashConfigIr::PluginDefinition::Type::OUTPUT
+  CODEC = Java::OrgLogstashConfigIr::PluginDefinition::Type::OUTPUT
+
+
+  describe "compiling to a PipelineRunner" do
+    subject(:source_file) { "fake_sourcefile" }
+    subject(:compiled) { described_class.compile(source, source_file) }
+
+    describe "a simple config" do
+      let(:source) do
+        <<-EOC
+          input {
+            stdin {}
+          }
+          filter {
+            mutate { add_field => {"something" => "else"} }
+          }
+          output {
+            stdout { codec => rubydebug }
+          }
+        EOC
+      end
+
+      it "should run correctly" do
+        #compiled.start(1)
+        #puts "SLEEP"
+        #sleep 100
+      end
+    end
+  end
+
+  describe "compiling to Pipeline" do
+    subject(:source_file) { "fake_sourcefile" }
+    subject(:compiled) { described_class.compile_graph(source, source_file) }
+
+    describe "a complex config" do
+      let(:source) do
+        <<-EOC
+input {
+  	stdin { }
+}
+
+filter {
+  csv {
+		columns => ["date","time","borough","zip_code","latitude","longitude","location","on_street_name","cross_street_name","off_street_name","number_of_persons_injured","number_of_persons_killed","number_of_pedestrians_injured","number_of_pedestrians_killed","number_of_cyclist_injured","number_of_cyclist_killed","number_of_motorist_injured","number_of_motorist_killed","contributing_factor_vehicle_1","contributing_factor_vehicle_2","contributing_factor_vehicle_3","contributing_factor_vehicle_4","contributing_factor_vehicle_5","unique_key","vehicle_type_code_1","vehicle_type_code_2","vehicle_type_code_3","vehicle_type_code_4","vehicle_type_code_5"]
+	}
+
+# Drop the first (header) row in the file
+
+  if ([date] == "DATE") {
+    drop { }
+  }
+
+# Combine latitude and longitude into single coords field
+	if [latitude] and [longitude] {
+		mutate {
+			add_field => {
+				"coords" => "%{longitude}"
+				"tmplat" => "%{latitude}"
+		    }
+		}
+		mutate {
+			merge => ["coords", "tmplat"]
+		}
+		mutate {
+		    # Convert our new array of strings back to float
+		    convert => [ "coords", "float" ]
+		    # Delete our temporary latitude field
+		    remove_field => [ "tmplat" ]
+		}
+	}
+
+  if [on_street_name] and [cross_street_name] {
+	  ruby {
+		# create new intersection field that combines cross street & on street names
+		code => "event.set('intersection',[event.get('on_street_name'), event.get('cross_street_name')].sort.join('--'))"
+	  }
+  }
+
+  # Merge date and time into datetime
+	mutate {
+		add_field => {
+			"datetime" => "%{date} %{time}"
+			"contributing_factor_vehicle" => "%{contributing_factor_vehicle_1}"
+			"vehicle_type" => "%{vehicle_type_code_1}"
+		}
+
+
+
+  # convert to integer type
+		convert => ["number_of_persons_injured","integer","number_of_persons_killed","integer","number_of_pedestrians_injured","integer","number_of_pedestrians_killed","integer","number_of_cyclist_injured","integer","number_of_cyclist_killed","integer","number_of_motorist_injured","integer","number_of_motorist_killed","integer"]
+		strip => ["on_street_name", "cross_street_name"]
+	}
+
+  if ![number_of_persons_killed]
+  {
+  	mutate {
+  		add_field => {"number_of_persons_killed" => "0"}
+  	}
+  }
+
+  if ![number_of_persons_injured]
+  {
+  	mutate {
+  		add_field => {"number_of_persons_injured" => "0"}
+  	}
+  }
+
+
+  ruby {
+	# Get total number of persons impacted
+	code =>  "event.set('number_persons_impacted',event.get('number_of_persons_killed') + event.get('number_of_persons_injured'))"
+  }
+
+
+# Combine contributing_factor_vehicle_X (X=1,2,3,4,5) fields into a single field
+	if [contributing_factor_vehicle_2] and "Unspecified" != [contributing_factor_vehicle_2] and [contributing_factor_vehicle_2] not in [contributing_factor_vehicle] {
+		mutate {
+			merge => ["contributing_factor_vehicle", "contributing_factor_vehicle_2"]
+		}
+	}
+
+	if [contributing_factor_vehicle_3] and "Unspecified" != [contributing_factor_vehicle_3] and [contributing_factor_vehicle_3] not in [contributing_factor_vehicle] {
+		mutate {
+			merge => ["contributing_factor_vehicle", "contributing_factor_vehicle_3"]
+		}
+	}
+
+	if [contributing_factor_vehicle_4] and "Unspecified" != [contributing_factor_vehicle_4] and [contributing_factor_vehicle_4] not in [contributing_factor_vehicle] {
+		mutate {
+			merge => ["contributing_factor_vehicle", "contributing_factor_vehicle_4"]
+		}
+	}
+
+	if [contributing_factor_vehicle_5] and "Unspecified" != [contributing_factor_vehicle_5] and [contributing_factor_vehicle_5] not in [contributing_factor_vehicle]  {
+		mutate {
+			merge => ["contributing_factor_vehicle", "contributing_factor_vehicle_5"]
+		}
+	}
+
+ # Combine vehicle_type_code_X (X=1,2,3,4,5) fields into a single field
+	if [vehicle_type_code_2] and "Unspecified" != [vehicle_type_code_2] and [vehicle_type_code_2] not in [vehicle_type] {
+		mutate {
+			merge => ["vehicle_type", "vehicle_type_code_2"]
+		}
+	}
+	if [vehicle_type_code_3] and "Unspecified" != [vehicle_type_code_3] and [vehicle_type_code_3] not in [vehicle_type] {
+		mutate {
+			merge => ["vehicle_type", "vehicle_type_code_3"]
+		}
+	}
+	if [vehicle_type_code_4] and "Unspecified" != [vehicle_type_code_4] and [vehicle_type_code_4] not in [vehicle_type] {
+		mutate {
+			merge => ["vehicle_type", "vehicle_type_code_4"]
+		}
+	}
+	if [vehicle_type_code_5] and "Unspecified" != [vehicle_type_code_5] and [vehicle_type_code_5] not in [vehicle_type] {
+		mutate {
+			merge => ["vehicle_type", "vehicle_type_code_5"]
+		}
+	}
+
+ # Map @timestamp (event timestamp) to datetime
+	date {
+		match => [ "datetime", "MM/dd/YY HH:mm", "MM/dd/YY H:mm"]
+		timezone => "EST"
+	}
+
+  # Grab hour of day from time
+  grok {
+    match => { "time" => "%{DATA:hour_of_day}:%{GREEDYDATA}" }
+    }
+  mutate {
+    convert => ["hour_of_day", "integer"]
+    }
+
+  # Remove extra fields
+	mutate {
+		remove_field => ["datetime", "contributing_factor_vehicle_1", "contributing_factor_vehicle_2", "contributing_factor_vehicle_3", "contributing_factor_vehicle_4", "contributing_factor_vehicle_5","vehicle_type_code_1", "vehicle_type_code_2", "vehicle_type_code_3", "vehicle_type_code_4", "vehicle_type_code_5"]
+	}
+}
+
+output {
+
+  #stdout {codec => rubydebug}
+  stdout { codec => dots }
+
+  elasticsearch {
+    index => "nyc_visionzero"
+    template => "./nyc_collision_template.json"
+    template_name => "nyc_visionzero"
+    template_overwrite => true
+    }
+}
+        EOC
+      end
+
+      it "should compile" do
+        puts "\n!!!SOURCE!!!"
+        puts source
+        puts "\n!!!AST!!!"
+        puts described_class.compile_ast(source).inspect
+        puts "\n!!!IMPERATIVE!!!"
+        imp = described_class.compile_imperative(source)
+        imp.each {|s,v| puts "\n!#{s}\n"; puts v.to_s}
+        puts "\n!!!GRAPH!!!\n"
+        puts g = described_class.compile_graph(source)
+        g.each {|s,v| puts "\n!#{s}\n"; puts v.to_s}
+        puts "\n!!!PIPELINE!!!"
+        puts compiled.to_s
+      end
+    end
+  end
+
+  describe "compiling imperative" do
+    subject(:source_file) { "fake_sourcefile" }
+    subject(:compiled) { described_class.compile_imperative(source, source_file) }
+
+    describe "an empty file" do
+      let(:source) { "input {} output {}" }
+
+      it "should have an empty input block" do
+        expect(compiled[:input]).to ir_eql(j.noop)
+      end
+
+      it "should have an empty filter block" do
+        expect(compiled[:filter]).to ir_eql(j.noop)
+      end
+
+      it "should have an empty output block" do
+        expect(compiled[:output]).to ir_eql(j.noop)
+      end
+    end
+
+    describe "SourceMetadata" do
+      let(:source) { "input { generator {} } output { }" }
+
+      it "should attach correct source text for components" do
+        expect(compiled[:input].get_meta.getSourceText).to eql("generator {}")
+      end
+    end
+
+    context "plugins" do
+      subject(:c_plugin) { compiled[:input] }
+      let(:source) { "input { #{plugin_source} } " }
+
+      describe "a simple plugin" do
+        let(:plugin_source) { "generator {}" }
+
+        it "should contain the plugin" do
+          expect(c_plugin).to ir_eql(j.iPlugin(INPUT, "generator"))
+        end
+      end
+
+      describe "a plugin with mixed parameter types" do
+        let(:plugin_source) { "generator { aarg => [1] hasharg => {foo => bar} iarg => 123 farg => 123.123 sarg => 'hello'}" }
+
+        it "should contain the plugin" do
+          expect(c_plugin).to ir_eql(j.iPlugin(INPUT, "generator", {"aarg" => [1],
+                                                                "hasharg" => {"foo" => "bar"},
+                                                                "iarg" => 123,
+                                                                "farg" => 123.123,
+                                                                "sarg" => 'hello'}))
+        end
+      end
+    end
+
+    context "inputs" do
+      subject(:input) { compiled[:input] }
+
+      describe "a single input" do
+        let(:source) { "input { generator {} }" }
+
+        it "should contain the single input" do
+          expect(input).to ir_eql(j.iPlugin(INPUT, "generator"))
+        end
+      end
+
+      describe "two inputs" do
+        let(:source) { "input { generator { count => 1 } generator { count => 2 } } output { }" }
+
+        it "should contain both inputs" do
+          expect(input).to ir_eql(j.iComposeParallel(
+                                j.iPlugin(INPUT, "generator", {"count" => 1}),
+                                j.iPlugin(INPUT, "generator", {"count" => 2})
+                              ))
+        end
+      end
+    end
+
+    shared_examples_for "complex grammar" do |section|
+      let(:section_name_enum) {
+        case section
+        when :input
+          INPUT
+        when :filter
+          FILTER
+        when :output
+          OUTPUT
+        else
+          raise "Unknown section"
+        end
+      }
+
+      let(:section) { section }
+      let (:c_section) { compiled[section] }
+
+      def splugin(*args)
+        j.iPlugin(section_name_enum, *args)
+      end
+
+      def compose(*statements)
+        if section == :filter
+          j.iComposeSequence(*statements)
+        else
+          j.iComposeParallel(*statements)
+        end
+      end
+
+      describe "two plugins" do
+        let(:source) do
+          # We care about line/column for this test, hence the indentation
+          <<-EOS
+          #{section} {
+            aplugin { count => 1 }
+            aplugin { count => 2 }
+            }
+          EOS
+        end
+
+        it "should contain both" do
+          expect(c_section).to ir_eql(compose(
+                                        splugin("aplugin", {"count" => 1}),
+                                        splugin("aplugin", {"count" => 2})
+                                      ))
+        end
+
+        it "should attach source_metadata with correct info to the statements" do
+          meta = c_section.statements.first.meta
+          expect(meta.getSourceText).to eql("aplugin { count => 1 }")
+          expect(meta.getSourceLine).to eql(2)
+          expect(meta.getSourceColumn).to eql(13)
+          expect(meta.getSourceFile).to eql(source_file)
+          expect(c_section.statements.first.meta)
+          expect(c_section)
+        end
+      end
+
+      describe "if conditions" do
+        describe "conditional expressions" do
+          let(:source) { "#{section} { if (#{expression}) { aplugin {} } }" }
+          let(:c_expression) { c_section.getBooleanExpression }
+
+          describe "logical expressions" do
+            describe "simple and" do
+              let(:expression) { "2 > 1 and 1 < 2" }
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(
+                                          j.eAnd(
+                                            j.eGt(j.eValue(2), j.eValue(1)),
+                                            j.eLt(j.eValue(1), j.eValue(2))
+                                          ))
+              end
+            end
+
+            describe "'in' array" do
+              let(:expression) { "'foo' in ['foo', 'bar']" }
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(
+                                          j.eIn(
+                                            j.eValue('foo'),
+                                            j.eValue(['foo', 'bar'])
+                                          ))
+              end
+            end
+
+            describe "'not in' array" do
+              let(:expression) { "'foo' not in ['foo', 'bar']" }
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(
+                                          j.eNot(
+                                            j.eIn(
+                                              j.eValue('foo'),
+                                              j.eValue(['foo', 'bar'])
+                                            )))
+              end
+            end
+
+            describe "'not'" do
+              let(:expression) { "!(1 > 2)" }
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eNot(j.eGt(j.eValue(1), j.eValue(2))))
+              end
+            end
+
+            describe "and or precedence" do
+              let(:expression) { "2 > 1 and 1 < 2 or 3 < 2" }
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(
+                                          j.eOr(
+                                            j.eAnd(
+                                              j.eGt(j.eValue(2), j.eValue(1)),
+                                              j.eLt(j.eValue(1), j.eValue(2))
+                                            ),
+                                            j.eLt(j.eValue(3), j.eValue(2))
+                                          )
+                                        )
+              end
+
+              describe "multiple or" do
+                let(:expression) { "2 > 1 or 1 < 2 or 3 < 2" }
+
+                it "should compile correctly" do
+                  expect(c_expression).to ir_eql(
+                                            j.eOr(
+                                              j.eGt(j.eValue(2), j.eValue(1)),
+                                              j.eOr(
+                                                j.eLt(j.eValue(1), j.eValue(2)),
+                                                j.eLt(j.eValue(3), j.eValue(2))
+                                              )
+                                            )
+                                          )
+                end
+              end
+
+              describe "a complex expression" do
+                let(:expression) { "1 > 2 and 3 > 4 or 6 > 7 and 8 > 9" }
+                false and false or true and true
+
+                it "should compile correctly" do
+                  expect(c_expression).to ir_eql(
+                                            j.eOr(
+                                              j.eAnd(
+                                                j.eGt(j.eValue(1), j.eValue(2)),
+                                                j.eGt(j.eValue(3), j.eValue(4))
+                                              ),
+                                              j.eAnd(
+                                                j.eGt(j.eValue(6), j.eValue(7)),
+                                                j.eGt(j.eValue(8), j.eValue(9))
+                                              )
+                                            )
+                                          )
+                end
+              end
+
+              describe "a complex nested expression" do
+                let(:expression) { "1 > 2 and (1 > 2 and 3 > 4 or 6 > 7 and 8 > 9) or 6 > 7 and 8 > 9" }
+                false and false or true and true
+
+                it "should compile correctly" do
+                  expect(c_expression).to ir_eql(
+                                            j.eOr(
+                                              j.eAnd(
+                                                j.eGt(j.eValue(1), j.eValue(2)),
+                                                j.eOr(
+                                                  j.eAnd(
+                                                    j.eGt(j.eValue(1), j.eValue(2)),
+                                                    j.eGt(j.eValue(3), j.eValue(4))
+                                                  ),
+                                                  j.eAnd(
+                                                    j.eGt(j.eValue(6), j.eValue(7)),
+                                                    j.eGt(j.eValue(8), j.eValue(9))
+                                                  )
+                                                )
+                                              ),
+                                              j.eAnd(
+                                                j.eGt(j.eValue(6), j.eValue(7)),
+                                                j.eGt(j.eValue(8), j.eValue(9))
+                                              )
+                                            )
+                                          )
+                end
+              end
+            end
+          end
+
+          describe "comparisons" do
+            describe "field not null" do
+              let(:expression) { "[foo]"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eTruthy(j.eEventValue("[foo]")))
+              end
+            end
+
+            describe "'=='" do
+              let(:expression) { "[foo] == 5"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eEq(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+
+            describe "'!='" do
+              let(:expression) { "[foo] != 5"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eNeq(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+
+            describe "'>'" do
+              let(:expression) { "[foo] > 5"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eGt(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+
+            describe "'<'" do
+              let(:expression) { "[foo] < 5"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eLt(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+
+            describe "'>='" do
+              let(:expression) { "[foo] >= 5"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eGte(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+
+            describe "'<='" do
+              let(:expression) { "[foo] <= 5"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eLte(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+
+            describe "'=~'" do
+              let(:expression) { "[foo] =~ /^abc$/"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eRegexEq(j.eEventValue("[foo]"), j.eRegex('^abc$')))
+              end
+            end
+
+            describe "'!~'" do
+              let(:expression) { "[foo] !~ /^abc$/"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eRegexNeq(j.eEventValue("[foo]"), j.eRegex('^abc$')))
+              end
+            end
+          end
+        end
+
+        describe "only true branch" do
+          let (:source) { "#{section} { if [foo] == [bar] { grok {} } }" }
+
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                            j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                            splugin("grok")
+                                          )
+                                       )
+          end
+        end
+
+        describe "only false branch" do
+          let (:source) { "#{section} { if [foo] == [bar] { } else { fplugin {} } }" }
+
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          j.noop,
+                                          splugin("fplugin"),
+                                        )
+                                       )
+          end
+        end
+
+        describe "empty if statement" do
+          let (:source) { "#{section} { if [foo] == [bar] { } }" }
+
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          j.noop,
+                                          j.noop
+                                        )
+                                       )
+          end
+        end
+
+        describe "if else" do
+          let (:source) { "#{section} { if [foo] == [bar] { tplugin {} } else { fplugin {} } }" }
+
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          splugin("tplugin"),
+                                          splugin("fplugin")
+                                        )
+                                       )
+          end
+        end
+
+        describe "if elsif else" do
+          let (:source) { "#{section} { if [foo] == [bar] { tplugin {} } else if [bar] == [baz] { eifplugin {} } else { fplugin {} } }" }
+
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          splugin("tplugin"),
+                                          j.iIf(
+                                            j.eEq(j.eEventValue("[bar]"), j.eEventValue("[baz]")),
+                                            splugin("eifplugin"),
+                                            splugin("fplugin")
+                                          )
+                                        )
+                                       )
+          end
+        end
+
+        describe "if elsif elsif else" do
+          let (:source) do
+            <<-EOS
+              #{section} {
+                if [foo] == [bar] { tplugin {} }
+                else if [bar] == [baz] { eifplugin {} }
+                else if [baz] == [bot] { eeifplugin {} }
+                else { fplugin {} }
+              }
+            EOS
+          end
+
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          splugin("tplugin"),
+                                          j.iIf(
+                                            j.eEq(j.eEventValue("[bar]"), j.eEventValue("[baz]")),
+                                            splugin("eifplugin"),
+                                            j.iIf(
+                                              j.eEq(j.eEventValue("[baz]"), j.eEventValue("[bot]")),
+                                              splugin("eeifplugin"),
+                                              splugin("fplugin")
+                                            )
+                                          )
+                                        )
+                                       )
+          end
+
+          describe "nested ifs" do
+let (:source) do
+            <<-EOS
+              #{section} {
+                if [foo] == [bar] {
+                  if [bar] == [baz] { aplugin {} }
+                } else {
+                  if [bar] == [baz] { bplugin {} }
+                  else if [baz] == [bot] { cplugin {} }
+                  else { dplugin {} }
+                }
+              }
+            EOS
+
+          end
+
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          j.iIf(j.eEq(j.eEventValue("[bar]"), j.eEventValue("[baz]")),
+                                                   splugin("aplugin"),
+                                                   j.noop
+                                                  ),
+                                          j.iIf(
+                                            j.eEq(j.eEventValue("[bar]"), j.eEventValue("[baz]")),
+                                            splugin("bplugin"),
+                                            j.iIf(
+                                              j.eEq(j.eEventValue("[baz]"), j.eEventValue("[bot]")),
+                                              splugin("cplugin"),
+                                              splugin("dplugin")
+                                            )
+                                          )
+                                        )
+                                       )
+          end
+          end
+        end
+      end
+    end
+
+    context "filters" do
+      subject(:filter) { compiled[:filter] }
+
+      describe "a single filter" do
+        let(:source) { "input { } filter { grok {} } output { }" }
+
+        it "should contain the single input" do
+          expect(filter).to ir_eql(j.iPlugin(FILTER, "grok"))
+        end
+      end
+
+      it_should_behave_like "complex grammar", :filter
+    end
+
+    context "outputs" do
+      subject(:output) { compiled[:output] }
+
+      describe "a single output" do
+        let(:source) { "input { } output { stdout {} }" }
+
+        it "should contain the single input" do
+          expect(output).to ir_eql(j.iPlugin(OUTPUT, "stdout"))
+        end
+      end
+
+      it_should_behave_like "complex grammar", :output
+    end
+  end
+end
diff --git a/logstash-core/src/main/java/org/logstash/config/compiler/CompilationError.java b/logstash-core/src/main/java/org/logstash/config/compiler/CompilationError.java
new file mode 100644
index 00000000000..b640a37991c
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/compiler/CompilationError.java
@@ -0,0 +1,16 @@
+package org.logstash.config.compiler;
+
+import org.logstash.config.ir.InvalidIRException;
+
+/**
+ * Created by andrewvc on 9/22/16.
+ */
+public class CompilationError extends Exception {
+    public CompilationError(String s, InvalidIRException e) {
+        super(s,e);
+    }
+
+    public CompilationError(String s) {
+        super(s);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/compiler/IExpressionCompiler.java b/logstash-core/src/main/java/org/logstash/config/compiler/IExpressionCompiler.java
new file mode 100644
index 00000000000..fe09782bd4a
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/compiler/IExpressionCompiler.java
@@ -0,0 +1,11 @@
+package org.logstash.config.compiler;
+
+import org.logstash.config.compiler.compiled.ICompiledExpression;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/22/16.
+ */
+public interface IExpressionCompiler {
+    ICompiledExpression compile(Expression expression) throws CompilationError;
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/compiler/IPluginCompiler.java b/logstash-core/src/main/java/org/logstash/config/compiler/IPluginCompiler.java
new file mode 100644
index 00000000000..51ee352783a
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/compiler/IPluginCompiler.java
@@ -0,0 +1,14 @@
+package org.logstash.config.compiler;
+
+import org.logstash.config.compiler.compiled.ICompiledInputPlugin;
+import org.logstash.config.compiler.compiled.ICompiledProcessor;
+import org.logstash.config.ir.graph.PluginVertex;
+
+/**
+ * Created by andrewvc on 9/22/16.
+ */
+public interface IPluginCompiler {
+   ICompiledInputPlugin compileInput(PluginVertex vertex) throws CompilationError;
+   ICompiledProcessor compileFilter(PluginVertex vertex) throws CompilationError;
+   ICompiledProcessor compileOutput(PluginVertex vertex) throws CompilationError;
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/compiler/IfCompiler.java b/logstash-core/src/main/java/org/logstash/config/compiler/IfCompiler.java
new file mode 100644
index 00000000000..66be4b94b74
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/compiler/IfCompiler.java
@@ -0,0 +1,71 @@
+package org.logstash.config.compiler;
+
+import org.logstash.Event;
+import org.logstash.config.compiler.compiled.ICompiledExpression;
+import org.logstash.config.compiler.compiled.ICompiledProcessor;
+import org.logstash.config.ir.graph.BooleanEdge;
+import org.logstash.config.ir.graph.Edge;
+import org.logstash.config.ir.graph.IfVertex;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by andrewvc on 10/13/16.
+ */
+public class IfCompiler {
+    public class CompiledIf implements ICompiledProcessor {
+        private final ICompiledExpression compiledExpression;
+        private final List<BooleanEdge> trueEdges;
+        private final List<BooleanEdge> falseEdges;
+
+        public CompiledIf(ICompiledExpression compiledExpression, List<BooleanEdge> trueEdges, List<BooleanEdge> falseEdges) {
+            this.compiledExpression = compiledExpression;
+            this.trueEdges = trueEdges;
+            this.falseEdges = falseEdges;
+        }
+
+        @Override
+        public Map<Edge, List<Event>> process(List<Event> events) {
+            List<Boolean> booleans = compiledExpression.execute(events);
+
+            ArrayList<Event> trueEvents = new ArrayList<>(events.size());
+            ArrayList<Event> falseEvents = new ArrayList<>(events.size());
+            for (int i = 0; i < events.size(); i++) {
+                if (booleans.get(i)) {
+                    trueEvents.add(events.get(i));
+                } else {
+                    falseEvents.add(events.get(i));
+                }
+            }
+
+            Map<Edge, List<Event>> out = new HashMap<>();
+            trueEdges.stream().forEach(e -> out.put(e, trueEvents));
+            falseEdges.stream().forEach(e -> out.put(e, falseEvents));
+            return out;
+        }
+
+        @Override
+        public void register() {
+            // Nothing to do!
+        }
+
+        @Override
+        public void stop() {
+            // Nothing to do!
+        }
+    }
+
+    private final IExpressionCompiler expressionCompiler;
+
+    public IfCompiler(IExpressionCompiler expressionCompiler) {
+        this.expressionCompiler = expressionCompiler;
+    }
+
+    public ICompiledProcessor compile(IfVertex vertex) throws CompilationError {
+        ICompiledExpression compiledExpression = expressionCompiler.compile(vertex.getBooleanExpression());
+        return new CompiledIf(compiledExpression, vertex.getOutgoingBooleanEdgesByType(true), vertex.getOutgoingBooleanEdgesByType(false));
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/compiler/RubyExpressionCompiler.java b/logstash-core/src/main/java/org/logstash/config/compiler/RubyExpressionCompiler.java
new file mode 100644
index 00000000000..2dd4619bab8
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/compiler/RubyExpressionCompiler.java
@@ -0,0 +1,51 @@
+package org.logstash.config.compiler;
+
+import org.jruby.RubyInstanceConfig;
+import org.jruby.embed.ScriptingContainer;
+import org.logstash.Event;
+import org.logstash.config.compiler.compiled.ICompiledExpression;
+import org.logstash.config.ir.expression.Expression;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Created by andrewvc on 10/11/16.
+ */
+public class RubyExpressionCompiler implements IExpressionCompiler {
+    private final ScriptingContainer container;
+    private long expressionCounter;
+
+    private class CompiledRubyExpression implements ICompiledExpression {
+        private final String expressionSource;
+        private final long expressionId;
+        private final String methodName;
+
+        public CompiledRubyExpression(long expressionId, String expressionSource) {
+            this.expressionId = expressionId;
+            this.methodName = "condition_" + expressionId;
+            container.runScriptlet("def " + methodName + "(events); events.map {|event| " + expressionSource + " }; end");
+            this.expressionSource = expressionSource;
+        }
+
+        @Override
+        public List<Boolean> execute(Collection<Event> events) {
+            // Unchecked cast because we enforce this ourselves. No need to take a speed hit here
+            List<Boolean> result = (List<Boolean>) container.callMethod(null, methodName, events);
+            return result;
+        }
+    }
+
+    public RubyExpressionCompiler() {
+        this.expressionCounter = 0l;
+        this.container = new ScriptingContainer();
+        this.container.setCompileMode(RubyInstanceConfig.CompileMode.FORCE);
+    }
+
+    @Override
+    public ICompiledExpression compile(Expression expression) throws CompilationError {
+        long expressionId = expressionCounter += 1;
+        return new CompiledRubyExpression(expressionId, expression.toRubyString());
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledExpression.java b/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledExpression.java
new file mode 100644
index 00000000000..2a86cbd69e5
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledExpression.java
@@ -0,0 +1,18 @@
+package org.logstash.config.compiler.compiled;
+
+import org.logstash.Event;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Created by andrewvc on 9/22/16.
+ */
+public interface ICompiledExpression {
+    List<Boolean> execute(Collection<Event> events);
+
+    default Boolean execute(Event event) {
+        return execute(Collections.singletonList(event)).get(0);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledInputPlugin.java b/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledInputPlugin.java
new file mode 100644
index 00000000000..0bb25497759
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledInputPlugin.java
@@ -0,0 +1,9 @@
+package org.logstash.config.compiler.compiled;
+
+import org.logstash.config.pipeline.pipette.IPipetteSource;
+
+/**
+ * Created by andrewvc on 9/22/16.
+ */
+public interface ICompiledInputPlugin extends ICompiledVertex, IPipetteSource {
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledProcessor.java b/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledProcessor.java
new file mode 100644
index 00000000000..ed2da972e22
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledProcessor.java
@@ -0,0 +1,14 @@
+package org.logstash.config.compiler.compiled;
+
+import org.logstash.Event;
+import org.logstash.config.ir.graph.Edge;
+
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by andrewvc on 9/22/16.
+ */
+public interface ICompiledProcessor extends ICompiledVertex {
+    Map<Edge, List<Event>> process(List<Event> events);
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledVertex.java b/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledVertex.java
new file mode 100644
index 00000000000..8f69e8aa0c2
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/compiler/compiled/ICompiledVertex.java
@@ -0,0 +1,9 @@
+package org.logstash.config.compiler.compiled;
+
+/**
+ * Created by andrewvc on 10/14/16.
+ */
+public interface ICompiledVertex {
+    void register();
+    void stop();
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/DSL.java b/logstash-core/src/main/java/org/logstash/config/ir/DSL.java
new file mode 100644
index 00000000000..cac53c10b09
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/DSL.java
@@ -0,0 +1,288 @@
+package org.logstash.config.ir;
+
+import org.logstash.config.ir.expression.*;
+import org.logstash.config.ir.expression.binary.*;
+import org.logstash.config.ir.expression.unary.Not;
+import org.logstash.config.ir.expression.unary.Truthy;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.IfVertex;
+import org.logstash.config.ir.graph.PluginVertex;
+import org.logstash.config.ir.imperative.*;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class DSL {
+    public static EventValueExpression eEventValue(SourceMetadata meta, String fieldName) {
+        return new EventValueExpression(meta, fieldName);
+    }
+
+    public static EventValueExpression eEventValue(String fieldName) {
+        return eEventValue(new SourceMetadata(), fieldName);
+    }
+
+    public static ValueExpression eValue(SourceMetadata meta, Object value) throws InvalidIRException {
+        return new ValueExpression(meta, value);
+    }
+
+    public static ValueExpression eValue(Object value) throws InvalidIRException {
+        return eValue(new SourceMetadata(), value);
+    }
+
+    public static ValueExpression eRegex(SourceMetadata meta, String pattern) throws InvalidIRException {
+       return new RegexValueExpression(meta, pattern);
+    }
+
+    public static ValueExpression eRegex(String pattern) throws InvalidIRException {
+        return eRegex(new SourceMetadata(), pattern);
+    }
+
+    public static ValueExpression eValue(long value) {
+        try {
+            return eValue(new SourceMetadata(), value);
+        } catch (InvalidIRException e) {
+            e.printStackTrace(); // Can't happen with an int
+            return null;
+        }
+    }
+
+    public static ValueExpression eValue(double value) {
+        try {
+            return eValue(new SourceMetadata(), value);
+        } catch (InvalidIRException e) {
+            e.printStackTrace(); // Can't happen with an int
+            return null;
+        }
+    }
+
+    public static Gt eGt(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        return new Gt(meta, left, right);
+    }
+
+    public static Gt eGt(Expression left, Expression right) throws InvalidIRException {
+        return new Gt(null, left, right);
+    }
+
+    public static Gte eGte(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        return new Gte(meta, left, right);
+    }
+
+    public static Gte eGte(Expression left, Expression right) throws InvalidIRException {
+        return new Gte(null, left, right);
+    }
+
+    public static Lt eLt(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        return new Lt(meta, left, right);
+    }
+
+    public static Lt eLt(Expression left, Expression right) throws InvalidIRException {
+        return new Lt(null, left, right);
+    }
+
+    public static Lte eLte(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        return new Lte(meta, left, right);
+    }
+    public static Lte eLte(Expression left, Expression right) throws InvalidIRException {
+        return new Lte(null, left, right);
+    }
+
+    public static Eq eEq(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        return new Eq(meta, left, right);
+    }
+
+    public static Eq eEq(Expression left, Expression right) throws InvalidIRException {
+        return new Eq(null, left, right);
+    }
+
+    public static And eAnd(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        return new And(meta, left, right);
+    }
+
+    public static And eAnd(Expression left, Expression right) throws InvalidIRException {
+        return new And(null, left, right);
+    }
+
+    public static Or eOr(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        return new Or(meta, left, right);
+    }
+
+    public static Or eOr(Expression left, Expression right) throws InvalidIRException {
+        return new Or(null, left, right);
+    }
+
+    public static RegexEq eRegexEq(SourceMetadata meta, Expression left, ValueExpression right) throws InvalidIRException {
+        return new RegexEq(meta, left, right);
+    }
+
+    public static RegexEq eRegexEq(Expression left, ValueExpression right) throws InvalidIRException {
+        return new RegexEq(null, left, right);
+    }
+
+    public static Expression eRegexNeq(SourceMetadata meta, Expression left, ValueExpression right) throws InvalidIRException {
+        return eNot(eRegexEq(meta, left, right));
+    }
+
+    public static Expression eRegexNeq(Expression left, ValueExpression right) throws InvalidIRException {
+        return eNot(eRegexEq(left, right));
+    }
+
+    public static Neq eNeq(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        return new Neq(meta, left, right);
+    }
+    public static Neq eNeq(Expression left, Expression right) throws InvalidIRException {
+        return new Neq(null, left, right);
+    }
+
+    public static In eIn(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        return new In(meta, left, right);
+    }
+
+    public static In eIn(Expression left, Expression right) throws InvalidIRException {
+        return new In(null, left, right);
+    }
+
+    public static Not eNot(SourceMetadata meta, Expression expr) throws InvalidIRException {
+        return new Not(meta, expr);
+    }
+
+    public static Not eNot(Expression expr) throws InvalidIRException {
+        return new Not(null, expr);
+    }
+
+    public static BooleanExpression eTruthy(SourceMetadata meta, Expression expr) throws InvalidIRException {
+        if (expr instanceof BooleanExpression) {
+            return (BooleanExpression) expr;
+        }
+        return new Truthy(meta, expr);
+    }
+    public static BooleanExpression eTruthy(Expression expr) throws InvalidIRException {
+        return eTruthy(null, expr);
+    }
+
+    public static Statement iCompose(ComposedStatement.IFactory factory, SourceMetadata meta, Statement... statements) throws InvalidIRException {
+        if (statements.length == 0 ) {
+            return new NoopStatement(meta);
+        } else if (statements.length == 1 ) {
+            return statements[0];
+        } else {
+            return factory.make(meta, Arrays.asList(statements));
+        }
+    }
+
+    public static Statement iComposeSequence(SourceMetadata meta, Statement... statements) throws InvalidIRException {
+        return iCompose(ComposedSequenceStatement::new, meta, statements);
+    }
+
+    public static Statement iComposeSequence(Statement... statements) throws InvalidIRException {
+        return iComposeSequence(null, statements);
+    }
+
+    public static Statement iComposeParallel(SourceMetadata meta, Statement... statements) throws InvalidIRException {
+        return iCompose(ComposedParallelStatement::new, meta, statements);
+    }
+
+    public static Statement iComposeParallel(Statement... statements) throws InvalidIRException {
+        return iComposeParallel(null, statements);
+    }
+
+    public static NoopStatement noop(SourceMetadata meta) {
+        return new NoopStatement(meta);
+    }
+
+    public static NoopStatement noop() {
+        return new NoopStatement(new SourceMetadata());
+    }
+
+    public static PluginStatement iPlugin(SourceMetadata meta, PluginDefinition.Type pluginType,  String pluginName, Map<String, Object> pluginArguments) {
+        return new PluginStatement(meta, new PluginDefinition(pluginType, pluginName, pluginArguments));
+    }
+
+    public static PluginStatement iPlugin(PluginDefinition.Type type, String pluginName, Map<String, Object> pluginArguments) {
+        return iPlugin(new SourceMetadata(), type, pluginName, pluginArguments);
+    }
+
+    public static PluginStatement iPlugin(PluginDefinition.Type type, String pluginName, MapBuilder<String, Object> argBuilder) {
+        return iPlugin(type, pluginName, argBuilder.build());
+    }
+
+    public static PluginStatement iPlugin(PluginDefinition.Type type, String pluginName) {
+        return iPlugin(type, pluginName, pargs());
+    }
+
+    public static IfStatement iIf(SourceMetadata meta,
+                                  Expression condition,
+                                  Statement ifTrue,
+                                  Statement ifFalse) throws InvalidIRException {
+        BooleanExpression booleanExpression = eTruthy(meta, condition);
+        return new IfStatement(meta, booleanExpression, ifTrue, ifFalse);
+    }
+
+    public static IfStatement iIf(Expression condition,
+                                  Statement ifTrue,
+                                  Statement ifFalse) throws InvalidIRException {
+        return iIf(new SourceMetadata(), condition, ifTrue, ifFalse);
+    }
+
+    public static IfStatement iIf(Expression condition,
+                                  Statement ifTrue) throws InvalidIRException {
+        return iIf(new SourceMetadata(), condition, ifTrue, noop());
+    }
+
+    public static class MapBuilder<K,V> {
+        private final HashMap<K, V> map;
+
+        public MapBuilder() {
+            this.map = new HashMap<>();
+        }
+
+        public MapBuilder<K, V> put(K k, V v) {
+            map.put(k, v);
+            return this;
+        }
+
+        public Map<K, V> build() {
+            return map;
+        }
+    }
+
+    static <K,V> MapBuilder<K,V> mapBuilder() {
+        return new MapBuilder<>();
+    }
+
+    public static MapBuilder<String, Object> argumentBuilder() {
+        return mapBuilder();
+    }
+
+    public static MapBuilder<String, Object> pargs() {
+        return argumentBuilder();
+    }
+
+    public static Graph graph() {
+        return new Graph();
+    }
+
+    public static PluginVertex gPlugin(SourceMetadata sourceMetadata, PluginDefinition.Type pluginType, String pluginName, Map<String, Object> pluginArgs) {
+       return new PluginVertex(sourceMetadata, new PluginDefinition(pluginType, pluginName, pluginArgs));
+    }
+
+    public static PluginVertex gPlugin(PluginDefinition.Type type, String pluginName, Map<String, Object> pluginArgs) {
+        return gPlugin(new SourceMetadata(), type, pluginName, pluginArgs);
+    }
+
+    public static PluginVertex gPlugin(PluginDefinition.Type type, String pluginName) {
+        return gPlugin(new SourceMetadata(), type, pluginName, new HashMap<>());
+    }
+
+
+    public static IfVertex gIf(SourceMetadata meta, BooleanExpression expression) {
+       return new IfVertex(meta, expression);
+    }
+
+    public static IfVertex gIf(BooleanExpression expression) {
+       return new IfVertex(new SourceMetadata(), expression);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/ISourceComponent.java b/logstash-core/src/main/java/org/logstash/config/ir/ISourceComponent.java
new file mode 100644
index 00000000000..af954dd09e2
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/ISourceComponent.java
@@ -0,0 +1,9 @@
+package org.logstash.config.ir;
+
+/**
+ * Created by andrewvc on 9/16/16.
+ */
+public interface ISourceComponent {
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent);
+    public SourceMetadata getMeta();
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/InvalidIRException.java b/logstash-core/src/main/java/org/logstash/config/ir/InvalidIRException.java
new file mode 100644
index 00000000000..7c4a30bf208
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/InvalidIRException.java
@@ -0,0 +1,10 @@
+package org.logstash.config.ir;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public class InvalidIRException extends Exception {
+    public InvalidIRException(String s) {
+        super(s);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/Pipeline.java b/logstash-core/src/main/java/org/logstash/config/ir/Pipeline.java
new file mode 100644
index 00000000000..55f1166a961
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/Pipeline.java
@@ -0,0 +1,87 @@
+package org.logstash.config.ir;
+
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.PluginVertex;
+import org.logstash.config.ir.graph.SpecialVertex;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.List;
+
+/**
+ * Created by andrewvc on 9/20/16.
+ */
+public class Pipeline {
+    public Graph getGraph() {
+        return graph;
+    }
+
+    public SpecialVertex getQueue() {
+        return queue;
+    }
+
+    public SpecialVertex getFilterOut() {
+        return filterOut;
+    }
+
+    private final Graph graph;
+    private final SpecialVertex queue;
+    private final SpecialVertex filterOut;
+
+    public Pipeline(Graph inputSection, Graph filterSection, Graph outputSection) throws InvalidIRException {
+        graph = DSL.graph();
+
+        // We don't really care about the edges in the input section, we just want the vertices as roots
+        for (Vertex inV : inputSection.getVertices()) {
+            if (inV instanceof PluginVertex) {
+                graph.addVertex(inV);
+            } else {
+                throw new InvalidIRException("Only plugin vertices are allowed in input sections!");
+            }
+        }
+
+        // Connect all the input vertices out to the queue
+        queue = new SpecialVertex(SpecialVertex.Type.QUEUE);
+        graph.extend(queue);
+
+        // Now we connect the queue to the root of the filter section
+        graph.extend(filterSection);
+
+        // Now we connect the leaves (and partial leaves) of the graph
+        // which should all be filters (unless no filters are defined)
+        // to the special filterOut node
+        filterOut = new SpecialVertex(SpecialVertex.Type.FILTER_OUT);
+        graph.extend(filterOut);
+
+        // Finally, connect the filter out node to all the outputs
+        graph.extend(outputSection);
+    }
+
+    public List<Vertex> getPostQueue() throws InvalidIRException {
+       return graph.getSortedVerticesAfter(queue);
+    }
+
+    public List<PluginVertex> getInputPluginVertices() {
+        return graph.getPluginVertices(PluginDefinition.Type.INPUT);
+    }
+
+    public List<PluginVertex> getFilterPluginVertices() {
+        return graph.getPluginVertices(PluginDefinition.Type.FILTER);
+    }
+
+    public List<PluginVertex> getOutputPluginVertices() {
+        return graph.getPluginVertices(PluginDefinition.Type.OUTPUT);
+    }
+
+    @Override
+    public String toString() {
+        String summary = String.format("[Pipeline] Inputs: %d Filters: %d Outputs %d",
+                getInputPluginVertices().size(),
+                getFilterPluginVertices().size(),
+                getOutputPluginVertices().size());
+        return summary + "\n" + graph.toString();
+    }
+
+    public String toRubyString() {
+        return "";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/PluginDefinition.java b/logstash-core/src/main/java/org/logstash/config/ir/PluginDefinition.java
new file mode 100644
index 00000000000..bba5392f49d
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/PluginDefinition.java
@@ -0,0 +1,60 @@
+package org.logstash.config.ir;
+
+import java.util.Map;
+import java.util.Objects;
+
+/**
+ * Created by andrewvc on 9/20/16.
+ */
+public class PluginDefinition {
+    public enum Type {
+        INPUT,
+        FILTER,
+        OUTPUT,
+        CODEC
+    }
+
+    private final Type type;
+    private final String name;
+    private final Map<String,Object> arguments;
+
+    public Type getType() {
+        return type;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String getId() {
+        return (String) arguments.get("id");
+    }
+
+    public Map<String, Object> getArguments() {
+        return arguments;
+    }
+
+    public PluginDefinition(Type type, String name, Map<String, Object> arguments) {
+        this.type = type;
+        this.name = name;
+        this.arguments = arguments;
+    }
+
+    public String toString() {
+        return type.toString().toLowerCase() + "-" + name + arguments;
+    }
+
+    public int hashCode() {
+        return Objects.hash(type, name, arguments);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o == null) return false;
+        if (o instanceof PluginDefinition) {
+            PluginDefinition oPlugin = (PluginDefinition) o;
+            return type.equals(oPlugin.type) && name.equals(oPlugin.name) && arguments.equals(oPlugin.arguments);
+        }
+        return false;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/SourceComponent.java b/logstash-core/src/main/java/org/logstash/config/ir/SourceComponent.java
new file mode 100644
index 00000000000..70374314fae
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/SourceComponent.java
@@ -0,0 +1,24 @@
+package org.logstash.config.ir;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public abstract class SourceComponent implements ISourceComponent {
+    private final SourceMetadata meta;
+
+    public SourceComponent(SourceMetadata meta) {
+        this.meta = meta;
+    }
+
+    public SourceMetadata getMeta() {
+        return meta;
+    }
+
+    public abstract boolean sourceComponentEquals(ISourceComponent sourceComponent);
+
+    public String toString(int indent) {
+        return "toString(int indent) should be implemented for " + this.getClass().getName();
+    }
+
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/SourceMetadata.java b/logstash-core/src/main/java/org/logstash/config/ir/SourceMetadata.java
new file mode 100644
index 00000000000..e45969ed30e
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/SourceMetadata.java
@@ -0,0 +1,46 @@
+package org.logstash.config.ir;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public class SourceMetadata {
+    private final String sourceFile;
+
+    public String getSourceFile() {
+        return sourceFile;
+    }
+
+    public Integer getSourceLine() {
+        return sourceLine;
+    }
+
+    public Integer getSourceColumn() {
+        return sourceColumn;
+    }
+
+    public String getSourceText() {
+        return sourceText;
+    }
+
+    private final Integer sourceLine;
+    private final Integer sourceColumn;
+    private final String sourceText;
+
+    public SourceMetadata(String sourceFile, Integer sourceLine, Integer sourceChar, String sourceText) {
+        this.sourceFile = sourceFile;
+        this.sourceLine = sourceLine;
+        this.sourceColumn = sourceChar;
+        this.sourceText = sourceText;
+    }
+
+    public SourceMetadata() {
+        this.sourceFile = null;
+        this.sourceLine = null;
+        this.sourceColumn = null;
+        this.sourceText = null;
+    }
+
+    public String toString() {
+        return sourceFile + ":" + sourceLine + ":" + sourceColumn + ":```\n" + sourceText + "\n```";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java
new file mode 100644
index 00000000000..5c2e26ba22e
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java
@@ -0,0 +1,48 @@
+package org.logstash.config.ir.expression;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public abstract class BinaryBooleanExpression extends BooleanExpression {
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (this == sourceComponent) return true;
+        if (this.getClass().equals(sourceComponent.getClass())) {
+            BinaryBooleanExpression other = (BinaryBooleanExpression) sourceComponent;
+            return (this.getLeft().sourceComponentEquals(other.getLeft()) &&
+                    this.getRight().sourceComponentEquals(other.getRight()));
+        }
+        return false;
+    }
+
+    private final Expression left;
+    private final Expression right;
+
+    public Expression getRight() {
+        return right;
+    }
+
+    public Expression getLeft() {
+        return left;
+    }
+
+    public BinaryBooleanExpression(SourceMetadata meta,
+                                   Expression left,
+                                   Expression right) throws InvalidIRException {
+        super(meta);
+        this.left = left;
+        this.right = right;
+    }
+
+    public abstract String rubyOperator();
+
+    @Override
+    public String toRubyString() {
+        return "(" + getLeft().toRubyString() + rubyOperator() + getRight().toRubyString() + ")";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/BooleanExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/BooleanExpression.java
new file mode 100644
index 00000000000..533d20f5c56
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/BooleanExpression.java
@@ -0,0 +1,13 @@
+package org.logstash.config.ir.expression;
+
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/14/16.
+ */
+public abstract class BooleanExpression extends Expression {
+    public BooleanExpression(SourceMetadata meta) {
+        super(meta);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/EventValueExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/EventValueExpression.java
new file mode 100644
index 00000000000..eeff014b6cb
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/EventValueExpression.java
@@ -0,0 +1,41 @@
+package org.logstash.config.ir.expression;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+
+/**
+ * Created by andrewvc on 9/13/16.
+ */
+public class EventValueExpression extends Expression {
+    private final String fieldName;
+
+    public EventValueExpression(SourceMetadata meta, String fieldName) {
+        super(meta);
+        this.fieldName = fieldName;
+    }
+
+    public String getFieldName() {
+        return fieldName;
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (this == sourceComponent) return true;
+        if (sourceComponent instanceof EventValueExpression) {
+            EventValueExpression other = (EventValueExpression) sourceComponent;
+            return (this.getFieldName().equals(other.getFieldName()));
+        }
+        return false;
+    }
+
+    @Override
+    public String toString() {
+        return "event.get('" + fieldName + "')";
+    }
+
+    @Override
+    public String toRubyString() {
+        return "event.getField('" + fieldName + "')";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java
new file mode 100644
index 00000000000..8a6b3a53e0f
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java
@@ -0,0 +1,48 @@
+package org.logstash.config.ir.expression;
+
+import org.jruby.RubyInstanceConfig;
+import org.jruby.embed.AttributeName;
+import org.jruby.embed.EmbedEvalUnit;
+import org.jruby.embed.ScriptingContainer;
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+
+/**
+ * [foo] == "foostr" eAnd [bar] > 10
+ * eAnd(eEq(eventValueExpr("foo"), value("foostr")), eEq(eEventValue("bar"), value(10)))
+ *
+ * if [foo]
+ * notnull(eEventValue("foo"))
+ * Created by andrewvc on 9/6/16.
+ */
+public abstract class Expression extends SourceComponent {
+    private Object compiled;
+    private ScriptingContainer container;
+
+    public Expression(SourceMetadata meta) {
+        super(meta);
+    }
+
+    public boolean eval() {
+        return true;
+    }
+
+    public void compile() {
+        container = new ScriptingContainer();
+        container.setCompileMode(RubyInstanceConfig.CompileMode.JIT);
+        container.setAttribute(AttributeName.SHARING_VARIABLES, false);
+        container.runScriptlet("def start(event)\n" + this.toString() + "\nend");
+    }
+
+    @Override
+    public String toString(int indent) {
+        return toString();
+    }
+
+    @Override
+    public String toString() {
+        return toRubyString();
+    }
+
+    public abstract String toRubyString();
+}
\ No newline at end of file
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/RegexValueExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/RegexValueExpression.java
new file mode 100644
index 00000000000..bbe8ae4756b
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/RegexValueExpression.java
@@ -0,0 +1,53 @@
+package org.logstash.config.ir.expression;
+
+import org.joni.Option;
+import org.joni.Regex;
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class RegexValueExpression extends ValueExpression {
+    private final Regex regex;
+
+    public RegexValueExpression(SourceMetadata meta, Object value) throws InvalidIRException {
+        super(meta, value);
+
+        if (!(value instanceof String)) {
+            throw new InvalidIRException("Regex value expressions can only take strings!");
+        }
+
+        byte[] patternBytes = getSource().getBytes();
+        this.regex = new Regex(patternBytes, 0, patternBytes.length, Option.NONE);
+    }
+
+    @Override
+    public Object get() {
+        return this.regex;
+    }
+
+    public String getSource() {
+        return (String) value;
+    }
+
+    @Override
+    public String toString() {
+        return this.value.toString();
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent other) {
+        if (other == null) return false;
+        if (other instanceof RegexValueExpression) {
+            return (((RegexValueExpression) other).getSource().equals(getSource()));
+        }
+        return false;
+    }
+
+    @Override
+    public String toRubyString() {
+       return (String) value;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/UnaryBooleanExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/UnaryBooleanExpression.java
new file mode 100644
index 00000000000..3c1c84572df
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/UnaryBooleanExpression.java
@@ -0,0 +1,23 @@
+package org.logstash.config.ir.expression;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+
+/**
+ * Created by andrewvc on 9/13/16.
+ */
+public abstract class UnaryBooleanExpression extends BooleanExpression {
+    private final Expression expression;
+
+    public Expression getExpression() {
+        return expression;
+    }
+
+    public UnaryBooleanExpression(SourceMetadata meta,
+                                   Expression expression) throws InvalidIRException {
+        super(meta);
+        if (expression == null) throw new InvalidIRException("Unary expressions cannot operate on null!");
+        this.expression = expression;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/ValueExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/ValueExpression.java
new file mode 100644
index 00000000000..db8b0324863
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/ValueExpression.java
@@ -0,0 +1,66 @@
+package org.logstash.config.ir.expression;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+
+import java.math.BigDecimal;
+import java.util.List;
+
+/**
+ * Created by andrewvc on 9/13/16.
+ */
+public class ValueExpression extends Expression {
+    protected final Object value;
+
+    public ValueExpression(SourceMetadata meta, Object value) throws InvalidIRException {
+        super(meta);
+
+        if (!(value == null ||
+                value instanceof Short ||
+                value instanceof Long ||
+                value instanceof Integer ||
+                value instanceof Float ||
+                value instanceof Double ||
+                value instanceof BigDecimal ||
+                value instanceof String ||
+                value instanceof List ||
+                value instanceof java.time.Instant
+        )) {
+            throw new InvalidIRException("Invalid eValue " + value + " with class " + value.getClass().getName());
+        }
+
+        this.value = value;
+    }
+
+    public Object get() {
+        return value;
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (this == sourceComponent) return true;
+        if (sourceComponent instanceof ValueExpression) {
+            ValueExpression other = (ValueExpression) sourceComponent;
+            if (this.get() == null) {
+                return (other.get() == null);
+            } else {
+                return (this.get().equals(other.get()));
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public String toRubyString() {
+        if (value == null) {
+            return "null";
+        }
+        if (value instanceof String) {
+            return "'" + get() + "'";
+        }
+
+        return get().toString();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/And.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/And.java
new file mode 100644
index 00000000000..434cea5c159
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/And.java
@@ -0,0 +1,20 @@
+package org.logstash.config.ir.expression.binary;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BinaryBooleanExpression;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class And extends BinaryBooleanExpression {
+    public And(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        super(meta, left, right);
+    }
+
+    @Override
+    public String rubyOperator() {
+        return "&&";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Eq.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Eq.java
new file mode 100644
index 00000000000..3ddbd50d3d0
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Eq.java
@@ -0,0 +1,21 @@
+package org.logstash.config.ir.expression.binary;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BinaryBooleanExpression;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class Eq extends BinaryBooleanExpression {
+    public Eq(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        super(meta, left, right);
+    }
+
+    @Override
+    public String rubyOperator() {
+        return "==";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Gt.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Gt.java
new file mode 100644
index 00000000000..e611a771790
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Gt.java
@@ -0,0 +1,20 @@
+package org.logstash.config.ir.expression.binary;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BinaryBooleanExpression;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class Gt extends BinaryBooleanExpression {
+    public Gt(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        super(meta, left, right);
+    }
+
+    @Override
+    public String rubyOperator() {
+        return ">";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Gte.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Gte.java
new file mode 100644
index 00000000000..3e9840c6eef
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Gte.java
@@ -0,0 +1,20 @@
+package org.logstash.config.ir.expression.binary;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BinaryBooleanExpression;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class Gte extends BinaryBooleanExpression {
+    public Gte(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        super(meta, left, right);
+    }
+
+    @Override
+    public String rubyOperator() {
+        return ">=";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/In.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/In.java
new file mode 100644
index 00000000000..0a4302c4608
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/In.java
@@ -0,0 +1,20 @@
+package org.logstash.config.ir.expression.binary;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BinaryBooleanExpression;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class In extends BinaryBooleanExpression {
+    public In(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        super(meta, left, right);
+    }
+
+    @Override
+    public String rubyOperator() {
+        return ".include?";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Lt.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Lt.java
new file mode 100644
index 00000000000..ea453b9a433
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Lt.java
@@ -0,0 +1,20 @@
+package org.logstash.config.ir.expression.binary;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BinaryBooleanExpression;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class Lt extends BinaryBooleanExpression {
+    public Lt(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        super(meta, left, right);
+    }
+
+    @Override
+    public String rubyOperator() {
+        return "<";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Lte.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Lte.java
new file mode 100644
index 00000000000..0a165023ddc
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Lte.java
@@ -0,0 +1,20 @@
+package org.logstash.config.ir.expression.binary;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BinaryBooleanExpression;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class Lte extends BinaryBooleanExpression {
+    public Lte(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        super(meta, left, right);
+    }
+
+    @Override
+    public String rubyOperator() {
+        return "<=";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Neq.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Neq.java
new file mode 100644
index 00000000000..5358a123948
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Neq.java
@@ -0,0 +1,20 @@
+package org.logstash.config.ir.expression.binary;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BinaryBooleanExpression;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class Neq extends BinaryBooleanExpression {
+    public Neq(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        super(meta, left, right);
+    }
+
+    @Override
+    public String rubyOperator() {
+        return "!=";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Or.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Or.java
new file mode 100644
index 00000000000..290200e2bc2
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Or.java
@@ -0,0 +1,20 @@
+package org.logstash.config.ir.expression.binary;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BinaryBooleanExpression;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class Or extends BinaryBooleanExpression {
+    public Or(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        super(meta, left, right);
+    }
+
+    @Override
+    public String rubyOperator() {
+        return "||";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/RegexEq.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/RegexEq.java
new file mode 100644
index 00000000000..043d84a3ad3
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/RegexEq.java
@@ -0,0 +1,26 @@
+package org.logstash.config.ir.expression.binary;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BinaryBooleanExpression;
+import org.logstash.config.ir.expression.Expression;
+import org.logstash.config.ir.expression.RegexValueExpression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class RegexEq extends BinaryBooleanExpression {
+    public RegexEq(SourceMetadata meta, Expression left, Expression right) throws InvalidIRException {
+        super(meta, left, right);
+
+        if (!(right instanceof RegexValueExpression)) {
+            throw new InvalidIRException("You must use a regexp operator with a regexp rval!" + right);
+        }
+    }
+
+    @Override
+    public String rubyOperator() {
+        return "=~";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/unary/Not.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/unary/Not.java
new file mode 100644
index 00000000000..968db43a5f2
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/unary/Not.java
@@ -0,0 +1,28 @@
+package org.logstash.config.ir.expression.unary;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.Expression;
+import org.logstash.config.ir.expression.UnaryBooleanExpression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class Not extends UnaryBooleanExpression {
+    public Not(SourceMetadata meta, Expression expression) throws InvalidIRException {
+        super(meta, expression);
+    }
+
+    @Override
+    public String toRubyString() {
+        return "!(" + getExpression().toRubyString() + ")";
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        return sourceComponent != null &&
+                (sourceComponent instanceof Not &&
+                        ((Not) sourceComponent).getExpression().sourceComponentEquals(getExpression()));
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/unary/Truthy.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/unary/Truthy.java
new file mode 100644
index 00000000000..6ef1550fa9f
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/unary/Truthy.java
@@ -0,0 +1,28 @@
+package org.logstash.config.ir.expression.unary;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.Expression;
+import org.logstash.config.ir.expression.UnaryBooleanExpression;
+
+/**
+ * Created by andrewvc on 9/21/16.
+ */
+public class Truthy extends UnaryBooleanExpression {
+    public Truthy(SourceMetadata meta, Expression expression) throws InvalidIRException {
+        super(meta, expression);
+    }
+
+    @Override
+    public String toRubyString() {
+        return "!!(" + this.getExpression() + ")";
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        return sourceComponent != null &&
+                sourceComponent instanceof Truthy &&
+                ((Truthy) sourceComponent).getExpression().sourceComponentEquals(this.getExpression());
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/BooleanEdge.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/BooleanEdge.java
new file mode 100644
index 00000000000..0cd31080d9b
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/BooleanEdge.java
@@ -0,0 +1,63 @@
+package org.logstash.config.ir.graph;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+
+import java.util.Collection;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class BooleanEdge extends Edge {
+    public static class BooleanEdgeFactory extends EdgeFactory {
+        private final Boolean edgeType;
+
+        public BooleanEdgeFactory(Boolean edgeType) {
+            this.edgeType = edgeType;
+        }
+
+        public BooleanEdge make(Vertex in, Vertex out) throws InvalidIRException {
+            return new BooleanEdge(edgeType, in, out);
+        }
+    }
+    public static BooleanEdge.BooleanEdgeFactory trueFactory = new BooleanEdge.BooleanEdgeFactory(true);
+    public static BooleanEdge.BooleanEdgeFactory falseFactory = new BooleanEdge.BooleanEdgeFactory(false);
+
+    public static Collection<Edge> trueThreadVertices(Vertex... vertices) throws InvalidIRException {
+        return threadVertices(new BooleanEdgeFactory(true), vertices);
+    }
+
+    public static Collection<Edge> falseThreadVertices(Vertex... vertices) throws InvalidIRException {
+        return threadVertices(new BooleanEdgeFactory(false), vertices);
+    }
+
+    private final Boolean edgeType;
+
+    public Boolean getEdgeType() {
+        return edgeType;
+    }
+
+    public BooleanEdge(Boolean edgeType, Vertex outVertex, Vertex inVertex) throws InvalidIRException {
+        super(outVertex, inVertex);
+        this.edgeType = edgeType;
+    }
+
+    public String toString() {
+        return getFrom() + " -|" + this.edgeType + "|-> " + getTo();
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (sourceComponent == this) return true;
+        if (sourceComponent instanceof BooleanEdge) {
+            BooleanEdge otherE = (BooleanEdge) sourceComponent;
+
+            return this.getFrom().sourceComponentEquals(otherE.getFrom()) &&
+                    this.getTo().sourceComponentEquals(otherE.getTo()) &&
+                    this.getEdgeType().equals(otherE.getEdgeType());
+        }
+        return false;
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/Edge.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/Edge.java
new file mode 100644
index 00000000000..ae801aeb819
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/Edge.java
@@ -0,0 +1,76 @@
+package org.logstash.config.ir.graph;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public abstract class Edge implements ISourceComponent {
+    public static abstract class EdgeFactory {
+        public abstract Edge make(Vertex out, Vertex in) throws InvalidIRException;
+    }
+
+    private final Vertex to;
+    private final Vertex from;
+
+    public static Collection<Edge> threadVertices(EdgeFactory edgeFactory, Vertex... vertices) throws InvalidIRException {
+        Collection<Edge> edges = new ArrayList<>();
+
+        for (int i = 0; i < vertices.length-1; i++) {
+            Vertex from = vertices[i];
+            Vertex to = vertices[i+1];
+
+            Edge edge = edgeFactory.make(from, to);
+            to.addInEdge(edge);
+            from.addOutEdge(edge);
+            edges.add(edge);
+        }
+
+        return edges;
+    }
+
+    public Edge(Vertex from, Vertex to) throws InvalidIRException {
+        this.from = from;
+        this.to = to;
+
+        if (this.from == this.to) {
+            throw new InvalidIRException("Cannot create a cyclic vertex!" + to);
+        }
+    }
+
+    public Vertex getTo() {
+        return to;
+    }
+
+    public Vertex getFrom() {
+        return from;
+    }
+
+    public String toString() {
+        return getFrom() + " -> " + getTo();
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (sourceComponent == this) return true;
+        if (sourceComponent.getClass() == sourceComponent.getClass()) {
+            Edge otherE = (Edge) sourceComponent;
+
+            return this.getFrom().sourceComponentEquals(otherE.getFrom()) &&
+                    this.getTo().sourceComponentEquals(otherE.getTo());
+        }
+        return false;
+    }
+
+
+    @Override
+    public SourceMetadata getMeta() {
+        return null;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java
new file mode 100644
index 00000000000..30692ff2772
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java
@@ -0,0 +1,345 @@
+package org.logstash.config.ir.graph;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.PluginDefinition;
+import org.logstash.config.ir.SourceMetadata;
+
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class Graph implements ISourceComponent {
+    private final Set<Vertex> vertices = new HashSet<>();
+    private final Set<Edge> edges = new HashSet<>();
+
+    public Graph(Collection<Vertex> vertices, Collection<Edge> edges) throws InvalidIRException {
+        this.vertices.addAll(vertices);
+        this.edges.addAll(edges);
+        validate();
+    }
+
+    public Graph() {
+    }
+
+    public static Graph empty() {
+        return new Graph();
+    }
+
+    public Graph addVertex(Vertex v) {
+        this.vertices.add(v);
+        return this;
+    }
+
+    public void merge(Graph otherGraph) throws InvalidIRException {
+        this.vertices.addAll(otherGraph.getVertices());
+        this.edges.addAll(otherGraph.edges);
+        refresh();
+    }
+
+    /*
+      Attach another graph's nodes to this one by connection this graph's leaves to
+      the other graph's root
+    */
+    public Graph extend(Graph otherGraph) throws InvalidIRException {
+        if (otherGraph.getVertices().size() == 0) return this;
+
+        if (this.isEmpty()) {
+            this.merge(otherGraph);
+            return this;
+        }
+
+        for (Vertex otherRoot : otherGraph.getRoots()) {
+            extend(otherRoot);
+        }
+
+        return this;
+    }
+
+    public Graph extend(Vertex otherVertex) throws InvalidIRException {
+        for (Vertex leaf : this.getPartialLeaves()) {
+            for (Edge.EdgeFactory unusedEf : leaf.getUnusedOutgoingEdgeFactories()) {
+                this.threadVertices(unusedEf, leaf, otherVertex);
+            }
+        }
+        return this;
+    }
+
+    public Graph threadVertices(Edge.EdgeFactory edgeFactory, Vertex... argVertices) throws InvalidIRException {
+        Collection<Edge> newEdges = Edge.threadVertices(edgeFactory, argVertices);
+        addEdges(newEdges);
+
+        return this;
+    }
+
+    public Graph threadVertices(boolean bool, Vertex... vertices) throws InvalidIRException {
+        Edge.EdgeFactory factory = new BooleanEdge.BooleanEdgeFactory(bool);
+        return threadVertices(factory, vertices);
+    }
+
+    public Graph threadVertices(Vertex... vertices) throws InvalidIRException {
+        return threadVertices(new PlainEdge.PlainEdgeFactory(), vertices);
+    }
+
+    private void addEdge(Edge e) throws InvalidIRException {
+        this.getEdges().add(e);
+        refresh();
+    }
+
+    public void refresh() throws InvalidIRException {
+        walk(e -> {
+            this.edges.add(e);
+            this.vertices.add(e.getTo());
+            this.vertices.add(e.getFrom());
+        });
+
+        this.validate();
+    }
+
+    public void validate() throws InvalidIRException {
+        if (this.getVertices().stream().noneMatch(Vertex::isLeaf)) {
+            throw new InvalidIRException("Graph has no leaf vertices!" + this.toString());
+        }
+
+        this.getSortedVertices();
+    }
+
+    public void walk(Consumer<Edge> consumer) {
+        // avoid stream interface to avoid concurrency issues if a new root is added
+        for (Vertex root : this.getRoots()) {
+            walk(consumer, root);
+        }
+    }
+
+    private void walk(Consumer<Edge> consumer, Vertex vertex) {
+       vertex.outgoingEdges().forEach(e -> {
+           consumer.accept(e);
+           walk(consumer,e.getTo());
+       });
+    }
+
+    public Graph addEdges(Collection<Edge> edges) throws InvalidIRException {
+        this.edges.addAll(edges);
+
+        this.edges.stream().forEach(edge -> {
+            this.vertices.add(edge.getTo());
+            this.vertices.add(edge.getFrom());
+        });
+
+        refresh();
+
+        return this;
+    }
+
+    public Stream<Vertex> roots() {
+        return vertices.stream().filter(Vertex::isRoot);
+    }
+
+    public List<Vertex> getRoots() {
+        return roots().collect(Collectors.toList());
+    }
+
+    // Vertices which are partially leaves in that they support multiple
+    // outgoing edge types but only have one or fewer attached
+    public Stream<Vertex> partialLeaves() {
+        return vertices.stream().filter(Vertex::isPartialLeaf);
+    }
+
+    public Collection<Vertex> getPartialLeaves() {
+        return partialLeaves().collect(Collectors.toList());
+    }
+
+    public Stream<Vertex> leaves() {
+        return vertices.stream().filter(Vertex::isLeaf);
+    }
+
+    public Collection<Vertex> getLeaves() {
+        return leaves().collect(Collectors.toList());
+    }
+
+    public Set<Vertex> getVertices() {
+        return vertices;
+    }
+
+    public Set<Edge> getEdges() {
+        return edges;
+    }
+
+    public String toString() {
+        Stream<Edge> edgesToFormat;
+        try {
+            edgesToFormat = getSortedEdges().stream();
+        } catch (InvalidIRException e) {
+            edgesToFormat = edges.stream();
+        }
+
+        String edgelessVerticesStr;
+        if (this.isolatedVertices().count() > 0) {
+            edgelessVerticesStr = "\n== Vertices Without Edges ==\n" +
+                    this.isolatedVertices().map(Vertex::toString).collect(Collectors.joining("\n"));
+        } else {
+            edgelessVerticesStr = "";
+        }
+
+        return "<<< GRAPH >>>\n" +
+                edgesToFormat.map(Edge::toString).collect(Collectors.joining("\n")) +
+                edgelessVerticesStr +
+                "\n<<< /GRAPH >>>";
+    }
+
+    public Stream<Vertex> isolatedVertices() {
+        return this.getVertices().stream().filter(v -> v.getOutgoingEdges().isEmpty() && v.getIncomingEdges().isEmpty());
+    }
+
+    // Uses Kahn's algorithm to do a topological sort and detect cycles
+    public List<Vertex> getSortedVertices() throws InvalidIRException {
+        if (this.edges.size() == 0) return new ArrayList(this.vertices);
+
+        List<Vertex> sorted = new ArrayList<>(this.vertices.size());
+
+        Deque<Vertex> pending = new LinkedList<>();
+        pending.addAll(this.getRoots());
+
+        Set<Edge> traversedEdges = new HashSet<>();
+
+        while (!pending.isEmpty()) {
+            Vertex currentVertex = pending.removeFirst();
+            sorted.add(currentVertex);
+
+            currentVertex.getOutgoingEdges().forEach(edge -> {
+                traversedEdges.add(edge);
+                Vertex toVertex = edge.getTo();
+                if (toVertex.getIncomingEdges().stream().allMatch(traversedEdges::contains)) {
+                    pending.add(toVertex);
+                }
+            });
+        }
+
+        // Check for cycles
+        if (this.edges.stream().noneMatch(traversedEdges::contains)) {
+            throw new InvalidIRException("Graph has cycles, is not a DAG! " + this.edges);
+        }
+
+        return sorted;
+    }
+
+    public List<Edge> getSortedEdges() throws InvalidIRException {
+        return getSortedVertices().stream().
+                flatMap(Vertex::outgoingEdges).
+                collect(Collectors.toList());
+    }
+
+    public List<Vertex> getSortedVerticesBefore(Vertex end) throws InvalidIRException {
+        return getSortedVerticesBetween(null, end);
+    }
+
+    public List<Vertex> getSortedVerticesAfter(Vertex start) throws InvalidIRException {
+        return getSortedVerticesBetween(start, null);
+    }
+
+    public List<Vertex> getSortedVerticesBetween(Vertex start, Vertex end) throws InvalidIRException {
+        List<Vertex> sortedVertices = getSortedVertices();
+
+        int startIndex = start == null ? 0 : sortedVertices.indexOf(start);
+        int endIndex = end == null ? sortedVertices.size() : sortedVertices.indexOf(end);
+
+        return sortedVertices.subList(startIndex+1, endIndex);
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        if (sourceComponent == this) return true;
+        if (sourceComponent instanceof Graph) {
+            Graph otherG = (Graph) sourceComponent;
+            if (otherG.getVertices().size() != this.getVertices().size()) return false;
+
+            boolean edgesEqual = this.getEdges().stream().
+                    allMatch(e -> otherG.getEdges().stream().anyMatch(oe -> oe.sourceComponentEquals(e)));
+
+            // We need to check vertices separately because there may be unconnected vertices
+            boolean verticesEqual = this.getVertices().stream().
+                    allMatch(v -> otherG.getVertices().stream().anyMatch(ov -> ov.sourceComponentEquals(v)));
+
+            return edgesEqual && verticesEqual;
+        }
+        return false;
+    }
+
+    // returns true if this graph has a .sourceComponentEquals equivalent edge
+    public boolean hasEquivalentEdge(Edge otherE) {
+        return this.getEdges().stream().anyMatch(e -> e.sourceComponentEquals(otherE));
+    }
+
+
+    public class DiffResult {
+        public Collection<Edge> getRemovedEdges() {
+            return removedEdges;
+        }
+
+        public Collection<Edge> getAddedEdges() {
+            return addedEdges;
+        }
+
+        private final Collection<Edge> removedEdges;
+        private final Collection<Edge> addedEdges;
+
+        public DiffResult(Collection<Edge> removed, Collection<Edge> added) {
+            this.removedEdges = removed;
+            this.addedEdges = added;
+        }
+
+        public String toString() {
+            return "Diff Result (-" + removedEdges.size() + ",+" + addedEdges.size() + ")\n" +
+                    removedEdges.stream().map(e -> "-" + e.toString()).collect(Collectors.joining("\n")) +
+                    "\n" +
+                    addedEdges.stream().map(e -> "+" + e.toString()).collect(Collectors.joining("\n"));
+        }
+    }
+
+    public DiffResult diff(Graph o) {
+       List<Edge> removedEdges = this.getEdges().stream().filter(e -> !o.hasEquivalentEdge(e)).collect(Collectors.toList());
+       List<Edge> addedEdges = o.getEdges().stream().filter(e -> !o.hasEquivalentEdge(e)).collect(Collectors.toList());
+        return new DiffResult(removedEdges, addedEdges);
+    }
+
+    @Override
+    public SourceMetadata getMeta() {
+        return null;
+    }
+
+    public boolean isEmpty() {
+        return (this.getVertices().size() == 0);
+    }
+
+    public Graph threadToGraph(BooleanEdge.BooleanEdgeFactory edgeFactory, Vertex v, Graph otherGraph) throws InvalidIRException {
+        if (otherGraph.getVertices().size() == 0) return this;
+
+        for (Vertex otherRoot : otherGraph.getRoots()) {
+            this.threadVertices(edgeFactory, v, otherRoot);
+        }
+
+        return this;
+    }
+
+    // Return plugin vertices by type
+    public List<PluginVertex> getPluginVertices(PluginDefinition.Type type) {
+       return pluginVertices()
+               .filter(v -> v.getPluginDefinition().getType().equals(type))
+               .collect(Collectors.toList());
+    }
+
+    public List<PluginVertex> getPluginVertices() {
+        return pluginVertices().collect(Collectors.toList());
+    }
+
+    public Stream<PluginVertex> pluginVertices() {
+        return this.vertices.stream()
+               .filter(v -> v instanceof PluginVertex)
+               .map(v -> (PluginVertex) v);
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java
new file mode 100644
index 00000000000..ffe49078bad
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java
@@ -0,0 +1,69 @@
+package org.logstash.config.ir.graph;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BooleanExpression;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class IfVertex extends Vertex {
+
+    public BooleanExpression getBooleanExpression() {
+        return booleanExpression;
+    }
+
+    private final BooleanExpression booleanExpression;
+
+    public IfVertex(SourceMetadata meta, BooleanExpression booleanExpression) {
+        super(meta);
+        this.booleanExpression = booleanExpression;
+    }
+
+    public String toString() {
+        return "[if " + booleanExpression.toString(0) + "]";
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent other) {
+        if (other == null) return false;
+        if (other == this) return true;
+        if (other instanceof IfVertex) {
+            IfVertex otherV = (IfVertex) other;
+            // We don't check the ID because that's randomly generated
+            return otherV.booleanExpression.sourceComponentEquals(this.booleanExpression);
+        }
+        return false;
+    }
+
+    public boolean hasEdgeType(boolean type) {
+        for (Edge e : getOutgoingEdges()) {
+            BooleanEdge bEdge = (BooleanEdge) e; // There should only  be boolean edges here!
+            if (bEdge.getEdgeType() == type) return true;
+        }
+        return false;
+    }
+
+    public Collection<Edge.EdgeFactory> getUnusedOutgoingEdgeFactories() {
+        List<Edge.EdgeFactory> l = new LinkedList<>();
+        if (!hasEdgeType(true)) l.add(BooleanEdge.trueFactory);
+        if (!hasEdgeType(false)) l.add(BooleanEdge.falseFactory);
+        return l;
+    }
+
+    public boolean acceptsOutgoingEdge(Edge e) {
+        return (e instanceof BooleanEdge);
+    }
+
+    public List<BooleanEdge> getOutgoingBooleanEdges() {
+        // Wish there was a way to do this as a java a cast without an operation
+        return getOutgoingEdges().stream().map(e -> (BooleanEdge) e).collect(Collectors.toList());
+    }
+
+    public List<BooleanEdge> getOutgoingBooleanEdgesByType(Boolean edgeType) {
+        return getOutgoingBooleanEdges().stream().filter(e -> e.getEdgeType().equals(edgeType)).collect(Collectors.toList());
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/PlainEdge.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/PlainEdge.java
new file mode 100644
index 00000000000..8237ceb8fc2
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/PlainEdge.java
@@ -0,0 +1,23 @@
+package org.logstash.config.ir.graph;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+
+/**
+ * Created by andrewvc on 9/19/16.
+ */
+public class PlainEdge extends Edge {
+    public static class PlainEdgeFactory extends Edge.EdgeFactory {
+        @Override
+        public Edge make(Vertex from, Vertex to) throws InvalidIRException {
+           return new PlainEdge(from, to);
+        }
+    }
+
+    public PlainEdge(Vertex from, Vertex to) throws InvalidIRException {
+        super(from, to);
+    }
+
+
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java
new file mode 100644
index 00000000000..3d67670be83
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java
@@ -0,0 +1,60 @@
+package org.logstash.config.ir.graph;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.PluginDefinition;
+import org.logstash.config.ir.SourceMetadata;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.UUID;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class PluginVertex extends Vertex {
+    private final SourceMetadata meta;
+
+    public String getId() {
+        return id;
+    }
+
+    @Override
+    public SourceMetadata getMeta() {
+        return meta;
+    }
+
+    private final String id;
+
+    public PluginDefinition getPluginDefinition() {
+        return pluginDefinition;
+    }
+
+    private final PluginDefinition pluginDefinition;
+
+    public PluginVertex(SourceMetadata meta, PluginDefinition pluginDefinition) {
+        super(meta);
+        this.meta = meta;
+
+        this.pluginDefinition = pluginDefinition;
+
+        Object argId = this.pluginDefinition.getArguments().get("id");
+        this.id = argId != null ? argId.toString() : UUID.randomUUID().toString();
+        this.pluginDefinition.getArguments().put("id", this.id);
+    }
+
+    public String toString() {
+        return "P[" + pluginDefinition + "]";
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent other) {
+        if (other == null) return false;
+        if (other == this) return true;
+        if (other instanceof PluginVertex) {
+            PluginVertex otherV = (PluginVertex) other;
+            // We don't check the ID because that's randomly generated
+            return otherV.getPluginDefinition().equals(this.getPluginDefinition());
+        }
+        return false;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/SpecialVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/SpecialVertex.java
new file mode 100644
index 00000000000..0986ac15a20
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/SpecialVertex.java
@@ -0,0 +1,54 @@
+package org.logstash.config.ir.graph;
+
+import org.logstash.config.ir.ISourceComponent;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class SpecialVertex extends Vertex {
+    private final Type type;
+
+    public SpecialVertex() {
+        super(null);
+        this.type = Type.QUEUE;
+    }
+
+    public SpecialVertex(Type type) {
+        super(null);
+        this.type = type;
+
+    }
+
+    public enum Type {
+        FILTER_IN ("FILTER_IN"),
+        FILTER_OUT ("FILTER OUT"),
+        OUTPUT_IN ("OUTPUT IN"),
+        OUTPUT_OUT ("OUTPUT OUT"),
+        QUEUE ("QUEUE");
+
+        private final String name;
+
+        Type(String s) {
+            this.name = s;
+        }
+
+        public String toString() {
+            return this.name;
+        }
+    }
+
+    public String toString() {
+        return "S[" + this.type + "]";
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent other) {
+        if (other == null) return false;
+        if (other == this) return true;
+        if (other instanceof SpecialVertex) {
+            SpecialVertex otherV = (SpecialVertex) other;
+            return otherV.type.equals(this.type);
+        }
+        return false;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java
new file mode 100644
index 00000000000..a6e7b51dee8
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java
@@ -0,0 +1,104 @@
+package org.logstash.config.ir.graph;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+
+import java.util.*;
+import java.util.stream.Stream;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public abstract class Vertex implements ISourceComponent {
+    private final Collection<Edge> incoming = new HashSet<Edge>();
+    private final Collection<Edge> outgoingEdges = new HashSet<Edge>();
+    private final SourceMetadata sourceMetadata;
+
+    public Vertex() {
+        this.sourceMetadata = null;
+    }
+
+    public Vertex(SourceMetadata sourceMetadata) {
+        this.sourceMetadata = sourceMetadata;
+    }
+
+    public Vertex(Collection<Edge> incoming, Collection<Edge> outgoingEdges, SourceMetadata sourceMetadata) {
+        this.sourceMetadata = sourceMetadata;
+        this.incoming.addAll(incoming);
+        this.outgoingEdges.addAll(outgoingEdges);
+    }
+
+    public Vertex addInEdge(Edge e) throws InvalidIRException {
+        if (!this.acceptsIncomingEdge(e)) throw new InvalidIRException("Invalid incoming edge!" + e + " for " + this);
+        this.incoming.add(e);
+        return this;
+    }
+
+    public Vertex addOutEdge(Edge e) throws InvalidIRException {
+        if (!this.acceptsOutgoingEdge(e)) {
+            throw new InvalidIRException(
+                "Invalid outgoing edge!" +
+                e + " for " + this +
+                " existing outgoing edges: " + this.getOutgoingEdges());
+        }
+        this.outgoingEdges.add(e);
+        return this;
+    }
+
+    public boolean isRoot() {
+        return incoming.size() == 0;
+    }
+
+    public boolean isLeaf() {
+        return outgoingEdges.size() == 0;
+    }
+
+    public boolean hasIncomingEdges() {
+        return incoming.size() > 0;
+    }
+
+    public boolean hasOutgoingEdges() {
+        return outgoingEdges.size() > 0;
+    }
+
+    public Collection<Edge> getIncomingEdges() {
+        return incoming;
+    }
+
+    public Collection<Edge> getOutgoingEdges() {
+        return outgoingEdges;
+    }
+
+    public Stream<Edge> incomingEdges() {
+        return getIncomingEdges().stream();
+    }
+
+    public Stream<Edge> outgoingEdges() {
+        return outgoingEdges.stream();
+    }
+
+    @Override
+    public SourceMetadata getMeta() {
+        return null;
+    }
+
+    public Collection<Edge.EdgeFactory> getUnusedOutgoingEdgeFactories() {
+       if (!this.hasOutgoingEdges()) {
+           return Collections.singletonList(new PlainEdge.PlainEdgeFactory());
+       }
+       return Collections.emptyList();
+    }
+
+    public boolean isPartialLeaf() {
+       return getUnusedOutgoingEdgeFactories().size() > 0;
+    }
+
+    public boolean acceptsIncomingEdge(Edge e) {
+        return true;
+    }
+
+    public boolean acceptsOutgoingEdge(Edge e) {
+        return true;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedParallelStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedParallelStatement.java
new file mode 100644
index 00000000000..7c504a696e3
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedParallelStatement.java
@@ -0,0 +1,32 @@
+package org.logstash.config.ir.imperative;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.graph.Graph;
+
+import java.util.List;
+
+/**
+ * Created by andrewvc on 9/22/16.
+ */
+public class ComposedParallelStatement extends ComposedStatement {
+    public ComposedParallelStatement(SourceMetadata meta, List<Statement> statements) throws InvalidIRException {
+        super(meta, statements);
+    }
+
+    @Override
+    protected String composeTypeString() {
+        return "composed-parallel";
+    }
+
+    @Override
+    public Graph toGraph() throws InvalidIRException {
+        Graph g = Graph.empty();
+
+        for (Statement s : getStatements()) {
+            g.merge(s.toGraph());
+        }
+
+        return g;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedSequenceStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedSequenceStatement.java
new file mode 100644
index 00000000000..69dad74d277
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedSequenceStatement.java
@@ -0,0 +1,34 @@
+package org.logstash.config.ir.imperative;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.graph.Graph;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * Created by andrewvc on 9/22/16.
+ */
+public class ComposedSequenceStatement extends ComposedStatement {
+    public ComposedSequenceStatement(SourceMetadata meta, List<Statement> statements) throws InvalidIRException {
+        super(meta, statements);
+    }
+
+    @Override
+    protected String composeTypeString() {
+        return "do-sequence";
+    }
+
+    @Override
+    public Graph toGraph() throws InvalidIRException {
+        Graph g = Graph.empty();
+
+        for (Statement statement : getStatements()) {
+            Graph sg = statement.toGraph();
+            g.extend(sg);
+        }
+
+        return g;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedStatement.java
new file mode 100644
index 00000000000..3b1ee61822f
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedStatement.java
@@ -0,0 +1,67 @@
+package org.logstash.config.ir.imperative;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public abstract class ComposedStatement extends Statement {
+    public interface IFactory {
+        ComposedStatement make(SourceMetadata meta, List<Statement> statements) throws InvalidIRException;
+    }
+
+    private final List<Statement> statements;
+
+    public ComposedStatement(SourceMetadata meta, List<Statement> statements) throws InvalidIRException {
+        super(meta);
+        if (statements == null || statements.stream().anyMatch(s -> s == null)) {
+            throw new InvalidIRException("Nulls eNot allowed for list eOr in statement list");
+        }
+        this.statements = statements;
+    }
+
+    public List<Statement> getStatements() {
+        return this.statements;
+    }
+
+    public int size() {
+        return getStatements().size();
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (this == sourceComponent) return true;
+        if (sourceComponent.getClass().equals(this.getClass())) {
+            ComposedStatement other = (ComposedStatement) sourceComponent;
+            if (this.size() != other.size()) {
+                return false;
+            }
+            for (int i = 0; i < size(); i++) {
+                Statement s = this.getStatements().get(i);
+                Statement os = other.getStatements().get(i);
+                if (!(s.sourceComponentEquals(os))) return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public String toString(int indent) {
+        return "(" + this.composeTypeString() + "\n" +
+                getStatements().stream().
+                  map(s -> s.toString(indent+2)).
+                  collect(Collectors.joining("\n")) +
+                "\n";
+    }
+
+    protected abstract String composeTypeString();
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/IfStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/IfStatement.java
new file mode 100644
index 00000000000..31bf6a9a19c
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/IfStatement.java
@@ -0,0 +1,99 @@
+package org.logstash.config.ir.imperative;
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BooleanExpression;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.graph.*;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ * if 5 {
+ *
+ * }
+ */
+
+public class IfStatement extends Statement {
+    private final BooleanExpression booleanExpression;
+    private final Statement trueStatement;
+    private final Statement falseStatement;
+
+    public BooleanExpression getBooleanExpression() {
+        return booleanExpression;
+    }
+
+    public Statement getTrueStatement() {
+        return trueStatement;
+    }
+
+    public Statement getFalseStatement() {
+        return falseStatement;
+    }
+
+    public IfStatement(SourceMetadata meta,
+                       BooleanExpression booleanExpression,
+                       Statement trueStatement,
+                       Statement falseStatement
+    ) throws InvalidIRException {
+        super(meta);
+
+        if (booleanExpression == null) throw new InvalidIRException("Boolean expr must eNot be null!");
+        if (trueStatement == null) throw new InvalidIRException("If Statement needs true statement!");
+        if (falseStatement == null) throw new InvalidIRException("If Statement needs false statement!");
+
+        this.booleanExpression = booleanExpression;
+        this.trueStatement = trueStatement;
+        this.falseStatement = falseStatement;
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (sourceComponent == this) return true;
+        if (sourceComponent instanceof IfStatement) {
+            IfStatement other = (IfStatement) sourceComponent;
+
+
+            return (this.booleanExpression.sourceComponentEquals(other.getBooleanExpression()) &&
+                    this.trueStatement.sourceComponentEquals(other.trueStatement) &&
+                    this.falseStatement.sourceComponentEquals(other.falseStatement));
+        }
+        return false;
+    }
+
+    @Override
+    public String toString(int indent) {
+        return indentPadding(indent) +
+                    "(if " + booleanExpression.toString(0) +
+                    "\n" +
+                    this.trueStatement +
+                    "\n" +
+                    this.falseStatement +
+                    ")";
+    }
+
+
+    @Override
+    public Graph toGraph() throws InvalidIRException {
+        Graph graph = new Graph();
+        Vertex ifVertex = new IfVertex(this.getMeta(), this.booleanExpression);
+        graph.addVertex(ifVertex);
+
+        if (!(getTrueStatement() instanceof NoopStatement)) {
+            Statement ts = this.getTrueStatement();
+            Graph tsg = ts.toGraph();
+            graph.threadToGraph(BooleanEdge.trueFactory, ifVertex, tsg);
+        }
+
+        if (!(getFalseStatement() instanceof NoopStatement)) {
+            Statement fs = this.getFalseStatement();
+            Graph fsg = fs.toGraph();
+            graph.threadToGraph(BooleanEdge.falseFactory, ifVertex, fsg);
+        }
+
+        return graph;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/NoopStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/NoopStatement.java
new file mode 100644
index 00000000000..ac3d26997fa
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/NoopStatement.java
@@ -0,0 +1,33 @@
+package org.logstash.config.ir.imperative;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.graph.Graph;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class NoopStatement extends Statement {
+
+    public NoopStatement(SourceMetadata meta) {
+        super(meta);
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (sourceComponent instanceof NoopStatement) return true;
+        return false;
+    }
+
+    @Override
+    public String toString(int indent) {
+        return indentPadding(indent) + "(Noop)";
+    }
+
+    @Override
+    public Graph toGraph() {
+        return Graph.empty();
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/PluginStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/PluginStatement.java
new file mode 100644
index 00000000000..9b2542f9184
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/PluginStatement.java
@@ -0,0 +1,44 @@
+package org.logstash.config.ir.imperative;
+
+import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.PluginDefinition;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.PluginVertex;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.Map;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public class PluginStatement extends Statement {
+    private final PluginDefinition pluginDefinition;
+
+    public PluginStatement(SourceMetadata meta, PluginDefinition pluginDefinition) {
+        super(meta);
+        this.pluginDefinition = pluginDefinition;
+    }
+
+    @Override
+    public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (sourceComponent == this) return true;
+        if (sourceComponent instanceof PluginStatement) {
+            PluginStatement other = (PluginStatement) sourceComponent;
+            return this.pluginDefinition.equals(other.pluginDefinition);
+        }
+        return false;
+    }
+
+    @Override
+    public String toString(int indent) {
+        return indentPadding(indent) + this.pluginDefinition;
+    }
+
+    @Override
+    public Graph toGraph() {
+        Vertex pluginVertex = new PluginVertex(getMeta(), pluginDefinition);
+        return Graph.empty().addVertex(pluginVertex);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/Statement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/Statement.java
new file mode 100644
index 00000000000..1051ff77acb
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/Statement.java
@@ -0,0 +1,31 @@
+package org.logstash.config.ir.imperative;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.graph.Edge;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.Collection;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public abstract class Statement extends SourceComponent {
+    public Statement(SourceMetadata meta) {
+        super(meta);
+    }
+
+    public abstract Graph toGraph() throws InvalidIRException;
+
+    public String toString() {
+        return toString(2);
+    }
+
+    public abstract String toString(int indent);
+
+    public String indentPadding(int length) {
+        return new String(new char[length]).replace("\0", " ");
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/pipeline/PassthroughProcessor.java b/logstash-core/src/main/java/org/logstash/config/pipeline/PassthroughProcessor.java
new file mode 100644
index 00000000000..f8c7d83e9fd
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/pipeline/PassthroughProcessor.java
@@ -0,0 +1,40 @@
+package org.logstash.config.pipeline;
+
+import org.logstash.Event;
+import org.logstash.config.compiler.compiled.ICompiledProcessor;
+import org.logstash.config.ir.graph.Edge;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by andrewvc on 9/23/16.
+ */
+public class PassthroughProcessor implements ICompiledProcessor {
+    private final Vertex vertex;
+
+    public PassthroughProcessor(Vertex vertex) {
+        this.vertex = vertex;
+    }
+
+    @Override
+    public Map<Edge, List<Event>> process(List<Event> events) {
+        HashMap<Edge, List<Event>> out = new HashMap<>(vertex.getOutgoingEdges().size());
+        for (Edge e : vertex.getOutgoingEdges()) {
+            out.put(e, events);
+        }
+        return out;
+    }
+
+    @Override
+    public void register() {
+
+    }
+
+    @Override
+    public void stop() {
+
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/pipeline/PipelineRunner.java b/logstash-core/src/main/java/org/logstash/config/pipeline/PipelineRunner.java
new file mode 100644
index 00000000000..d425b84f8ec
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/pipeline/PipelineRunner.java
@@ -0,0 +1,238 @@
+package org.logstash.config.pipeline;
+
+import org.logstash.Event;
+import org.logstash.config.compiler.*;
+import org.logstash.config.compiler.compiled.ICompiledInputPlugin;
+import org.logstash.config.compiler.compiled.ICompiledProcessor;
+import org.logstash.config.pipeline.pipette.*;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.Pipeline;
+import org.logstash.config.ir.PluginDefinition;
+import org.logstash.config.ir.graph.IfVertex;
+import org.logstash.config.ir.graph.PluginVertex;
+import org.logstash.config.ir.graph.SpecialVertex;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.*;
+import java.util.concurrent.BlockingQueue;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+/**
+ * Created by andrewvc on 9/22/16.
+ */
+public class PipelineRunner {
+    private final Pipeline pipeline;
+    private final IPluginCompiler pluginCompiler;
+    private final IExpressionCompiler expressionCompiler;
+    private final HashMap<PluginVertex, ICompiledInputPlugin> inputVerticesToCompiled;
+    private final Collection<Pipette> inputPipettes;
+    private final HashMap<Pipette, Thread> pipettesThreads;
+    private final Map<Vertex, ICompiledProcessor> processorVerticesToCompiled;
+    private final List<Vertex> orderedPostQueue;
+    private final Collection<Pipette> processorPipettes;
+    private final BlockingQueue<List<Event>> queue;
+    private final QueueReadSource queueReadSource;
+    private final QueueWriteProcessor queueWriteProcessor;
+    private final IfCompiler ifCompiler;
+    private final PipelineRunnerObserver observer;
+
+    public PipelineRunner(Pipeline pipeline, BlockingQueue<List<Event>> queue, IExpressionCompiler expressionCompiler, IPluginCompiler pluginCompiler, PipelineRunnerObserver observer) throws CompilationError, InvalidIRException {
+        this.pipeline = pipeline;
+        this.expressionCompiler = expressionCompiler;
+        this.observer = observer != null ? observer : new PipelineRunnerObserver();
+        this.ifCompiler = new IfCompiler(expressionCompiler);
+        this.pluginCompiler = pluginCompiler;
+        this.pipettesThreads = new HashMap<Pipette, Thread>();
+        this.queue = queue;
+        this.queueWriteProcessor = new QueueWriteProcessor(queue);
+        this.queueReadSource = new QueueReadSource(queue);
+
+        // Handle stuff before the queue, e.g. inputs
+        this.inputVerticesToCompiled = compileInputs();
+        this.inputPipettes = new ArrayList<>();
+
+        // Handle stuff after the queue, e.g. processors
+        this.orderedPostQueue = pipeline.getPostQueue();
+        this.processorVerticesToCompiled = this.compileProcessors();
+        this.processorPipettes = new ArrayList<>();
+        this.observer.initialize(this);
+    }
+
+    public void start(int workers) throws PipetteExecutionException, CompilationError {
+        observer.beforeStart(this);
+        startInputs();
+        startProcessors(workers);
+        observer.afterStart(this);
+    }
+
+    public void join() throws InterruptedException, PipetteExecutionException {
+        // Join on input threads
+        for (Map.Entry<Pipette,Thread> entry : pipettesThreads(inputPipettes).entrySet()) {
+            entry.getValue().join();
+            System.out.println("Input thread finished: " + entry.getKey());
+        }
+
+        while (queue.peek() != null) {
+            System.out.println("Waiting for queue to shutdown");
+        }
+
+        // Join on processors / close them out
+        for (Map.Entry<Pipette,Thread> entry : pipettesThreads(processorPipettes).entrySet()) {
+            Pipette pipette = entry.getKey();
+            Thread thread = entry.getValue();
+
+            pipette.stop();
+            thread.join();
+
+            System.out.println("Processor thread finished: " + pipette);
+        }
+
+    }
+
+    public Map<Pipette,Thread> pipettesThreads(Collection<Pipette> pipettes) {
+        return pipettes.stream().collect(Collectors.toMap(Function.identity(), pipettesThreads::get));
+    }
+
+    public void stop(int workers) throws PipetteExecutionException {
+        observer.beforeStop(this);
+        stopInputs();
+        observer.inputsStopped(this);
+        stopProcessors();
+        observer.afterStop(this);
+    }
+
+    private Pipette createProcessorPipette(String name) {
+        OrderedVertexPipetteProcessor processor = new OrderedVertexPipetteProcessor(this.orderedPostQueue, this.processorVerticesToCompiled, pipeline.getQueue(), observer);
+        return new Pipette(name, queueReadSource, processor);
+    }
+
+    private Map<Vertex, ICompiledProcessor> compileProcessors() throws CompilationError {
+        Map<Vertex, ICompiledProcessor> vertexToCompiled = new HashMap<>(orderedPostQueue.size());
+
+        for (Vertex v : orderedPostQueue) {
+            if (v instanceof PluginVertex) {
+                PluginDefinition pluginDefinition = ((PluginVertex) v).getPluginDefinition();
+
+                ICompiledProcessor compiled;
+                switch (pluginDefinition.getType()) {
+                    case FILTER:
+                        compiled = pluginCompiler.compileFilter((PluginVertex) v);
+                        break;
+                    case OUTPUT:
+                        compiled = pluginCompiler.compileOutput((PluginVertex) v);
+                        break;
+                    default:
+                        throw new CompilationError("Invariant violated! only filter / output plugins expected in filter/output stage");
+                }
+
+                if (compiled == null) {
+                    throw new CompilationError("Compilation of vertex returned null! Vertex:" + v);
+                }
+
+                compiled.register();
+                vertexToCompiled.put(v, compiled);
+            } else if (v instanceof SpecialVertex) {
+                vertexToCompiled.put(v, new PassthroughProcessor((SpecialVertex) v));
+            } else if (v instanceof IfVertex) {
+                vertexToCompiled.put(v, ifCompiler.compile((IfVertex) v));
+            } else {
+                throw new CompilationError("Invariant violated!, only plugin / special vertices were expected! Got: " + v);
+            }
+        }
+
+        return vertexToCompiled;
+    }
+
+    private HashMap<PluginVertex, ICompiledInputPlugin> compileInputs() throws CompilationError {
+        HashMap<PluginVertex, ICompiledInputPlugin> compiled = new HashMap<>();
+        for (PluginVertex pv : pipeline.getInputPluginVertices()) {
+            ICompiledInputPlugin c = pluginCompiler.compileInput(pv);
+            c.register();
+            compiled.put(pv, c);
+        }
+        return compiled;
+    }
+
+    private Collection<Pipette> createInputPipettes(Queue<List<Event>> queue) throws CompilationError {
+        List<Pipette> inputPipettes = new ArrayList<>(this.inputVerticesToCompiled.size());
+        for (Map.Entry<PluginVertex, ICompiledInputPlugin> entry : this.inputVerticesToCompiled.entrySet()) {
+            String name = "Input[" + entry.getKey().getId() + "]";
+            Pipette inputPipette = new Pipette(name, entry.getValue(), queueWriteProcessor, observer);
+            inputPipettes.add(inputPipette);
+        }
+        return inputPipettes;
+    }
+
+    public void startInputs() throws PipetteExecutionException, CompilationError {
+        observer.beforeInputsStart(this);
+        stopInputs();
+        this.inputPipettes.clear();
+        Collection<Pipette> newPipettes = createInputPipettes(this.queue);
+        this.inputPipettes.addAll(newPipettes);
+        startPipettes(inputPipettes);
+        observer.afterInputsStart(this);
+    }
+
+    public void stopInputs() throws PipetteExecutionException {
+        stopPipettes(this.inputPipettes);
+    }
+
+    public void startProcessors(int workers) throws PipetteExecutionException {
+        observer.beforeProcessorsStart(this);
+        stopProcessors();
+        this.processorPipettes.clear();
+
+        for (int i = 0; i < workers; i++) {
+            String name = "> PostQueue Processor[" + i + "]";
+            this.processorPipettes.add(createProcessorPipette(name));
+        }
+
+        startPipettes(this.processorPipettes);
+        observer.afterProcessorsStart(this);
+    }
+
+    private void stopProcessors() throws PipetteExecutionException {
+        stopPipettes(this.processorPipettes);
+    }
+
+    private void stopPipettes(Collection<Pipette> pipettes) throws PipetteExecutionException {
+        for (Pipette pipette : pipettes) {
+            stopPipette(pipette);
+        }
+    }
+
+    private void startPipettes(Collection<Pipette> pipettes) {
+        for (Pipette pipette : pipettes) {
+            startPipette(pipette);
+        }
+    }
+
+    private Thread startPipette(Pipette pipette) {
+        Thread thread = new Thread(() -> {
+            try {
+                pipette.start();
+            } catch (PipetteExecutionException e) {
+                //TODO: We need some failure handling here
+                e.printStackTrace();
+            }
+        });
+        thread.start();
+
+        this.pipettesThreads.put(pipette, thread);
+
+        return thread;
+    }
+
+    private void stopPipette(Pipette pipette) throws PipetteExecutionException {
+        pipette.stop();
+        Thread thread = pipettesThreads.get(pipette);
+        if (thread.isAlive()) {
+            throw new PipetteExecutionException(
+                    "Pipette stop succeeded, but its thread is still alive! " +
+                            "Pipette: "  + pipette + " Thread " + thread
+            );
+        }
+        pipettesThreads.remove(pipette);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/pipeline/PipelineRunnerObserver.java b/logstash-core/src/main/java/org/logstash/config/pipeline/PipelineRunnerObserver.java
new file mode 100644
index 00000000000..927b252621e
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/pipeline/PipelineRunnerObserver.java
@@ -0,0 +1,53 @@
+package org.logstash.config.pipeline;
+
+import org.logstash.Event;
+import org.logstash.config.pipeline.pipette.OrderedVertexPipetteProcessor;
+import org.logstash.config.ir.graph.Edge;
+
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by andrewvc on 10/14/16.
+ *
+ * By default this class is a noop, override any methods you want to implement
+ */
+public class PipelineRunnerObserver {
+    public void postExecutionStep(OrderedVertexPipetteProcessor.ExecutionStep executionStep, List<Event> incomingEvents, Map<Edge, List<Event>> outgoingEvents) {
+
+    }
+
+    public void initialize(PipelineRunner pipelineRunner) {
+        
+    }
+
+    public void beforeStart(PipelineRunner pipelineRunner) {
+    }
+
+    public void afterStart(PipelineRunner pipelineRunner) {
+    }
+
+    public void beforeStop(PipelineRunner pipelineRunner) {
+        
+    }
+
+    public void inputsStopped(PipelineRunner pipelineRunner) {
+    }
+
+    public void afterStop(PipelineRunner pipelineRunner) {
+    }
+
+    public void beforeInputsStart(PipelineRunner pipelineRunner) {
+
+    }
+
+    public void afterInputsStart(PipelineRunner pipelineRunner) {
+        
+    }
+
+    public void beforeProcessorsStart(PipelineRunner pipelineRunner) {
+    }
+
+    public void afterProcessorsStart(PipelineRunner pipelineRunner) {
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/IPipetteProcessor.java b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/IPipetteProcessor.java
new file mode 100644
index 00000000000..534879f4048
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/IPipetteProcessor.java
@@ -0,0 +1,13 @@
+package org.logstash.config.pipeline.pipette;
+
+import org.logstash.Event;
+
+import java.util.List;
+
+/**
+ * Created by andrewvc on 9/30/16.
+ */
+public interface IPipetteProcessor {
+    public void process(List<Event> events) throws PipetteExecutionException;
+    public void stop() throws PipetteExecutionException;
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/IPipetteSource.java b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/IPipetteSource.java
new file mode 100644
index 00000000000..7638c00e417
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/IPipetteSource.java
@@ -0,0 +1,12 @@
+package org.logstash.config.pipeline.pipette;
+
+/**
+ * Created by andrewvc on 9/30/16.
+ */
+public interface IPipetteSource {
+    void start() throws PipetteExecutionException;
+
+    void stop();
+
+    void onEvents(PipetteSourceEmitter sourceEmitter);
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/OrderedVertexPipetteProcessor.java b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/OrderedVertexPipetteProcessor.java
new file mode 100644
index 00000000000..05784c4cafc
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/OrderedVertexPipetteProcessor.java
@@ -0,0 +1,103 @@
+package org.logstash.config.pipeline.pipette;
+
+import org.logstash.Event;
+import org.logstash.config.pipeline.PipelineRunnerObserver;
+import org.logstash.config.compiler.compiled.ICompiledProcessor;
+import org.logstash.config.ir.graph.Edge;
+import org.logstash.config.ir.graph.SpecialVertex;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+/**
+ * Created by andrewvc on 10/11/16.
+ */
+public class OrderedVertexPipetteProcessor implements IPipetteProcessor {
+    private final List<Vertex> orderedVertices;
+    private final Map<Edge,List<Event>> edgesToEvents;
+    private final Map<Vertex, ICompiledProcessor> verticesToCompiled;
+    private final ArrayList<ExecutionStep> executionSteps;
+    private final SpecialVertex queueVertex;
+    private final PipelineRunnerObserver observer;
+
+    public class ExecutionStep {
+        public Collection<Edge> getOutgoingEdges() {
+            return outgoingEdges;
+        }
+
+        public Collection<Edge> getIncomingEdges() {
+            return incomingEdges;
+        }
+
+        public ICompiledProcessor getCompiledProcessor() {
+            return compiledProcessor;
+        }
+
+        public Vertex getVertex() {
+            return vertex;
+        }
+
+        private final Collection<Edge> outgoingEdges;
+        private final Collection<Edge> incomingEdges;
+        private final ICompiledProcessor compiledProcessor;
+        private final Vertex vertex;
+
+        public ExecutionStep(Vertex vertex, ICompiledProcessor compiledProcessor,
+                             Collection<Edge> incomingEdges, Collection<Edge> outgoingEdges) {
+            this.vertex = vertex;
+            this.compiledProcessor = compiledProcessor;
+            this.incomingEdges = incomingEdges;
+            this.outgoingEdges = outgoingEdges;
+        }
+
+        public String toString() {
+            return "[Execution Step] Vertex: " + vertex;
+        }
+    }
+
+    public OrderedVertexPipetteProcessor(List<Vertex> orderedVertices, Map<Vertex, ICompiledProcessor> processorVerticesToCompiled, SpecialVertex queueVertex, PipelineRunnerObserver observer) {
+        this.orderedVertices = orderedVertices;
+        this.verticesToCompiled = processorVerticesToCompiled;
+        this.executionSteps = new ArrayList<>(this.orderedVertices.size());
+        this.edgesToEvents = new HashMap<>();
+        this.queueVertex = queueVertex;
+        this.observer = observer;
+
+        for (Vertex vertex : this.orderedVertices) {
+            this.executionSteps.add(new ExecutionStep(vertex, verticesToCompiled.get(vertex), vertex.getIncomingEdges(), vertex.getOutgoingEdges()));
+        }
+    }
+
+    @Override
+    public void process(List<Event> events) throws PipetteExecutionException {
+        // Reset this on each run, probably cheaper than reallocating
+        edgesToEvents.clear();
+        // The queue edges just have the input set of events
+
+        queueVertex.getOutgoingEdges().forEach(e -> edgesToEvents.put(e, events));
+
+        for (ExecutionStep executionStep : executionSteps) {
+            List<Event> incomingEvents = new ArrayList<>();
+            for (Edge edge : executionStep.incomingEdges) {
+                List<Event> edgeEvents = edgesToEvents.get(edge);
+                if (edgeEvents != null) incomingEvents.addAll(edgeEvents);
+            }
+
+            // If there's nothing coming in, just skip execution
+            if (incomingEvents.isEmpty()) {
+                continue;
+            }
+
+
+            Map<Edge, List<Event>> outgoingEvents = executionStep.getCompiledProcessor().process(incomingEvents);
+            observer.postExecutionStep(executionStep, incomingEvents, outgoingEvents);
+            edgesToEvents.putAll(outgoingEvents);
+        }
+    }
+
+    @Override
+    public void stop() throws PipetteExecutionException {
+
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/Pipette.java b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/Pipette.java
new file mode 100644
index 00000000000..e26ef6e8661
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/Pipette.java
@@ -0,0 +1,56 @@
+package org.logstash.config.pipeline.pipette;
+
+
+import org.logstash.Event;
+import org.logstash.config.pipeline.PipelineRunnerObserver;
+
+import java.util.List;
+
+/**
+ * Created by andrewvc on 9/30/16.
+ */
+public class Pipette {
+    public final IPipetteSource source;
+    public final IPipetteProcessor processor;
+    private final String name;
+    private final PipelineRunnerObserver observer;
+
+
+    private final class OnWriteEmitter implements PipetteSourceEmitter {
+        @Override
+        public void emit(List<Event> events) throws PipetteExecutionException {
+            process(events);
+        }
+    }
+
+    public Pipette(String name, IPipetteSource source, IPipetteProcessor processor, PipelineRunnerObserver observer) {
+        this.name = name;
+        this.source = source;
+        this.processor = processor;
+        this.observer = observer;
+        this.source.onEvents(new OnWriteEmitter());
+    }
+
+
+    public Pipette(String name, IPipetteSource source, IPipetteProcessor processor) {
+        this(name, source, processor, null);
+    }
+
+    public void start() throws PipetteExecutionException {
+        source.start();
+    }
+
+    private void process(List<Event> events) throws PipetteExecutionException {
+        processor.process(events);
+    }
+
+    public void stop() throws PipetteExecutionException {
+        source.stop();
+        processor.stop();
+    }
+
+    public String toString() {
+        return name;
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/PipetteExecutionException.java b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/PipetteExecutionException.java
new file mode 100644
index 00000000000..43b7dccecba
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/PipetteExecutionException.java
@@ -0,0 +1,15 @@
+package org.logstash.config.pipeline.pipette;
+
+
+/**
+ * Created by andrewvc on 9/30/16.
+ */
+public class PipetteExecutionException extends Exception {
+    public PipetteExecutionException(String s) {
+        super(s);
+    }
+
+    public PipetteExecutionException(String s, Exception e) {
+        super(s,e);
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/PipetteSourceEmitter.java b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/PipetteSourceEmitter.java
new file mode 100644
index 00000000000..01d0ff2c18e
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/PipetteSourceEmitter.java
@@ -0,0 +1,12 @@
+package org.logstash.config.pipeline.pipette;
+
+import org.logstash.Event;
+
+import java.util.List;
+
+/**
+ * Created by andrewvc on 10/11/16.
+ */
+public interface PipetteSourceEmitter {
+    void emit(List<Event> events) throws PipetteExecutionException;
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/QueueReadSource.java b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/QueueReadSource.java
new file mode 100644
index 00000000000..798024ada9b
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/QueueReadSource.java
@@ -0,0 +1,46 @@
+package org.logstash.config.pipeline.pipette;
+
+import org.logstash.Event;
+
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
+
+/**
+ * Created by andrewvc on 10/11/16.
+ */
+public class QueueReadSource implements IPipetteSource {
+    private final BlockingQueue<List<Event>> queue;
+    private volatile boolean running;
+    private PipetteSourceEmitter onEventsReader;
+
+    public QueueReadSource(BlockingQueue<List<Event>> queue) {
+        this.queue = queue;
+        this.running = true;
+    }
+
+    @Override
+    public void start() throws PipetteExecutionException {
+        while (this.running) {
+            List<Event> events = null;
+            try {
+                events = queue.take();
+            } catch (InterruptedException e) {
+                throw new PipetteExecutionException("Unexpected Interruption!", e);
+            }
+
+            onEventsReader.emit(events);
+        }
+    }
+
+    @Override
+    public void stop() {
+        this.running = false;
+    }
+
+    @Override
+    public void onEvents(PipetteSourceEmitter onEvents) {
+       this.onEventsReader = onEvents;
+    }
+
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/QueueWriteProcessor.java b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/QueueWriteProcessor.java
new file mode 100644
index 00000000000..735d8eb0694
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/pipeline/pipette/QueueWriteProcessor.java
@@ -0,0 +1,31 @@
+package org.logstash.config.pipeline.pipette;
+
+import org.logstash.Event;
+
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
+
+/**
+ * Created by andrewvc on 10/11/16.
+ */
+public class QueueWriteProcessor implements IPipetteProcessor {
+    private final BlockingQueue<List<Event>> queue;
+
+    public QueueWriteProcessor(BlockingQueue<List<Event>> queue) {
+        this.queue = queue;
+    }
+
+    @Override
+    public void process(List<Event> events) throws PipetteExecutionException {
+        try {
+            this.queue.put(events);
+        } catch (InterruptedException e) {
+            throw new PipetteExecutionException("Unexpected interruption!", e);
+        }
+    }
+
+    @Override
+    public void stop() throws PipetteExecutionException {
+
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java b/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java
new file mode 100644
index 00000000000..78622a8709a
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java
@@ -0,0 +1,27 @@
+package org.logstash.config.ir;
+
+import org.hamcrest.MatcherAssert;
+import org.logstash.config.ir.graph.Edge;
+import org.logstash.config.ir.graph.Graph;
+
+import java.util.stream.Stream;
+
+/**
+ * Created by andrewvc on 9/19/16.
+ */
+public class IRHelpers {
+    public static void assertSyntaxEquals(ISourceComponent left, ISourceComponent right) {
+        String message = String.format("Expected '%s' to equal '%s'", left, right);
+        MatcherAssert.assertThat(message, left.sourceComponentEquals(right));
+    }
+
+    public static void assertGraphEquals(Graph left, Graph right) {
+        String message = String.format("Expected '%s' to equal '%s'\n%s", left, right, left.diff(right));
+
+        MatcherAssert.assertThat(message, left.sourceComponentEquals(right));
+    }
+
+
+
+
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/PipelineRunnerTest.java b/logstash-core/src/test/java/org/logstash/config/ir/PipelineRunnerTest.java
new file mode 100644
index 00000000000..d2155e0d153
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/PipelineRunnerTest.java
@@ -0,0 +1,110 @@
+package org.logstash.config.ir;
+
+import org.junit.Test;
+import org.logstash.Event;
+import org.logstash.config.pipeline.PassthroughProcessor;
+import org.logstash.config.pipeline.PipelineRunner;
+import org.logstash.config.compiler.*;
+import org.logstash.config.compiler.compiled.ICompiledInputPlugin;
+import org.logstash.config.compiler.compiled.ICompiledProcessor;
+import org.logstash.config.pipeline.pipette.PipetteExecutionException;
+import org.logstash.config.pipeline.pipette.PipetteSourceEmitter;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.PluginVertex;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.stream.Collectors;
+
+import static org.logstash.config.ir.DSL.*;
+import static org.logstash.config.ir.PluginDefinition.Type.*;
+
+/**
+ * Created by andrewvc on 10/11/16.
+ */
+public class PipelineRunnerTest {
+    @Test
+    public void testPipelineRunner() throws InvalidIRException, CompilationError, PipetteExecutionException, InterruptedException {
+        Graph inputSection = iComposeParallel(iPlugin(INPUT, "generator"), iPlugin(INPUT, "stdin")).toGraph();
+        Graph filterSection = iIf(eEq(eEventValue("[foo]"), eEventValue("[bar]")),
+                iPlugin(FILTER, "grok"),
+                iPlugin(FILTER, "kv")).toGraph();
+        Graph outputSection = iIf(eGt(eEventValue("[baz]"), eValue(1000)),
+                iComposeParallel(
+                        iPlugin(OUTPUT, "s3"),
+                        iPlugin(OUTPUT, "elasticsearch")),
+                iPlugin(OUTPUT, "stdout")).toGraph();
+
+        Pipeline pipeline = new Pipeline(inputSection, filterSection, outputSection);
+
+        BlockingQueue<List<Event>> queue = new SynchronousQueue<>();
+
+        IExpressionCompiler expressionCompiler = new RubyExpressionCompiler();
+        IPluginCompiler pluginCompiler = new IPluginCompiler() {
+            @Override
+            public ICompiledInputPlugin compileInput(PluginVertex vertex) throws CompilationError {
+                return new ICompiledInputPlugin() {
+                    public PipetteSourceEmitter onWriteWriter;
+
+                    @Override
+                    public void register() {
+
+                    }
+
+                    public Event generateEvent() {
+                        Event e = new Event();
+                        int seed = ThreadLocalRandom.current().nextInt(1,100);
+                        e.setField("[foo]", (seed % 2 == 0 ? "String1" : "String2"));
+                        e.setField("[bar]", (seed % 2 == 0 ? "String1" : "String2"));
+                        e.setField("[baz]", (seed % 2 == 0 ? 500 : 5000));
+
+                        List<Event> events = Collections.singletonList(e);
+
+                        return e;
+                    }
+
+                    public List<Event> generateEvents() {
+                        return Collections.nCopies(2, ThreadLocalRandom.current().nextInt(5,10)).
+                                stream().
+                                map(i -> generateEvent()).
+                                collect(Collectors.toList());
+                    }
+
+                    @Override
+                    public void start() throws PipetteExecutionException {
+                        for (int i = 0; i < 10; i++) {
+                            onWriteWriter.emit(generateEvents());
+                        }
+                    }
+
+                    @Override
+                    public void stop() {
+
+                    }
+
+                    @Override
+                    public void onEvents(PipetteSourceEmitter sourceWriter) {
+                        this.onWriteWriter = sourceWriter;
+                    }
+                };
+            }
+
+            @Override
+            public ICompiledProcessor compileFilter(PluginVertex vertex) throws CompilationError {
+                return new PassthroughProcessor(vertex);
+            }
+
+            @Override
+            public ICompiledProcessor compileOutput(PluginVertex vertex) throws CompilationError {
+                return new PassthroughProcessor(vertex);
+            }
+        };
+
+        PipelineRunner runner = new PipelineRunner(pipeline, queue, expressionCompiler, pluginCompiler, null);
+        runner.start(1);
+        runner.join();
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/PipelineTest.java b/logstash-core/src/test/java/org/logstash/config/ir/PipelineTest.java
new file mode 100644
index 00000000000..9934577c8c0
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/PipelineTest.java
@@ -0,0 +1,27 @@
+package org.logstash.config.ir;
+
+import org.junit.Test;
+import org.logstash.config.ir.graph.Graph;
+import static org.logstash.config.ir.DSL.*;
+import static org.logstash.config.ir.PluginDefinition.Type.*;
+
+/**
+ * Created by andrewvc on 9/20/16.
+ */
+public class PipelineTest {
+    @Test
+    public void testPipelineCreation() throws InvalidIRException {
+        Graph inputSection = iComposeParallel(iPlugin(INPUT, "generator"), iPlugin(INPUT, "stdin")).toGraph();
+        Graph filterSection = iIf(eEq(eEventValue("[foo]"), eEventValue("[bar]")),
+                                    iPlugin(FILTER, "grok"),
+                                    iPlugin(FILTER, "kv")).toGraph();
+        Graph outputSection = iIf(eGt(eEventValue("[baz]"), eValue(1000)),
+                                    iComposeParallel(
+                                            iPlugin(OUTPUT, "s3"),
+                                            iPlugin(OUTPUT, "elasticsearch")),
+                                    iPlugin(OUTPUT, "stdout")).toGraph();
+
+        Pipeline pipeline = new Pipeline(inputSection, filterSection, outputSection);
+        System.out.println(pipeline.toString());
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/compiler/ExpressionCompilerTest.java b/logstash-core/src/test/java/org/logstash/config/ir/compiler/ExpressionCompilerTest.java
new file mode 100644
index 00000000000..881c4c09edf
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/compiler/ExpressionCompilerTest.java
@@ -0,0 +1,67 @@
+package org.logstash.config.ir.compiler;
+
+import org.junit.Test;
+import org.logstash.Event;
+import org.logstash.config.compiler.CompilationError;
+import org.logstash.config.compiler.compiled.ICompiledExpression;
+import org.logstash.config.compiler.RubyExpressionCompiler;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.expression.Expression;
+
+import static junit.framework.TestCase.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.logstash.config.ir.DSL.*;
+
+
+/**
+ * Created by andrewvc on 10/11/16.
+ */
+public class ExpressionCompilerTest {
+    @Test
+    public void testSimpleEquality() throws InvalidIRException, CompilationError {
+        assertExpressionTrue(eEq(eValue(1), eValue(1)));
+        assertExpressionFalse(eEq(eValue(1), eValue(2)));
+    }
+
+    @Test
+    public void testFieldComparison() throws InvalidIRException, CompilationError {
+        Event event = new Event();
+        event.setField("[foo]", "bar");
+
+        assertExpressionTrue(eEq(eEventValue("foo"), eValue("bar")), event);
+        assertExpressionFalse(eEq(eEventValue("foo"), eValue("WRONG!")), event);
+    }
+
+    @Test
+    public void testNested() throws InvalidIRException, CompilationError {
+        assertExpressionTrue(eAnd(
+                eGt(eValue(2), eValue(1)),
+                eLt(eValue(100), eValue(1000))));
+
+        assertExpressionFalse(eOr(
+                eGt(eValue(-1), eValue(1)),
+                eLt(eValue(100000), eValue(1000))));
+    }
+
+    public void assertExpressionTrue(Expression expression) throws CompilationError {
+        assertExpressionTrue(expression, new Event());
+    }
+
+    public void assertExpressionTrue(Expression expression, Event event) throws CompilationError {
+        assertTrue("Expected expr to be true: " + expression.toRubyString() + " Event: " + event.getData(), runExpression(expression, event));
+    }
+
+    public void assertExpressionFalse(Expression expression) throws CompilationError {
+        assertExpressionFalse(expression, new Event());
+    }
+
+    public void assertExpressionFalse(Expression expression, Event event) throws CompilationError {
+       assertFalse("Expected expr to be false: " + expression.toRubyString() + " Event: " + event.getData(), runExpression(expression, event));
+    }
+
+    public boolean runExpression(Expression expression, Event event) throws CompilationError {
+        RubyExpressionCompiler expressionCompiler = new RubyExpressionCompiler();
+        ICompiledExpression compiled = expressionCompiler.compile(expression);
+        return compiled.execute(event);
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/GraphTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/GraphTest.java
new file mode 100644
index 00000000000..f36fd803879
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/GraphTest.java
@@ -0,0 +1,7 @@
+package org.logstash.config.ir.graph;
+
+/**
+ * Created by andrewvc on 9/19/16.
+ */
+public class GraphTest {
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/imperative/DSLTest.java b/logstash-core/src/test/java/org/logstash/config/ir/imperative/DSLTest.java
new file mode 100644
index 00000000000..d23b10e4758
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/imperative/DSLTest.java
@@ -0,0 +1,61 @@
+package org.logstash.config.ir.imperative;
+
+import org.junit.Test;
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+
+import java.util.ArrayList;
+
+import static org.logstash.config.ir.DSL.*;
+import static org.logstash.config.ir.IRHelpers.assertSyntaxEquals;
+import static org.logstash.config.ir.PluginDefinition.Type.*;
+
+/**
+ * Created by andrewvc on 9/13/16.
+ */
+public class DSLTest {
+    @Test
+    public void testDSLOnePluginEquality() {
+        assertSyntaxEquals(iPlugin(FILTER, "foo"), iPlugin(FILTER, "foo"));
+    }
+
+    @Test
+    public void testComposedPluginEquality() throws InvalidIRException {
+        assertSyntaxEquals(composedPlugins(), composedPlugins());
+    }
+
+    @Test
+    public void testDSLComplexEquality() throws InvalidIRException {
+        assertSyntaxEquals(complexExpression(), complexExpression());
+    }
+
+    @Test
+    public void testComposeSingle() throws InvalidIRException {
+        assertSyntaxEquals(iPlugin(FILTER, "grok"), iComposeSequence(iPlugin(FILTER, "grok")));
+    }
+
+    @Test
+    public void testComposeMulti() throws InvalidIRException {
+        Statement composed = iComposeSequence(iPlugin(FILTER, "grok"), iPlugin(FILTER, "foo"));
+        assertSyntaxEquals(iComposeSequence(iPlugin(FILTER, "grok"), iPlugin(FILTER, "foo")), composed);
+}
+
+
+    public SourceComponent composedPlugins() throws InvalidIRException {
+        return iComposeSequence(iPlugin(FILTER, "json"), iPlugin(FILTER, "stuff"));
+    }
+
+    public SourceComponent complexExpression() throws InvalidIRException {
+        return iComposeSequence(
+                iPlugin(FILTER, "grok"),
+                iPlugin(FILTER, "kv"),
+                iIf(eAnd(eTruthy(eValue(5l)), eTruthy(eValue(null))),
+                        iPlugin(FILTER, "grok"),
+                        iComposeSequence(iPlugin(FILTER, "json"), iPlugin(FILTER, "stuff"))
+                )
+        );
+    }
+
+
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/imperative/ImperativeToGraphtest.java b/logstash-core/src/test/java/org/logstash/config/ir/imperative/ImperativeToGraphtest.java
new file mode 100644
index 00000000000..b3e3ddd4dff
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/imperative/ImperativeToGraphtest.java
@@ -0,0 +1,105 @@
+package org.logstash.config.ir.imperative;
+
+import org.junit.Test;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.IfVertex;
+import org.logstash.config.ir.graph.PluginVertex;
+
+import static org.logstash.config.ir.DSL.*;
+import static org.logstash.config.ir.IRHelpers.assertGraphEquals;
+import static org.logstash.config.ir.PluginDefinition.Type.*;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class ImperativeToGraphtest {
+
+    @Test
+    public void convertSimpleExpression() throws InvalidIRException {
+        Graph g =  iComposeSequence(iPlugin(FILTER, "json"), iPlugin(FILTER, "stuff")).toGraph();
+        Graph expected = graph().threadVertices(gPlugin(FILTER, "json"), gPlugin(FILTER, "stuff"));
+
+        assertGraphEquals(g, expected);
+    }
+
+    @Test
+    public void convertComplexExpression() throws InvalidIRException {
+        Graph generated = iComposeSequence(
+                iPlugin(FILTER, "p1"),
+                iPlugin(FILTER, "p2"),
+                iIf(eAnd(eTruthy(eValue(5l)), eTruthy(eValue(null))),
+                        iPlugin(FILTER, "p3"),
+                        iComposeSequence(iPlugin(FILTER, "p4"), iPlugin(FILTER, "p5"))
+                )
+        ).toGraph();
+
+        PluginVertex p1 = gPlugin(FILTER, "p1");
+        PluginVertex p2 = gPlugin(FILTER, "p2");
+        PluginVertex p3 = gPlugin(FILTER, "p3");
+        PluginVertex p4 = gPlugin(FILTER, "p4");
+        PluginVertex p5 = gPlugin(FILTER, "p5");
+        IfVertex testIf = gIf(eAnd(eTruthy(eValue(5l)), eTruthy(eValue(null))));
+
+        Graph expected = graph().threadVertices(p1,p2,testIf)
+            .threadVertices(true, testIf, p3)
+            .threadVertices(false, testIf, p4)
+            .threadVertices(p4, p5);
+
+        //PluginVertex p6 = gPlugin(FILTER, "p6");
+        //expected.threadVertices(p5,p6);
+
+        assertGraphEquals(generated, expected);
+    }
+
+    // This is a good test for what the filter block will do, where there
+    // will be a  composed set of ifs potentially, all of which must terminate at a
+    // single node
+    @Test
+    public void convertComplexExpressionWithTerminal() throws InvalidIRException {
+        Graph generated = iComposeSequence(
+            iPlugin(FILTER, "p1"),
+            iIf(eTruthy(eValue(1)),
+                iComposeSequence(
+                    iIf(eTruthy(eValue(2)), noop(), iPlugin(FILTER, "p2")),
+                    iIf(eTruthy(eValue(3)), iPlugin(FILTER, "p3"), noop())
+                ),
+                iComposeSequence(
+                    iIf(eTruthy(eValue(4)), iPlugin(FILTER, "p4")),
+                    iPlugin(FILTER, "p5")
+                )
+            ),
+            iPlugin(FILTER, "terminal")
+        ).toGraph();
+
+        PluginVertex p1 = gPlugin(FILTER,"p1");
+        PluginVertex p2 = gPlugin(FILTER, "p2");
+        PluginVertex p3 = gPlugin(FILTER, "p3");
+        PluginVertex p4 = gPlugin(FILTER, "p4");
+        PluginVertex p5 = gPlugin(FILTER, "p5");
+        PluginVertex terminal = gPlugin(FILTER, "terminal");
+
+        IfVertex if1 = gIf(eTruthy(eValue(1)));
+        IfVertex if2 = gIf(eTruthy(eValue(2)));
+        IfVertex if3 = gIf(eTruthy(eValue(3)));
+        IfVertex if4 = gIf(eTruthy(eValue(4)));
+
+        Graph expected = graph()
+                .threadVertices(p1, if1)
+                .threadVertices(true, if1, if2)
+                .threadVertices(false, if1, if4)
+                .threadVertices(true, if2, if3)
+                .threadVertices(false, if2, p2)
+                .threadVertices(p2, if3)
+                .threadVertices(true, if3, p3)
+                .threadVertices(false, if3, terminal)
+                .threadVertices(p3, terminal)
+                .threadVertices(true, if4, p4)
+                .threadVertices(false, if4, p5)
+                .threadVertices(p4, p5)
+                .threadVertices(p5, terminal);
+
+        assertGraphEquals(generated, expected);
+
+    }
+}
diff --git a/spec/spec_helper.rb b/spec/spec_helper.rb
index 4e49758160e..0fbe7f3b605 100644
--- a/spec/spec_helper.rb
+++ b/spec/spec_helper.rb
@@ -47,3 +47,17 @@ def puts(payload)
 def installed_plugins
   Gem::Specification.find_all.select { |spec| spec.metadata["logstash_plugin"] }.map { |plugin| plugin.name }
 end
+
+RSpec::Matchers.define :ir_eql do |expected|
+  match do |actual|
+    if expected.java_kind_of?(org.logstash.config.ir.SourceComponent) && actual.java_kind_of?(org.logstash.config.ir.SourceComponent)
+      expected.sourceComponentEquals(actual)
+    else
+      return false
+    end    
+  end
+  
+  failure_message do |actual|
+    "actual value \n#{actual.to_s}\nis not .sourceComponentEquals to the expected value: \n#{expected.to_s}\n"
+  end
+end
