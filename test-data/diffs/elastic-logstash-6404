diff --git a/Gemfile b/Gemfile
index cbf6dbf3555..6079926dabb 100644
--- a/Gemfile
+++ b/Gemfile
@@ -6,6 +6,7 @@ gem "logstash-core", :path => "./logstash-core"
 gem "logstash-core-queue-jruby", :path => "./logstash-core-queue-jruby"
 gem "logstash-core-event-java", :path => "./logstash-core-event-java"
 gem "logstash-core-plugin-api", :path => "./logstash-core-plugin-api"
+gem "paquet", "~> 0.2.0"
 gem "ruby-progressbar", "~> 1.8.1"
 gem "builder", "~> 3.2.2"
 gem "file-dependencies", "0.1.6"
diff --git a/ci/ci_integration.sh b/ci/ci_integration.sh
index ff343cf8438..de26ea120f8 100755
--- a/ci/ci_integration.sh
+++ b/ci/ci_integration.sh
@@ -16,6 +16,7 @@ rake artifact:tar
 cd build
 echo "Extracting logstash tar file in build/"
 tar xf *.tar.gz
+
 cd ../qa/integration
 # to install test dependencies
 bundle install
diff --git a/ci/travis_integration_install.sh b/ci/travis_integration_install.sh
index 2b8a63ac419..3f174da3f3f 100755
--- a/ci/travis_integration_install.sh
+++ b/ci/travis_integration_install.sh
@@ -18,8 +18,9 @@ rake artifact:tar
 cd build
 echo "Extracting logstash tar file in build/"
 tar xf *.tar.gz
+
 cd ../qa/integration
 pwd
 echo $BUNDLE_GEMFILE
 # to install test dependencies
-bundle install --gemfile="Gemfile"
\ No newline at end of file
+bundle install --gemfile="Gemfile"
diff --git a/lib/pluginmanager/bundler/logstash_injector.rb b/lib/pluginmanager/bundler/logstash_injector.rb
index 1ac2e0ebe68..6193cfb100a 100644
--- a/lib/pluginmanager/bundler/logstash_injector.rb
+++ b/lib/pluginmanager/bundler/logstash_injector.rb
@@ -5,6 +5,8 @@
 require "bundler/dependency"
 require "bundler/dsl"
 require "bundler/injector"
+require "pluginmanager/gemfile"
+
 
 # This class cannot be in the logstash namespace, because of the way the DSL
 # class interact with the other libraries
@@ -14,17 +16,24 @@ def self.inject!(new_deps, options = { :gemfile => LogStash::Environment::GEMFIL
       gemfile = options.delete(:gemfile)
       lockfile = options.delete(:lockfile)
 
-      bundler_format = Array(new_deps).collect { |plugin|  ::Bundler::Dependency.new(plugin.name, "=#{plugin.version}")}
+      bundler_format = new_deps.plugins.collect(&method(:dependency))
+      dependencies = new_deps.dependencies.collect(&method(:dependency))
 
       injector = new(bundler_format)
-      injector.inject(gemfile, lockfile)
+      injector.inject(gemfile, lockfile, dependencies)
     end
 
+    def self.dependency(plugin)
+      ::Bundler::Dependency.new(plugin.name, "=#{plugin.version}")
+    end
 
     # This class is pretty similar to what bundler's injector class is doing
     # but we only accept a local resolution of the dependencies instead of calling rubygems.
     # so we removed `definition.resolve_remotely!`
-    def inject(gemfile_path, lockfile_path)
+    #
+    # And managing the gemfile is down by using our own Gemfile parser, this allow us to
+    # make it work with gems that are already defined in the gemfile.
+    def inject(gemfile_path, lockfile_path, dependencies)
       if Bundler.settings[:frozen]
         # ensure the lock and Gemfile are synced
         Bundler.definition.ensure_equivalent_gemfile_and_lockfile(true)
@@ -33,16 +42,31 @@ def inject(gemfile_path, lockfile_path)
       end
 
       builder = Dsl.new
-      builder.eval_gemfile(gemfile_path)
+      gemfile = LogStash::Gemfile.new(File.new(gemfile_path, "r+")).load
 
-      @new_deps -= builder.dependencies
+      begin
+        @new_deps.each do |dependency|
+          gemfile.update(dependency.name, dependency.requirement)
+        end
 
-      builder.eval_gemfile("injected gems", new_gem_lines) if @new_deps.any?
-      definition = builder.to_definition(lockfile_path, {})
-      append_to(gemfile_path) if @new_deps.any?
-      definition.lock(lockfile_path)
+        # If the dependency is defined in the gemfile, lets try to update the version with the one we have
+        # with the pack.
+        dependencies.each do |dependency|
+          if gemfile.defined_in_gemfile?(dependency.name)
+            gemfile.update(dependency.name, dependency.requirement)
+          end
+        end
 
-      return @new_deps
+        builder.eval_gemfile("bundler file", gemfile.generate())
+        definition = builder.to_definition(lockfile_path, {})
+        definition.lock(lockfile_path)
+        gemfile.save
+      rescue => e
+        # the error should be handled elsewhere but we need to get the original file if we dont
+        # do this logstash will be in an inconsistent state
+        gemfile.restore!
+        raise e
+      end
     ensure
       Bundler.settings[:frozen] = "1" if frozen
     end
diff --git a/lib/pluginmanager/command.rb b/lib/pluginmanager/command.rb
index 1a7c88bedc9..fa4d40dc8fc 100644
--- a/lib/pluginmanager/command.rb
+++ b/lib/pluginmanager/command.rb
@@ -6,7 +6,7 @@ def gemfile
 
   # If set in debug mode we will raise an exception and display the stacktrace
   def report_exception(readable_message, exception)
-    if ENV["DEBUG"]
+    if debug?
       raise exception
     else
       signal_error("#{readable_message}, message: #{exception.message}")
@@ -14,7 +14,7 @@ def report_exception(readable_message, exception)
   end
 
   def display_bundler_output(output)
-    if ENV['DEBUG'] && output
+    if debug? && output
       # Display what bundler did in the last run
       $stderr.puts("Bundler output")
       $stderr.puts(output)
@@ -35,4 +35,8 @@ def relative_path(path)
     require "pathname"
     ::Pathname.new(path).relative_path_from(::Pathname.new(LogStash::Environment::LOGSTASH_HOME)).to_s
   end
+
+  def debug?
+    ENV["DEBUG"]
+  end
 end
diff --git a/lib/pluginmanager/custom_gem_indexer.rb b/lib/pluginmanager/custom_gem_indexer.rb
new file mode 100644
index 00000000000..0d7d273de2f
--- /dev/null
+++ b/lib/pluginmanager/custom_gem_indexer.rb
@@ -0,0 +1,63 @@
+# encoding: utf-8
+require "pluginmanager/ui"
+require "stud/temporary"
+
+module LogStash module PluginManager
+  class CustomGemIndexer
+    GEMS_DIR = "gems"
+
+    class << self
+      # Copy the file to a specific format that `Gem::Indexer` can understand
+      # See `#update_in_memory_index`
+      def copy_to_local_source(temporary_directory)
+        local_source = Stud::Temporary.pathname
+        local_source_gems = ::File.join(local_source, GEMS_DIR)
+
+        FileUtils.mkdir_p(local_source_gems)
+        PluginManager.ui.debug("Creating the index structure format from #{temporary_directory} to #{local_source}")
+
+        Dir.glob(::File.join(temporary_directory, "**", "*.gem")).each do |file|
+          destination = ::File.join(local_source_gems, ::File.basename(file))
+          FileUtils.cp(file, destination)
+        end
+
+        local_source
+      end
+
+      # *WARNING*: Bundler need to not be activated at this point because it wont find anything that
+      # is not defined in the gemfile/lock combo
+      #
+      # This takes a folder with a special structure, will generate an index
+      # similar to what rubygems do and make them available in the local program,
+      # we use this **side effect** to validate theses gems with the current gemfile/lock.
+      # Bundler will assume they are system gems and will use them when doing resolution checks.
+      #
+      #.
+      # ├── gems
+      # │   ├── addressable-2.4.0.gem
+      # │   ├── cabin-0.9.0.gem
+      # │   ├── ffi-1.9.14-java.gem
+      # │   ├── gemoji-1.5.0.gem
+      # │   ├── launchy-2.4.3-java.gem
+      # │   ├── logstash-output-elasticsearch-5.2.0-java.gem
+      # │   ├── logstash-output-secret-0.1.0.gem
+      # │   ├── manticore-0.6.0-java.gem
+      # │   ├── spoon-0.0.6.gem
+      # │   └── stud-0.0.22.gem
+      #
+      # Right now this work fine, but I think we could also use Bundler's SourceList classes to handle the same thing
+      def update_in_memory_index!(local_source)
+        PluginManager.ui.debug("Generating indexes in #{local_source}")
+        indexer = ::Gem::Indexer.new(local_source, { :build_modern => true})
+        indexer.ui = ::Gem::SilentUI.new unless ENV["DEBUG"]
+        indexer.generate_index
+      end
+
+      def index(path)
+        local_source = copy_to_local_source(path)
+        update_in_memory_index!(local_source)
+        local_source
+      end
+    end
+  end
+end end
diff --git a/lib/pluginmanager/errors.rb b/lib/pluginmanager/errors.rb
index 260c5815cbc..691c8b67500 100644
--- a/lib/pluginmanager/errors.rb
+++ b/lib/pluginmanager/errors.rb
@@ -1,6 +1,8 @@
 # encoding: utf-8
 module LogStash module PluginManager
     class PluginManagerError < StandardError; end
+    class PluginNotFoundError < PluginManagerError; end
+    class UnpackablePluginError < PluginManagerError; end
     class FileNotFoundError < PluginManagerError; end
     class InvalidPackError < PluginManagerError; end
     class InstallError < PluginManagerError
diff --git a/lib/pluginmanager/gem_installer.rb b/lib/pluginmanager/gem_installer.rb
index 4a1cf020983..abb686d50db 100644
--- a/lib/pluginmanager/gem_installer.rb
+++ b/lib/pluginmanager/gem_installer.rb
@@ -2,6 +2,7 @@
 require "pluginmanager/ui"
 require "pathname"
 require "rubygems/package"
+require "fileutils"
 
 module LogStash module PluginManager
   # Install a physical gem package to the appropriate location inside logstash
@@ -12,11 +13,13 @@ class GemInstaller
     GEM_HOME = Pathname.new(::File.join(LogStash::Environment::BUNDLE_DIR, "jruby", "1.9"))
     SPECIFICATIONS_DIR = "specifications"
     GEMS_DIR = "gems"
+    CACHE_DIR = "cache"
 
     attr_reader :gem_home
 
     def initialize(gem_file, display_post_install_message = false, gem_home = GEM_HOME)
-      @gem = ::Gem::Package.new(gem_file)
+      @gem_file = gem_file
+      @gem = ::Gem::Package.new(@gem_file)
       @gem_home = Pathname.new(gem_home)
       @display_post_install_message = display_post_install_message
     end
@@ -26,6 +29,7 @@ def install
       extract_files
       write_specification
       display_post_install_message
+      copy_gem_file_to_cache
     end
 
     def self.install(gem_file, display_post_install_message = false, gem_home = GEM_HOME)
@@ -41,6 +45,10 @@ def spec_dir
       gem_home.join(SPECIFICATIONS_DIR)
     end
 
+    def cache_dir
+      gem_home.join(CACHE_DIR)
+    end
+
     def spec_file
       spec_dir.join("#{spec.full_name}.gemspec")
     end
@@ -69,10 +77,16 @@ def display_post_install_message?
       @display_post_install_message && !spec.post_install_message.nil?
     end
 
+    def copy_gem_file_to_cache
+      destination = ::File.join(cache_dir, ::File.basename(@gem_file))
+      FileUtils.cp(@gem_file, destination)
+    end
+
     def create_destination_folders
       FileUtils.mkdir_p(gem_home)
       FileUtils.mkdir_p(gem_dir)
       FileUtils.mkdir_p(spec_dir)
+      FileUtils.mkdir_p(cache_dir)
     end
   end
 end end
diff --git a/lib/pluginmanager/gemfile.rb b/lib/pluginmanager/gemfile.rb
index c0b996dffd7..86af9a40826 100644
--- a/lib/pluginmanager/gemfile.rb
+++ b/lib/pluginmanager/gemfile.rb
@@ -71,6 +71,10 @@ def restore
       @gemset = @original_backup
     end
 
+    def defined_in_gemfile?(name)
+      @gemset.find_gem(name)
+    end
+
     def restore!
       restore
       save
diff --git a/lib/pluginmanager/install.rb b/lib/pluginmanager/install.rb
index 514ca502bf9..476b00ec7be 100644
--- a/lib/pluginmanager/install.rb
+++ b/lib/pluginmanager/install.rb
@@ -158,6 +158,7 @@ def install_gems_list!(install_list)
   # Bundler 2.0, will have support for plugins source we could create a .gem source
   # to support it.
   def extract_local_gems_plugins
+    FileUtils.mkdir_p(LogStash::Environment::CACHE_PATH)
     plugins_arg.collect do |plugin|
       # We do the verify before extracting the gem so we dont have to deal with unused path
       if verify?
@@ -165,6 +166,9 @@ def extract_local_gems_plugins
         signal_error("Installation aborted, verification failed for #{plugin}") unless LogStash::PluginManager.logstash_plugin?(plugin, version)
       end
 
+      # Make the original .gem available for the prepare-offline-pack,
+      # paquet will lookup in the cache directory before going to rubygems.
+      FileUtils.cp(plugin, ::File.join(LogStash::Environment::CACHE_PATH, ::File.basename(plugin)))
       package, path = LogStash::Rubygems.unpack(plugin, LogStash::Environment::LOCAL_GEM_PATH)
       [package.spec.name, package.spec.version, { :path => relative_path(path) }]
     end
diff --git a/lib/pluginmanager/main.rb b/lib/pluginmanager/main.rb
index 5323f4370a7..fed9c4cddc6 100644
--- a/lib/pluginmanager/main.rb
+++ b/lib/pluginmanager/main.rb
@@ -21,6 +21,7 @@ module PluginManager
 require "pluginmanager/pack"
 require "pluginmanager/unpack"
 require "pluginmanager/generate"
+require "pluginmanager/prepare_offline_pack"
 
 module LogStash
   module PluginManager
@@ -31,10 +32,11 @@ class Main < Clamp::Command
       subcommand "install", "Install a Logstash plugin", LogStash::PluginManager::Install
       subcommand "remove", "Remove a Logstash plugin", LogStash::PluginManager::Remove
       subcommand "update", "Update a plugin", LogStash::PluginManager::Update
-      subcommand "pack", "Package currently installed plugins", LogStash::PluginManager::Pack
-      subcommand "unpack", "Unpack packaged plugins", LogStash::PluginManager::Unpack
+      subcommand "pack", "Package currently installed plugins, Deprecated: Please use prepare-offline-pack instead", LogStash::PluginManager::Pack
+      subcommand "unpack", "Unpack packaged plugins, Deprecated: Please use prepare-offline-pack instead", LogStash::PluginManager::Unpack
       subcommand "generate", "Create the foundation for a new plugin", LogStash::PluginManager::Generate
       subcommand "uninstall", "Uninstall a plugin. Deprecated: Please use remove instead", LogStash::PluginManager::Remove
+      subcommand "prepare-offline-pack", "Create an archive of specified plugins to use for offline installation", LogStash::PluginManager::PrepareOfflinePack
     end
   end
 end
diff --git a/lib/pluginmanager/offline_plugin_packager.rb b/lib/pluginmanager/offline_plugin_packager.rb
new file mode 100644
index 00000000000..a0d21413570
--- /dev/null
+++ b/lib/pluginmanager/offline_plugin_packager.rb
@@ -0,0 +1,120 @@
+# encoding: utf-8
+require "pluginmanager/ui"
+require "pluginmanager/errors"
+require "bootstrap/environment"
+require "bootstrap/util/compress"
+require "paquet"
+require "stud/temporary"
+require "fileutils"
+
+module LogStash module PluginManager
+  class SpecificationHelpers
+    WILDCARD = "*"
+    WILDCARD_INTO_RE = ".*"
+
+    def self.find_by_name_with_wildcards(pattern)
+      re = transform_pattern_into_re(pattern)
+      ::Gem::Specification.find_all.select do |specification|
+        specification.name =~ re
+      end
+    end
+
+    def self.transform_pattern_into_re(pattern)
+      Regexp.new("^#{pattern.gsub(WILDCARD, WILDCARD_INTO_RE)}$")
+    end
+  end
+
+  class OfflinePluginPackager
+    LOGSTASH_DIR = "logstash"
+    DEPENDENCIES_DIR = ::File.join(LOGSTASH_DIR, "dependencies")
+
+    # To make sure we have the maximun compatibility
+    # we will ignore theses gems and they wont be included in the pack
+    IGNORE_GEMS_IN_PACK = %w(
+      logstash-core
+      logstash-core-queue-jruby
+      logstash-core-event-java
+      logstash-core-plugin-api
+      jar-dependencies
+    )
+
+    INVALID_PLUGINS_TO_EXPLICIT_PACK = IGNORE_GEMS_IN_PACK.collect { |name| /^#{name}/ } + [
+      /mixin/
+    ]
+
+    def initialize(plugins_to_package, target)
+      @plugins_to_package = Array(plugins_to_package)
+      @target = target
+
+      validate_plugins!
+    end
+
+    def validate_plugins!
+      @plugins_to_package.each do |plugin_name|
+        if INVALID_PLUGINS_TO_EXPLICIT_PACK.any? { |invalid_name| plugin_name =~ invalid_name }
+          raise UnpackablePluginError, "Cannot explicitly pack `#{plugin_name}` for offline installation"
+        end
+      end
+    end
+
+    def generate_temporary_path
+      Stud::Temporary.pathname
+    end
+
+    def explicitly_declared_plugins_specs
+      @plugins_to_package.collect do |plugin_pattern|
+        specs = SpecificationHelpers.find_by_name_with_wildcards(plugin_pattern)
+
+        if specs.size > 0
+          specs
+        else
+          raise LogStash::PluginManager::PluginNotFoundError, "Cannot find plugins matching: `#{plugin_pattern}`"
+        end
+      end.flatten
+    end
+
+    def execute
+      temp_path = generate_temporary_path
+      packet_gem = Paquet::Gem.new(temp_path, LogStash::Environment::CACHE_PATH)
+
+      explicit_plugins_specs = explicitly_declared_plugins_specs
+
+      explicit_plugins_specs.each do |spec|
+        packet_gem.add(spec.name)
+      end
+
+      IGNORE_GEMS_IN_PACK.each do |gem_name|
+        packet_gem.ignore(gem_name)
+      end
+
+      packet_gem.pack
+
+      prepare_package(explicit_plugins_specs, temp_path)
+      LogStash::Util::Zip.compress(temp_path, @target)
+    ensure
+      FileUtils.rm_rf(temp_path)
+    end
+
+    def prepare_package(explicit_plugins, temp_path)
+      FileUtils.mkdir_p(::File.join(temp_path, LOGSTASH_DIR))
+      FileUtils.mkdir_p(::File.join(temp_path, DEPENDENCIES_DIR))
+
+      explicit_path = ::File.join(temp_path, LOGSTASH_DIR)
+      dependencies_path = ::File.join(temp_path, DEPENDENCIES_DIR)
+
+      Dir.glob(::File.join(temp_path, "*.gem")).each do |gem_file|
+        filename = ::File.basename(gem_file)
+
+        if explicit_plugins.any? { |spec| filename =~ /^#{spec.name}/ }
+          FileUtils.mv(gem_file, ::File.join(explicit_path, filename))
+        else
+          FileUtils.mv(gem_file, ::File.join(dependencies_path, filename))
+        end
+      end
+    end
+
+    def self.package(plugins_args, target)
+      OfflinePluginPackager.new(plugins_args, target).execute
+    end
+  end
+end end
diff --git a/lib/pluginmanager/pack.rb b/lib/pluginmanager/pack.rb
index 18b46e18511..2f00728199d 100644
--- a/lib/pluginmanager/pack.rb
+++ b/lib/pluginmanager/pack.rb
@@ -8,6 +8,8 @@ class LogStash::PluginManager::Pack < LogStash::PluginManager::PackCommand
   option "--overwrite", :flag, "Overwrite a previously generated package file", :default => false
 
   def execute
+    signal_deprecation_warning_for_pack
+
     puts("Packaging plugins for offline usage")
 
     validate_target_file
diff --git a/lib/pluginmanager/pack_command.rb b/lib/pluginmanager/pack_command.rb
index 2409b212f97..3f4ed0b383c 100644
--- a/lib/pluginmanager/pack_command.rb
+++ b/lib/pluginmanager/pack_command.rb
@@ -10,4 +10,12 @@ def archive_manager
   def file_extension
     zip? ? ".zip" : ".tar.gz"
   end
+
+  def signal_deprecation_warning_for_pack
+  message =<<-EOS
+The pack and the unpack command are now deprecated and will be removed in a future version of Logstash.
+See the `prepare-offline-pack` to update your workflow. You can get documentation about this by running `bin/logstash-plugin prepare-offline-pack --help`
+  EOS
+  puts message
+  end
 end
diff --git a/lib/pluginmanager/pack_installer/local.rb b/lib/pluginmanager/pack_installer/local.rb
index 702eb408754..ff75b971026 100644
--- a/lib/pluginmanager/pack_installer/local.rb
+++ b/lib/pluginmanager/pack_installer/local.rb
@@ -2,6 +2,7 @@
 require "pluginmanager/ui"
 require "pluginmanager/bundler/logstash_injector"
 require "pluginmanager/gem_installer"
+require "pluginmanager/custom_gem_indexer"
 require "pluginmanager/errors"
 require "pluginmanager/pack_installer/pack"
 require "bootstrap/util/compress"
@@ -10,7 +11,6 @@
 module LogStash module PluginManager module PackInstaller
   class Local
     PACK_EXTENSION = ".zip"
-    GEMS_DIR = "gems"
     LOGSTASH_PATTERN_RE = /logstash\/?/
 
     attr_reader :local_file
@@ -29,13 +29,12 @@ def execute
       pack = LogStash::PluginManager::PackInstaller::Pack.new(uncompressed_path)
       raise PluginManager::InvalidPackError, "The pack must contains at least one plugin" unless pack.valid?
 
-      local_source = move_to_local_source(uncompressed_path)
-      update_in_memory_index(local_source)
+      local_source = LogStash::PluginManager::CustomGemIndexer.index(uncompressed_path)
 
       # Try to add the gems to the current gemfile and lock file, if successful
       # both of them will be updated. This injector is similar to Bundler's own injector class
       # minus the support for additionals source and doing local resolution only.
-      added = ::Bundler::LogstashInjector.inject!(pack.plugins)
+      ::Bundler::LogstashInjector.inject!(pack)
 
       # When successfull its safe to install the gem and their specifications in the bundle directory
       pack.gems.each do |packed_gem|
@@ -44,7 +43,7 @@ def execute
       end
       PluginManager.ui.info("Install successful")
     rescue ::Bundler::BundlerError => e
-      raise PluginManager::InstallError.new(e), "An error occurent went installing plugins"
+      raise PluginManager::InstallError.new(e), "An error occurred went installing plugins"
     ensure
       FileUtils.rm_rf(uncompressed_path) if uncompressed_path && Dir.exist?(uncompressed_path)
       FileUtils.rm_rf(local_source) if local_source && Dir.exist?(local_source)
@@ -64,48 +63,5 @@ def uncompress(source)
     def valid_format?(local_file)
       ::File.extname(local_file).downcase == PACK_EXTENSION
     end
-
-    # Copy the file to a specific format that `Gem::Indexer` can understand
-    # See `#update_in_memory_index`
-    def move_to_local_source(temporary_directory)
-      local_source = Stud::Temporary.pathname
-      local_source_gems = ::File.join(local_source, GEMS_DIR)
-
-      FileUtils.mkdir_p(local_source_gems)
-      PluginManager.ui.debug("Creating the index structure format from #{temporary_directory} to #{local_source}")
-
-      Dir.glob(::File.join(temporary_directory, "**", "*.gem")).each do |file|
-        destination = ::File.join(local_source_gems, ::File.basename(file))
-        FileUtils.cp(file, destination)
-      end
-
-      local_source
-    end
-
-    # This takes a folder with a special structure, will generate an index
-    # similar to what rubygems do and make them available in the local program,
-    # we use this **side effect** to validate theses gems with the current gemfile/lock.
-    # Bundler will assume they are system gems and will use them when doing resolution checks.
-    #
-    #.
-    # ├── gems
-    # │   ├── addressable-2.4.0.gem
-    # │   ├── cabin-0.9.0.gem
-    # │   ├── ffi-1.9.14-java.gem
-    # │   ├── gemoji-1.5.0.gem
-    # │   ├── launchy-2.4.3-java.gem
-    # │   ├── logstash-output-elasticsearch-5.2.0-java.gem
-    # │   ├── logstash-output-secret-0.1.0.gem
-    # │   ├── manticore-0.6.0-java.gem
-    # │   ├── spoon-0.0.6.gem
-    # │   └── stud-0.0.22.gem
-    #
-    # Right now this work fine, but I think we could also use Bundler's SourceList classes to handle the same thing
-    def update_in_memory_index(local_source)
-      PluginManager.ui.debug("Generating indexes in #{local_source}")
-      indexer = ::Gem::Indexer.new(local_source, { :build_modern => true})
-      indexer.ui = ::Gem::SilentUI.new unless ENV["DEBUG"]
-      indexer.generate_index
-    end
   end
 end end end
diff --git a/lib/pluginmanager/pack_installer/pack.rb b/lib/pluginmanager/pack_installer/pack.rb
index 7c9b5bbe8e7..3090472dbf2 100644
--- a/lib/pluginmanager/pack_installer/pack.rb
+++ b/lib/pluginmanager/pack_installer/pack.rb
@@ -67,7 +67,6 @@ def initialize(source)
     end
 
     def plugins
-      require "pry"
       gems.select { |gem| !gem.dependency? }
     end
 
diff --git a/lib/pluginmanager/prepare_offline_pack.rb b/lib/pluginmanager/prepare_offline_pack.rb
new file mode 100644
index 00000000000..8cd9736bcf5
--- /dev/null
+++ b/lib/pluginmanager/prepare_offline_pack.rb
@@ -0,0 +1,61 @@
+# encoding: utf-8
+require "pluginmanager/command"
+require "pluginmanager/errors"
+
+class LogStash::PluginManager::PrepareOfflinePack < LogStash::PluginManager::Command
+  parameter "[PLUGIN] ...", "plugin name(s)", :attribute_name => :plugins_arg
+  option "--output", "OUTPUT", "output file", :default => ::File.join(LogStash::Environment::LOGSTASH_HOME, "logstash-offline-plugins-#{LOGSTASH_VERSION}.zip")
+
+  def execute
+    validate_arguments!
+
+    # We need to start bundler, dependencies so  the plugins are available for the prepare
+    LogStash::Bundler.setup!({:without => [:build, :development]})
+
+    # manually require paquet since its an external dependency
+    require "pluginmanager/offline_plugin_packager"
+    require "paquet"
+    require "paquet/shell_ui"
+
+    # Override the shell output with the one from the plugin manager
+    # To silence some of debugs/info statements
+    Paquet.ui = Paquet::SilentUI unless debug?
+
+    FileUtils.rm_rf(output) if ::File.exist?(output)
+
+    LogStash::PluginManager::OfflinePluginPackager.package(plugins_arg, output)
+
+    message = <<-EOS
+Offline package created at: #{output}
+
+You can install it with this command `bin/logstash-plugin install file://#{::File.expand_path(output)}`
+    EOS
+
+    LogStash::PluginManager::ui.info(message)
+  rescue LogStash::PluginManager::UnpackablePluginError => e
+    report_exception("Offline package", e)
+  rescue LogStash::PluginManager::PluginNotFoundError => e
+    report_exception("Cannot create the offline archive", e)
+  end
+
+  def validate_arguments!
+    if plugins_arg.size == 0
+      message = <<-EOS
+You need to specify at least one plugin or use a wildcard expression.
+
+Examples:
+bin/logstash-plugin prepare-offline-pack logstash-input-beats
+bin/logstash-plugin prepare-offline-pack logstash-filter-jdbc logstash-input-beats
+bin/logstash-plugin prepare-offline-pack logstash-filter-*
+bin/logstash-plugin prepare-offline-pack logstash-filter-* logstash-input-beats
+
+You can get a list of the installed plugin by running `bin/logstash-plugin list`
+
+The prepare offline will pack the currently installed plugins and their dependencies
+for offline installation.
+EOS
+      signal_usage_error(message)
+    end
+  end
+end
+
diff --git a/lib/pluginmanager/unpack.rb b/lib/pluginmanager/unpack.rb
index 7937e7d2e24..f1f7221e171 100644
--- a/lib/pluginmanager/unpack.rb
+++ b/lib/pluginmanager/unpack.rb
@@ -8,6 +8,8 @@ class LogStash::PluginManager::Unpack < LogStash::PluginManager::PackCommand
   parameter "file", "the package file name", :attribute_name => :package_file, :required => true
 
   def execute
+    signal_deprecation_warning_for_pack
+
     puts("Unpacking #{package_file}")
 
     FileUtils.rm_rf(LogStash::Environment::CACHE_PATH)
diff --git a/qa/integration/.gitignore b/qa/integration/.gitignore
index e7775797e47..01f9fbcf19f 100644
--- a/qa/integration/.gitignore
+++ b/qa/integration/.gitignore
@@ -1,2 +1,4 @@
 /services/installed
 /fixtures/certificates
+/fixtures/offline.o
+/fixtures/offline
diff --git a/qa/integration/.ruby-version b/qa/integration/.ruby-version
deleted file mode 100644
index cd53e881769..00000000000
--- a/qa/integration/.ruby-version
+++ /dev/null
@@ -1 +0,0 @@
-jruby-9.1.5.0
diff --git a/qa/integration/fixtures/install_spec.yml b/qa/integration/fixtures/install_spec.yml
new file mode 100644
index 00000000000..cbfc784af81
--- /dev/null
+++ b/qa/integration/fixtures/install_spec.yml
@@ -0,0 +1,3 @@
+---
+services:
+  - logstash
diff --git a/qa/integration/fixtures/logstash-dummy-pack/.gitiginore b/qa/integration/fixtures/logstash-dummy-pack/.gitiginore
new file mode 100644
index 00000000000..0bd659d183a
--- /dev/null
+++ b/qa/integration/fixtures/logstash-dummy-pack/.gitiginore
@@ -0,0 +1,3 @@
+vendor/bundle
+dependencies/
+build/
diff --git a/qa/integration/fixtures/logstash-dummy-pack/Gemfile b/qa/integration/fixtures/logstash-dummy-pack/Gemfile
new file mode 100644
index 00000000000..f40ab78d3d1
--- /dev/null
+++ b/qa/integration/fixtures/logstash-dummy-pack/Gemfile
@@ -0,0 +1,4 @@
+source 'https://rubygems.org'
+gemspec
+
+gem "paquet", :path => "#{File.dirname(__FILE__)}/../../../../tools/paquet"
diff --git a/qa/integration/fixtures/logstash-dummy-pack/Rakefile b/qa/integration/fixtures/logstash-dummy-pack/Rakefile
new file mode 100644
index 00000000000..bb55078e69e
--- /dev/null
+++ b/qa/integration/fixtures/logstash-dummy-pack/Rakefile
@@ -0,0 +1,14 @@
+# encoding: utf-8
+require "paquet"
+
+TARGET_DIRECTORY = File.join(File.dirname(__FILE__), "dependencies")
+
+Paquet::Task.new(TARGET_DIRECTORY) do
+  pack "manticore"
+  pack "gemoji"
+
+  # Everything not defined here will be assumed to be provided
+  # by the target installation
+  ignore "logstash-core-plugin-api"
+  ignore "logstash-core"
+end
diff --git a/qa/integration/fixtures/logstash-dummy-pack/bundle.sh b/qa/integration/fixtures/logstash-dummy-pack/bundle.sh
new file mode 100755
index 00000000000..bc16b58dcfc
--- /dev/null
+++ b/qa/integration/fixtures/logstash-dummy-pack/bundle.sh
@@ -0,0 +1,20 @@
+bundle install --path vendor
+bundle exec rake vendor
+bundle exec rake paquet:vendor
+rm -rf build/
+mkdir -p build/logstash-dummy-pack/logstash/
+cp -r dependencies build/logstash-dummy-pack/logstash/
+gem build logstash-output-secret.gemspec
+mv logstash-output-secret*.gem build/logstash-dummy-pack/logstash/
+
+# Generate stuff for a uber zip
+mkdir -p build/logstash-dummy-pack/elasticsearch
+touch build/logstash-dummy-pack/elasticsearch/README.md
+
+mkdir -p build/logstash-dummy-pack/kibana
+touch build/logstash-dummy-pack/kibana/README.md
+
+cd build/
+zip -r logstash-dummy-pack.zip logstash-dummy-pack
+cp *.zip ../
+cd ..
diff --git a/qa/integration/fixtures/logstash-dummy-pack/lib/logstash/outputs/secret.rb b/qa/integration/fixtures/logstash-dummy-pack/lib/logstash/outputs/secret.rb
new file mode 100644
index 00000000000..ed621ac3259
--- /dev/null
+++ b/qa/integration/fixtures/logstash-dummy-pack/lib/logstash/outputs/secret.rb
@@ -0,0 +1,17 @@
+# encoding: utf-8
+require "logstash/outputs/base"
+require "logstash/namespace"
+
+# An secret output that does nothing.
+class LogStash::Outputs::Secret < LogStash::Outputs::Base
+  config_name "secret"
+
+  public
+  def register
+  end # def register
+
+  public
+  def receive(event)
+    return "Event received"
+  end # def event
+end # class LogStash::Outputs::Secret
diff --git a/qa/integration/fixtures/logstash-dummy-pack/logstash-dummy-pack.zip b/qa/integration/fixtures/logstash-dummy-pack/logstash-dummy-pack.zip
new file mode 100644
index 00000000000..f2dbc63c8d6
Binary files /dev/null and b/qa/integration/fixtures/logstash-dummy-pack/logstash-dummy-pack.zip differ
diff --git a/qa/integration/fixtures/logstash-dummy-pack/logstash-output-secret.gemspec b/qa/integration/fixtures/logstash-dummy-pack/logstash-output-secret.gemspec
new file mode 100644
index 00000000000..af9a1e2b192
--- /dev/null
+++ b/qa/integration/fixtures/logstash-dummy-pack/logstash-output-secret.gemspec
@@ -0,0 +1,33 @@
+Gem::Specification.new do |s|
+  s.name          = 'logstash-output-secret'
+  s.version       = '0.1.0'
+  s.licenses      = ['Apache License (2.0)']
+  s.summary       = 'Write a short summary, because Rubygems requires one.'
+  s.description   = 'Write a longer description or delete this line.'
+  s.homepage      = 'https://github.com/ph/secret'
+  s.authors       = ['Pier-Hugues Pellerin']
+  s.email         = 'phpellerin@gmail.com'
+  s.require_paths = ['lib']
+
+  # Files
+  s.files = Dir['lib/**/*','spec/**/*','*.gemspec','*.md','CONTRIBUTORS','Gemfile','LICENSE','NOTICE.TXT']
+   # Tests
+  s.test_files = s.files.grep(%r{^(test|spec|features)/})
+
+  # Special flag to let us know this is actually a logstash plugin
+  s.metadata = { "logstash_plugin" => "true", "logstash_group" => "output" }
+  s.post_install_message =<<eos
+This plugins will require the configuration of XXXXX in the logstash.yml
+
+Make sure you double check your configuration
+eos
+
+
+  # Gem dependencies
+  s.add_runtime_dependency "manticore"
+  s.add_runtime_dependency "gemoji", "< 2.0"
+
+
+  s.add_development_dependency "paquet"
+  s.add_development_dependency "rake"
+end
diff --git a/qa/integration/fixtures/logstash-dummy-pack/spec/outputs/secret_spec.rb b/qa/integration/fixtures/logstash-dummy-pack/spec/outputs/secret_spec.rb
new file mode 100644
index 00000000000..341b7a2501d
--- /dev/null
+++ b/qa/integration/fixtures/logstash-dummy-pack/spec/outputs/secret_spec.rb
@@ -0,0 +1,22 @@
+# encoding: utf-8
+require "logstash/devutils/rspec/spec_helper"
+require "logstash/outputs/secret"
+require "logstash/codecs/plain"
+require "logstash/event"
+
+describe LogStash::Outputs::Secret do
+  let(:sample_event) { LogStash::Event.new }
+  let(:output) { LogStash::Outputs::Secret.new }
+
+  before do
+    output.register
+  end
+
+  describe "receive message" do
+    subject { output.receive(sample_event) }
+
+    it "returns a string" do
+      expect(subject).to eq("Event received")
+    end
+  end
+end
diff --git a/qa/integration/fixtures/logstash-filter-qatest-0.1.1.gem b/qa/integration/fixtures/logstash-filter-qatest-0.1.1.gem
new file mode 100644
index 00000000000..3dd8ba42d1f
Binary files /dev/null and b/qa/integration/fixtures/logstash-filter-qatest-0.1.1.gem differ
diff --git a/qa/integration/fixtures/offline_wrapper/.gitignore b/qa/integration/fixtures/offline_wrapper/.gitignore
new file mode 100644
index 00000000000..e4d959a4151
--- /dev/null
+++ b/qa/integration/fixtures/offline_wrapper/.gitignore
@@ -0,0 +1 @@
+offine
diff --git a/qa/integration/fixtures/offline_wrapper/Makefile b/qa/integration/fixtures/offline_wrapper/Makefile
new file mode 100644
index 00000000000..448c4e434fe
--- /dev/null
+++ b/qa/integration/fixtures/offline_wrapper/Makefile
@@ -0,0 +1,8 @@
+OBJECTS=offline offline.o
+
+default: offline
+
+clean:
+	rm -f $(OBJECTS)
+offline: offline.o
+	$(CC) -o $@ $<
diff --git a/qa/integration/fixtures/offline_wrapper/README.md b/qa/integration/fixtures/offline_wrapper/README.md
new file mode 100644
index 00000000000..34e35214aa5
--- /dev/null
+++ b/qa/integration/fixtures/offline_wrapper/README.md
@@ -0,0 +1,31 @@
+
+# offline with seccomp
+
+This is a little hack I wrote while trying to see if seccomp could be used to
+help me more easily test programs in "offline mode" without having to actually
+disable networking on my whole laptop.
+
+Building:
+
+```
+make offline
+```
+
+Usage:
+
+```
+./offline <program> [args]
+```
+
+Example:
+
+```
+% nc localhost 10000
+Ncat: Connection refused.
+
+% ./offline nc localhost 10000
+Ncat: Permission denied.
+
+% ./offline host google.com
+host: isc_socket_bind: permission denied
+```
diff --git a/qa/integration/fixtures/offline_wrapper/offline.c b/qa/integration/fixtures/offline_wrapper/offline.c
new file mode 100644
index 00000000000..b335729876d
--- /dev/null
+++ b/qa/integration/fixtures/offline_wrapper/offline.c
@@ -0,0 +1,98 @@
+#include <linux/seccomp.h>
+#include <linux/filter.h>
+#include <sys/syscall.h>
+#include <stddef.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <stdio.h>
+#include <sys/prctl.h>
+#include <unistd.h>
+
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+
+struct sock_filter reject_connect_and_bind[] = {
+  // LD|W|ABS == Load Word at ABSolute offset
+  // Load the syscall number
+  BPF_STMT(BPF_LD|BPF_W|BPF_ABS, (offsetof(struct seccomp_data, nr))),
+
+  // JMP|JEQ|K Do a jump after comparing EQuality of the loaded value and a
+  // constant. If equal, jump 2 positions forward, if not equal, do not jump(zero jump).
+  // Is it the `connect` syscall?
+  BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_connect, 2, 0),
+  // Is it the `bind` syscall?
+  BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_bind, 1, 0),
+
+  // RET|K Return a constant.
+  // Neither bind nor connect? Allow it.
+  BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),
+
+  // Fun fact. `connect` and `bind` take the same arguments, so we can process them the same way.
+  // int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
+  // int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
+
+  // Ideally, we'd load the 2nd arg (sockaddr struct) and look at the `sa_family` member to see
+  // what kind of socket address is to be used. However, BPF/seccomp doesn't allow you to 
+  // dereference pointers... so let's try relying on the sockaddr_len argument.
+
+  // Load third argument to the syscall (addrlen)
+  BPF_STMT(BPF_LD|BPF_W|BPF_ABS, offsetof(struct seccomp_data, args[2])),
+
+  // Try filtering based on the sockaddr len. This isn't great, but may be better than nothing.
+  //   - Reject sockaddr_in and sockaddr_in6
+  //   - Allow everything else (unix sockets, etc)
+  BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, sizeof(struct sockaddr_in), 1, 0),
+  BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, sizeof(struct sockaddr_in6), 0, 1),
+  BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO|(EACCES&SECCOMP_RET_DATA)),
+  BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),
+};
+
+struct sock_filter reject_inet_socket[] = {
+  // LD|W|ABS == Load Word at ABSolute offset
+  // Load the syscall number
+  BPF_STMT(BPF_LD|BPF_W|BPF_ABS, (offsetof(struct seccomp_data, nr))),
+
+  // Is it the `socket` syscall?
+  BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, __NR_socket, 1, 0),
+  // Not `socket` call? Allow it.
+  BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),
+
+  // Load first argument to the syscall (domain)
+  BPF_STMT(BPF_LD|BPF_W|BPF_ABS, offsetof(struct seccomp_data, args[0])),
+
+  // Reject INET and INET6
+  BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, AF_INET, 1, 0),
+  BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, AF_INET6, 0, 1),
+  BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO|(EACCES&SECCOMP_RET_DATA)),
+  BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),
+};
+
+int main(int argc, char **argv) {
+  struct sock_filter *filter = reject_inet_socket;
+  unsigned short count = sizeof(reject_inet_socket) / sizeof(filter[0]);
+
+  struct sock_fprog prog = {
+    .len = count,
+    .filter = filter,
+  };
+
+  if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
+    perror("seccomp PR_SET_NO_NEW_PRIVS");
+    return 1;
+  }
+
+  if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {
+    perror("seccomp");
+    return 1;
+  }
+
+  if (argc == 1) {
+    printf("Usage: %s <program> [args]\n", argv[0]);
+    return 1;
+  }
+
+  argv++;
+  execvp(argv[0], argv);
+  return 0;
+}
diff --git a/qa/integration/fixtures/prepare_offline_pack_spec.yml b/qa/integration/fixtures/prepare_offline_pack_spec.yml
new file mode 100644
index 00000000000..cbfc784af81
--- /dev/null
+++ b/qa/integration/fixtures/prepare_offline_pack_spec.yml
@@ -0,0 +1,3 @@
+---
+services:
+  - logstash
diff --git a/qa/integration/framework/helpers.rb b/qa/integration/framework/helpers.rb
index 23a911e091e..5692dec5e0c 100644
--- a/qa/integration/framework/helpers.rb
+++ b/qa/integration/framework/helpers.rb
@@ -1,7 +1,8 @@
 # encoding: utf-8
 # Helper module for all tests
-
 require "flores/random"
+require "fileutils"
+require "zip"
 
 def wait_for_port(port, retry_attempts)
   tries = retry_attempts
@@ -42,4 +43,66 @@ def config_to_temp_file(config)
 def random_port
   # 9600-9700 is reserved in Logstash HTTP server, so we don't want that
   Flores::Random.integer(9701..15000)
-end  
\ No newline at end of file
+end
+
+class Pack
+  PLUGINS_PATH = "logstash"
+  DEPENDENCIES_PATH = File.join("logstash", "dependencies")
+  GEM_EXTENSION = ".gem"
+
+  def initialize(target)
+    @target = target
+  end
+
+  def plugins
+    @plugins ||= extract_gems_data(File.join(@target, PLUGINS_PATH))
+  end
+
+  def dependencies
+    @dependencies ||= extract_gems_data(File.join(@target, DEPENDENCIES_PATH))
+  end
+
+  def glob_gems
+    "*#{GEM_EXTENSION}"
+  end
+
+  def extract_gems_data(path)
+    Dir.glob(File.join(path, glob_gems)).collect { |gem_file| extract_gem_data_from_file(gem_file) }
+  end
+
+  def extract_gem_data_from_file(gem_file)
+    gem = File.basename(gem_file.downcase, GEM_EXTENSION)
+
+    parts = gem.split("-")
+
+    if gem.match(/java/)
+      platform = parts.pop
+      version = parts.pop
+      name = parts.join("-")
+
+      OpenStruct.new(:name => name, :version => version, :platform => platform)
+    else
+      version = parts.pop
+      name = parts.join("-")
+
+      OpenStruct.new(:name => name, :version => version, :platform => nil)
+    end
+  end
+end
+
+def extract(source, target, pattern = nil)
+  raise "Directory #{target} exist" if ::File.exist?(target)
+  Zip::File.open(source) do |zip_file|
+    zip_file.each do |file|
+      path = ::File.join(target, file.name)
+      FileUtils.mkdir_p(::File.dirname(path))
+      zip_file.extract(file, path) if pattern.nil? || pattern =~ file.name
+    end
+  end
+end
+
+def unpack(zip)
+  target = Stud::Temporary.pathname
+  extract(zip, target)
+  Pack.new(target)
+end
diff --git a/qa/integration/integration_tests.gemspec b/qa/integration/integration_tests.gemspec
index 5a44f769538..8a95b4a015a 100644
--- a/qa/integration/integration_tests.gemspec
+++ b/qa/integration/integration_tests.gemspec
@@ -20,4 +20,5 @@ Gem::Specification.new do |s|
   s.add_development_dependency 'pry'
   s.add_development_dependency 'logstash-devutils'
   s.add_development_dependency 'flores'
+  s.add_development_dependency 'rubyzip'
 end
diff --git a/qa/integration/services/logstash_service.rb b/qa/integration/services/logstash_service.rb
index b873ab89bbc..282010ea4c7 100644
--- a/qa/integration/services/logstash_service.rb
+++ b/qa/integration/services/logstash_service.rb
@@ -199,6 +199,10 @@ def plugin_cli
     PluginCli.new(@logstash_home)
   end
 
+  def lock_file
+    File.join(@logstash_home, "Gemfile.jruby-1.9.lock")
+  end
+
   class PluginCli
     class ProcessStatus < Struct.new(:exit_code, :stderr_and_stdout); end
 
@@ -209,12 +213,23 @@ class ProcessStatus < Struct.new(:exit_code, :stderr_and_stdout); end
 
     def initialize(logstash_home)
       @logstash_plugin = File.join(logstash_home, LOGSTASH_PLUGIN)
+      @logstash_home = logstash_home
     end
 
     def remove(plugin_name)
       run("remove #{plugin_name}")
     end
 
+    def prepare_offline_pack(plugins, output_zip = nil)
+      plugins = Array(plugins)
+
+      if output_zip.nil?
+        run("prepare-offline-pack #{plugins.join(" ")}")
+      else
+        run("prepare-offline-pack --output #{output_zip} #{plugins.join(" ")}")
+      end
+    end
+
     def list(plugin_name, verbose = false)
       run("list #{plugin_name} #{verbose ? "--verbose" : ""}")
     end
@@ -223,19 +238,29 @@ def install(plugin_name)
       run("install #{plugin_name}")
     end
 
-    def run(command)
+    def run_raw(cmd_parameters)
       out = Tempfile.new("content")
       out.sync = true
-      process = ChildProcess.build(logstash_plugin,*command.split(" "))
+
+      parts = cmd_parameters.split(" ")
+      cmd = parts.shift
+
+      process = ChildProcess.build(cmd, *parts)
       process.io.stdout = process.io.stderr = out
 
-      Bundler.with_clean_env do
-        process.start
+      Dir.chdir(@logstash_home) do
+        Bundler.with_clean_env do
+          process.start
+        end
       end
 
       process.poll_for_exit(TIMEOUT_MAXIMUM)
       out.rewind
       ProcessStatus.new(process.exit_code, out.read)
     end
+
+    def run(command)
+      run_raw("#{logstash_plugin} #{command}")
+    end
   end
 end
diff --git a/qa/integration/specs/cli/install_spec.rb b/qa/integration/specs/cli/install_spec.rb
new file mode 100644
index 00000000000..0208b292146
--- /dev/null
+++ b/qa/integration/specs/cli/install_spec.rb
@@ -0,0 +1,68 @@
+# encoding: utf-8
+require_relative "../../framework/fixture"
+require_relative "../../framework/settings"
+require_relative "../../services/logstash_service"
+require_relative "../../framework/helpers"
+require "logstash/devutils/rspec/spec_helper"
+
+def gem_in_lock_file?(pattern, lock_file)
+  content =  File.read(lock_file)
+  content.match(pattern)
+end
+
+describe "CLI > logstash-plugin install" do
+
+  before(:all) do
+    @fixture = Fixture.new(__FILE__)
+    @logstash = @fixture.get_service("logstash")
+    @logstash_plugin = @logstash.plugin_cli
+    @pack_directory =  File.expand_path(File.join(File.dirname(__FILE__), "..", "..", "fixtures", "logstash-dummy-pack"))
+  end
+
+  context "pack" do
+    let(:pack) { "file://#{File.join(@pack_directory, "logstash-dummy-pack.zip")}" }
+
+    # When you are on anything by linux we wont disable the internet with seccomp
+    if RbConfig::CONFIG["host_os"] == "linux"
+      context "without internet connection (linux seccomp wrapper)" do
+
+        let(:offline_wrapper_path) { File.expand_path(File.join(File.dirname(__FILE__), "..", "..", "fixtures", "offline_wrapper")) }
+
+        before do
+          Dir.chdir(offline_wrapper_path) do
+            system("make clean")
+            system("make")
+          end
+        end
+
+        let(:offline_wrapper_cmd) { File.join(offline_wrapper_path, "offline") }
+
+        it "successfully install the pack" do
+          execute = @logstash_plugin.run_raw("#{offline_wrapper_cmd} bin/logstash-plugin install #{pack}")
+
+          expect(execute.stderr_and_stdout).to match(/Install successful/)
+          expect(execute.exit_code).to eq(0)
+
+          installed = @logstash_plugin.list("logstash-output-secret")
+          expect(installed.stderr_and_stdout).to match(/logstash-output-secret/)
+
+          expect(gem_in_lock_file?(/gemoji/, @logstash.lock_file)).to be_truthy
+        end
+      end
+    else
+      context "with internet connection" do
+        it "successfully install the pack" do
+          execute = @logstash_plugin.install(pack)
+
+          expect(execute.stderr_and_stdout).to match(/Install successful/)
+          expect(execute.exit_code).to eq(0)
+
+          installed = @logstash_plugin.list("logstash-output-secret")
+          expect(installed.stderr_and_stdout).to match(/logstash-output-secret/)
+
+          expect(gem_in_lock_file?(/gemoji/, @logstash.lock_file)).to be_truthy
+        end
+      end
+    end
+  end
+end
diff --git a/qa/integration/specs/cli/prepare_offline_pack_spec.rb b/qa/integration/specs/cli/prepare_offline_pack_spec.rb
new file mode 100644
index 00000000000..c4f19f5a8b7
--- /dev/null
+++ b/qa/integration/specs/cli/prepare_offline_pack_spec.rb
@@ -0,0 +1,88 @@
+# encoding: utf-8
+require_relative "../../framework/fixture"
+require_relative "../../framework/settings"
+require_relative "../../services/logstash_service"
+require_relative "../../framework/helpers"
+require "logstash/devutils/rspec/spec_helper"
+
+describe "CLI > logstash-plugin prepare-offline-pack" do
+  before(:all) do
+    @fixture = Fixture.new(__FILE__)
+    @logstash_plugin = @fixture.get_service("logstash").plugin_cli
+  end
+
+  let(:temporary_zip_file) do
+    p = Stud::Temporary.pathname
+    FileUtils.mkdir_p(p)
+    File.join(p, "mypack.zip")
+  end
+
+  context "creating a pack for specific plugins" do
+    let(:plugins_to_pack) { %w(logstash-input-beats logstash-output-elasticsearch) }
+
+    it "successfully create a pack" do
+      execute = @logstash_plugin.prepare_offline_pack(plugins_to_pack, temporary_zip_file)
+
+      expect(execute.exit_code).to eq(0)
+      expect(execute.stderr_and_stdout).to match(/Offline package created at/)
+      expect(execute.stderr_and_stdout).to match(/#{temporary_zip_file}/)
+
+      unpacked = unpack(temporary_zip_file)
+
+      expect(unpacked.plugins.collect(&:name)).to include(*plugins_to_pack)
+      expect(unpacked.plugins.size).to eq(2)
+
+      expect(unpacked.dependencies.size).to be > 0
+    end
+  end
+
+  context "create a pack from a wildcard" do
+    let(:plugins_to_pack) { %w(logstash-filter-*) }
+
+    it "successfully create a pack" do
+      execute = @logstash_plugin.prepare_offline_pack(plugins_to_pack, temporary_zip_file)
+
+      expect(execute.exit_code).to eq(0)
+      expect(execute.stderr_and_stdout).to match(/Offline package created at/)
+      expect(execute.stderr_and_stdout).to match(/#{temporary_zip_file}/)
+
+      unpacked = unpack(temporary_zip_file)
+
+      filters = @logstash_plugin.list(plugins_to_pack.first).stderr_and_stdout.split("\n")
+
+      expect(unpacked.plugins.collect(&:name)).to include(*filters)
+      expect(unpacked.plugins.size).to eq(filters.size)
+
+      expect(unpacked.dependencies.size).to be > 0
+    end
+  end
+
+  context "create a pack with a locally installed .gem" do
+    let(:plugin_to_pack) { "logstash-filter-qatest" }
+
+    before do
+      @logstash_plugin.install(File.join(File.dirname(__FILE__), "..", "..", "fixtures", "logstash-filter-qatest-0.1.1.gem"))
+
+      # assert that the plugins is correctly installed
+      execute = @logstash_plugin.list(plugin_to_pack)
+
+      expect(execute.stderr_and_stdout).to match(/#{plugin_to_pack}/)
+      expect(execute.exit_code).to eq(0)
+    end
+
+    it "successfully create a pack" do
+      execute = @logstash_plugin.prepare_offline_pack(plugin_to_pack, temporary_zip_file)
+
+      expect(execute.stderr_and_stdout).to match(/Offline package created at/)
+      expect(execute.stderr_and_stdout).to match(/#{temporary_zip_file}/)
+      expect(execute.exit_code).to eq(0)
+
+      unpacked = unpack(temporary_zip_file)
+
+      expect(unpacked.plugins.collect(&:name)).to include(plugin_to_pack)
+      expect(unpacked.plugins.size).to eq(1)
+
+      expect(unpacked.dependencies.size).to eq(0)
+    end
+  end
+end
diff --git a/qa/integration/specs/cli/remove_spec.rb b/qa/integration/specs/cli/remove_spec.rb
index f390b61d00d..95981265d5a 100644
--- a/qa/integration/specs/cli/remove_spec.rb
+++ b/qa/integration/specs/cli/remove_spec.rb
@@ -5,40 +5,87 @@
 require_relative '../../framework/helpers'
 require "logstash/devutils/rspec/spec_helper"
 
-describe "Test removal of plugin" do
+describe "CLI > logstash-plugin remove" do
   before(:all) do
     @fixture = Fixture.new(__FILE__)
     @logstash_plugin = @fixture.get_service("logstash").plugin_cli
   end
 
-  context "when no other plugins depends on this plugin" do
-    it "successfully remove the plugin" do
-      execute = @logstash_plugin.remove("logstash-input-twitter")
+    if RbConfig::CONFIG["host_os"] == "linux"
+      context "without internet connection (linux seccomp wrapper)" do
 
-      expect(execute.exit_code).to eq(0)
-      expect(execute.stderr_and_stdout).to match(/Successfully removed logstash-input-twitter/)
+        let(:offline_wrapper_path) { File.expand_path(File.join(File.dirname(__FILE__), "..", "..", "fixtures", "offline_wrapper")) }
+        let(:offline_wrapper_cmd) { File.join(offline_wrapper_path, "offline") }
 
-      presence_check = @logstash_plugin.list("logstash-input-twitter")
-      expect(presence_check.exit_code).to eq(1)
-      expect(presence_check.stderr_and_stdout).to match(/ERROR: No plugins found/)
+        before do
+          Dir.chdir(offline_wrapper_path) do
+            system("make clean")
+            system("make")
+          end
+        end
 
-      @logstash_plugin.install("logstash-input-twitter")
-    end
-  end
+        context "when no other plugins depends on this plugin" do
+          it "successfully remove the plugin" do
+            execute = @logstash_plugin.run_raw("#{offline_wrapper_cmd} bin/logstash-plugin remove logstash-input-twitter")
+
+            expect(execute.exit_code).to eq(0)
+            expect(execute.stderr_and_stdout).to match(/Successfully removed logstash-input-twitter/)
+
+            presence_check = @logstash_plugin.list("logstash-input-twitter")
+            expect(presence_check.exit_code).to eq(1)
+            expect(presence_check.stderr_and_stdout).to match(/ERROR: No plugins found/)
+
+            @logstash_plugin.install("logstash-input-twitter")
+          end
+        end
+
+        context "when other plugins depends on this plugin" do
+          it "refuses to remove the plugin and display the plugin that depends on it." do
+            execute = @logstash_plugin.run_raw("#{offline_wrapper_cmd} bin/logstash-plugin remove logstash-codec-json")
+
+            expect(execute.exit_code).to eq(1)
+            expect(execute.stderr_and_stdout).to match(/Failed to remove "logstash-codec-json"/)
+            expect(execute.stderr_and_stdout).to match(/logstash-input-beats/) # one of the dependency
+            expect(execute.stderr_and_stdout).to match(/logstash-output-udp/) # one of the dependency
 
-  context "when other plugins depends on this plugin" do
-    it "refuses to remove the plugin and display the plugin that depends on it." do
-      execute = @logstash_plugin.remove("logstash-codec-json")
+            presence_check = @logstash_plugin.list("logstash-codec-json")
 
-      expect(execute.exit_code).to eq(1)
-      expect(execute.stderr_and_stdout).to match(/Failed to remove "logstash-codec-json"/)
-      expect(execute.stderr_and_stdout).to match(/logstash-input-beats/) # one of the dependency
-      expect(execute.stderr_and_stdout).to match(/logstash-output-udp/) # one of the dependency
+            expect(presence_check.exit_code).to eq(0)
+            expect(presence_check.stderr_and_stdout).to match(/logstash-codec-json/)
+          end
+        end
 
-      presence_check = @logstash_plugin.list("logstash-codec-json")
+      end
+    else
+      context "when no other plugins depends on this plugin" do
+        it "successfully remove the plugin" do
+          execute = @logstash_plugin.remove("logstash-input-twitter")
 
-      expect(presence_check.exit_code).to eq(0)
-      expect(presence_check.stderr_and_stdout).to match(/logstash-codec-json/)
+          expect(execute.exit_code).to eq(0)
+          expect(execute.stderr_and_stdout).to match(/Successfully removed logstash-input-twitter/)
+
+          presence_check = @logstash_plugin.list("logstash-input-twitter")
+          expect(presence_check.exit_code).to eq(1)
+          expect(presence_check.stderr_and_stdout).to match(/ERROR: No plugins found/)
+
+          @logstash_plugin.install("logstash-input-twitter")
+        end
+      end
+
+      context "when other plugins depends on this plugin" do
+        it "refuses to remove the plugin and display the plugin that depends on it." do
+          execute = @logstash_plugin.remove("logstash-codec-json")
+
+          expect(execute.exit_code).to eq(1)
+          expect(execute.stderr_and_stdout).to match(/Failed to remove "logstash-codec-json"/)
+          expect(execute.stderr_and_stdout).to match(/logstash-input-beats/) # one of the dependency
+          expect(execute.stderr_and_stdout).to match(/logstash-output-udp/) # one of the dependency
+
+          presence_check = @logstash_plugin.list("logstash-codec-json")
+
+          expect(presence_check.exit_code).to eq(0)
+          expect(presence_check.stderr_and_stdout).to match(/logstash-codec-json/)
+        end
+      end
     end
-  end
 end
diff --git a/qa/support/logstash-filter-qatest/logstash-filter-qatest-0.1.1.gem b/qa/support/logstash-filter-qatest/logstash-filter-qatest-0.1.1.gem
new file mode 100644
index 00000000000..3dd8ba42d1f
Binary files /dev/null and b/qa/support/logstash-filter-qatest/logstash-filter-qatest-0.1.1.gem differ
diff --git a/spec/unit/plugin_manager/offline_plugin_packager_spec.rb b/spec/unit/plugin_manager/offline_plugin_packager_spec.rb
new file mode 100644
index 00000000000..feca32dfaff
--- /dev/null
+++ b/spec/unit/plugin_manager/offline_plugin_packager_spec.rb
@@ -0,0 +1,132 @@
+# encoding: utf-8
+require "pluginmanager/offline_plugin_packager"
+require "stud/temporary"
+require "bootstrap/util/compress"
+require "fileutils"
+require "spec_helper"
+
+def retrieve_packaged_plugins(path)
+  Dir.glob(::File.join(path, "logstash", "*.gem"))
+end
+
+def retrieve_dependencies_gems(path)
+  Dir.glob(::File.join(path, "logstash", "dependencies", "*.gem"))
+end
+
+describe LogStash::PluginManager::SpecificationHelpers do
+  subject { described_class }
+
+  context "when it find gems" do
+    it "returns filtered results" do
+      expect(subject.find_by_name_with_wildcards("logstash-filter-*").all? { |spec| spec.name =~ /logstash-filter-/ }).to be_truthy
+    end
+  end
+
+  context "when it doesn't find gems" do
+    it "doesnt return gemspecs" do
+      expect(subject.find_by_name_with_wildcards("donotexistatall").size).to eq(0)
+    end
+  end
+end
+
+describe LogStash::PluginManager::OfflinePluginPackager do
+  before do
+    WebMock.allow_net_connect!
+  end
+
+  subject { described_class }
+
+  let(:temporary_dir) { Stud::Temporary.pathname }
+  let(:target) { ::File.join(temporary_dir, "my-pack.zip")}
+  let(:extract_to) { Stud::Temporary.pathname }
+
+  context "when the plugins doesn't" do
+    let(:plugins_args) { "idotnotexist" }
+
+    it "raise an exception" do
+      expect { subject.package(plugins_args, target) }.to raise_error(LogStash::PluginManager::PluginNotFoundError)
+    end
+  end
+
+  context "when the plugins is a core gem" do
+    %W(
+    logstash-core
+    logstash-core-event-java
+    logstash-core-plugin-api
+    logstash-core-queue-jruby).each do |plugin_name|
+      it "raise an exception with plugin: #{plugin_name}" do
+        expect { subject.package(plugin_name, target) }.to raise_error(LogStash::PluginManager::UnpackablePluginError)
+      end
+    end
+  end
+
+  context "when the plugins exist" do
+    before :all do
+      Paquet.ui = Paquet::SilentUI
+    end
+
+    before do
+      FileUtils.mkdir_p(temporary_dir)
+
+      subject.package(plugins_args, target)
+      LogStash::Util::Zip.extract(target, extract_to)
+    end
+
+    context "one plugin specified" do
+      let(:plugins_args) { ["logstash-input-stdin"] }
+
+      it "creates a pack with the plugin" do
+        expect(retrieve_packaged_plugins(extract_to).size).to eq(1)
+        expect(retrieve_packaged_plugins(extract_to)).to include(/logstash-input-stdin/)
+        expect(retrieve_dependencies_gems(extract_to).size).to be > 0
+      end
+    end
+
+    context "multiples plugins" do
+      let(:plugins_args) { ["logstash-input-stdin", "logstash-input-beats"] }
+
+      it "creates pack with the plugins" do
+        expect(retrieve_packaged_plugins(extract_to).size).to eq(2)
+
+        plugins_args.each do |plugin_name|
+          expect(retrieve_packaged_plugins(extract_to)).to include(/#{plugin_name}/)
+        end
+
+        expect(retrieve_dependencies_gems(extract_to).size).to be > 0
+      end
+    end
+
+    context "with wildcards" do
+      let(:plugins_args) { ["logstash-filter-*"] }
+
+      it "creates a pack with the plugins" do
+        expect(retrieve_packaged_plugins(extract_to).size).to eq(LogStash::PluginManager::SpecificationHelpers.find_by_name_with_wildcards(plugins_args.first).size)
+
+        retrieve_packaged_plugins(extract_to).each do |gem_file|
+          expect(gem_file).to match(/logstash-filter-.+/)
+        end
+
+        expect(retrieve_dependencies_gems(extract_to).size).to be > 0
+      end
+    end
+
+    context "with wildcards and normal plugins" do
+      let(:plugins_args) { ["logstash-filter-*", "logstash-input-beats"] }
+
+      it "creates a pack with the plugins" do
+        groups = retrieve_packaged_plugins(extract_to).group_by { |gem_file| ::File.basename(gem_file).split("-")[1] }
+
+        expect(groups["filter"].size).to eq(LogStash::PluginManager::SpecificationHelpers.find_by_name_with_wildcards(plugins_args.first).size)
+
+        groups["filter"].each do |gem_file|
+          expect(gem_file).to match(/logstash-filter-.+/)
+        end
+
+        expect(groups["input"].size).to eq(1)
+        expect(groups["input"]).to include(/logstash-input-beats/)
+
+        expect(retrieve_dependencies_gems(extract_to).size).to be > 0
+      end
+    end
+  end
+end
diff --git a/spec/unit/plugin_manager/pack_installer/local_spec.rb b/spec/unit/plugin_manager/pack_installer/local_spec.rb
index 9fb799cf956..b99712a4c07 100644
--- a/spec/unit/plugin_manager/pack_installer/local_spec.rb
+++ b/spec/unit/plugin_manager/pack_installer/local_spec.rb
@@ -49,7 +49,7 @@
       let(:local_file) { ::File.join(::File.dirname(__FILE__), "..", "..", "..", "support", "pack", "valid-pack.zip") }
 
       it "install the gems" do
-        expect(::Bundler::LogstashInjector).to receive(:inject!).with(be_kind_of(Array)).and_return([])
+        expect(::Bundler::LogstashInjector).to receive(:inject!).with(be_kind_of(LogStash::PluginManager::PackInstaller::Pack)).and_return([])
 
         expect(::LogStash::PluginManager::GemInstaller).to receive(:install).with(/logstash-input-packtest/, anything)
         expect(::LogStash::PluginManager::GemInstaller).to receive(:install).with(/logstash-input-packtestdep/, anything)
diff --git a/spec/unit/plugin_manager/prepare_offline_pack_spec.rb b/spec/unit/plugin_manager/prepare_offline_pack_spec.rb
new file mode 100644
index 00000000000..bcda5993c02
--- /dev/null
+++ b/spec/unit/plugin_manager/prepare_offline_pack_spec.rb
@@ -0,0 +1,99 @@
+# encoding: utf-8
+require "spec_helper"
+require "pluginmanager/main"
+require "pluginmanager/prepare_offline_pack"
+require "pluginmanager/offline_plugin_packager"
+require "stud/temporary"
+require "fileutils"
+
+# This Test only handle the interaction with the OfflinePluginPackager class
+# any test for bundler will need to be done as rats test
+describe LogStash::PluginManager::PrepareOfflinePack do
+  before do
+    WebMock.allow_net_connect!
+  end
+
+  subject { described_class.new(cmd, {}) }
+
+  let(:temporary_dir) { Stud::Temporary.pathname }
+  let(:tmp_zip_file) { ::File.join(temporary_dir, "myspecial.zip") }
+  let(:offline_plugin_packager) { double("offline_plugin_packager") }
+  let(:cmd_args) { ["--output", tmp_zip_file, "logstash-input-stdin"] }
+  let(:cmd) { "install" }
+
+  before do
+    FileUtils.mkdir_p(temporary_dir)
+
+    allow(LogStash::Bundler).to receive(:invoke!).and_return(nil)
+    allow(LogStash::PluginManager::OfflinePluginPackager).to receive(:package).with(anything, anything).and_return(offline_plugin_packager)
+  end
+
+  context "when not debbuging" do
+    before do
+      @before_debug_value = ENV["DEBUG"]
+      ENV["DEBUG"] = nil
+    end
+
+    after do
+      ENV["DEBUG"] = @before_debug_value
+    end
+
+    it "silences paquet ui reporter" do
+      expect(Paquet).to receive(:ui=).with(Paquet::SilentUI)
+      subject.run(cmd_args)
+    end
+
+    context "when file target already exist" do
+      before do
+        FileUtils.touch(tmp_zip_file)
+      end
+
+      it "overrides the file" do
+        expect(FileUtils).to receive(:rm_rf).with(tmp_zip_file)
+        subject.run(cmd_args)
+      end
+    end
+
+    context "when trying to use a core gem" do
+      let(:exception) { LogStash::PluginManager::UnpackablePluginError }
+
+      before do
+        allow(LogStash::PluginManager::OfflinePluginPackager).to receive(:package).with(anything, anything).and_raise(exception)
+      end
+
+      it "catches the error" do
+        expect(subject).to receive(:report_exception).with("Offline package", be_kind_of(exception)).and_return(nil)
+        subject.run(cmd_args)
+      end
+    end
+
+    context "when trying to pack a plugin that doesnt exist" do
+      let(:exception) { LogStash::PluginManager::PluginNotFoundError }
+
+      before do
+        allow(LogStash::PluginManager::OfflinePluginPackager).to receive(:package).with(anything, anything).and_raise(exception)
+      end
+
+      it "catches the error" do
+        expect(subject).to receive(:report_exception).with("Cannot create the offline archive", be_kind_of(exception)).and_return(nil)
+        subject.run(cmd_args)
+      end
+    end
+  end
+
+  context "when debugging" do
+    before do
+      @before_debug_value = ENV["DEBUG"]
+      ENV["DEBUG"] = "1"
+    end
+
+    after do
+      ENV["DEBUG"] = @before_debug_value
+    end
+
+    it "doesn't silence paquet ui reporter" do
+      expect(Paquet).not_to receive(:ui=).with(Paquet::SilentUI)
+      subject.run(cmd_args)
+    end
+  end
+end
diff --git a/tools/paquet/lib/paquet/gem.rb b/tools/paquet/lib/paquet/gem.rb
index 2e009c78f64..88219651546 100644
--- a/tools/paquet/lib/paquet/gem.rb
+++ b/tools/paquet/lib/paquet/gem.rb
@@ -9,10 +9,11 @@ class Gem
 
     attr_reader :gems, :ignores
 
-    def initialize(target_path)
+    def initialize(target_path, cache = nil)
       @target_path = target_path
       @gems = []
       @ignores = []
+      @cache = cache
     end
 
     def add(name)
@@ -29,7 +30,38 @@ def pack
       FileUtils.rm_rf(@target_path)
       FileUtils.mkdir_p(@target_path)
 
-      download_gems(collect_required_gems)
+      package_gems(collect_required_gems)
+    end
+
+    def package_gems(collect_required_gems)
+      gems_to_package = collect_required_gems
+        .collect { |gem| gem_full_name(gem) }
+        .uniq
+
+      if use_cache?
+        gems_to_package.each do |gem_name|
+          if gem_file = find_in_cache(gem_name)
+            destination = File.join(@target_path, File.basename(gem_file))
+            FileUtils.cp(gem_file, destination)
+            Paquet::ui.info("Vendoring: #{gem_name}, from cache: #{gem_file}")
+          else
+            download_gem(gem_name)
+          end
+        end
+      else
+        gems_to_package.each do |gem_name|
+          download_gem(gem_name)
+        end
+      end
+    end
+
+    def use_cache?
+      @cache
+    end
+
+    def find_in_cache(gem_name)
+      filename = File.join(@cache, gem_name)
+      File.exist?(filename) ? filename : nil
     end
 
     def size
@@ -62,17 +94,16 @@ def resolve_dependencies(name)
       end
     end
 
-    def download_gems(required_gems)
-      required_gems
-        .collect { |gem| gem.ruby? ? "#{gem.name}-#{gem.version}.gem" : "#{gem.name}-#{gem.version}-#{gem.platform}.gem" }
-        .uniq
-        .each do |name|
-        source = "#{RUBYGEMS_URI}/#{name}"
-        destination = File.join(@target_path, name)
+    def gem_full_name(gem)
+      gem.ruby? ? "#{gem.name}-#{gem.version}.gem" : "#{gem.name}-#{gem.version}-#{gem.platform}.gem" 
+    end
 
-        Paquet::ui.info("Vendoring: #{name}, downloading: #{source}")
-        Paquet::Utils::download_file(source, destination)
-      end
+    def download_gem(gem_name)
+      source = "#{RUBYGEMS_URI}/#{gem_name}"
+      destination = File.join(@target_path, gem_name)
+
+      Paquet::ui.info("Vendoring: #{gem_name}, downloading: #{source}")
+      Paquet::Utils::download_file(source, destination)
     end
   end
 end
diff --git a/tools/paquet/lib/paquet/rspec/tasks.rb b/tools/paquet/lib/paquet/rspec/tasks.rb
index bb352471d2a..29a66e0d830 100644
--- a/tools/paquet/lib/paquet/rspec/tasks.rb
+++ b/tools/paquet/lib/paquet/rspec/tasks.rb
@@ -16,8 +16,8 @@
 # By default, the tool wont fetch everything and the developper need to declare what gems he want to download.
 module Paquet
   class Task < Rake::TaskLib
-    def initialize(target_path, &block)
-      @gem = Gem.new(target_path)
+    def initialize(target_path, cache_path = nil, &block)
+      @gem = Gem.new(target_path, cache_path)
 
       instance_eval(&block)
 
diff --git a/tools/paquet/lib/paquet/shell_ui.rb b/tools/paquet/lib/paquet/shell_ui.rb
index f1f73027528..331c37bef88 100644
--- a/tools/paquet/lib/paquet/shell_ui.rb
+++ b/tools/paquet/lib/paquet/shell_ui.rb
@@ -1,5 +1,14 @@
 # encoding: utf-8
 module Paquet
+  class SilentUI
+    class << self
+      def debug(message)
+      end
+      def info(message)
+      end
+    end
+  end
+
   class ShellUi
     def debug(message)
       report_message(:debug, message) if debug?
@@ -21,4 +30,8 @@ def debug?
   def self.ui
     @logger ||= ShellUi.new
   end
+
+  def self.ui=(new_output)
+    @logger = new_output
+  end
 end
diff --git a/tools/paquet/lib/paquet/utils.rb b/tools/paquet/lib/paquet/utils.rb
index b12f2bd87cb..44fd98b7455 100644
--- a/tools/paquet/lib/paquet/utils.rb
+++ b/tools/paquet/lib/paquet/utils.rb
@@ -27,7 +27,7 @@ def self.download_file(source, destination, counter = REDIRECTION_LIMIT)
           counter -= 1
           download_file(response['location'], destination, counter)
         else
-          raise "Response not handled: #{response.class}"
+          raise "Response not handled: #{response.class}, path: #{uri.path}"
         end
         f.path
       rescue => e
diff --git a/tools/paquet/lib/paquet/version.rb b/tools/paquet/lib/paquet/version.rb
index 454bc4d4680..14b1b5ab010 100644
--- a/tools/paquet/lib/paquet/version.rb
+++ b/tools/paquet/lib/paquet/version.rb
@@ -1,3 +1,3 @@
 module Paquet
-  VERSION = "0.1.1"
+  VERSION = "0.2.0"
 end
diff --git a/tools/paquet/paquet.gemspec b/tools/paquet/paquet.gemspec
index b784ab3802b..b195778d0ee 100644
--- a/tools/paquet/paquet.gemspec
+++ b/tools/paquet/paquet.gemspec
@@ -23,6 +23,6 @@ Gem::Specification.new do |spec|
 
   spec.add_development_dependency "rspec"
   spec.add_development_dependency "pry"
-  spec.add_development_dependency "webmock"
+  spec.add_development_dependency "webmock", "~> 2.2.0"
   spec.add_development_dependency "stud"
 end
diff --git a/tools/paquet/spec/integration/paquet_spec.rb b/tools/paquet/spec/integration/paquet_spec.rb
index 267f65efe4c..b5b52f1ecdb 100644
--- a/tools/paquet/spec/integration/paquet_spec.rb
+++ b/tools/paquet/spec/integration/paquet_spec.rb
@@ -6,28 +6,69 @@
 describe "Pack the dependencies", :integration => true do
   let(:path) { File.expand_path(File.join(File.dirname(__FILE__), "..", "support")) }
   let(:vendor_path) { Stud::Temporary.pathname }
-  let(:dependecies_path) { File.join(path, "dependencies") }
+  let(:dependencies_path) { File.join(path, "dependencies") }
   let(:bundler_cmd) { "bundle install --path #{vendor_path}"}
   let(:rake_cmd) { "bundler exec rake paquet:vendor" }
   let(:bundler_config) { File.join(path, ".bundler") }
+  let(:cache_path) { File.join(path, "cache") }
+  let(:cache_flores_gem) { File.join(cache_path, "flores-0.0.6.gem")}
+  let(:dummy_checksum_content) { "hello world" }
 
   before do
-    FileUtils.rm_rf(bundler_config)
-    FileUtils.rm_rf(vendor_path)
+    FileUtils.mkdir_p(cache_path)
+  end
+
+  context "with gems in cache" do
+    before do
+      File.open(cache_flores_gem, "w") { |f| f.write(dummy_checksum_content) }
 
-    Bundler.with_clean_env do
-      Dir.chdir(path) do
-        system(bundler_cmd)
-        system(rake_cmd)
+      FileUtils.rm_rf(bundler_config)
+      FileUtils.rm_rf(vendor_path)
+
+      Bundler.with_clean_env do
+        Dir.chdir(path) do
+          system(bundler_cmd)
+          system(rake_cmd)
+        end
       end
     end
+
+    after do
+      FileUtils.rm_rf(cache_flores_gem)
+    end
+
+    it "download the dependencies" do
+      downloaded_dependencies = Dir.glob(File.join(dependencies_path, "*.gem"))
+
+      expect(downloaded_dependencies.size).to eq(2)
+      expect(downloaded_dependencies).to include(/flores-0\.0\.6/,/stud/)
+      expect(downloaded_dependencies).not_to include(/logstash-devutils/)
+
+      expect(File.read(Dir.glob(File.join(dependencies_path, "flores*.gem")).first)).to eq(dummy_checksum_content)
+    end
   end
 
-  it "download the dependencies" do
-    downloaded_dependencies = Dir.glob(File.join(dependecies_path, "*.gem"))
+  context "without cached gems" do
+    before do
+      FileUtils.rm_rf(bundler_config)
+      FileUtils.rm_rf(vendor_path)
+
+      Bundler.with_clean_env do
+        Dir.chdir(path) do
+          system(bundler_cmd)
+          system(rake_cmd)
+        end
+      end
+    end
 
-    expect(downloaded_dependencies.size).to eq(2)
-    expect(downloaded_dependencies).to include(/flores-0\.0\.6/,/stud/)
-    expect(downloaded_dependencies).not_to include(/logstash-devutils/)
+    it "download the dependencies" do
+      downloaded_dependencies = Dir.glob(File.join(dependencies_path, "*.gem"))
+
+      expect(downloaded_dependencies.size).to eq(2)
+      expect(downloaded_dependencies).to include(/flores-0\.0\.6/,/stud/)
+      expect(downloaded_dependencies).not_to include(/logstash-devutils/)
+
+      expect(File.read(Dir.glob(File.join(dependencies_path, "flores*.gem")).first)).not_to eq(dummy_checksum_content)
+    end
   end
 end
diff --git a/tools/paquet/spec/paquet/gem_spec.rb b/tools/paquet/spec/paquet/gem_spec.rb
index 5226c68e8d0..b18bc731f36 100644
--- a/tools/paquet/spec/paquet/gem_spec.rb
+++ b/tools/paquet/spec/paquet/gem_spec.rb
@@ -1,6 +1,7 @@
 # encoding: utf-8
 require "paquet/gem"
 require "stud/temporary"
+require "fileutils"
 
 describe Paquet::Gem do
   let(:target_path) { Stud::Temporary.pathname }
@@ -21,4 +22,46 @@
   it "keeps track of the number of gem to pack" do
     expect { subject.add(dummy_gem) }.to change { subject.size }.by(1)
   end
+
+  context "when not configuring cache" do
+    it "use_cache? returns false" do
+      expect(subject.use_cache?).to be_truthy
+    end
+  end
+
+  context "when configuring cache" do
+    let(:cache_path) do
+      p = Stud::Temporary.pathname
+      FileUtils.mkdir_p(p)
+      p
+    end
+
+    subject { described_class.new(target_path, cache_path) }
+
+    it "use_cache? returns true" do
+      expect(subject.use_cache?).to be_truthy
+    end
+
+    context "#find_in_cache" do
+      let(:gem_full_name) { "super-lib-0.1.0.gem" }
+
+      context "when the gem is in cache directory" do
+        let(:gem_file_path) { File.join(cache_path, gem_full_name) }
+
+        before do
+          FileUtils.touch(gem_file_path)
+        end
+
+        it "returns true" do
+          expect(subject.find_in_cache(gem_full_name)).to match(gem_file_path)
+        end
+      end
+
+      context "when the gem is not in the cache directory" do
+        it "returns false" do
+          expect(subject.find_in_cache(gem_full_name)).to be_falsey
+        end
+      end
+    end
+  end
 end
diff --git a/tools/paquet/spec/support/Rakefile b/tools/paquet/spec/support/Rakefile
index 3b8d26ce65f..5e8040d8521 100644
--- a/tools/paquet/spec/support/Rakefile
+++ b/tools/paquet/spec/support/Rakefile
@@ -2,8 +2,9 @@
 require "paquet"
 
 TARGET_DIRECTORY = File.join(File.dirname(__FILE__), "dependencies")
+CACHE_PATH = File.join(File.dirname(__FILE__), "cache")
 
-Paquet::Task.new(TARGET_DIRECTORY) do
+Paquet::Task.new(TARGET_DIRECTORY, CACHE_PATH) do
   pack "stud"
   pack "flores"
 
