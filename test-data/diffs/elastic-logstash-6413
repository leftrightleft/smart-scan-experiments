diff --git a/.gitignore b/.gitignore
index 6ffc2014992..05aace0c69c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -37,6 +37,9 @@ qa/Gemfile.lock
 *.iws
 *.iml
 .gradle
+**/.gradle/*
+**/gradle/*
+**/gradlew*
 .idea
 logs
 qa/integration/services/installed/
diff --git a/logstash-core/lib/logstash-core_jars.rb b/logstash-core/lib/logstash-core_jars.rb
index b759e1d5833..d1c7bc4332d 100644
--- a/logstash-core/lib/logstash-core_jars.rb
+++ b/logstash-core/lib/logstash-core_jars.rb
@@ -1,18 +1,8 @@
 # this is a generated file, to avoid over-writing it just delete this comment
-begin
-  require 'jar_dependencies'
-rescue LoadError
-  require 'org/apache/logging/log4j/log4j-core/2.6.2/log4j-core-2.6.2.jar'
-  require 'org/apache/logging/log4j/log4j-api/2.6.2/log4j-api-2.6.2.jar'
-  require 'com/fasterxml/jackson/core/jackson-core/2.7.4/jackson-core-2.7.4.jar'
-  require 'com/fasterxml/jackson/core/jackson-annotations/2.7.0/jackson-annotations-2.7.0.jar'
-  require 'com/fasterxml/jackson/core/jackson-databind/2.7.4/jackson-databind-2.7.4.jar'
-end
+require 'jar_dependencies'
 
-if defined? Jars
-  require_jar( 'org.apache.logging.log4j', 'log4j-core', '2.6.2' )
-  require_jar( 'org.apache.logging.log4j', 'log4j-api', '2.6.2' )
-  require_jar( 'com.fasterxml.jackson.core', 'jackson-core', '2.7.4' )
-  require_jar( 'com.fasterxml.jackson.core', 'jackson-annotations', '2.7.0' )
-  require_jar( 'com.fasterxml.jackson.core', 'jackson-databind', '2.7.4' )
-end
+require_jar( 'org.apache.logging.log4j', 'log4j-core', '2.6.2' )
+require_jar( 'com.fasterxml.jackson.core', 'jackson-annotations', '2.7.0' )
+require_jar( 'com.fasterxml.jackson.core', 'jackson-databind', '2.7.4' )
+require_jar( 'org.apache.logging.log4j', 'log4j-api', '2.6.2' )
+require_jar( 'com.fasterxml.jackson.core', 'jackson-core', '2.7.4' )
diff --git a/logstash-core/spec/logstash/compiler/compiler_spec.rb b/logstash-core/spec/logstash/compiler/compiler_spec.rb
index d6e1d7c7c29..9f4856110bc 100644
--- a/logstash-core/spec/logstash/compiler/compiler_spec.rb
+++ b/logstash-core/spec/logstash/compiler/compiler_spec.rb
@@ -27,6 +27,10 @@ def j
           it "should compile" do
             expect(compiled).to be_java_kind_of(Java::OrgLogstashConfigIr::Pipeline)
           end
+          
+          it "should have a hash" do
+            expect(compiled.uniqueHash)
+          end
         end
       end
       
diff --git a/logstash-core/src/main/java/org/logstash/common/Util.java b/logstash-core/src/main/java/org/logstash/common/Util.java
new file mode 100644
index 00000000000..e5be66b0cb8
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/common/Util.java
@@ -0,0 +1,33 @@
+package org.logstash.common;
+
+import java.nio.charset.StandardCharsets;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * Created by andrewvc on 12/23/16.
+ */
+public class Util {
+    // Modified from http://stackoverflow.com/a/11009612/11105
+    public static String sha256(String base) {
+        try {
+            MessageDigest digest = MessageDigest.getInstance("SHA-256");
+            byte[] hash = digest.digest(base.getBytes(StandardCharsets.UTF_8));
+            return bytesToHexString(hash);
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException("Your system is (somehow) missing the SHA-256 algorithm!", e);
+        }
+    }
+
+    public static String bytesToHexString(byte[] bytes) {
+        StringBuilder hexString = new StringBuilder();
+
+        for (byte aHash : bytes) {
+            String hex = Integer.toHexString(0xff & aHash);
+            if (hex.length() == 1) hexString.append('0');
+            hexString.append(hex);
+        }
+
+        return hexString.toString();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/DSL.java b/logstash-core/src/main/java/org/logstash/config/ir/DSL.java
index d635716e6d4..b6170e74ee9 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/DSL.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/DSL.java
@@ -1,6 +1,5 @@
 package org.logstash.config.ir;
 
-import org.apache.logging.log4j.core.config.plugins.Plugin;
 import org.logstash.config.ir.expression.*;
 import org.logstash.config.ir.expression.binary.*;
 import org.logstash.config.ir.expression.unary.Not;
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/IHashable.java b/logstash-core/src/main/java/org/logstash/config/ir/IHashable.java
new file mode 100644
index 00000000000..38ab60bbb29
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/IHashable.java
@@ -0,0 +1,14 @@
+package org.logstash.config.ir;
+
+import org.logstash.common.Util;
+
+/**
+ * Created by andrewvc on 12/23/16.
+ */
+public interface IHashable {
+    String hashSource();
+
+    default String uniqueHash() {
+        return Util.sha256(this.hashSource());
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/Pipeline.java b/logstash-core/src/main/java/org/logstash/config/ir/Pipeline.java
index 5c871bb4e9a..927b63e6b04 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/Pipeline.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/Pipeline.java
@@ -12,7 +12,7 @@
 /**
  * Created by andrewvc on 9/20/16.
  */
-public class Pipeline {
+public class Pipeline implements IHashable {
     public Graph getGraph() {
         return graph;
     }
@@ -30,32 +30,23 @@ public SpecialVertex getFilterOut() {
     private final SpecialVertex filterOut;
 
     public Pipeline(Graph inputSection, Graph filterSection, Graph outputSection) throws InvalidIRException {
-        graph = DSL.graph();
-
-        // We don't really care about the edges in the input section, we just want the vertices as roots
-        for (Vertex inV : inputSection.getVertices()) {
-            if (inV instanceof PluginVertex) {
-                graph.addVertex(inV);
-            } else {
-                throw new InvalidIRException("Only plugin vertices are allowed in input sections!");
-            }
-        }
+        Graph tempGraph = inputSection.copy(); // The input section are our roots, so we can import that wholesale
 
         // Connect all the input vertices out to the queue
         queue = new SpecialVertex(SpecialVertex.Type.QUEUE);
-        graph.threadLeavesInto(queue);
+        tempGraph = tempGraph.chain(queue);
 
         // Now we connect the queue to the root of the filter section
-        graph.threadLeavesInto(filterSection);
+        tempGraph = tempGraph.chain(filterSection);
 
         // Now we connect the leaves (and partial leaves) of the graph
         // which should all be filters (unless no filters are defined)
         // to the special filterOut node
         filterOut = new SpecialVertex(SpecialVertex.Type.FILTER_OUT);
-        graph.threadLeavesInto(filterOut);
+        tempGraph = tempGraph.chain(filterOut);
 
         // Finally, connect the filter out node to all the outputs
-        graph.threadLeavesInto(outputSection);
+        this.graph = tempGraph.chain(outputSection);
     }
 
     public List<Vertex> getPostQueue() throws InvalidIRException {
@@ -104,4 +95,9 @@ public Stream<PluginVertex> pluginVertices() {
                .filter(v -> v instanceof PluginVertex)
                .map(v -> (PluginVertex) v);
     }
+
+    @Override
+    public String hashSource() {
+        return this.graph.uniqueHash();
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/PluginDefinition.java b/logstash-core/src/main/java/org/logstash/config/ir/PluginDefinition.java
index 42bcd660b57..31b020c6587 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/PluginDefinition.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/PluginDefinition.java
@@ -1,5 +1,8 @@
 package org.logstash.config.ir;
 
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Objects;
@@ -8,7 +11,22 @@
 /**
  * Created by andrewvc on 9/20/16.
  */
-public class PluginDefinition implements ISourceComponent {
+public class PluginDefinition implements ISourceComponent, IHashable {
+    private static ObjectMapper om = new ObjectMapper();
+
+    @Override
+    public String hashSource() {
+        try {
+            String serializedArgs = om.writeValueAsString(this.getArguments());
+            return this.getClass().getCanonicalName() + "|" +
+                    this.getType().toString() + "|" +
+                    this.getName() + "|" +
+                   serializedArgs;
+        } catch (JsonProcessingException e) {
+            throw new IllegalArgumentException("Could not serialize plugin args as JSON", e);
+        }
+    }
+
     public enum Type {
         INPUT,
         FILTER,
@@ -28,10 +46,6 @@ public String getName() {
         return name;
     }
 
-    public String getId() {
-        return (String) arguments.get("id");
-    }
-
     public Map<String, Object> getArguments() {
         return arguments;
     }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/SourceMetadata.java b/logstash-core/src/main/java/org/logstash/config/ir/SourceMetadata.java
index e45969ed30e..8a9a3205ac8 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/SourceMetadata.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/SourceMetadata.java
@@ -1,5 +1,7 @@
 package org.logstash.config.ir;
 
+import java.util.Objects;
+
 /**
  * Created by andrewvc on 9/6/16.
  */
@@ -40,6 +42,10 @@ public SourceMetadata() {
         this.sourceText = null;
     }
 
+    public int hashCode() {
+        return Objects.hash(this.sourceFile, this.sourceLine, this.sourceColumn, this.sourceText);
+    }
+
     public String toString() {
         return sourceFile + ":" + sourceLine + ":" + sourceColumn + ":```\n" + sourceText + "\n```";
     }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java
index 5c2e26ba22e..d707ca11e0e 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java
@@ -45,4 +45,9 @@ public BinaryBooleanExpression(SourceMetadata meta,
     public String toRubyString() {
         return "(" + getLeft().toRubyString() + rubyOperator() + getRight().toRubyString() + ")";
     }
+
+    @Override
+    public String hashSource() {
+        return getLeft().hashSource() + this.getClass().getCanonicalName() + getRight().hashSource();
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/BooleanExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/BooleanExpression.java
index 533d20f5c56..066f175b998 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/expression/BooleanExpression.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/BooleanExpression.java
@@ -1,7 +1,6 @@
 package org.logstash.config.ir.expression;
 
 import org.logstash.config.ir.SourceMetadata;
-import org.logstash.config.ir.expression.Expression;
 
 /**
  * Created by andrewvc on 9/14/16.
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/EventValueExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/EventValueExpression.java
index eeff014b6cb..ec432038ae2 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/expression/EventValueExpression.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/EventValueExpression.java
@@ -38,4 +38,9 @@ public String toString() {
     public String toRubyString() {
         return "event.getField('" + fieldName + "')";
     }
+
+    @Override
+    public String hashSource() {
+        return this.getClass().getCanonicalName() + "|" + fieldName;
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java
index 8a6b3a53e0f..96a5c7509a0 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java
@@ -2,8 +2,8 @@
 
 import org.jruby.RubyInstanceConfig;
 import org.jruby.embed.AttributeName;
-import org.jruby.embed.EmbedEvalUnit;
 import org.jruby.embed.ScriptingContainer;
+import org.logstash.config.ir.IHashable;
 import org.logstash.config.ir.SourceComponent;
 import org.logstash.config.ir.SourceMetadata;
 
@@ -15,7 +15,7 @@
  * notnull(eEventValue("foo"))
  * Created by andrewvc on 9/6/16.
  */
-public abstract class Expression extends SourceComponent {
+public abstract class Expression extends SourceComponent implements IHashable {
     private Object compiled;
     private ScriptingContainer container;
 
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/UnaryBooleanExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/UnaryBooleanExpression.java
index 3c1c84572df..1d5f1a47a0e 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/expression/UnaryBooleanExpression.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/UnaryBooleanExpression.java
@@ -1,6 +1,5 @@
 package org.logstash.config.ir.expression;
 
-import org.logstash.config.ir.ISourceComponent;
 import org.logstash.config.ir.InvalidIRException;
 import org.logstash.config.ir.SourceMetadata;
 
@@ -20,4 +19,9 @@ public UnaryBooleanExpression(SourceMetadata meta,
         if (expression == null) throw new InvalidIRException("Unary expressions cannot operate on null!");
         this.expression = expression;
     }
+
+    @Override
+    public String hashSource() {
+        return this.getClass().getCanonicalName() + this.expression.hashSource();
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/ValueExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/ValueExpression.java
index db8b0324863..088caabf038 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/expression/ValueExpression.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/ValueExpression.java
@@ -63,4 +63,9 @@ public String toRubyString() {
 
         return get().toString();
     }
+
+    @Override
+    public String hashSource() {
+        return this.getClass().getCanonicalName() + "|" + value;
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Eq.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Eq.java
index 3ddbd50d3d0..b2772a18da1 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Eq.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/Eq.java
@@ -1,6 +1,5 @@
 package org.logstash.config.ir.expression.binary;
 
-import org.logstash.config.ir.ISourceComponent;
 import org.logstash.config.ir.InvalidIRException;
 import org.logstash.config.ir.SourceMetadata;
 import org.logstash.config.ir.expression.BinaryBooleanExpression;
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/RegexEq.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/RegexEq.java
index 043d84a3ad3..44ec686d1ea 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/RegexEq.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/binary/RegexEq.java
@@ -1,6 +1,5 @@
 package org.logstash.config.ir.expression.binary;
 
-import org.logstash.config.ir.ISourceComponent;
 import org.logstash.config.ir.InvalidIRException;
 import org.logstash.config.ir.SourceMetadata;
 import org.logstash.config.ir.expression.BinaryBooleanExpression;
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/BooleanEdge.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/BooleanEdge.java
index c9a744b5d0b..814af86e66f 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/BooleanEdge.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/BooleanEdge.java
@@ -3,8 +3,6 @@
 import org.logstash.config.ir.ISourceComponent;
 import org.logstash.config.ir.InvalidIRException;
 
-import java.util.Collection;
-
 /**
  * Created by andrewvc on 9/15/16.
  */
@@ -50,6 +48,11 @@ public BooleanEdge(Boolean edgeType, Vertex outVertex, Vertex inVertex) throws I
         this.edgeType = edgeType;
     }
 
+    @Override
+    public String individualHashSource() {
+        return this.getClass().getCanonicalName() + "|" + this.getEdgeType();
+    }
+
     public String toString() {
         return getFrom() + " -|" + this.edgeType + "|-> " + getTo();
     }
@@ -68,4 +71,9 @@ public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
         return false;
     }
 
+    @Override
+    public BooleanEdge copy(Vertex from, Vertex to) throws InvalidIRException {
+        return new BooleanEdge(this.edgeType, from, to);
+    }
+
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/Edge.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/Edge.java
index 43d9074d8de..44422e99ae3 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/Edge.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/Edge.java
@@ -4,50 +4,45 @@
 import org.logstash.config.ir.InvalidIRException;
 import org.logstash.config.ir.SourceMetadata;
 
-import java.util.ArrayList;
-import java.util.Collection;
+import java.util.stream.Stream;
 
 /**
  * Created by andrewvc on 9/15/16.
  */
 public abstract class Edge implements ISourceComponent {
-    public static abstract class EdgeFactory {
-        public abstract Edge make(Vertex out, Vertex in) throws InvalidIRException;
+    private Graph graph;
+
+    public void setGraph(Graph graph) {
+        if (this.graph == graph) {
+            return;
+        } else if (this.graph == null) {
+            this.graph = graph;
+        } else {
+            throw new IllegalArgumentException("Attempted to set graph for edge that already has one!" + this);
+        }
     }
 
-    private final Vertex to;
-    private final Vertex from;
+    public abstract Edge copy(Vertex from, Vertex to) throws InvalidIRException;
 
-    public static Edge threadVertices(Vertex v1, Vertex v2) throws InvalidIRException {
-        Vertex[] args = { v1, v2 };
-        // Only ever returns one edge
-        return threadVertices(PlainEdge.factory, args).stream().findFirst().get();
+    public static abstract class EdgeFactory {
+        public abstract Edge make(Vertex from, Vertex to) throws InvalidIRException;
     }
 
-    public static Edge threadVertices(EdgeFactory edgeFactory, Vertex v1, Vertex v2) throws InvalidIRException {
-        Vertex[] args = { v1, v2 };
-        // Only ever returns one edge`
-        return threadVertices(edgeFactory, args).stream().findFirst().get();
-    }
+    private final Vertex from;
+    private final Vertex to;
 
-    public static Collection<Edge> threadVertices(Vertex... vertices) throws InvalidIRException {
-        return threadVertices(PlainEdge.factory, vertices);
+    public Stream<Edge> ancestors() {
+       // Without all the distinct calls this can be slow
+       return Stream.concat(this.from.incomingEdges(), this.from.incomingEdges().flatMap(Edge::ancestors).distinct()).distinct();
     }
 
-    public static Collection<Edge> threadVertices(EdgeFactory edgeFactory, Vertex... vertices) throws InvalidIRException {
-        Collection<Edge> edges = new ArrayList<>();
-
-        for (int i = 0; i < vertices.length-1; i++) {
-            Vertex from = vertices[i];
-            Vertex to = vertices[i+1];
-
-            Edge edge = edgeFactory.make(from, to);
-            to.addInEdge(edge);
-            from.addOutEdge(edge);
-            edges.add(edge);
-        }
+    public Stream<Edge> descendants() {
+       // Without all the distinct calls this can be slow
+       return Stream.concat(this.to.outgoingEdges(), this.to.outgoingEdges().flatMap(Edge::ancestors).distinct()).distinct();
+    }
 
-        return edges;
+    public Stream<Edge> lineage() {
+        return Stream.concat(Stream.concat(ancestors(), Stream.of(this)), descendants());
     }
 
     public Edge(Vertex from, Vertex to) throws InvalidIRException {
@@ -57,6 +52,14 @@ public Edge(Vertex from, Vertex to) throws InvalidIRException {
         if (this.from == this.to) {
             throw new InvalidIRException("Cannot create a cyclic vertex! " + to);
         }
+
+        if (!this.from.acceptsOutgoingEdge(this)) {
+            throw new Vertex.InvalidEdgeTypeException(String.format("Invalid outgoing edge %s for edge %s", this.from, this));
+        }
+
+        if (!this.to.acceptsIncomingEdge(this)) {
+            throw new Vertex.InvalidEdgeTypeException(String.format("Invalid incoming edge %s for edge %s", this.from, this));
+        }
     }
 
     public Vertex getTo() {
@@ -75,7 +78,7 @@ public String toString() {
     public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
         if (sourceComponent == null) return false;
         if (sourceComponent == this) return true;
-        if (sourceComponent.getClass() == sourceComponent.getClass()) {
+        if (sourceComponent.getClass() == this.getClass()) {
             Edge otherE = (Edge) sourceComponent;
 
             return this.getFrom().sourceComponentEquals(otherE.getFrom()) &&
@@ -84,6 +87,7 @@ public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
         return false;
     }
 
+    public abstract String individualHashSource();
 
     @Override
     public SourceMetadata getMeta() {
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java
index 56fb5df5c67..3901de41378 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java
@@ -1,75 +1,173 @@
 package org.logstash.config.ir.graph;
 
+import org.logstash.config.ir.IHashable;
 import org.logstash.config.ir.ISourceComponent;
 import org.logstash.config.ir.InvalidIRException;
-import org.logstash.config.ir.PluginDefinition;
 import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.graph.algorithms.BreadthFirst;
+import org.logstash.config.ir.graph.algorithms.GraphDiff;
 
+import java.lang.reflect.Array;
 import java.util.*;
-import java.util.function.Consumer;
+import java.util.function.BiFunction;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 /**
  * Created by andrewvc on 9/15/16.
  */
-public class Graph implements ISourceComponent {
+public class Graph implements ISourceComponent, IHashable {
     private final Set<Vertex> vertices = new HashSet<>();
     private final Set<Edge> edges = new HashSet<>();
+    private Map<Vertex, Integer> vertexRanks = new HashMap<>();
+    private final Map<Vertex,Set<Edge>> outgoingEdgeLookup = new HashMap<>();
+    private final Map<Vertex,Set<Edge>> incomingEdgeLookup = new HashMap<>();
+
 
     public Graph(Collection<Vertex> vertices, Collection<Edge> edges) throws InvalidIRException {
-        this.vertices.addAll(vertices);
-        this.edges.addAll(edges);
-        validate();
+        for (Vertex vertex : vertices) { this.addVertex(vertex, false); }
+        for (Edge edge : edges) { this.addEdge(edge, false); }
+        this.refresh();
     }
 
-    public Graph() {
-    }
+    public Graph() {}
 
     public static Graph empty() {
         return new Graph();
     }
 
-    public Graph addVertex(Vertex v) throws InvalidIRException {
+    public void addVertex(Vertex v) throws InvalidIRException {
+        addVertex(v, true);
+    }
+
+    private void addVertex(Vertex v, boolean doRefresh) throws InvalidIRException {
+        // If this belongs to another graph use a copy
+        if (v.getGraph() != null && v.getGraph() != this) {
+            throw new InvalidIRException("Attempted to add vertex already belonging to a graph!");
+        }
+
+        v.setGraph(this);
+
         this.vertices.add(v);
-        this.refresh();
+
+        if (doRefresh) this.refresh();
+    }
+
+    // Takes an arbitrary vertex from any graph and brings it into this one.
+    // It may have to copy it. The actual vertex that gets used is returned
+    public Vertex importVertex(Vertex v) throws InvalidIRException {
+        if (v.getGraph() != this) {
+            if (v.getGraph() == null) {
+                this.addVertex(v);
+                return v;
+            } else {
+                Vertex copy = v.copy();
+                this.addVertex(copy);
+                return copy;
+            }
+        } else {
+            return v;
+        }
+    }
+
+    public Vertex getVertexById(String id) {
+        return this.vertices().filter(v -> v.getId().equals(id)).findAny().get();
+    }
+
+    // Use threadVertices instead
+    private Graph addEdge(Edge e) throws InvalidIRException {
+        return addEdge(e, true);
+    }
+
+    private Graph addEdge(Edge e, boolean doRefresh) throws InvalidIRException {
+        if (!(this.getVertices().contains(e.getFrom()) && this.getVertices().contains(e.getTo()))) {
+            throw new InvalidIRException("Attempted to add edge referencing vertices not in this graph!");
+        }
+
+        this.edges.add(e);
+
+        BiFunction<Vertex, Set<Edge>, Set<Edge>> lookupComputeFunction = (vertex, edgeSet) -> {
+            if (edgeSet == null) edgeSet = new HashSet<>();
+            edgeSet.add(e);
+            return edgeSet;
+        };
+        this.outgoingEdgeLookup.compute(e.getFrom(), lookupComputeFunction);
+        this.incomingEdgeLookup.compute(e.getTo(), lookupComputeFunction);
+
+        e.setGraph(this);
+        if (doRefresh) this.refresh();
         return this;
     }
 
-    public void merge(Graph otherGraph) throws InvalidIRException {
-        this.vertices.addAll(otherGraph.getVertices());
-        this.edges.addAll(otherGraph.edges);
-        this.refresh();
+    protected Collection<Edge> getOutgoingEdges(Vertex v) {
+        return this.outgoingEdgeLookup.getOrDefault(v, Collections.emptySet());
+    }
+
+    protected Collection<Edge> getIncomingEdges(Vertex v) {
+        return this.incomingEdgeLookup.getOrDefault(v, Collections.emptySet());
+    }
+
+    // Returns a copy of this graph
+    public Graph copy() throws InvalidIRException {
+        return Graph.combine(this).graph;
+    }
+
+    // Returns a new graph that is the union of all provided graphs.
+    // If a single graph is passed in this will return a copy of it
+    public static GraphCombinationResult combine(Graph... graphs) throws InvalidIRException {
+        Map<Vertex, Vertex> oldToNewVertices = new HashMap<>();
+        Map<Edge,Edge> oldToNewEdges = new HashMap<>();
+
+        for (Graph graph : graphs) {
+            graph.vertices().forEach(v -> oldToNewVertices.put(v, v.copy()));
+
+            for (Edge e : graph.getEdges()) {
+                Edge copy = e.copy(oldToNewVertices.get(e.getFrom()), oldToNewVertices.get(e.getTo()));
+                oldToNewEdges.put(e, copy);
+            }
+        }
+
+        Graph newGraph = new Graph(oldToNewVertices.values(), oldToNewEdges.values());
+        return new GraphCombinationResult(newGraph, oldToNewVertices, oldToNewEdges);
+    }
+
+    public static final class GraphCombinationResult {
+        public final Graph graph;
+        public final Map<Vertex, Vertex> oldToNewVertices;
+        public final Map<Edge, Edge> oldToNewEdges;
+
+        GraphCombinationResult(Graph graph, Map<Vertex, Vertex> oldToNewVertices, Map<Edge, Edge> oldToNewEdges) {
+            this.graph = graph;
+            this.oldToNewVertices = oldToNewVertices;
+            this.oldToNewEdges = oldToNewEdges;
+        }
     }
 
     /*
-      Attach another graph's nodes to this one by connection this graph's leaves to
+      Return a copy of this graph with the other graph's nodes to this one by connection this graph's leaves to
       the other graph's root
     */
-    public Graph threadLeavesInto(Graph otherGraph) throws InvalidIRException {
-        if (otherGraph.getVertices().size() == 0) return this;
+    public Graph chain(Graph otherGraph) throws InvalidIRException {
+        if (otherGraph.getVertices().size() == 0) return this.copy();
+        if (this.isEmpty()) return otherGraph.copy();
+
+        GraphCombinationResult combineResult = Graph.combine(this, otherGraph);
 
         // Build these lists here since we do mutate the graph in place later
         // This isn't strictly necessary, but makes things less confusing
-        Collection<Vertex> fromLeaves = getLeaves();
-        Collection<Vertex> toRoots = otherGraph.getRoots();
-
-        if (this.isEmpty()) {
-            this.merge(otherGraph);
-            return this;
-        }
-
-        threadLeavesInto(fromLeaves, toRoots);
+        Collection<Vertex> fromLeaves = allLeaves().map(combineResult.oldToNewVertices::get).collect(Collectors.toSet());
+        Collection<Vertex> toRoots = otherGraph.roots().map(combineResult.oldToNewVertices::get).collect(Collectors.toSet());
 
-        return this;
+        return combineResult.graph.chain(fromLeaves, toRoots);
     }
 
-    public Graph threadLeavesInto(Vertex... otherVertex) throws InvalidIRException {
-        threadLeavesInto(this.getPartialLeaves(), Arrays.asList(otherVertex));
+    public Graph chain(Vertex... otherVertex) throws InvalidIRException {
+        chain(this.getAllLeaves(), Arrays.asList(otherVertex));
         return this;
     }
 
-    private void threadLeavesInto(Collection<Vertex> fromLeaves, Collection<Vertex> toVertices) throws InvalidIRException {
+    // This does *not* return a copy for performance reasons
+    private Graph chain(Collection<Vertex> fromLeaves, Collection<Vertex> toVertices) throws InvalidIRException {
         for (Vertex leaf : fromLeaves) {
             for (Edge.EdgeFactory unusedEf : leaf.getUnusedOutgoingEdgeFactories()) {
                 for (Vertex toVertex : toVertices) {
@@ -77,106 +175,121 @@ private void threadLeavesInto(Collection<Vertex> fromLeaves, Collection<Vertex>
                 }
             }
         }
+
+        return this;
+    }
+
+    public Collection<Edge> threadVerticesById(String... vertexIds) throws InvalidIRException {
+        return threadVerticesById(PlainEdge.factory, vertexIds);
+    }
+
+    public Collection<Edge> threadVerticesById(Edge.EdgeFactory edgeFactory, String... vertexIds) throws InvalidIRException {
+        Vertex[] argVertices = new Vertex[vertexIds.length];
+        for (int i = 0; i < vertexIds.length; i ++) {
+            String id = vertexIds[i];
+            Vertex v = getVertexById(id);
+            if (v==null) throw new InvalidIRException("Could not thread vertex, id not found in graph: !" + id + "\n" + this);
+            argVertices[i] = v;
+        }
+        return threadVertices(edgeFactory, argVertices);
     }
 
-    public Graph threadVertices(Edge.EdgeFactory edgeFactory, Vertex... argVertices) throws InvalidIRException {
-        Collection<Edge> newEdges = Edge.threadVertices(edgeFactory, argVertices);
+    public Collection<Edge> threadVertices(Edge.EdgeFactory edgeFactory, Vertex... argVertices) throws InvalidIRException {
+        List<Vertex> importedVertices = new ArrayList<>(argVertices.length);
+        for (Vertex va : argVertices) {
+            importedVertices.add(this.importVertex(va));
+        }
+
+        List<Edge> newEdges = new ArrayList<>();
+        for (int i = 0; i < importedVertices.size()-1; i++) {
+            Vertex from = importedVertices.get(i);
+            Vertex to = importedVertices.get(i+1);
+
+            this.addVertex(from);
+            this.addVertex(to);
 
-        for (Edge edge : newEdges) {
-            this.vertices.add(edge.getFrom());
-            this.vertices.add(edge.getTo());
-            this.edges.add(edge);
+            Edge edge = edgeFactory.make(from, to);
+            newEdges.add(edge);
+            this.addEdge(edge);
         }
 
         refresh();
 
-        return this;
+        return newEdges;
     }
 
-    public Graph threadVertices(boolean bool, Vertex... vertices) throws InvalidIRException {
-        Edge.EdgeFactory factory = bool ? BooleanEdge.trueFactory : BooleanEdge.falseFactory;
-        return threadVertices(factory, vertices);
+    public Edge threadVertices(Vertex a, Vertex b) throws InvalidIRException {
+        return threadVertices(PlainEdge.factory, a, b).stream().findFirst().get();
     }
 
-    public Graph threadVertices(Vertex... vertices) throws InvalidIRException {
+    public Collection<Edge> threadVertices(Vertex... vertices) throws InvalidIRException {
         return threadVertices(PlainEdge.factory, vertices);
     }
 
-    // Many of the operations we perform involve modifying one graph but adding vertices/edges
+    public Collection<Edge> threadVertices(boolean bool, Vertex... vertices) throws InvalidIRException {
+        Edge.EdgeFactory factory = bool ? BooleanEdge.trueFactory : BooleanEdge.falseFactory;
+        return threadVertices(factory, vertices);
+    }
+
+    // Many of the operations we perform involve modifying one graph by adding vertices/edges
     // from another. This method ensures that all the vertices/edges we know about having been pulled into
     // this graph. Methods in this class that add or remove externally provided vertices/edges
     // should call this method to ensure that the rest of the graph these items depend on are pulled
     // in.
     public void refresh() throws InvalidIRException {
-        walkEdges(e -> {
-            this.edges.add(e);
-            this.vertices.add(e.getTo());
-            this.vertices.add(e.getFrom());
-        });
-
-        walkVertices(v -> {
-            this.vertices.add(v);
-            this.edges.addAll(v.getIncomingEdges());
-            this.edges.addAll(v.getOutgoingEdges());
-        });
-
+        this.calculateRanks();
         this.validate();
     }
 
+    private void calculateRanks() {
+        vertexRanks = BreadthFirst.breadthFirst(this.getRoots()).vertexDistances;
+    }
+
+    public Integer rank(Vertex vertex) {
+        Integer rank = vertexRanks.get(vertex);
+        // This should never happen
+        if (rank == null) throw new RuntimeException("Attempted to get rank from vertex where it is not yet calculated: " + this);
+        return rank;
+    }
+
+    public Map<String, List<Vertex>> verticesByHash() {
+        return this.vertices().collect(Collectors.groupingBy(Vertex::uniqueHash));
+    }
+
     public void validate() throws InvalidIRException {
         if (this.getVertices().stream().noneMatch(Vertex::isLeaf)) {
             throw new InvalidIRException("Graph has no leaf vertices!" + this.toString());
         }
 
-        this.getSortedVertices();
-    }
+        List<List<Vertex>> duplicates = verticesByHash().values().stream().filter((group) -> group.size() > 1).collect(Collectors.toList());
+        if (!duplicates.isEmpty()) {
+            Stream<String> errorMessageGroups = duplicates.stream().
+                    map((group) -> group.stream().map(Object::toString).collect(Collectors.joining("===")));
 
-    public void walkVertices(Consumer<Vertex> consumer) {
-        for (Vertex vertex : this.getRoots()) {
-            walkVertices(consumer, vertex);
-        }
-    }
+            String joinedErrorMessageGroups = errorMessageGroups.collect(Collectors.joining("\n---\n"));
 
-    public void walkVertices(Consumer<Vertex> consumer, Vertex vertex) {
-        vertex.outgoingVertices().forEach(v -> {
-            consumer.accept(v);
-            walkVertices(consumer, v);
-        });
-    }
-
-    // Walk the graph, visiting each edge on it with the provided Consumer<Edge>
-    public void walkEdges(Consumer<Edge> consumer) {
-        // Avoid stream interface to avoid concurrency issues if a new root is added
-        // since streams are lazy you can't mutate the graph while walking it with a
-        // stream. Using this iterative approach we can allow such operations.
-        for (Vertex root : this.getRoots()) {
-            walkEdges(consumer, root);
+            throw new InvalidIRException("Some nodes on the graph are fully redundant!\n" + joinedErrorMessageGroups);
         }
     }
 
-    private void walkEdges(Consumer<Edge> consumer, Vertex vertex) {
-       vertex.outgoingEdges().forEach(e -> {
-           consumer.accept(e);
-           walkEdges(consumer,e.getTo());
-       });
-    }
 
     public Stream<Vertex> roots() {
         return vertices.stream().filter(Vertex::isRoot);
     }
 
-    public List<Vertex> getRoots() {
+    public Collection<Vertex> getRoots() {
         return roots().collect(Collectors.toList());
     }
 
     // Vertices which are partially leaves in that they support multiple
     // outgoing edge types but only have one or fewer attached
-    public Stream<Vertex> partialLeaves() {
+    public Stream<Vertex> allLeaves() {
         return vertices.stream().filter(Vertex::isPartialLeaf);
     }
 
-    public Collection<Vertex> getPartialLeaves() {
-        return partialLeaves().collect(Collectors.toList());
+    // Get all leaves whether partial or not
+    public Collection<Vertex> getAllLeaves() {
+        return allLeaves().collect(Collectors.toList());
     }
 
     public Stream<Vertex> leaves() {
@@ -280,17 +393,10 @@ public List<Vertex> getSortedVerticesBetween(Vertex start, Vertex end) throws In
     public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
         if (sourceComponent == this) return true;
         if (sourceComponent instanceof Graph) {
-            Graph otherG = (Graph) sourceComponent;
-            if (otherG.getVertices().size() != this.getVertices().size()) return false;
-
-            boolean edgesEqual = this.getEdges().stream().
-                    allMatch(e -> otherG.getEdges().stream().anyMatch(oe -> oe.sourceComponentEquals(e)));
+            Graph otherGraph = (Graph) sourceComponent;
+            GraphDiff.DiffResult diff = GraphDiff.diff(this, otherGraph);
+            return diff.isIdentical();
 
-            // We need to check vertices separately because there may be unconnected vertices
-            boolean verticesEqual = this.getVertices().stream().
-                    allMatch(v -> otherG.getVertices().stream().anyMatch(ov -> ov.sourceComponentEquals(v)));
-
-            return edgesEqual && verticesEqual;
         }
         return false;
     }
@@ -300,36 +406,8 @@ public boolean hasEquivalentEdge(Edge otherE) {
         return this.getEdges().stream().anyMatch(e -> e.sourceComponentEquals(otherE));
     }
 
-
-    public class DiffResult {
-        public Collection<Edge> getRemovedEdges() {
-            return removedEdges;
-        }
-
-        public Collection<Edge> getAddedEdges() {
-            return addedEdges;
-        }
-
-        private final Collection<Edge> removedEdges;
-        private final Collection<Edge> addedEdges;
-
-        public DiffResult(Collection<Edge> removed, Collection<Edge> added) {
-            this.removedEdges = removed;
-            this.addedEdges = added;
-        }
-
-        public String toString() {
-            return "Diff Result (-" + removedEdges.size() + ",+" + addedEdges.size() + ")\n" +
-                    removedEdges.stream().map(e -> "-" + e.toString()).collect(Collectors.joining("\n")) +
-                    "\n" +
-                    addedEdges.stream().map(e -> "+" + e.toString()).collect(Collectors.joining("\n"));
-        }
-    }
-
-    public DiffResult diff(Graph o) {
-       List<Edge> removedEdges = this.getEdges().stream().filter(e -> !o.hasEquivalentEdge(e)).collect(Collectors.toList());
-       List<Edge> addedEdges = o.getEdges().stream().filter(e -> !this.hasEquivalentEdge(e)).collect(Collectors.toList());
-        return new DiffResult(removedEdges, addedEdges);
+    public boolean hasEquivalentVertex(Vertex otherV) {
+        return this.getVertices().stream().anyMatch(v -> v.sourceComponentEquals(otherV));
     }
 
     @Override
@@ -341,16 +419,6 @@ public boolean isEmpty() {
         return (this.getVertices().size() == 0);
     }
 
-    public Graph threadToGraph(BooleanEdge.BooleanEdgeFactory edgeFactory, Vertex v, Graph otherGraph) throws InvalidIRException {
-        if (otherGraph.getVertices().size() == 0) return this;
-
-        for (Vertex otherRoot : otherGraph.getRoots()) {
-            this.threadVertices(edgeFactory, v, otherRoot);
-        }
-
-        return this;
-    }
-
     public Stream<Vertex> vertices() {
         return this.vertices.stream();
     }
@@ -358,4 +426,9 @@ public Stream<Vertex> vertices() {
     public Stream<Edge> edges() {
         return this.edges.stream();
     }
+
+    @Override
+    public String hashSource() {
+        return this.vertices.stream().map(Vertex::hashSource).sorted().collect(Collectors.joining("\n"));
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java
index 0653e2c82cf..b6374e99a3d 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java
@@ -4,14 +4,16 @@
 import org.logstash.config.ir.SourceMetadata;
 import org.logstash.config.ir.expression.BooleanExpression;
 
-import java.util.*;
+import java.util.Collection;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.UUID;
 import java.util.stream.Collectors;
 
 /**
  * Created by andrewvc on 9/15/16.
  */
 public class IfVertex extends Vertex {
-
     public BooleanExpression getBooleanExpression() {
         return booleanExpression;
     }
@@ -59,6 +61,11 @@ public boolean acceptsOutgoingEdge(Edge e) {
         return (e instanceof BooleanEdge);
     }
 
+    @Override
+    public String getId() {
+        return this.uniqueHash();
+    }
+
     public Collection<BooleanEdge> getOutgoingBooleanEdges() {
         // Wish there was a way to do this as a java a cast without an operation
         return getOutgoingEdges().stream().map(e -> (BooleanEdge) e).collect(Collectors.toList());
@@ -67,4 +74,25 @@ public Collection<BooleanEdge> getOutgoingBooleanEdges() {
     public Collection<BooleanEdge> getOutgoingBooleanEdgesByType(Boolean edgeType) {
         return getOutgoingBooleanEdges().stream().filter(e -> e.getEdgeType().equals(edgeType)).collect(Collectors.toList());
     }
+
+    // The easiest readable version of this for a human.
+    // If the original source is available we use that, otherwise we serialize the expression
+    public String humanReadableExpression() {
+        String sourceText = this.booleanExpression.getMeta() != null ? this.booleanExpression.getMeta().getSourceText() : null;
+        if (sourceText != null) {
+            return sourceText;
+        } else {
+            return this.getBooleanExpression().toRubyString();
+        }
+    }
+
+    @Override
+    public IfVertex copy() {
+        return new IfVertex(getMeta(),getBooleanExpression());
+    }
+
+    @Override
+    public String individualHashSource() {
+        return this.getClass().getCanonicalName() + "|" + this.booleanExpression.hashSource();
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/PlainEdge.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/PlainEdge.java
index 66507a0fc48..32c9d6f68e1 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/PlainEdge.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/PlainEdge.java
@@ -1,6 +1,5 @@
 package org.logstash.config.ir.graph;
 
-import org.logstash.config.ir.ISourceComponent;
 import org.logstash.config.ir.InvalidIRException;
 
 /**
@@ -16,10 +15,17 @@ public PlainEdge make(Vertex from, Vertex to) throws InvalidIRException {
 
     public static PlainEdgeFactory factory = new PlainEdgeFactory();
 
+    @Override
+    public String individualHashSource() {
+        return this.getClass().getCanonicalName();
+    }
+
     public PlainEdge(Vertex from, Vertex to) throws InvalidIRException {
         super(from, to);
     }
 
-
-
+    @Override
+    public PlainEdge copy(Vertex from, Vertex to) throws InvalidIRException {
+        return new PlainEdge(from, to);
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java
index 84d68c3b3b2..9bb71a5421b 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java
@@ -1,35 +1,34 @@
 package org.logstash.config.ir.graph;
 
+import org.logstash.common.Util;
 import org.logstash.config.ir.ISourceComponent;
 import org.logstash.config.ir.PluginDefinition;
 import org.logstash.config.ir.SourceMetadata;
 
-import java.util.Map;
-import java.util.Objects;
-import java.util.UUID;
-
 /**
  * Created by andrewvc on 9/15/16.
  */
 public class PluginVertex extends Vertex {
     private final SourceMetadata meta;
+    private final String id;
+    private final PluginDefinition pluginDefinition;
 
     public String getId() {
-        return id;
+        if (id != null) return id;
+        if (this.getGraph() == null) {
+            throw new RuntimeException("Attempted to get ID from PluginVertex before attaching it to a graph!");
+        }
+        return this.uniqueHash();
     }
 
+    public PluginDefinition getPluginDefinition() {
+        return pluginDefinition;
+    }
     @Override
     public SourceMetadata getMeta() {
         return meta;
     }
 
-    private final String id;
-
-    public PluginDefinition getPluginDefinition() {
-        return pluginDefinition;
-    }
-
-    private final PluginDefinition pluginDefinition;
 
     public PluginVertex(SourceMetadata meta, PluginDefinition pluginDefinition) {
         super(meta);
@@ -38,14 +37,29 @@ public PluginVertex(SourceMetadata meta, PluginDefinition pluginDefinition) {
         this.pluginDefinition = pluginDefinition;
 
         Object argId = this.pluginDefinition.getArguments().get("id");
-        this.id = argId != null ? argId.toString() : UUID.randomUUID().toString();
-        this.pluginDefinition.getArguments().put("id", this.id);
+        this.id = argId != null ? argId.toString() : null;
     }
 
     public String toString() {
         return "P[" + pluginDefinition + "]";
     }
 
+    @Override
+    public String individualHashSource() {
+        return Util.sha256(this.getClass().getCanonicalName() + "|" +
+                (this.id != null ? this.id : "NOID") + "|" +
+                this.getPluginDefinition().hashSource());
+    }
+
+    public String individualHash() {
+        return Util.sha256(individualHashSource());
+    }
+
+    @Override
+    public PluginVertex copy() {
+        return new PluginVertex(meta, getPluginDefinition());
+    }
+
     @Override
     public boolean sourceComponentEquals(ISourceComponent other) {
         if (other == null) return false;
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/SpecialVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/SpecialVertex.java
index 895c2b4818c..fa2ed63eacc 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/SpecialVertex.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/SpecialVertex.java
@@ -6,19 +6,6 @@
  * Created by andrewvc on 9/15/16.
  */
 public class SpecialVertex extends Vertex {
-    private final Type type;
-
-    public SpecialVertex() {
-        super(null);
-        this.type = Type.QUEUE;
-    }
-
-    public SpecialVertex(Type type) {
-        super(null);
-        this.type = type;
-
-    }
-
     public enum Type {
         FILTER_OUT ("FILTER_OUT"),
         QUEUE ("QUEUE");
@@ -34,10 +21,41 @@ public String toString() {
         }
     }
 
+    private final Type type;
+    private final String id;
+
+    public SpecialVertex(Type type) {
+        super(null);
+        this.id = "special-" + type.toString();
+        this.type = type;
+
+    }
+
+    @Override
+    public String getId() {
+        // There can only be one of each special vertex!
+        return id;
+    }
+
+    @Override
+    public String individualHashSource() {
+        return this.getClass().getCanonicalName() + "|" + this.type;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+
     public String toString() {
         return "S[" + this.type + "]";
     }
 
+    @Override
+    public SpecialVertex copy() {
+        return new SpecialVertex(this.type);
+    }
+
     @Override
     public boolean sourceComponentEquals(ISourceComponent other) {
         if (other == null) return false;
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java
index a34e23f3e14..846c2ef4623 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java
@@ -1,20 +1,27 @@
 package org.logstash.config.ir.graph;
 
+import org.logstash.common.Util;
+import org.logstash.config.ir.IHashable;
 import org.logstash.config.ir.ISourceComponent;
 import org.logstash.config.ir.InvalidIRException;
 import org.logstash.config.ir.SourceMetadata;
-
-import java.util.*;
+import org.logstash.config.ir.graph.algorithms.DepthFirst;
+
+import java.io.UnsupportedEncodingException;
+import java.nio.charset.StandardCharsets;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Collection;
+import java.util.Collections;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 /**
  * Created by andrewvc on 9/15/16.
  */
-public abstract class Vertex implements ISourceComponent {
-    private final Collection<Edge> incomingEdges = new HashSet<Edge>();
-    private final Collection<Edge> outgoingEdges = new HashSet<Edge>();
+public abstract class Vertex implements ISourceComponent, IHashable {
     private final SourceMetadata sourceMetadata;
+    private Graph graph = this.getGraph();
 
     public Vertex() {
         this.sourceMetadata = null;
@@ -24,57 +31,50 @@ public Vertex(SourceMetadata sourceMetadata) {
         this.sourceMetadata = sourceMetadata;
     }
 
-    public Vertex(Collection<Edge> incoming, Collection<Edge> outgoingEdges, SourceMetadata sourceMetadata) {
-        this.sourceMetadata = sourceMetadata;
-        this.incomingEdges.addAll(incoming);
-        this.outgoingEdges.addAll(outgoingEdges);
-    }
+    public abstract Vertex copy();
 
-    public class InvalidEdgeTypeException extends InvalidIRException {
+    public static class InvalidEdgeTypeException extends InvalidIRException {
         public InvalidEdgeTypeException(String s) {
             super(s);
         }
     }
 
-    public Vertex addInEdge(Edge e) throws InvalidEdgeTypeException {
-        if (!this.acceptsIncomingEdge(e)) throw new InvalidEdgeTypeException("Invalid incomingEdges edge!" + e + " for " + this);
-        this.incomingEdges.add(e);
-        return this;
+    public Graph getGraph() {
+        return this.graph;
     }
 
-    public Vertex addOutEdge(Edge e) throws InvalidEdgeTypeException {
-        if (!this.acceptsOutgoingEdge(e)) {
-            throw new InvalidEdgeTypeException(
-                "Invalid outgoing edge!" +
-                e + " for " + this +
-                " existing outgoing edges: " + this.getOutgoingEdges());
+    public void setGraph(Graph graph) {
+        if (this.graph == graph) {
+            return;
+        } else if (this.graph == null) {
+            this.graph = graph;
+        } else {
+            throw new IllegalArgumentException("Cannot set graph property on Vertex that is already assigned to an existing graph!");
         }
-        this.outgoingEdges.add(e);
-        return this;
     }
 
     public boolean isRoot() {
-        return incomingEdges.isEmpty();
+        return getIncomingEdges().isEmpty();
     }
 
     public boolean isLeaf() {
-        return outgoingEdges.isEmpty();
+        return getOutgoingEdges().isEmpty();
     }
 
     public boolean hasIncomingEdges() {
-        return !incomingEdges.isEmpty();
+        return !getIncomingEdges().isEmpty();
     }
 
     public boolean hasOutgoingEdges() {
-        return !outgoingEdges.isEmpty();
+        return !getOutgoingEdges().isEmpty();
     }
 
     public Collection<Edge> getIncomingEdges() {
-        return incomingEdges;
+        return incomingEdges().collect(Collectors.toSet());
     }
 
     public Collection<Edge> getOutgoingEdges() {
-        return outgoingEdges;
+        return outgoingEdges().collect(Collectors.toSet());
     }
 
     public Collection<Vertex> getOutgoingVertices() {
@@ -94,13 +94,81 @@ public Stream<Vertex> incomingVertices() {
     }
 
     public Stream<Edge> incomingEdges() {
-        return getIncomingEdges().stream();
+        return this.getGraph().getIncomingEdges(this).stream();
     }
 
     public Stream<Edge> outgoingEdges() {
-        return outgoingEdges.stream();
+        return this.getGraph().getOutgoingEdges(this).stream();
+    }
+
+    public Stream<Vertex> ancestors() {
+        return DepthFirst.reverseDepthFirst(this).filter(v -> v != this);
+    }
+
+    public Stream<Vertex> roots() {
+        return ancestors().filter(Vertex::isRoot);
+    }
+
+    public Stream<Vertex> descendants() {
+        return DepthFirst.depthFirst(this).filter(v -> v != this);
+    }
+
+    public Stream<Vertex> lineage() {
+        return Stream.concat(Stream.concat(ancestors(), Stream.of(this)), descendants());
+    }
+
+    // Rank is the shortest distance to a root for this vertex
+    public int rank() {
+        return this.graph.rank(this);
     }
 
+    @Override
+    public String hashSource() {
+        // Sort the lineage to ensure consistency. We prepend each item with a lexicographically sortable
+        // encoding of its rank (using hex notation) so that the sort order is identical to the traversal order.
+        // This is a required since there may be individually identical components in different locations in the graph.
+        // It is, however, illegal to have functionally identical vertices, that is to say two vertices with the same
+        // contents that have the same lineage.
+
+        try {
+            MessageDigest lineageDigest = MessageDigest.getInstance("SHA-256");
+
+            // The lineage can be quite long and we want to avoid the quadratic complexity of string concatenation
+            lineage().
+                    map(Vertex::contextualHashSource).
+                    sorted().
+                    forEachOrdered(v -> {
+                        byte[] bytes = v.getBytes(StandardCharsets.UTF_8);
+                        lineageDigest.update(bytes);
+                    });
+
+            return hashPrefix() + Util.bytesToHexString(lineageDigest.digest());
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public String hashPrefix() {
+        return String.format("Vertex[%08x]=", this.rank()) + this.individualHashSource() + "|";
+    }
+
+    public String contextualHashSource() {
+        // This string must be lexicographically sortable hence the ID at the front. It also must have the individualHashSource
+        // repeated at the front for the case of a graph with two nodes at the same rank
+        StringBuilder result = new StringBuilder();
+        result.append(hashPrefix());
+
+
+        result.append("INCOMING=");
+        this.incomingEdges().map(Edge::individualHashSource).sorted().forEachOrdered(result::append);
+        result.append("OUTGOING=");
+        this.outgoingEdges().map(Edge::individualHashSource).sorted().forEachOrdered(result::append);
+
+        return result.toString();
+    }
+
+    public abstract String individualHashSource();
+
     @Override
     public SourceMetadata getMeta() {
         return null;
@@ -129,5 +197,5 @@ public boolean acceptsOutgoingEdge(Edge e) {
         return true;
     }
 
-
+    public abstract String getId();
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/BreadthFirst.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/BreadthFirst.java
new file mode 100644
index 00000000000..26b2f1b1a02
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/BreadthFirst.java
@@ -0,0 +1,64 @@
+package org.logstash.config.ir.graph.algorithms;
+
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+
+/**
+ * Created by andrewvc on 1/5/17.
+ *
+ */
+public class BreadthFirst {
+    public static BfsResult breadthFirst(Collection<Vertex> roots) {
+        return breadthFirst(roots, false, null);
+    }
+
+    /* This isn't as pretty as the DFS search with its streaminess, but for our current uses we only really
+    *  care about using this to get the calculated vertexDistances, so that's fine. */
+    public static BfsResult breadthFirst(Collection<Vertex> roots,
+                                        boolean reverse,
+                                        Consumer<Map.Entry<Vertex, Integer>> consumer
+                                        ) {
+    Map<Vertex, Integer> vertexDistances = new HashMap<>();
+    Map<Vertex, Vertex> vertexParents = new HashMap<>();
+
+    Deque<Vertex> queue = new ArrayDeque<>(roots);
+    roots.forEach(v -> vertexDistances.put(v, 0));
+
+    while (!queue.isEmpty()) {
+        Vertex currentVertex = queue.removeFirst();
+        Integer currentDistance = vertexDistances.get(currentVertex);
+
+        if (consumer != null) {
+            consumer.accept(new AbstractMap.SimpleImmutableEntry<>(currentVertex, currentDistance));
+        }
+
+        Stream<Vertex> nextVertices = reverse ? currentVertex.incomingVertices() : currentVertex.outgoingVertices();
+        nextVertices.forEach(nextVertex -> {
+            if (vertexDistances.get(nextVertex) == null) {
+                vertexDistances.put(nextVertex, currentDistance+1);
+                vertexParents.put(nextVertex, currentVertex);
+                queue.push(nextVertex);
+            }
+        });
+    }
+
+    return new BfsResult(vertexDistances, vertexParents);
+}
+
+    public static final class BfsResult {
+        public final Map<Vertex, Integer> vertexDistances;
+        private final Map<Vertex, Vertex> vertexParents;
+
+        BfsResult(Map<Vertex, Integer> vertexDistances, Map<Vertex,Vertex> vertexParents) {
+            this.vertexDistances = vertexDistances;
+            this.vertexParents = vertexParents;
+        }
+
+        public Collection<Vertex> getVertices() {
+            return vertexDistances.keySet();
+        }
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/DepthFirst.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/DepthFirst.java
new file mode 100644
index 00000000000..cc0ef0fc60f
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/DepthFirst.java
@@ -0,0 +1,71 @@
+package org.logstash.config.ir.graph.algorithms;
+
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.*;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+
+/**
+ * Created by andrewvc on 1/5/17.
+ */
+public class DepthFirst {
+    public static Stream<Vertex> depthFirst(Graph g) {
+        return depthFirst(g.getRoots());
+    }
+
+    public static Stream<Vertex> reverseDepthFirst(Graph g) {
+        return reverseDepthFirst(g.getLeaves());
+    }
+
+    public static Stream<Vertex> depthFirst(Vertex v) {
+        return depthFirst(Collections.singleton(v));
+    }
+
+    public static Stream<Vertex> reverseDepthFirst(Vertex v) {
+        return depthFirst(Collections.singleton(v));
+    }
+
+    public static Stream<Vertex> depthFirst(Collection<Vertex> v) {
+        return streamify(new Traversal(v, false));
+    }
+
+    public static Stream<Vertex> reverseDepthFirst(Collection<Vertex> v) {
+        return streamify(new Traversal(v, true));
+    }
+
+    private static Stream<Vertex> streamify(Traversal t) {
+         return StreamSupport.stream(Spliterators.spliteratorUnknownSize(t, Spliterator.DISTINCT),false);
+    }
+
+    public static class Traversal implements Iterator<Vertex> {
+        private final Set<Vertex> visited = new HashSet<>();
+        private final Deque<Vertex> pending;
+        private final boolean reverse;
+
+        Traversal(Collection<Vertex> initialVertices, boolean reverse) {
+            this.reverse = reverse;
+            this.pending = new ArrayDeque<>(initialVertices);
+        }
+
+        @Override
+        public boolean hasNext() {
+            return !pending.isEmpty();
+        }
+
+        @Override
+        public Vertex next() {
+            Vertex current = pending.removeFirst();
+            this.visited.add(current);
+
+            Stream<Vertex> next = reverse ? current.incomingVertices() : current.outgoingVertices();
+            next.forEach(v -> {
+                if (!visited.contains(v)) {
+                    this.pending.add(v);
+                }
+            });
+            return current;
+        }
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/GraphDiff.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/GraphDiff.java
new file mode 100644
index 00000000000..05517fb367e
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/GraphDiff.java
@@ -0,0 +1,100 @@
+package org.logstash.config.ir.graph.algorithms;
+
+import org.logstash.config.ir.graph.Edge;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Created by andrewvc on 1/5/17.
+ */
+public class GraphDiff {
+    public static DiffResult diff(Graph left, Graph right) {
+        List<Edge> removedEdges = left.edges().filter(e -> !right.hasEquivalentEdge(e)).collect(Collectors.toList());
+        List<Vertex> removedVertices = left.vertices().filter(v -> !right.hasEquivalentVertex(v)).collect(Collectors.toList());
+        List<Edge> addedEdges = right.edges().filter(e -> !left.hasEquivalentEdge(e)).collect(Collectors.toList());
+        List<Vertex> addedVertices = right.vertices().filter(v -> !left.hasEquivalentVertex(v)).collect(Collectors.toList());
+        return new DiffResult(removedEdges, addedEdges, removedVertices, addedVertices);
+    }
+
+    public static class DiffResult {
+        private final List<Vertex> removedVertices;
+        private final List<Vertex> addedVertices;
+        private final Collection<Edge> removedEdges;
+        private final Collection<Edge> addedEdges;
+
+        public Collection<Edge> getRemovedEdges() {
+            return removedEdges;
+        }
+
+        public Collection<Edge> getAddedEdges() {
+            return addedEdges;
+        }
+
+        public Collection<Vertex> getRemovedVertices() {
+            return removedVertices;
+        }
+
+        public Collection<Vertex> getAddedVertices() {
+            return addedVertices;
+        }
+
+        public DiffResult(Collection<Edge> removedEdges, Collection<Edge> addedEdges, List<Vertex> removedVertices, List<Vertex> addedVertices) {
+            this.removedEdges = removedEdges;
+            this.addedEdges = addedEdges;
+            this.removedVertices = removedVertices;
+            this.addedVertices = addedVertices;
+        }
+
+        public String summary() {
+            String template = "(-%d,+%d Edges | -%d,+%d Vertices)";
+            return String.format(template, removedEdges.size(), addedEdges.size(), removedVertices.size(), addedVertices.size());
+        }
+
+        public boolean hasSameEdges() {
+            return addedEdges.isEmpty() && removedEdges.isEmpty();
+        }
+
+        public boolean hasSameVertices() {
+            return addedVertices.isEmpty() && removedVertices.isEmpty();
+        }
+
+        public boolean isIdentical() {
+            return hasSameEdges() && hasSameVertices();
+        }
+
+        public String toString() {
+            if (isIdentical()) return "Identical Graphs";
+
+            StringBuilder output = new StringBuilder();
+            output.append(this.summary());
+
+            if (!hasSameEdges()) {
+                output.append("\n");
+                output.append(detailedDiffFor("Edges", removedEdges, addedEdges));
+            }
+            if (!hasSameVertices()) {
+                output.append("\n");
+                output.append(detailedDiffFor("Vertices", removedVertices, addedVertices));
+            }
+            output.append("\n");
+
+            return output.toString();
+        }
+
+        private String detailedDiffFor(String name, Collection removed, Collection added) {
+            return (name + " GraphDiff: " + "\n") +
+                    "--------------------------\n" +
+                    Stream.concat(removed.stream().map(c -> "-" + c.toString()),
+                            added.stream().map(c -> "+" + c.toString())).
+                            map(Object::toString).
+                            collect(Collectors.joining("\n")) +
+                    "\n--------------------------";
+        }
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/ShortestPath.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/ShortestPath.java
new file mode 100644
index 00000000000..81694b5391f
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/algorithms/ShortestPath.java
@@ -0,0 +1,88 @@
+package org.logstash.config.ir.graph.algorithms;
+
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.*;
+import java.util.stream.Stream;
+
+/**
+ * Created by andrewvc on 1/5/17.
+ * This class isn't currently used anywhere, I wrote it for some code that is now removed, however, I'm sure it will be
+ * useful shortly, so we should hold onto it for a while.
+ */
+public class ShortestPath {
+    public static List<Vertex> shortestPath(Vertex from, Vertex to) {
+        return shortestPath(from, Collections.singleton(to)).get(to);
+    }
+
+    public static Map<Vertex, List<Vertex>> shortestPath(Vertex from, Collection<Vertex> to) {
+        return shortestPath(from, to, false);
+    }
+
+    // Finds the shortest paths to the specified vertices traversing edges backward using Dijkstra's algorithm.
+    // The items in `to` must be ancestors of this Vertex!
+    public static Map<Vertex, List<Vertex>> shortestReversePath(Vertex from, Collection<Vertex> to) {
+        return shortestPath(from, to, true);
+    }
+
+    // Finds the shortest paths to the specified vertices using Dijkstra's algorithm.
+    // The items in `to` must be ancestors of this Vertex!
+    public static Map<Vertex, List<Vertex>> shortestPath(Vertex from, Collection<Vertex> to, boolean reverseSearch) {
+        Map<Vertex, Integer> vertexDistances = new HashMap<>();
+        Map<Vertex, Vertex> vertexPathPrevious = new HashMap<>();
+
+        List<Vertex> pending = new ArrayList<>();
+        Stream<Vertex> searchSpace = reverseSearch ? from.ancestors() : from.descendants();
+        searchSpace.forEach((vertex) -> {
+            pending.add(vertex);
+            // Max value is an unknown distance
+            // using this is more convenient and concise than null in later code
+            vertexDistances.put(vertex, Integer.MAX_VALUE);
+        });
+
+        pending.add(from);
+        vertexDistances.put(from, 0);
+
+        for (Vertex toVertex : to) {
+            if (!pending.contains(toVertex)) {
+                throw new IllegalArgumentException("Attempted to determine path for vertex that is not in the search space!" + toVertex);
+            }
+        }
+
+        while (!pending.isEmpty()) {
+            Vertex current = pending.stream().min(Comparator.comparing(vertexDistances::get)).get();
+            int currentDistance = vertexDistances.get(current);
+            pending.remove(current);
+
+            Stream<Vertex> toProcess = reverseSearch ? current.incomingVertices() : current.outgoingVertices();
+
+            toProcess.forEach((v) -> {
+                Integer curDistance = vertexDistances.get(v);
+                int altDistance = currentDistance + 1; // Fixed cost per edge of 1
+                if (altDistance < curDistance) {
+                    vertexDistances.put(v, altDistance);
+                    vertexPathPrevious.put(v, current);
+                }
+            });
+        }
+
+        Map<Vertex, List<Vertex>> result = new HashMap<>(to.size());
+
+        for (Vertex toVertex : to) {
+            int toVertexDistance = vertexDistances.get(toVertex);
+
+            List<Vertex> path = new ArrayList<>(toVertexDistance+1);
+            Vertex pathCurrentVertex = toVertex;
+            while (pathCurrentVertex != from) {
+                path.add(pathCurrentVertex);
+                pathCurrentVertex = vertexPathPrevious.get(pathCurrentVertex);
+            }
+            path.add(from);
+            Collections.reverse(path);
+            result.put(toVertex, path);
+        }
+
+        return result;
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedParallelStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedParallelStatement.java
index 7c504a696e3..d054a414d53 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedParallelStatement.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedParallelStatement.java
@@ -24,7 +24,7 @@ public Graph toGraph() throws InvalidIRException {
         Graph g = Graph.empty();
 
         for (Statement s : getStatements()) {
-            g.merge(s.toGraph());
+            g = Graph.combine(g, s.toGraph()).graph;
         }
 
         return g;
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedSequenceStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedSequenceStatement.java
index 6cc55ca02a0..823da140b30 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedSequenceStatement.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedSequenceStatement.java
@@ -25,7 +25,7 @@ public Graph toGraph() throws InvalidIRException {
 
         for (Statement statement : getStatements()) {
             Graph sg = statement.toGraph();
-            g.threadLeavesInto(sg);
+            g = g.chain(sg);
         }
 
         return g;
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedStatement.java
index 3b1ee61822f..b93ca3dd68a 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedStatement.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedStatement.java
@@ -1,12 +1,10 @@
 package org.logstash.config.ir.imperative;
 
 import org.logstash.config.ir.ISourceComponent;
-import org.logstash.config.ir.SourceMetadata;
 import org.logstash.config.ir.InvalidIRException;
-import org.logstash.config.ir.graph.Graph;
-import org.logstash.config.ir.graph.Vertex;
+import org.logstash.config.ir.SourceMetadata;
 
-import java.util.*;
+import java.util.List;
 import java.util.stream.Collectors;
 
 /**
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/IfStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/IfStatement.java
index 31bf6a9a19c..871de9ebace 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/imperative/IfStatement.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/IfStatement.java
@@ -1,12 +1,15 @@
 package org.logstash.config.ir.imperative;
+
 import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.InvalidIRException;
 import org.logstash.config.ir.SourceMetadata;
 import org.logstash.config.ir.expression.BooleanExpression;
-import org.logstash.config.ir.InvalidIRException;
-import org.logstash.config.ir.graph.*;
+import org.logstash.config.ir.graph.BooleanEdge;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.IfVertex;
+import org.logstash.config.ir.graph.Vertex;
 
-import java.util.List;
-import java.util.Optional;
+import java.util.Collection;
 import java.util.stream.Collectors;
 
 /**
@@ -78,22 +81,25 @@ public String toString(int indent) {
 
     @Override
     public Graph toGraph() throws InvalidIRException {
-        Graph graph = new Graph();
-        Vertex ifVertex = new IfVertex(this.getMeta(), this.booleanExpression);
-        graph.addVertex(ifVertex);
-
-        if (!(getTrueStatement() instanceof NoopStatement)) {
-            Statement ts = this.getTrueStatement();
-            Graph tsg = ts.toGraph();
-            graph.threadToGraph(BooleanEdge.trueFactory, ifVertex, tsg);
+        Graph trueGraph = getTrueStatement().toGraph();
+        Graph falseGraph = getFalseStatement().toGraph();
+
+        Graph.GraphCombinationResult combination = Graph.combine(trueGraph, falseGraph);
+        Graph newGraph = combination.graph;
+        Collection<Vertex> trueRoots = trueGraph.roots().map(combination.oldToNewVertices::get).collect(Collectors.toList());
+        Collection<Vertex> falseRoots = falseGraph.roots().map(combination.oldToNewVertices::get).collect(Collectors.toList());
+
+        IfVertex ifVertex = new IfVertex(this.getMeta(), this.booleanExpression);
+        newGraph.addVertex(ifVertex);
+
+        for (Vertex v : trueRoots) {
+            newGraph.threadVertices(BooleanEdge.trueFactory, ifVertex, v);
         }
 
-        if (!(getFalseStatement() instanceof NoopStatement)) {
-            Statement fs = this.getFalseStatement();
-            Graph fsg = fs.toGraph();
-            graph.threadToGraph(BooleanEdge.falseFactory, ifVertex, fsg);
+        for (Vertex v : falseRoots) {
+            newGraph.threadVertices(BooleanEdge.falseFactory, ifVertex, v);
         }
 
-        return graph;
+        return newGraph;
     }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/PluginStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/PluginStatement.java
index 36183438983..b31ca4d3c2f 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/imperative/PluginStatement.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/PluginStatement.java
@@ -8,8 +8,6 @@
 import org.logstash.config.ir.graph.PluginVertex;
 import org.logstash.config.ir.graph.Vertex;
 
-import java.util.Map;
-
 /**
  * Created by andrewvc on 9/6/16.
  */
@@ -40,6 +38,8 @@ public String toString(int indent) {
     @Override
     public Graph toGraph() throws InvalidIRException {
         Vertex pluginVertex = new PluginVertex(getMeta(), pluginDefinition);
-        return Graph.empty().addVertex(pluginVertex);
+        Graph g = Graph.empty();
+        g.addVertex(pluginVertex);
+        return g;
     }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/Statement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/Statement.java
index 1051ff77acb..3a791969336 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/imperative/Statement.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/Statement.java
@@ -3,11 +3,7 @@
 import org.logstash.config.ir.InvalidIRException;
 import org.logstash.config.ir.SourceComponent;
 import org.logstash.config.ir.SourceMetadata;
-import org.logstash.config.ir.graph.Edge;
 import org.logstash.config.ir.graph.Graph;
-import org.logstash.config.ir.graph.Vertex;
-
-import java.util.Collection;
 
 /**
  * Created by andrewvc on 9/6/16.
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java b/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java
index 64c673614b6..1379fee5694 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java
@@ -1,6 +1,5 @@
 package org.logstash.config.ir;
 
-import org.apache.logging.log4j.core.config.plugins.Plugin;
 import org.hamcrest.MatcherAssert;
 import org.logstash.config.ir.expression.BooleanExpression;
 import org.logstash.config.ir.expression.ValueExpression;
@@ -8,8 +7,14 @@
 import org.logstash.config.ir.graph.Edge;
 import org.logstash.config.ir.graph.Graph;
 import org.logstash.config.ir.graph.Vertex;
+import org.logstash.config.ir.graph.algorithms.GraphDiff;
 
 import java.util.HashMap;
+import java.util.Objects;
+import java.util.UUID;
+
+import static org.logstash.config.ir.DSL.*;
+import static org.logstash.config.ir.PluginDefinition.Type.*;
 
 /**
  * Created by andrewvc on 9/19/16.
@@ -21,27 +26,79 @@ public static void assertSyntaxEquals(ISourceComponent left, ISourceComponent ri
     }
 
     public static void assertGraphEquals(Graph left, Graph right) {
-        String message = String.format("Expected \n'%s'\n to equal \n'%s'\n%s", left, right, left.diff(right));
+        String message = String.format("Expected \n'%s'\n to equal \n'%s'\n%s", left, right, GraphDiff.diff(left, right));
         MatcherAssert.assertThat(message, left.sourceComponentEquals(right));
     }
 
     public static Vertex testVertex() {
-        return new Vertex() {
-            @Override
-            public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
-                return this.equals(sourceComponent);
+        return testVertex(UUID.randomUUID().toString());
+    }
+
+    public static Vertex testVertex(String id) {
+        return new TestVertex(id);
+    }
+
+    static class TestVertex extends Vertex {
+        private String id;
+
+        public TestVertex(String id) {
+            this.id = id;
+        }
+
+        @Override
+        public Vertex copy() {
+            return new TestVertex(id);
+        }
+
+        @Override
+        public String individualHashSource() {
+            return "TVertex" + "|" + id;
+        }
+
+        @Override
+        public String getId() {
+            return this.id;
+        }
+
+        public String toString() {
+            return "TestVertex-" + id;
+        }
+
+        @Override
+        public boolean sourceComponentEquals(ISourceComponent other) {
+            if (other == null) return false;
+            if (other instanceof TestVertex) {
+                return Objects.equals(getId(), ((TestVertex) other).getId());
             }
-        };
+            return false;
+        }
     }
 
     public static Edge testEdge() throws InvalidIRException {
         Vertex v1 = testVertex();
         Vertex v2 = testVertex();
-        return new Edge(v1, v2) {};
+        return new TestEdge(v1,v2);
+
     }
 
     public static Edge testEdge(Vertex from, Vertex to) throws InvalidIRException {
-        return new Edge(from, to) {};
+        return new TestEdge(from, to);
+    }
+
+    public static final class TestEdge extends Edge {
+        TestEdge(Vertex from, Vertex to) throws InvalidIRException {
+            super(from, to);
+        }
+
+        @Override
+        public Edge copy(Vertex from, Vertex to) throws InvalidIRException {
+            return new TestEdge(from, to);
+        }
+
+        @Override
+        public String individualHashSource() {
+            return "TEdge";
+        }
     }
 
     public static BooleanExpression testExpression() throws InvalidIRException {
@@ -55,4 +112,18 @@ public static SourceMetadata testMetadata() {
     public static PluginDefinition testPluginDefinition() {
         return new PluginDefinition(PluginDefinition.Type.FILTER, "testDefinition", new HashMap<String, Object>());
     }
+
+    public static Pipeline samplePipeline() throws InvalidIRException {
+        Graph inputSection = iComposeParallel(iPlugin(INPUT, "generator"), iPlugin(INPUT, "stdin")).toGraph();
+        Graph filterSection = iIf(eEq(eEventValue("[foo]"), eEventValue("[bar]")),
+                                    iPlugin(FILTER, "grok"),
+                                    iPlugin(FILTER, "kv")).toGraph();
+        Graph outputSection = iIf(eGt(eEventValue("[baz]"), eValue(1000)),
+                                    iComposeParallel(
+                                            iPlugin(OUTPUT, "s3"),
+                                            iPlugin(OUTPUT, "elasticsearch")),
+                                    iPlugin(OUTPUT, "stdout")).toGraph();
+
+        return new Pipeline(inputSection, filterSection, outputSection);
+    }
 }
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/EdgeTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/EdgeTest.java
index e156ff8fa55..80ae13fdde8 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/graph/EdgeTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/EdgeTest.java
@@ -6,6 +6,7 @@
 
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Optional;
 
 import static org.junit.Assert.*;
 import static org.hamcrest.CoreMatchers.*;
@@ -23,38 +24,4 @@ public void testBasicEdge() throws InvalidIRException {
         assertThat("From is edge", e.getFrom(), notNullValue());
         assertThat("To is edge", e.getTo(), notNullValue());
     }
-
-    @Test
-    public void testThreading() throws InvalidIRException {
-        Vertex v1 = testVertex();
-        Vertex v2 = testVertex();
-        Edge e = Edge.threadVertices(v1, v2);
-        assertThat(v1.getOutgoingEdges().stream().findFirst().get(), is(e));
-        assertThat(v2.getIncomingEdges().stream().findFirst().get(), is(e));
-        assertThat(e, instanceOf(PlainEdge.class));
-    }
-
-    @Test
-    public void testThreadingMulti() throws InvalidIRException {
-        Vertex v1 = testVertex();
-        Vertex v2 = testVertex();
-        Vertex v3 = testVertex();
-        Collection<Edge> multiEdges = Edge.threadVertices(v1, v2, v3);
-
-        assertThat(multiEdges.size(), is(2));
-        assertThat(v1.getOutgoingVertices(), is(Collections.singletonList(v2)));
-        assertThat(v2.getIncomingVertices(), is(Collections.singletonList(v1)));
-        assertThat(v2.getOutgoingVertices(), is(Collections.singletonList(v3)));
-        assertThat(v3.getIncomingVertices(), is(Collections.singletonList(v2)));
-    }
-
-    @Test
-    public void testThreadingTyped() throws InvalidIRException {
-        Vertex if1 = new IfVertex(null, testExpression());
-        Vertex condT = testVertex();
-        Edge tEdge = Edge.threadVertices(BooleanEdge.trueFactory, if1, condT);
-        assertThat(tEdge, instanceOf(BooleanEdge.class));
-        BooleanEdge tBooleanEdge = (BooleanEdge) tEdge;
-        assertThat(tBooleanEdge.getEdgeType(), is(true));
-    }
 }
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/GraphTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/GraphTest.java
index f8c642d2f8d..238f09c56f0 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/graph/GraphTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/GraphTest.java
@@ -1,16 +1,20 @@
 package org.logstash.config.ir.graph;
 
 import org.junit.Test;
-import org.logstash.config.ir.ISourceComponent;
+import org.logstash.config.ir.IRHelpers;
 import org.logstash.config.ir.InvalidIRException;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
-import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.*;
+import static org.logstash.config.ir.IRHelpers.testExpression;
+import static org.logstash.config.ir.IRHelpers.testVertex;
 
 /**
  * Created by andrewvc on 11/18/16.
@@ -40,70 +44,111 @@ public void testGraphCycleDetection() throws InvalidIRException {
     }
 
     @Test
-    public void extendingLeavesIntoRoots() throws InvalidIRException {
-        Vertex fromV1 = testVertex();
-        Vertex fromV2 = testVertex();
-        Graph fromGraph = Graph.empty().threadVertices(fromV1, fromV2);
-
-        Vertex toV1 = testVertex();
-        Vertex toV2 = testVertex();
-        Graph toGraph = Graph.empty().threadVertices(toV1, toV2);
-
-        fromGraph.threadLeavesInto(toGraph);
-        assertEquals(fromGraph.getEdges().size(), 3);
-        assertVerticesConnected(fromV2, toV1);
-        assertEquals(fromV2.getOutgoingEdges(), toV1.getIncomingEdges());
+    public void chaining() throws InvalidIRException {
+        Graph fromGraph = Graph.empty();
+        fromGraph.threadVertices(testVertex("fromV1"), testVertex("fromV2"));
+
+        Graph toGraph = Graph.empty();
+        toGraph.threadVertices(testVertex("toV1"), testVertex("toV2"));
+
+        Graph result = fromGraph.chain(toGraph);
+        assertEquals(3, result.getEdges().size());
+        assertVerticesConnected(result, "fromV2", "toV1");
     }
 
     @Test
-    public void extendingLeavesIntoRootsMultiRoot() throws InvalidIRException {
-        Vertex fromV1 = testVertex("fromV1");
-        Vertex fromV2 = testVertex("fromV2");
-        Graph fromGraph = Graph.empty().threadVertices(fromV1, fromV2);
-
-        Vertex toV1 = testVertex("toV1");
-        Vertex toV2 = testVertex("toV2");
-        Vertex toV3 = testVertex("toV3");
-        Graph toGraph = Graph.empty().threadVertices(toV1, toV2).addVertex(toV3);
-
-        fromGraph.threadLeavesInto(toGraph);
-        assertEquals(fromGraph.getEdges().size(), 4);
-        assertVerticesConnected(fromV2, toV1);
-        assertVerticesConnected(fromV2, toV3);
+    public void chainingIntoMultipleRoots() throws InvalidIRException {
+        Graph fromGraph = Graph.empty();
+        fromGraph.threadVertices(testVertex("fromV1"), testVertex("fromV2"));
+
+        Graph toGraph = Graph.empty();
+        toGraph.threadVertices(testVertex("toV1"), testVertex("toV2"));
+        toGraph.addVertex(testVertex("toV3"));
+
+        Graph result = fromGraph.chain(toGraph);
+        assertEquals(4, result.getEdges().size());
+        assertVerticesConnected(result, "fromV2", "toV1");
+        assertVerticesConnected(result, "fromV2", "toV3");
     }
 
     @Test
-    public void testWalk() throws InvalidIRException {
-        Graph g = Graph.empty().
-                threadVertices(testVertex(), testVertex(), testVertex());
-        final AtomicInteger visitCount = new AtomicInteger();
-        final List<Vertex> visited = new ArrayList<>();
-        g.walkEdges(v -> {
-            visitCount.incrementAndGet();
-        });
-        assertEquals("It should visit each node once", visitCount.get(), 2);
+    public void SimpleConsistencyTest() throws InvalidIRException {
+        Graph g1 = Graph.empty();
+        g1.addVertex(testVertex("a"));
+        Graph g2 = Graph.empty();
+        g2.addVertex(testVertex("a"));
+
+        assertEquals(g1.uniqueHash(), g2.uniqueHash());
     }
 
-    public void assertVerticesConnected(Vertex from, Vertex to) {
-        assertTrue(from.getOutgoingVertices().contains(to));
-        assertTrue(to.getIncomingVertices().contains(from));
+    @Test
+    public void ComplexConsistencyTest() throws InvalidIRException {
+        Graph g1 = IRHelpers.samplePipeline().getGraph();
+        Graph g2 = IRHelpers.samplePipeline().getGraph();
+
+        assertEquals(g1.hashSource(), g2.hashSource());
+    }
+
+    @Test
+    public void testThreading() throws InvalidIRException {
+        Graph graph = Graph.empty();
+        Vertex v1 = testVertex();
+        Vertex v2 = testVertex();
+        graph.threadVertices(v1, v2);
+        assertVerticesConnected(v1, v2);
+        Edge v1Edge = v1.outgoingEdges().findFirst().get();
+        Edge v2Edge = v2.incomingEdges().findFirst().get();
+        assertThat(v1Edge, is(v2Edge));
+        assertThat(v1Edge, instanceOf(PlainEdge.class));
+    }
+
+    @Test
+    public void testThreadingMulti() throws InvalidIRException {
+        Graph graph = Graph.empty();
+        Vertex v1 = testVertex();
+        Vertex v2 = testVertex();
+        Vertex v3 = testVertex();
+        Collection<Edge> multiEdges = graph.threadVertices(v1, v2, v3);
+
+        assertThat(v1.getOutgoingVertices(), is(Collections.singletonList(v2)));
+        assertThat(v2.getIncomingVertices(), is(Collections.singletonList(v1)));
+        assertThat(v2.getOutgoingVertices(), is(Collections.singletonList(v3)));
+        assertThat(v3.getIncomingVertices(), is(Collections.singletonList(v2)));
+    }
+
+    @Test
+    public void testThreadingTyped() throws InvalidIRException {
+        Graph graph = Graph.empty();
+        Vertex if1 = new IfVertex(null, testExpression());
+        Vertex condT = testVertex();
+        Edge tEdge = graph.threadVertices(BooleanEdge.trueFactory, if1, condT).stream().findFirst().get();
+        assertThat(tEdge, instanceOf(BooleanEdge.class));
+        BooleanEdge tBooleanEdge = (BooleanEdge) tEdge;
+        assertThat(tBooleanEdge.getEdgeType(), is(true));
+    }
+
+    @Test
+    public void copyTest() throws InvalidIRException {
+        Graph left = Graph.empty();
+        left.addVertex(testVertex("t1"));
+        Graph right = left.copy();
+
+        Vertex lv = left.getVertexById("t1");
+        Vertex rv = right.getVertexById("t1");
+        assertTrue(lv.sourceComponentEquals(rv));
+        assertTrue(rv.sourceComponentEquals(lv));
     }
 
-    public Vertex testVertex() {
-        return testVertex(UUID.randomUUID().toString());
+    private void assertVerticesConnected(Graph graph, String fromId, String toId) {
+        Vertex from = graph.getVertexById(fromId);
+        assertNotNull(from);
+        Vertex to = graph.getVertexById(toId);
+        assertNotNull(to);
+        assertVerticesConnected(from, to);
     }
 
-    public Vertex testVertex(String name) {
-        return new Vertex() {
-            public String toString() {
-                return "TestVertex-" + name;
-            }
-
-            @Override
-            public boolean sourceComponentEquals(ISourceComponent sourceComponent) {
-                // For testing purposes only object identity counts
-                return this == sourceComponent;
-            }
-        };
+    public void assertVerticesConnected(Vertex from, Vertex to) {
+        assertTrue("No connection: " + from + " -> " + to, from.getOutgoingVertices().contains(to));
+        assertTrue("No reverse connection: " + from + " -> " + to, to.getIncomingVertices().contains(from));
     }
 }
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/IfVertexTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/IfVertexTest.java
index b3361583336..12002379462 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/graph/IfVertexTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/IfVertexTest.java
@@ -20,22 +20,25 @@ public void testIfVertexCreation() throws InvalidIRException {
 
     @Test(expected = Vertex.InvalidEdgeTypeException.class)
     public void testDoesNotAcceptNonBooleanEdges() throws InvalidIRException {
+        Graph graph = Graph.empty();
         IfVertex ifV = testIfVertex();
         Vertex otherV = testVertex();
-
-        Edge.threadVertices(PlainEdge.factory, ifV, otherV);
+        graph.threadVertices(PlainEdge.factory, ifV, otherV);
     }
 
     @Test
     public void testEdgeTypeHandling() throws InvalidIRException {
+        Graph graph = Graph.empty();
         IfVertex ifV = testIfVertex();
+        graph.addVertex(ifV);
         Vertex trueV = testVertex();
+        graph.addVertex(trueV);
 
         assertThat(ifV.hasEdgeType(true), is(false));
         assertThat(ifV.hasEdgeType(false), is(false));
         assertThat(ifV.getUnusedOutgoingEdgeFactories().size(), is(2));
 
-        Edge.threadVertices(BooleanEdge.trueFactory, ifV, trueV);
+        graph.threadVertices(BooleanEdge.trueFactory, ifV, trueV);
 
         assertThat(ifV.hasEdgeType(true), is(true));
         assertThat(ifV.hasEdgeType(false), is(false));
@@ -46,7 +49,7 @@ public void testEdgeTypeHandling() throws InvalidIRException {
         );
 
         Vertex falseV = testVertex();
-        Edge.threadVertices(BooleanEdge.falseFactory, ifV, falseV);
+        graph.threadVertices(BooleanEdge.falseFactory, ifV, falseV);
 
         assertThat(ifV.hasEdgeType(false), is(true));
         assertThat(ifV.getUnusedOutgoingEdgeFactories().isEmpty(), is(true));
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/PlainEdgeTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/PlainEdgeTest.java
index 0ed396f5654..a300904e145 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/graph/PlainEdgeTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/PlainEdgeTest.java
@@ -16,12 +16,12 @@
 public class PlainEdgeTest {
     @Test
     public void creationDoesNotRaiseException() throws InvalidIRException {
-        PlainEdge e = new PlainEdge(testVertex(), testVertex());
+        new PlainEdge(testVertex(), testVertex());
     }
 
     @Test
-    public void testFactoryCreationDoesNotRaiseException(Boolean edgeType) throws InvalidIRException {
+    public void testFactoryCreationDoesNotRaiseException() throws InvalidIRException {
         PlainEdge.PlainEdgeFactory factory = new PlainEdge.PlainEdgeFactory();
-        PlainEdge e = factory.make(testVertex(), testVertex());
+        factory.make(testVertex(), testVertex());
     }
 }
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/PluginVertexTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/PluginVertexTest.java
index e46c5308a9e..b11b35a8c35 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/graph/PluginVertexTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/PluginVertexTest.java
@@ -1,6 +1,7 @@
 package org.logstash.config.ir.graph;
 
 import org.junit.Test;
+import org.logstash.config.ir.InvalidIRException;
 import org.logstash.config.ir.PluginDefinition;
 
 import java.util.HashMap;
@@ -15,11 +16,12 @@
  */
 public class PluginVertexTest {
     @Test
-    public void testConstructionIdHandlingWhenNoExplicitId() {
+    public void testConstructionIdHandlingWhenNoExplicitId() throws InvalidIRException {
         PluginDefinition pluginDefinition = testPluginDefinition();
         PluginVertex pluginVertex = new PluginVertex(testMetadata(), pluginDefinition);
+        Graph graph = Graph.empty();
+        graph.addVertex(pluginVertex);
         assertThat(pluginVertex.getId(), notNullValue());
-        assertThat(pluginVertex.getId(), is(pluginVertex.getPluginDefinition().getArguments().get("id")));
     }
 
     @Test
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/VertexTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/VertexTest.java
index 41226dc6db5..29cad606cf2 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/graph/VertexTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/VertexTest.java
@@ -12,9 +12,10 @@
 public class VertexTest {
     @Test
     public void TestVertexBasics() throws InvalidIRException {
+        Graph graph = Graph.empty();
         Vertex v1 = testVertex();
         Vertex v2 = testVertex();
-        Edge e = Edge.threadVertices(v1, v2);
+        graph.threadVertices(v1, v2);
 
         assertTrue("v1 has v2 as an outgoing vertex", v1.outgoingVertices().anyMatch(v2::equals));
         assertTrue("v2 has v1 as an incoming vertex", v2.incomingVertices().anyMatch(v1::equals));
@@ -22,14 +23,17 @@ public void TestVertexBasics() throws InvalidIRException {
 
     @Test
     public void testIsLeafAndRoot() throws InvalidIRException {
+        Graph graph = Graph.empty();
+
         Vertex v = testVertex();
+        graph.addVertex(v);
 
         // Nodes should be leaves and roots if they are isolated
         assertTrue(v.isLeaf());
         assertTrue(v.isRoot());
 
         Vertex otherV = testVertex();
-        Edge e = Edge.threadVertices(v, otherV);
+        graph.threadVertices(v, otherV);
 
         assertFalse(v.isLeaf());
         assertTrue(v.isRoot());
@@ -38,8 +42,10 @@ public void testIsLeafAndRoot() throws InvalidIRException {
     }
 
     @Test
-    public void testPartialLeafOnUnconnectedVertex() {
+    public void testPartialLeafOnUnconnectedVertex() throws InvalidIRException {
+        Graph g = Graph.empty();
         Vertex v = testVertex();
+        g.addVertex(v);
         assertEquals(v.getUnusedOutgoingEdgeFactories().size(), 1);
         assertTrue(v.isPartialLeaf());
     }
@@ -48,7 +54,8 @@ public void testPartialLeafOnUnconnectedVertex() {
     public void testPartialLeafOnConnectedVertex() throws InvalidIRException {
         Vertex v = testVertex();
         Vertex otherV = testVertex();
-        Edge e = Edge.threadVertices(v, otherV);
+        Graph graph = Graph.empty();
+        graph.threadVertices(v, otherV);
 
         assertEquals(v.getUnusedOutgoingEdgeFactories().size(), 0);
         assertFalse(v.isPartialLeaf());
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/BreadthFirstTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/BreadthFirstTest.java
new file mode 100644
index 00000000000..b1a56eb21b9
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/BreadthFirstTest.java
@@ -0,0 +1,35 @@
+package org.logstash.config.ir.graph.algorithms;
+
+import org.junit.Test;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static junit.framework.TestCase.assertEquals;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.logstash.config.ir.IRHelpers.testVertex;
+
+/**
+ * Created by andrewvc on 1/5/17.
+ */
+public class BreadthFirstTest {
+    @Test
+    public void testBFSBasic() throws InvalidIRException {
+        Graph g = Graph.empty();
+        g.threadVertices(testVertex(), testVertex(), testVertex());
+
+        // We don't *really* need threadsafety for the count,
+        // but since we're using a lambda we need something that's final
+        final AtomicInteger visitCount = new AtomicInteger();
+        BreadthFirst.BfsResult res = BreadthFirst.breadthFirst(g.getRoots(), false, (v -> visitCount.incrementAndGet()));
+
+        assertEquals("It should visit each node once", visitCount.get(), 3);
+        assertThat(res.getVertices(), is(g.getVertices()));
+    }
+
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/DepthFirstTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/DepthFirstTest.java
new file mode 100644
index 00000000000..fe1c15f495c
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/DepthFirstTest.java
@@ -0,0 +1,28 @@
+package org.logstash.config.ir.graph.algorithms;
+
+import org.junit.Test;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static junit.framework.TestCase.assertEquals;
+import static org.logstash.config.ir.IRHelpers.testVertex;
+
+/**
+ * Created by andrewvc on 1/5/17.
+ */
+public class DepthFirstTest {
+    @Test
+    public void testDFSBasic() throws InvalidIRException {
+        Graph g = Graph.empty();
+        g.threadVertices(testVertex(), testVertex(), testVertex());
+        final AtomicInteger visitCount = new AtomicInteger();
+        final List<Vertex> visited = new ArrayList<>();
+        DepthFirst.depthFirst(g).forEach(v -> visitCount.incrementAndGet());
+        assertEquals("It should visit each node once", visitCount.get(), 3);
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/GraphDiffTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/GraphDiffTest.java
new file mode 100644
index 00000000000..3659b3a592b
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/GraphDiffTest.java
@@ -0,0 +1,68 @@
+package org.logstash.config.ir.graph.algorithms;
+
+import org.junit.Test;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.graph.Edge;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.Collections;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.logstash.config.ir.IRHelpers.testVertex;
+
+/**
+ * Created by andrewvc on 1/5/17.
+ */
+public class GraphDiffTest {
+    @Test
+    public void testIdenticalGraphs() throws InvalidIRException {
+        Graph left = simpleGraph();
+        Graph right = simpleGraph();
+        GraphDiff.DiffResult result = GraphDiff.diff(left, right);
+
+        assertTrue(result.isIdentical());
+
+        assertTrue(result.getAddedEdges().isEmpty());
+        assertTrue(result.getRemovedEdges().isEmpty());
+        assertTrue(result.getAddedVertices().isEmpty());
+        assertTrue(result.getRemovedVertices().isEmpty());
+    }
+
+    @Test
+    public void testDifferentSimpleGraphs() throws InvalidIRException {
+        Graph left = simpleGraph();
+
+        Graph right = left.copy();
+        Vertex new1 = testVertex("new1");
+        right.addVertex(new1);
+        right.threadVerticesById("t3", "new1");
+
+        GraphDiff.DiffResult result = GraphDiff.diff(left, right);
+
+        assertFalse(result.isIdentical());
+
+        assertThat(result.getAddedVertices().size(), is(1));
+        assertThat(result.getAddedVertices().stream().findAny().get().getId(), is("new1"));
+
+        assertThat(result.getAddedEdges().size(), is(1));
+        Edge expectedEdge = new1.incomingEdges().findAny().get();
+        assertTrue(result.getAddedEdges().stream().findAny().get().sourceComponentEquals(expectedEdge));
+
+        assertTrue(result.getRemovedVertices().isEmpty());
+        assertTrue(result.getRemovedEdges().isEmpty());
+    }
+
+    public Graph simpleGraph() throws InvalidIRException {
+        Graph graph = Graph.empty();
+        graph.addVertex(testVertex("t1"));
+        graph.addVertex(testVertex("t2"));
+        graph.addVertex(testVertex("t3"));
+        graph.threadVerticesById("t1", "t2", "t3");
+        graph.threadVerticesById("t1", "t3");
+        return graph;
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/ShortestPathTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/ShortestPathTest.java
new file mode 100644
index 00000000000..686e15cb435
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/algorithms/ShortestPathTest.java
@@ -0,0 +1,38 @@
+package org.logstash.config.ir.graph.algorithms;
+
+import org.junit.Test;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.logstash.config.ir.IRHelpers.testVertex;
+
+/**
+ * Created by andrewvc on 1/5/17.
+ */
+public class ShortestPathTest {
+    @Test
+    public void testShortestPathBasic() throws InvalidIRException {
+        Graph g = Graph.empty();
+        Vertex v1 = testVertex("v1");
+        g.addVertex(v1);
+        Vertex v2 = testVertex("v2");
+        g.addVertex(v2);
+        Vertex v3 = testVertex("v3");
+        g.addVertex(v3);
+        Vertex v4 = testVertex("v4");
+        g.addVertex(v4);
+
+        g.threadVertices(v1, v2, v3, v4);
+        g.threadVertices(v2, v4);
+
+        List<Vertex> path = ShortestPath.shortestPath(v1, v4);
+        List<Vertex> expected = Arrays.asList(v1,v2,v4);
+        assertThat(path, is(expected));
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/imperative/ImperativeToGraphtest.java b/logstash-core/src/test/java/org/logstash/config/ir/imperative/ImperativeToGraphtest.java
index bdf58e61e34..e3ad7d7b5a8 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/imperative/ImperativeToGraphtest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/imperative/ImperativeToGraphtest.java
@@ -2,6 +2,7 @@
 
 import org.junit.Test;
 import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.Pipeline;
 import org.logstash.config.ir.graph.Graph;
 import org.logstash.config.ir.graph.IfVertex;
 import org.logstash.config.ir.graph.PluginVertex;
@@ -17,18 +18,20 @@ public class ImperativeToGraphtest {
 
     @Test
     public void convertSimpleExpression() throws InvalidIRException {
-        Graph g =  iComposeSequence(iPlugin(FILTER, "json"), iPlugin(FILTER, "stuff")).toGraph();
-        Graph expected = graph().threadVertices(gPlugin(FILTER, "json"), gPlugin(FILTER, "stuff"));
+        Graph imperative =  iComposeSequence(iPlugin(FILTER, "json"), iPlugin(FILTER, "stuff")).toGraph();
+        Graph regular = Graph.empty();
+        regular.threadVertices(gPlugin(FILTER, "json"), gPlugin(FILTER, "stuff"));
 
-        assertGraphEquals(g, expected);
+        assertGraphEquals(imperative, regular);
     }
 
     @Test
     public void testIdsDontAffectSourceComponentEquality() throws InvalidIRException {
-        Graph g =  iComposeSequence(iPlugin(FILTER, "json", "oneid"), iPlugin(FILTER, "stuff", "anotherid")).toGraph();
-        Graph expected = graph().threadVertices(gPlugin(FILTER, "json", "someotherid"), gPlugin(FILTER, "stuff", "graphid"));
+        Graph imperative =  iComposeSequence(iPlugin(FILTER, "json", "oneid"), iPlugin(FILTER, "stuff", "anotherid")).toGraph();
+        Graph regular = Graph.empty();
+        regular.threadVertices(gPlugin(FILTER, "json", "someotherid"), gPlugin(FILTER, "stuff", "graphid"));
 
-        assertGraphEquals(g, expected);
+        assertGraphEquals(imperative, regular);
     }
 
     @Test
@@ -49,13 +52,57 @@ public void convertComplexExpression() throws InvalidIRException {
         PluginVertex p5 = gPlugin(FILTER, "p5");
         IfVertex testIf = gIf(eAnd(eTruthy(eValue(5l)), eTruthy(eValue(null))));
 
-        Graph expected = graph().threadVertices(p1,p2,testIf)
-            .threadVertices(true, testIf, p3)
-            .threadVertices(false, testIf, p4)
-            .threadVertices(p4, p5);
+        Graph expected = Graph.empty();
+        expected.threadVertices(p1,p2,testIf);
+        expected.threadVertices(true, testIf, p3);
+        expected.threadVertices(false, testIf, p4);
+        expected.threadVertices(p4, p5);
 
-        //PluginVertex p6 = gPlugin(FILTER, "p6");
-        //expected.threadVertices(p5,p6);
+        assertGraphEquals(expected, generated);
+    }
+
+    // This test has an imperative grammar with nested ifs and dangling
+    // partial leaves. This makes sure they all wire-up right
+    @Test
+    public void deepDanglingPartialLeaves() throws InvalidIRException {
+         Graph generated = iComposeSequence(
+                 iPlugin(FILTER, "p0"),
+                 iIf(eTruthy(eValue(1)),
+                         iPlugin(FILTER, "p1"),
+                         iIf(eTruthy(eValue(3)),
+                             iPlugin(FILTER, "p5"))
+                 ),
+                 iIf(eTruthy(eValue(2)),
+                         iPlugin(FILTER, "p3"),
+                         iPlugin(FILTER, "p4")
+                 ),
+                 iPlugin(FILTER, "pLast")
+
+         ).toGraph();
+
+        IfVertex if1 = gIf(eTruthy(eValue(1)));
+        IfVertex if2 = gIf(eTruthy(eValue(2)));
+        IfVertex if3 = gIf(eTruthy(eValue(3)));
+        PluginVertex p0 = gPlugin(FILTER, "p0");
+        PluginVertex p1 = gPlugin(FILTER, "p1");
+        PluginVertex p2 = gPlugin(FILTER, "p2");
+        PluginVertex p3 = gPlugin(FILTER, "p3");
+        PluginVertex p4 = gPlugin(FILTER, "p4");
+        PluginVertex p5 = gPlugin(FILTER, "p5");
+        PluginVertex pLast = gPlugin(FILTER, "pLast");
+
+        Graph expected = Graph.empty();
+        expected.threadVertices(p0, if1);
+        expected.threadVertices(true, if1, p1);
+        expected.threadVertices(false, if1, if3);
+        expected.threadVertices(true, if3, p5);
+        expected.threadVertices(false, if3, if2);
+        expected.threadVertices(p5, if2);
+        expected.threadVertices(p1, if2);
+        expected.threadVertices(true, if2, p3);
+        expected.threadVertices(false, if2, p4);
+        expected.threadVertices(p3, pLast);
+        expected.threadVertices(p4,pLast);
 
         assertGraphEquals(generated, expected);
     }
@@ -92,20 +139,20 @@ public void convertComplexExpressionWithTerminal() throws InvalidIRException {
         IfVertex if3 = gIf(eTruthy(eValue(3)));
         IfVertex if4 = gIf(eTruthy(eValue(4)));
 
-        Graph expected = graph()
-                .threadVertices(p1, if1)
-                .threadVertices(true, if1, if2)
-                .threadVertices(false, if1, if4)
-                .threadVertices(true, if2, if3)
-                .threadVertices(false, if2, p2)
-                .threadVertices(p2, if3)
-                .threadVertices(true, if3, p3)
-                .threadVertices(false, if3, terminal)
-                .threadVertices(p3, terminal)
-                .threadVertices(true, if4, p4)
-                .threadVertices(false, if4, p5)
-                .threadVertices(p4, p5)
-                .threadVertices(p5, terminal);
+        Graph expected = Graph.empty();
+        expected.threadVertices(p1, if1);
+        expected.threadVertices(true, if1, if2);
+        expected.threadVertices(false, if1, if4);
+        expected.threadVertices(true, if2, if3);
+        expected.threadVertices(false, if2, p2);
+        expected.threadVertices(p2, if3);
+        expected.threadVertices(true, if3, p3);
+        expected.threadVertices(false, if3, terminal);
+        expected.threadVertices(p3, terminal);
+        expected.threadVertices(true, if4, p4);
+        expected.threadVertices(false, if4, p5);
+        expected.threadVertices(p4, p5);
+        expected.threadVertices(p5, terminal);
 
         assertGraphEquals(generated, expected);
 
