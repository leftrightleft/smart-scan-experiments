diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index ca78035ef05..7a3265ee94c 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradlew b/gradlew
index 27309d92314..cccdd3d517f 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -33,11 +33,11 @@ DEFAULT_JVM_OPTS=""
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
index f6d5974e72f..e95643d6a2c 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -49,7 +49,6 @@ goto fail
 @rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/logstash-core/src/main/java/org/logstash/common/parser/DeprecatedField.java b/logstash-core/src/main/java/org/logstash/common/parser/DeprecatedField.java
new file mode 100644
index 00000000000..b663d1f169d
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/common/parser/DeprecatedField.java
@@ -0,0 +1,24 @@
+package org.logstash.common.parser;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.function.Function;
+
+public class DeprecatedField<Value> extends FieldDefinition<Value> {
+    private static final Logger logger = LogManager.getLogger();
+    private final String details;
+
+    DeprecatedField(String name, Function<Object, Value> transform, String details) {
+        super(name, transform);
+        this.details = details;
+    }
+
+    @Override
+    public Value apply(Object object) {
+        if (object != null) {
+            logger.warn("The field '" + getName() + "' is deprecated and will be removed soon: " + details);
+        }
+        return super.apply(object);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/common/parser/Field.java b/logstash-core/src/main/java/org/logstash/common/parser/Field.java
new file mode 100644
index 00000000000..87ddc1993be
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/common/parser/Field.java
@@ -0,0 +1,56 @@
+package org.logstash.common.parser;
+
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+
+public interface Field<Value> extends Function<Object, Value> {
+    static <V> Field<V> declareObject(String name, ObjectFactory<V> parser) {
+        return declareField(name, (config) -> parser.apply(ObjectTransforms.transformMap(config)));
+    }
+
+    String getName();
+
+    String getDetails();
+
+    static Field<String> declareString(String name) {
+        return declareField(name, ObjectTransforms::transformString);
+    }
+
+    static Field<Float> declareFloat(String name) {
+        return declareField(name, ObjectTransforms::transformFloat);
+    }
+
+    static Field<Long> declareLong(String name) {
+        return declareField(name, ObjectTransforms::transformLong);
+    }
+
+    static Field<Double> declareDouble(String name) {
+        return declareField(name, ObjectTransforms::transformDouble);
+    }
+
+    static Field<Boolean> declareBoolean(String name) {
+        return declareField(name, ObjectTransforms::transformBoolean);
+    }
+
+    static Field<Integer> declareInteger(String name) {
+        return declareField(name, ObjectTransforms::transformInteger);
+    }
+
+    static Field<Map<String, Object>> declareMap(String name) {
+        return declareField(name, ObjectTransforms::transformMap);
+    }
+
+    default Value apply(Map<String, Object> map) {
+        return apply(map.get(getName()));
+    }
+
+    static <V> Field<List<V>> declareList(String name, Function<Object, V> transform) {
+        return new FieldDefinition<>(name, (object) -> ObjectTransforms.transformList(object, transform));
+    }
+
+    static <V> Field<V> declareField(String name, Function<Object, V> transform) {
+        return new FieldDefinition<>(name, transform);
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/common/parser/FieldDefinition.java b/logstash-core/src/main/java/org/logstash/common/parser/FieldDefinition.java
new file mode 100644
index 00000000000..140a9b4ef49
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/common/parser/FieldDefinition.java
@@ -0,0 +1,40 @@
+package org.logstash.common.parser;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.function.Function;
+
+class FieldDefinition<Value> implements Field<Value> {
+    private static final Logger logger = LogManager.getLogger();
+    private final Function<Object, Value> transform;
+
+    private final String name;
+
+    // XXX: Should Field definitions be separated in Field, DeprecatedField, ObsoleteField ?
+    private FieldStatus status = FieldStatus.Supported;
+    private String details;
+
+    FieldDefinition(String name, Function<Object, Value> transform) {
+        this.name = name;
+        this.transform = transform;
+    }
+
+    @Override
+    public Value apply(Object object) {
+        if (object == null) {
+            throw new NullPointerException("The '" + name + "' field is required and no value was provided.");
+        }
+        return transform.apply(object);
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    @Override
+    public String getDetails() {
+        return details;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/common/parser/FieldStatus.java b/logstash-core/src/main/java/org/logstash/common/parser/FieldStatus.java
new file mode 100644
index 00000000000..7d94e0fbe6c
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/common/parser/FieldStatus.java
@@ -0,0 +1,7 @@
+package org.logstash.common.parser;
+
+enum FieldStatus {
+    Supported,
+    Deprecated,
+    Obsolete
+}
diff --git a/logstash-core/src/main/java/org/logstash/common/parser/Functions.java b/logstash-core/src/main/java/org/logstash/common/parser/Functions.java
new file mode 100644
index 00000000000..bd7294d51f4
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/common/parser/Functions.java
@@ -0,0 +1,31 @@
+package org.logstash.common.parser;
+
+class Functions {
+    interface Function3<Arg0, Arg1, Arg2, Value> {
+        Value apply(Arg0 arg0, Arg1 arg1, Arg2 arg2);
+    }
+
+    interface Function4<Arg0, Arg1, Arg2, Arg3, Value> {
+        Value apply(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3);
+    }
+
+    interface Function5<Arg0, Arg1, Arg2, Arg3, Arg4, Value> {
+        Value apply(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4);
+    }
+
+    interface Function6<Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Value> {
+        Value apply(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5);
+    }
+
+    interface Function7<Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Value> {
+        Value apply(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6);
+    }
+
+    interface Function8<Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Value> {
+        Value apply(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7);
+    }
+
+    interface Function9<Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Value> {
+        Value apply(Arg0 arg0, Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/common/parser/ObjectFactory.java b/logstash-core/src/main/java/org/logstash/common/parser/ObjectFactory.java
new file mode 100644
index 00000000000..16dcc1226a0
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/common/parser/ObjectFactory.java
@@ -0,0 +1,189 @@
+package org.logstash.common.parser;
+
+import org.logstash.common.parser.Functions.Function3;
+import org.logstash.common.parser.Functions.Function4;
+import org.logstash.common.parser.Functions.Function5;
+import org.logstash.common.parser.Functions.Function6;
+import org.logstash.common.parser.Functions.Function7;
+import org.logstash.common.parser.Functions.Function8;
+import org.logstash.common.parser.Functions.Function9;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+
+/**
+ * A functional class which constructs an object from a given configuration map.
+ * <p>
+ * History: This is idea is taken largely from Elasticsearch's ConstructingObjectParser
+ *
+ * @param <Value> The object type to construct when `parse` is called.
+ */
+public class ObjectFactory<Value> implements Function<Map<String, Object>, Value> {
+    private final Map<String, BiConsumer<Value, Object>> parsers = new HashMap<>();
+    private List<Field<?>> constructorFields;
+    private final Function<Map<String, Object>, Value> builder;
+
+    /**
+     * Zero-argument object constructor (A Supplier)
+     *
+     * @param supplier The supplier which produces an object instance.
+     */
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public ObjectFactory(Supplier<Value> supplier) {
+        this(config -> supplier.get());
+        constructorFields = Collections.emptyList();
+    }
+
+    /**
+     * One-argument object constructor
+     */
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <Arg0> ObjectFactory(Function<Arg0, Value> function, Field<Arg0> arg0) {
+        this(config -> function.apply(arg0.apply(config)));
+        constructorFields = Collections.singletonList(arg0);
+    }
+
+    /**
+     * Two-argument object constructor
+     */
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <Arg0, Arg1> ObjectFactory(BiFunction<Arg0, Arg1, Value> function, Field<Arg0> arg0, Field<Arg1> arg1) {
+        this(config -> function.apply(arg0.apply(config), arg1.apply(config)));
+        constructorFields = Arrays.asList(arg0, arg1);
+    }
+
+    /**
+     * Three-argument object constructor
+     */
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <Arg0, Arg1, Arg2> ObjectFactory(Function3<Arg0, Arg1, Arg2, Value> function, Field<Arg0> arg0, Field<Arg1> arg1, Field<Arg2> arg2) {
+        this(config -> function.apply(arg0.apply(config), arg1.apply(config), arg2.apply(config)));
+        constructorFields = Arrays.asList(arg0, arg1, arg2);
+    }
+
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <Arg0, Arg1, Arg2, Arg3> ObjectFactory(Function4<Arg0, Arg1, Arg2, Arg3, Value> function, Field<Arg0> arg0, Field<Arg1> arg1, Field<Arg2> arg2, Field<Arg3> arg3) {
+        this(config -> function.apply(arg0.apply(config), arg1.apply(config), arg2.apply(config), arg3.apply(config)));
+        constructorFields = Arrays.asList(arg0, arg1, arg2, arg3);
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <Arg0, Arg1, Arg2, Arg3, Arg4> ObjectFactory(Function5<Arg0, Arg1, Arg2, Arg3, Arg4, Value> function, Field<Arg0> arg0, Field<Arg1> arg1, Field<Arg2> arg2, Field<Arg3> arg3, Field<Arg4> arg4) {
+        this(config -> function.apply(arg0.apply(config), arg1.apply(config), arg2.apply(config), arg3.apply(config), arg4.apply(config)));
+        constructorFields = Arrays.asList(arg0, arg1, arg2, arg3, arg4);
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <Arg0, Arg1, Arg2, Arg3, Arg4, Arg5> ObjectFactory(Function6<Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Value> function, Field<Arg0> arg0, Field<Arg1> arg1, Field<Arg2> arg2, Field<Arg3> arg3, Field<Arg4> arg4, Field<Arg5> arg5) {
+        this(config -> function.apply(arg0.apply(config), arg1.apply(config), arg2.apply(config), arg3.apply(config), arg4.apply(config), arg5.apply(config)));
+        constructorFields = Arrays.asList(arg0, arg1, arg2, arg3, arg4, arg5);
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6> ObjectFactory(Function7<Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Value> function, Field<Arg0> arg0, Field<Arg1> arg1, Field<Arg2> arg2, Field<Arg3> arg3, Field<Arg4> arg4, Field<Arg5> arg5, Field<Arg6> arg6) {
+        this(config -> function.apply(arg0.apply(config), arg1.apply(config), arg2.apply(config), arg3.apply(config), arg4.apply(config), arg5.apply(config), arg6.apply(config)));
+        constructorFields = Arrays.asList(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7> ObjectFactory(Function8<Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Value> function, Field<Arg0> arg0, Field<Arg1> arg1, Field<Arg2> arg2, Field<Arg3> arg3, Field<Arg4> arg4, Field<Arg5> arg5, Field<Arg6> arg6, Field<Arg7> arg7) {
+        this(config -> function.apply(arg0.apply(config), arg1.apply(config), arg2.apply(config), arg3.apply(config), arg4.apply(config), arg5.apply(config), arg6.apply(config), arg7.apply(config)));
+        constructorFields = Arrays.asList(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8> ObjectFactory(Function9<Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Value> function, Field<Arg0> arg0, Field<Arg1> arg1, Field<Arg2> arg2, Field<Arg3> arg3, Field<Arg4> arg4, Field<Arg5> arg5, Field<Arg6> arg6, Field<Arg7> arg7, Field<Arg8> arg8) {
+        this(config -> function.apply(arg0.apply(config), arg1.apply(config), arg2.apply(config), arg3.apply(config), arg4.apply(config), arg5.apply(config), arg6.apply(config), arg7.apply(config), arg8.apply(config)));
+        constructorFields = Arrays.asList(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
+    }
+
+    private ObjectFactory(Function<Map<String, Object>, Value> builder) {
+        this.builder = builder;
+    }
+
+    /**
+     * Use the given config to produce the Value object.
+     * <p>
+     * Contract:
+     * 1) All declared constructor arguments are required. If any are missing, an IllegalArgumentException is thrown.
+     * 2) All declared fields are optional.
+     * 3) Any unknown fields found will cause this method to throw an IllegalArgumentException.
+     * 4) If any field processing fails, an IllegalArgumentException is thrown
+     *
+     * @param config the configuration
+     * @return the configured object
+     */
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public Value apply(Map<String, Object> config) {
+        rejectUnknownFields(config.keySet());
+
+        Value value = this.builder.apply(config);
+
+        // Now call all the object setters/etc
+        for (Map.Entry<String, Object> entry : config.entrySet()) {
+            String name = entry.getKey();
+            if (isConstructorField(name)) {
+                continue;
+            }
+
+            BiConsumer<Value, Object> parser = parsers.get(name);
+            assert parser != null;
+
+            try {
+                parser.accept(value, entry.getValue());
+            } catch (IllegalArgumentException e) {
+                throw new IllegalArgumentException("Field " + name + ": " + e.getMessage(), e);
+            }
+        }
+
+        return value;
+    }
+
+    private boolean isConstructorField(String name) {
+        return constructorFields.stream().anyMatch(f -> f.getName().equals(name));
+    }
+
+    private boolean isKnownField(String name) {
+        return parsers.containsKey(name) || isConstructorField(name);
+    }
+
+
+    private void rejectUnknownFields(Set<String> configNames) throws IllegalArgumentException {
+        // Check for any unknown parameters.
+        List<String> unknown = configNames.stream().filter(name -> !isKnownField(name)).collect(Collectors.toList());
+
+        if (!unknown.isEmpty()) {
+            throw new IllegalArgumentException("Unknown settings: " + unknown);
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <T> ObjectFactory<Value> define(Field<T> field, BiConsumer<Value, T> consumer) {
+        if (isKnownField(field.getName())) {
+            throw new IllegalArgumentException("Duplicate field defined '" + field.getName() + "'");
+        }
+
+        parsers.put(field.getName(), (value, input) -> consumer.accept(value, field.apply(input)));
+        return this;
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <T> ObjectFactory<Value> deprecate(Field<T> field, BiConsumer<Value, T> consumer, String details) {
+        return define(new DeprecatedField<>(field.getName(), field, details), consumer);
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public <T> ObjectFactory<Value> obsolete(Field<T> field, BiConsumer<Value, T> consumer, String details) {
+        return define(new ObsoleteField<>(field.getName(), field, details), consumer);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/common/parser/ObjectTransforms.java b/logstash-core/src/main/java/org/logstash/common/parser/ObjectTransforms.java
new file mode 100644
index 00000000000..a8244929b91
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/common/parser/ObjectTransforms.java
@@ -0,0 +1,121 @@
+package org.logstash.common.parser;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+
+public class ObjectTransforms {
+    /**
+     * A function which takes an Object and returns an Integer
+     *
+     * @param object the object to transform to Integer
+     * @return An Integer based on the given object.
+     * @throws IllegalArgumentException if conversion is not possible
+     */
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public static Integer transformInteger(Object object) throws IllegalArgumentException {
+        if (object instanceof Number) {
+            return ((Number) object).intValue();
+        } else if (object instanceof String) {
+            return Integer.parseInt((String) object);
+        } else {
+            throw new IllegalArgumentException("Value must be a number, but is a " + object.getClass());
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public static Float transformFloat(Object object) throws IllegalArgumentException {
+        if (object instanceof Number) {
+            return ((Number) object).floatValue();
+        } else if (object instanceof String) {
+            return Float.parseFloat((String) object);
+        } else {
+            throw new IllegalArgumentException("Value must be a number, but is a " + object.getClass());
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public static Double transformDouble(Object object) throws IllegalArgumentException {
+        if (object instanceof Number) {
+            return ((Number) object).doubleValue();
+        } else if (object instanceof String) {
+            return Double.parseDouble((String) object);
+        } else {
+            throw new IllegalArgumentException("Value must be a number, but is a " + object.getClass());
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public static Long transformLong(Object object) throws IllegalArgumentException {
+        if (object instanceof Number) {
+            return ((Number) object).longValue();
+        } else if (object instanceof String) {
+            return Long.parseLong((String) object);
+        } else {
+            throw new IllegalArgumentException("Value must be a number, but is a " + object.getClass());
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public static String transformString(Object object) throws IllegalArgumentException {
+        if (object instanceof String) {
+            return (String) object;
+        } else if (object instanceof Number) {
+            return object.toString();
+        } else {
+            throw new IllegalArgumentException("Value must be a string, but is a " + object.getClass());
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public static Boolean transformBoolean(Object object) throws IllegalArgumentException {
+        if (object instanceof Boolean) {
+            return (Boolean) object;
+        } else if (object instanceof String) {
+            switch ((String) object) {
+                case "true":
+                    return true;
+                case "false":
+                    return false;
+                default:
+                    throw new IllegalArgumentException("Value must be a boolean 'true' or 'false', but is " + object);
+            }
+        } else {
+            throw new IllegalArgumentException("Value must be a boolean, but is " + object.getClass());
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public static <T> T transformObject(Object object, ObjectFactory<T> parser) throws IllegalArgumentException {
+        if (object instanceof Map) {
+            // XXX: Fix this unchecked cast.
+            return parser.apply((Map<String, Object>) object);
+        } else {
+            throw new IllegalArgumentException("Object value must be a Map, but is a " + object.getClass());
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public static <T> List<T> transformList(Object object, Function<Object, T> transform) throws IllegalArgumentException {
+        // XXX: Support Iterator?
+        if (object instanceof List) {
+            List<Object> list = (List<Object>) object;
+            List<T> result = new ArrayList<>(list.size());
+            list.stream().map(transform).forEach(result::add);
+            return result;
+        } else {
+            throw new IllegalArgumentException("Object value must be a List, but is a " + object.getClass());
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess") // Public Interface
+    public static Map<String, Object> transformMap(Object object) {
+        if (object instanceof Map) {
+            // XXX: Validate all entries in this map for the cast?
+            return (Map<String, Object>) object;
+        } else {
+            throw new IllegalArgumentException("Expected a map `{ ... }` but got a " + object.getClass());
+        }
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/common/parser/ObsoleteField.java b/logstash-core/src/main/java/org/logstash/common/parser/ObsoleteField.java
new file mode 100644
index 00000000000..9a6b22bd212
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/common/parser/ObsoleteField.java
@@ -0,0 +1,23 @@
+package org.logstash.common.parser;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.function.Function;
+
+public class ObsoleteField<Value> extends FieldDefinition<Value> {
+    private static final Logger logger = LogManager.getLogger();
+    private final String details;
+
+    ObsoleteField(String name, Function<Object, Value> transform, String details) {
+        super(name, transform);
+        this.details = details;
+    }
+
+    @Override
+    public Value apply(Object object) {
+        String message = "The field '" + getName() + "' is obsolete and no longer functions. Remove it from your configuration. " + details;
+        logger.fatal(message);
+        throw new IllegalArgumentException(message);
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/TestUtil.java b/logstash-core/src/test/java/org/logstash/TestUtil.java
new file mode 100644
index 00000000000..6d21168af0c
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/TestUtil.java
@@ -0,0 +1,10 @@
+package org.logstash;
+
+import java.util.Random;
+
+public class TestUtil {
+    /**
+     * A random instance to share in the test suite.
+     */
+    public static final Random random = new Random();
+}
diff --git a/logstash-core/src/test/java/org/logstash/common/parser/ConstructingObjectParserTest.java b/logstash-core/src/test/java/org/logstash/common/parser/ConstructingObjectParserTest.java
new file mode 100644
index 00000000000..4c840b08b41
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/common/parser/ConstructingObjectParserTest.java
@@ -0,0 +1,295 @@
+package org.logstash.common.parser;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.experimental.runners.Enclosed;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.BiConsumer;
+
+import static org.junit.Assert.*;
+import static org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Enclosed.class)
+public class ConstructingObjectParserTest {
+    @SuppressWarnings("unused")
+    private static void check(ObjectFactory<?> factory) {
+        // Exists to do return type compile-time checks.
+        // no body is needed
+    }
+
+    public static class MixedUsageTest {
+        private final Map<String, Object> config = new HashMap<>();
+        private final int foo = 1000; // XXX: randomize
+        private final String bar = "hello"; // XXX: randomize
+
+        @Before
+        public void setup() {
+            config.put("foo", foo);
+            config.put("bar", bar);
+        }
+
+        @Test
+        public void testGoodConstruction() {
+            MixedExample example = MixedExample.BUILDER.apply(config);
+            assertEquals(foo, example.getFoo());
+            assertEquals(bar, example.getBar());
+        }
+    }
+
+    public static class NestedTest {
+        private final Map<String, Object> config = Collections.singletonMap("foo", Collections.singletonMap("i", 100));
+
+        @Test
+        public void testNested() {
+            NestedExample e = NestedExample.BUILDER.apply(config);
+            assertEquals(100, e.getNested().getI());
+        }
+
+        @Test
+        public void testNestedSetter() {
+            NestedExample e = NestedExample.BUILDER_USING_SETTERS.apply(config);
+            assertEquals(100, e.getNested().getI());
+
+        }
+
+    }
+
+    public static class FieldIntegrationTest {
+        private final Map<String, Object> config = new HashMap<>();
+
+        @Before
+        public void setup() {
+            config.put("integer", 1);
+            config.put("float", 1F);
+            config.put("double", 1D);
+            config.put("long", 1L);
+            config.put("boolean", true);
+            config.put("string", "hello");
+            config.put("list", Collections.singletonList("hello"));
+        }
+
+        @Test
+        public void testParsing() {
+            FieldExample e = FieldExample.BUILDER.apply(config);
+            assertEquals(1F, e.getF(), 0.1);
+            assertEquals(1D, e.getD(), 0.1);
+            assertEquals(1, e.getI());
+            assertEquals(1L, e.getL());
+            assertEquals(true, e.isB());
+            assertEquals("hello", e.getS());
+            assertEquals(Collections.singletonList("hello"), e.getStringList());
+
+            // because they are not set and the default in the Example class is null.
+            assertNull(e.getP());
+        }
+
+        @Test
+        public void testCustomTransform() {
+            config.put("path", "example");
+            FieldExample e = FieldExample.BUILDER.apply(config);
+            assertEquals(Paths.get("example"), e.getP());
+        }
+
+        @Test
+        public void testNestedObject() {
+            //config.put("object", Collections.singletonMap("path", "example"));
+            //Example e = EXAMPLE_BUILDER.apply(config);
+            //assertEquals(Paths.get("example"), e.getP2());
+        }
+
+        @Test(expected = IllegalArgumentException.class)
+        public void testDuplicateFieldsAreRejected() {
+            // field 'float' is already defined, so this should fail.
+            check(FieldExample.BUILDER.define(Field.declareString("float"), (a, b) -> { /*empty*/ }));
+        }
+    }
+
+    public static class ConstructorIntegrationTest {
+        private final Map<String, Object> config = new LinkedHashMap<>();
+
+        @Before
+        public void setup() {
+            config.put("float", 1F);
+            config.put("integer", 1);
+            config.put("long", 1L);
+            config.put("double", 1D);
+            config.put("boolean", true);
+            config.put("string", "hello");
+            config.put("path", "path");
+            config.put("list", Collections.singletonList("hello"));
+        }
+
+        @Test
+        public void testParsing() {
+            ConstructorExample e = ConstructorExample.BUILDER.apply(config);
+            assertEquals(1F, e.getF(), 0.1);
+            assertEquals(1D, e.getD(), 0.1);
+            assertEquals(1, e.getI());
+            assertEquals(1L, e.getL());
+            assertEquals(true, e.isB());
+            assertEquals("hello", e.getS());
+            assertEquals(Paths.get("path"), e.getP());
+            assertEquals(Collections.singletonList("hello"), e.getStringList());
+        }
+
+        @Test(expected = IllegalArgumentException.class)
+        public void testInvalidTypesAreRejected() {
+            config.put("float", "Hello"); // put a string for the float field.
+            ConstructorExample.BUILDER.apply(config); // should fail
+        }
+
+        @Test(expected = NullPointerException.class)
+        public void testMissingArgumentsAreRejected() {
+            config.remove("path");
+            ConstructorExample.BUILDER.apply(config); // should fail
+
+        }
+    }
+
+    @RunWith(Parameterized.class)
+    public static class StringAccepts {
+        private final Object input;
+        private final Object expected;
+
+        public StringAccepts(Object input, Object expected) {
+            this.input = input;
+            this.expected = expected;
+        }
+
+        @Parameters
+        public static Collection<Object[]> data() {
+            return Arrays.asList(new Object[][]{
+                    {"1", "1"},
+                    {1, "1"},
+                    {1L, "1"},
+                    {1F, "1.0"},
+                    {1D, "1.0"},
+            });
+        }
+
+        @Test
+        public void testStringTransform() {
+            String value = ObjectTransforms.transformString(input);
+            assertEquals(expected, value);
+
+        }
+    }
+
+    @RunWith(Parameterized.class)
+    public static class StringRejections {
+        private final Object input;
+
+        public StringRejections(Object input) {
+            this.input = input;
+        }
+
+        @Parameters
+        public static List<Object> data() {
+            return Arrays.asList(
+                    new Object(),
+                    Collections.emptyMap(),
+                    Collections.emptyList()
+            );
+        }
+
+        @Test(expected = IllegalArgumentException.class)
+        public void testFailure() {
+            ObjectTransforms.transformString(input);
+        }
+    }
+
+    public static class DeprecationsAndObsoletes {
+        static final BiConsumer<Object, Integer> noOp = (a, b) -> { /* empty */ };
+        final ObjectFactory<Object> c = new ObjectFactory<>(Object::new);
+
+        @Before
+        public void setup() {
+            check(c.deprecate(Field.declareInteger("deprecated"), noOp, "This thing is deprecated."));
+            check(c.obsolete(Field.declareInteger("obsolete"), noOp, "This thing is obsolete."));
+        }
+
+        @Test
+        public void deprecatedUsageIsAllowed() {
+            // XXX: Implement a custom log appender that captures log4j logs so we can verify the warning is logged.
+            c.apply(Collections.singletonMap("deprecated", 1));
+        }
+
+        @Test(expected = IllegalArgumentException.class)
+        public void obsoleteUsageFails() {
+            c.apply(Collections.singletonMap("obsolete", 1));
+        }
+    }
+
+    @RunWith(Parameterized.class)
+    public static class ConstructionArguments {
+        static final ObjectFactory<List<Integer>> c0 = /* 0 args */ new ObjectFactory<>(Arrays::<Integer>asList);
+        static final ObjectFactory<List<Integer>> c1 = /* 1 args */ new ObjectFactory<>(Arrays::<Integer>asList, Field.declareInteger("a0"));
+        static final ObjectFactory<List<Integer>> c2 = /* 2 args */ new ObjectFactory<>(Arrays::<Integer>asList, Field.declareInteger("a0"), Field.declareInteger("a1"));
+        static final ObjectFactory<List<Integer>> c3 = /* 3 args */ new ObjectFactory<>(Arrays::<Integer>asList, Field.declareInteger("a0"), Field.declareInteger("a1"), Field.declareInteger("a2"));
+        static final ObjectFactory<List<Integer>> c4 = /* 4 args */ new ObjectFactory<>(Arrays::<Integer>asList, Field.declareInteger("a0"), Field.declareInteger("a1"), Field.declareInteger("a2"), Field.declareInteger("a3"));
+        static final ObjectFactory<List<Integer>> c5 = /* 5 args */ new ObjectFactory<>(Arrays::<Integer>asList, Field.declareInteger("a0"), Field.declareInteger("a1"), Field.declareInteger("a2"), Field.declareInteger("a3"), Field.declareInteger("a4"));
+        static final ObjectFactory<List<Integer>> c6 = /* 6 args */ new ObjectFactory<>(Arrays::<Integer>asList, Field.declareInteger("a0"), Field.declareInteger("a1"), Field.declareInteger("a2"), Field.declareInteger("a3"), Field.declareInteger("a4"), Field.declareInteger("a5"));
+        static final ObjectFactory<List<Integer>> c7 = /* 7 args */ new ObjectFactory<>(Arrays::<Integer>asList, Field.declareInteger("a0"), Field.declareInteger("a1"), Field.declareInteger("a2"), Field.declareInteger("a3"), Field.declareInteger("a4"), Field.declareInteger("a5"), Field.declareInteger("a6"));
+        static final ObjectFactory<List<Integer>> c8 = /* 8 args */ new ObjectFactory<>(Arrays::<Integer>asList, Field.declareInteger("a0"), Field.declareInteger("a1"), Field.declareInteger("a2"), Field.declareInteger("a3"), Field.declareInteger("a4"), Field.declareInteger("a5"), Field.declareInteger("a6"), Field.declareInteger("a7"));
+        static final ObjectFactory<List<Integer>> c9 = /* 9 args */ new ObjectFactory<>(Arrays::<Integer>asList, Field.declareInteger("a0"), Field.declareInteger("a1"), Field.declareInteger("a2"), Field.declareInteger("a3"), Field.declareInteger("a4"), Field.declareInteger("a5"), Field.declareInteger("a6"), Field.declareInteger("a7"), Field.declareInteger("a8"));
+        private final ObjectFactory<List<Integer>> builder;
+        private final int i;
+
+        public ConstructionArguments(ObjectFactory<List<Integer>> builder, int i) {
+            this.builder = builder;
+            this.i = i;
+        }
+
+        static Map<String, Object> genMap(int count) {
+            Map<String, Object> map = new HashMap<>();
+            for (int i = 0; i < count; i++) {
+                map.put("a" + i, i);
+            }
+            return map;
+        }
+
+        @Parameters
+        public static Collection<Object[]> data() {
+            return Arrays.asList(new Object[][]{
+                    {c0, 0},
+                    {c1, 1},
+                    {c2, 2},
+                    {c3, 3},
+                    {c4, 4},
+                    {c5, 5},
+                    {c6, 6},
+                    {c7, 7},
+                    {c8, 8},
+                    {c9, 9},
+            });
+        }
+
+        @Test
+        public void testBuilder() {
+            for (int args = 0; args <= 9; args++) {
+                try {
+                    builder.apply(genMap(args));
+                } catch (IllegalArgumentException e) {
+                    if (args < i) {
+                        fail("Having fewer args than required should not generate an IllegalArgumentException");
+                    }
+                } catch (NullPointerException e) {
+                    if (args >= i) {
+                        fail("Having enough arguments should not generate a NullPointerException");
+                    }
+                }
+            }
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/common/parser/ConstructorExample.java b/logstash-core/src/test/java/org/logstash/common/parser/ConstructorExample.java
new file mode 100644
index 00000000000..e88ce15dc67
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/common/parser/ConstructorExample.java
@@ -0,0 +1,76 @@
+package org.logstash.common.parser;
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.List;
+
+class ConstructorExample {
+    static final ObjectFactory<ConstructorExample> BUILDER = new ObjectFactory<>(
+            ConstructorExample::new,
+            Field.declareInteger("integer"),
+            Field.declareFloat("float"),
+            Field.declareLong("long"),
+            Field.declareDouble("double"),
+            Field.declareBoolean("boolean"),
+            Field.declareString("string"),
+            Field.declareField("path", object -> Paths.get(ObjectTransforms.transformString(object))),
+            Field.declareList("list", ObjectTransforms::transformString)
+    );
+
+    private Path path;
+    private final int i;
+    private final float f;
+    private final double d;
+    private final boolean b;
+    private final long l;
+    private final String s;
+    private final Path p;
+    private final List<String> stringList;
+
+    private ConstructorExample(int i, float f, long l, double d, boolean b, String s, Path p, List<String> stringList) {
+        this.i = i;
+        this.f = f;
+        this.l = l;
+        this.d = d;
+        this.b = b;
+        this.s = s;
+        this.p = p;
+        this.stringList = stringList;
+    }
+
+    int getI() {
+        return i;
+    }
+
+    float getF() {
+        return f;
+    }
+
+    double getD() {
+        return d;
+    }
+
+    boolean isB() {
+        return b;
+    }
+
+    long getL() {
+        return l;
+    }
+
+    String getS() {
+        return s;
+    }
+
+    Path getP() {
+        return p;
+    }
+
+    List<String> getStringList() {
+        return stringList;
+    }
+
+    public Path getPath() {
+        return path;
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/common/parser/FieldExample.java b/logstash-core/src/test/java/org/logstash/common/parser/FieldExample.java
new file mode 100644
index 00000000000..abae76abffc
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/common/parser/FieldExample.java
@@ -0,0 +1,90 @@
+package org.logstash.common.parser;
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.List;
+
+class FieldExample {
+    static final ObjectFactory<FieldExample> BUILDER = new ObjectFactory<>(FieldExample::new)
+            .define(Field.declareInteger("integer"), FieldExample::setI)
+            .define(Field.declareFloat("float"), FieldExample::setF)
+            .define(Field.declareDouble("double"), FieldExample::setD)
+            .define(Field.declareLong("long"), FieldExample::setL)
+            .define(Field.declareBoolean("boolean"), FieldExample::setB)
+            .define(Field.declareString("string"), FieldExample::setS)
+            .define(Field.declareField("path", (object) -> Paths.get(ObjectTransforms.transformString(object))), FieldExample::setP)
+            .define(Field.declareList("list", ObjectTransforms::transformString), FieldExample::setStringList);
+
+    private int i;
+    private float f;
+    private double d;
+    private boolean b;
+    private long l;
+    private String s;
+    private Path p;
+    private List<String> stringList;
+
+    public int getI() {
+        return i;
+    }
+
+    private void setI(int i) {
+        this.i = i;
+    }
+
+    float getF() {
+        return f;
+    }
+
+    private void setF(float f) {
+        this.f = f;
+    }
+
+    double getD() {
+        return d;
+    }
+
+    private void setD(double d) {
+        this.d = d;
+    }
+
+    boolean isB() {
+        return b;
+    }
+
+    private void setB(boolean b) {
+        this.b = b;
+    }
+
+    long getL() {
+        return l;
+    }
+
+    private void setL(long l) {
+        this.l = l;
+    }
+
+    public String getS() {
+        return s;
+    }
+
+    private void setS(String s) {
+        this.s = s;
+    }
+
+    Path getP() {
+        return p;
+    }
+
+    private void setP(Path p) {
+        this.p = p;
+    }
+
+    List<String> getStringList() {
+        return stringList;
+    }
+
+    private void setStringList(List<String> stringList) {
+        this.stringList = stringList;
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/common/parser/MixedExample.java b/logstash-core/src/test/java/org/logstash/common/parser/MixedExample.java
new file mode 100644
index 00000000000..60c2272f025
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/common/parser/MixedExample.java
@@ -0,0 +1,26 @@
+package org.logstash.common.parser;
+
+class MixedExample {
+    static final ObjectFactory<MixedExample> BUILDER = new ObjectFactory<>(MixedExample::new, Field.declareInteger("foo"))
+            .define(Field.declareString("bar"), MixedExample::setBar);
+
+    private int foo;
+    private String bar;
+
+    private MixedExample(int foo) {
+        this.foo = foo;
+    }
+
+
+    public int getFoo() {
+        return foo;
+    }
+
+    public String getBar() {
+        return bar;
+    }
+
+    private void setBar(String bar) {
+        this.bar = bar;
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/common/parser/NestedExample.java b/logstash-core/src/test/java/org/logstash/common/parser/NestedExample.java
new file mode 100644
index 00000000000..cace2da598f
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/common/parser/NestedExample.java
@@ -0,0 +1,39 @@
+package org.logstash.common.parser;
+
+public class NestedExample {
+    static final ObjectFactory<NestedExample> BUILDER = new ObjectFactory<>(NestedExample::new, Field.declareObject("foo", Nested.BUILDER));
+
+    static final ObjectFactory<NestedExample> BUILDER_USING_SETTERS = new ObjectFactory<>(NestedExample::new)
+            .define(Field.declareObject("foo", Nested.BUILDER), NestedExample::setNested);
+
+    private Nested nested;
+
+    private NestedExample() {
+    }
+    private NestedExample(Nested nested) {
+        this.nested = nested;
+    }
+
+    public Nested getNested() {
+        return nested;
+    }
+
+    public void setNested(Nested nested) {
+        this.nested = nested;
+    }
+
+    public static class Nested {
+        static final ObjectFactory<Nested> BUILDER = new ObjectFactory<>(Nested::new, Field.declareInteger("i"));
+
+        private final int i;
+
+        Nested(int i) {
+            this.i = i;
+        }
+
+        public int getI() {
+            return i;
+        }
+    }
+
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugin/Conversion.java b/logstash-core/src/test/java/org/logstash/plugin/Conversion.java
new file mode 100644
index 00000000000..d4042514e35
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/Conversion.java
@@ -0,0 +1,44 @@
+package org.logstash.plugin;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+enum Conversion {
+    String,
+    Integer,
+    Float,
+    Boolean;
+
+    static Optional<Conversion> lookup(String value) {
+        return Arrays.stream(Conversion.values()).filter(c -> c.toString().toLowerCase().equals(value.toLowerCase())).findFirst();
+    }
+
+    static List<String> names() {
+        return Arrays.stream(Conversion.values()).map(Object::toString).map(java.lang.String::toLowerCase).collect(Collectors.toList());
+    }
+
+    Object convert(Object value) {
+        switch (this) {
+            case String:
+                return value.toString();
+            case Integer:
+                return java.lang.Integer.parseInt((String) value);
+            case Float:
+                return java.lang.Float.parseFloat((String) value);
+            case Boolean:
+                switch (((String) value).toLowerCase()) {
+                    case "true":
+                        return true;
+                    case "false":
+                        return false;
+                    default:
+                        throw new IllegalArgumentException("Boolean convert only works on values 'true' or 'false' (case insensitive)");
+                }
+        }
+
+        assert (false); // should not get here
+        throw new IllegalArgumentException("BUG: Unreachable code has been reached.");
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugin/MutateProcessorBuilder.java b/logstash-core/src/test/java/org/logstash/plugin/MutateProcessorBuilder.java
new file mode 100644
index 00000000000..53d66f04d50
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/MutateProcessorBuilder.java
@@ -0,0 +1,69 @@
+package org.logstash.plugin;
+
+import org.logstash.Event;
+import org.logstash.FieldReference;
+import org.logstash.Javafier;
+import org.logstash.PathCache;
+
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.Consumer;
+
+/**
+ * A builder for the Mutate processor which builds a chain of Consumers.
+ * <p>
+ * This differs from the Ruby implementation by using build-time knowledge to build a consumer that
+ * executes exactly the required steps and nothing more.
+ * <p>
+ * In Ruby, we always check if @convert is set, for example, and this model (chaining Consumer.andThen),
+ * we can build a Consumer that doesn't waste any energy on things never configured by the user.
+ * <p>
+ * XXX: Would this be similarly efficient as a Processor that lazily built itself?
+ * <p>
+ * Something like:
+ * void process(Event event) {
+ * if (this.consumer == null) { build(); }
+ * this.consumer.accept(event);
+ * }
+ */
+class MutateProcessorBuilder {
+    private Consumer<Event> consumer;
+
+    MutateProcessorBuilder withConvert(Map<String, Object> map) {
+        for (Map.Entry<String, Object> entry : map.entrySet()) {
+            FieldReference ref = PathCache.cache(entry.getKey());
+            Optional<Conversion> result = Conversion.lookup((String) entry.getValue());
+            if (!result.isPresent()) {
+                throw new IllegalArgumentException("Invalid conversion '" + entry.getValue() + "'. Must be one of: " + Conversion.names());
+            }
+
+            Conversion conversion = result.get();
+
+            append((Event event) -> {
+                if (event.includes(ref)) {
+                    Object value = event.getUnconvertedField(ref);
+                    if (value != null) {
+                        event.setField(ref, conversion.convert(Javafier.deep(value)));
+                    }
+                }
+            });
+        }
+
+        return this;
+    }
+
+    private void append(Consumer<Event> consumer) {
+        if (this.consumer == null) {
+            this.consumer = consumer;
+        } else {
+            //System.out.println("Appending consumer: " + consumer);
+            this.consumer = this.consumer.andThen(consumer);
+        }
+    }
+
+
+    Consumer<Event> build() {
+        return consumer;
+    }
+
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugin/MutateProcessorTest.java b/logstash-core/src/test/java/org/logstash/plugin/MutateProcessorTest.java
new file mode 100644
index 00000000000..a07f1fd9d93
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/MutateProcessorTest.java
@@ -0,0 +1,45 @@
+package org.logstash.plugin;
+
+import org.junit.Test;
+import org.logstash.Event;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Consumer;
+
+import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertThat;
+
+public class MutateProcessorTest {
+    private MutateProcessorBuilder builder = new MutateProcessorBuilder();
+
+    private Map<String, Object> conversions = new HashMap<String, Object>() {{
+        put("foo", "integer");
+        put("bar", "float");
+        put("baz", "boolean");
+    }};
+
+    @Test
+    public void testBuilder() {
+        builder.withConvert(conversions);
+        Consumer<Event> consumer = builder.build();
+
+        Event event = new Event();
+        event.setField("foo", "1");
+        event.setField("bar", "1");
+        event.setField("baz", "true");
+
+        consumer.accept(event);
+
+        // Ok so... Event actually stores Long, not Integer.
+        assertThat("foo type is integer", event.getField("foo"), instanceOf(Long.class));
+        assertThat("foo is 1", event.getField("foo"), is(1L));
+
+        assertThat("bar type is float", event.getField("bar"), instanceOf(Double.class));
+        assertThat("bar is 1.0", event.getField("bar"), is(1.0));
+
+        assertThat("baz type is boolean", event.getField("baz"), instanceOf(Boolean.class));
+        assertThat("baz is true", event.getField("baz"), is(true));
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugin/TranslateFilterPlugin.java b/logstash-core/src/test/java/org/logstash/plugin/TranslateFilterPlugin.java
new file mode 100644
index 00000000000..0b7c0cf3f9d
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/TranslateFilterPlugin.java
@@ -0,0 +1,157 @@
+package org.logstash.plugin;
+
+import org.logstash.Event;
+import org.logstash.common.parser.Field;
+import org.logstash.common.parser.ObjectFactory;
+import org.logstash.common.parser.ObjectTransforms;
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Map;
+import java.util.function.Function;
+
+class TranslateFilterPlugin {
+    private final static ObjectFactory<TranslateFilter> TRANSLATE_MAP = new ObjectFactory<>(
+            TranslateFilter::new, Field.declareString("field"), Field.declareMap("dictionary"));
+    private final static ObjectFactory<FileBackedTranslateFilter> TRANSLATE_FILE = new ObjectFactory<>(
+            FileBackedTranslateFilter::new, Field.declareString("field"), Field.declareField("dictionary_path", TranslateFilterPlugin::parsePath));
+
+    /**
+     * The translate filter (as written in Ruby) is currently bimodal. There are two modes:
+     * <p>
+     * 1) A hand-written dictionary `dictionary => { "key" => value, ... }
+     * 2) A file-backed dictionary `dictionary_path => "/some/path.yml"`
+     * <p>
+     * Because of these, provide a custom Function to call the correct implementation (file or static)
+     */
+    final static Function<Map<String, Object>, TranslateFilter> BUILDER = TranslateFilterPlugin::newFilter;
+
+    static {
+        // Apply most settings to both Translate Filter modes.
+        for (ObjectFactory<? extends TranslateFilter> builder : Arrays.asList(TRANSLATE_MAP, TRANSLATE_FILE)) {
+            builder.define(Field.declareString("destination"), TranslateFilter::setDestination);
+            builder.define(Field.declareBoolean("exact"), TranslateFilter::setExact);
+            builder.define(Field.declareBoolean("override"), TranslateFilter::setOverride);
+            builder.define(Field.declareBoolean("regex"), TranslateFilter::setRegex);
+            builder.define(Field.declareString("fallback"), TranslateFilter::setFallback);
+        }
+
+        // File-backed mode gets a special `refresh_interval` setting.
+        TRANSLATE_FILE.define(Field.declareInteger("refresh_interval"), FileBackedTranslateFilter::setRefreshInterval);
+    }
+
+    private static Path parsePath(Object input) {
+        Path path = Paths.get(ObjectTransforms.transformString(input));
+
+        if (!path.toFile().exists()) {
+            throw new IllegalArgumentException("The given path does not exist: " + path);
+        }
+
+        return path;
+    }
+
+    private static TranslateFilter newFilter(Map<String, Object> config) {
+        if (config.containsKey("dictionary") && config.containsKey("dictionary_path")) {
+            throw new IllegalArgumentException("You must specify either dictionary or dictionary_path, not both. Both are set.");
+        }
+
+        if (config.containsKey("dictionary")) {
+            // "dictionary" field was set, so args[1] is a map.
+            return TRANSLATE_MAP.apply(config);
+        } else {
+            // dictionary_path set, so let's use a file-backed translate filter.
+            return TRANSLATE_FILE.apply(config);
+        }
+    }
+
+    // Processor interface will be defined in another PR, so this exists as a placeholder;
+    private interface Processor extends Function<Collection<Event>, Collection<Event>> {
+    }
+
+    public static class TranslateFilter implements Processor {
+        Map<String, Object> map;
+        private String source;
+        private String target = "translation";
+        private String fallback;
+        private boolean exact = true;
+        private boolean override = false;
+        private boolean regex = false;
+
+        TranslateFilter(String source, Map<String, Object> map, Path path) { /* ... */ }
+
+        TranslateFilter(String source, Map<String, Object> map) {
+            this(source);
+            this.map = map;
+        }
+
+        TranslateFilter(String source) {
+            this.source = source;
+        }
+
+        void setDestination(String target) {
+            this.target = target;
+        }
+
+        private Object translate(Object input) {
+            if (input instanceof String) {
+                return map.get(input);
+            } else {
+                return null;
+            }
+        }
+
+        @Override
+        public Collection<Event> apply(Collection<Event> events) {
+            // This implementation is incomplete. This test implementation primarily exists to demonstrate
+            // the usage of the ConstructingObjectParser with a real plugin.
+            for (Event event : events) {
+                Object input = event.getField(source);
+                if (input == null && fallback != null) {
+                    event.setField(target, fallback);
+                } else {
+                    Object output = translate(input);
+                    if (output != null) {
+                        event.setField(target, output);
+                    }
+                }
+            }
+            return null;
+        }
+
+        void setExact(boolean exact) {
+            this.exact = exact;
+        }
+
+        void setOverride(boolean flag) {
+            this.override = flag;
+        }
+
+        void setFallback(String fallback) {
+            this.fallback = fallback;
+        }
+
+        void setRegex(boolean flag) {
+            this.regex = flag;
+
+        }
+    }
+
+    static class FileBackedTranslateFilter extends TranslateFilter {
+        private final Path path;
+        private int refresh;
+
+        FileBackedTranslateFilter(String source, Path path) {
+            super(source);
+            this.path = path;
+            // start a thread to read the Path and update the Map periodically.
+            // implementation left as an exercise, since this is just a demo code :)
+        }
+
+        private void setRefreshInterval(int refresh) {
+            this.refresh = refresh;
+
+        }
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugin/TranslateFilterPluginTest.java b/logstash-core/src/test/java/org/logstash/plugin/TranslateFilterPluginTest.java
new file mode 100644
index 00000000000..6eb85c90e34
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/TranslateFilterPluginTest.java
@@ -0,0 +1,18 @@
+package org.logstash.plugin;
+
+import org.junit.Test;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+public class TranslateFilterPluginTest {
+    @Test
+    public void exampleConfig() {
+        Map<String, Object> config = new HashMap<>();
+        config.put("dictionary", Collections.emptyMap());
+        config.put("field", "fancy");
+
+        TranslateFilterPlugin.TranslateFilter filter = TranslateFilterPlugin.BUILDER.apply(config);
+    }
+}
