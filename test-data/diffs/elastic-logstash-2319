diff --git a/logstash-event.gemspec b/logstash-event.gemspec
index 41286036830..48cf153ec5c 100644
--- a/logstash-event.gemspec
+++ b/logstash-event.gemspec
@@ -21,9 +21,8 @@ Gem::Specification.new do |gem|
   gem.name          = "logstash-event"
   gem.require_paths = ["lib"]
   gem.version       = "1.2.02"
-  
+
   gem.add_development_dependency "rspec"
   gem.add_development_dependency "guard"
   gem.add_development_dependency "guard-rspec"
-  gem.add_development_dependency "insist", "1.0.0"
 end
diff --git a/logstash.gemspec b/logstash.gemspec
index 5c24b675a5b..3bfe8b2a581 100644
--- a/logstash.gemspec
+++ b/logstash.gemspec
@@ -68,7 +68,6 @@ Gem::Specification.new do |gem|
 
   # These are runtime-deps so you can do 'java -jar logstash.jar rspec <test>'
   gem.add_runtime_dependency "rspec", "~> 2.14.0" #(MIT license)
-  gem.add_runtime_dependency "insist", "1.0.0"    #(Apache 2.0 license)
 
   gem.add_runtime_dependency "logstash-devutils"
 
diff --git a/spec/core/conditionals_spec.rb b/spec/core/conditionals_spec.rb
index 576851ae484..cd3f3210238 100644
--- a/spec/core/conditionals_spec.rb
+++ b/spec/core/conditionals_spec.rb
@@ -63,24 +63,24 @@ def conditional(expression, &block)
     CONFIG
 
     sample({"foo" => "bar"}) do
-      insist { subject["always"] } == "awesome"
-      insist { subject["hello"] } == "world"
-      insist { subject["fancy"] }.nil?
-      insist { subject["free"] }.nil?
+      expect(subject["always"]).to eq("awesome")
+      expect(subject["hello"]).to eq("world")
+      expect(subject["fancy"]).to be_nil
+      expect(subject["free"]).to be_nil
     end
 
     sample({"notfoo" => "bar"}) do
-      insist { subject["always"] } == "awesome"
-      insist { subject["hello"] }.nil?
-      insist { subject["fancy"] }.nil?
-      insist { subject["free"] } == "hugs"
+      expect(subject["always"]).to eq("awesome")
+      expect(subject["hello"]).to be_nil
+      expect(subject["fancy"]).to be_nil
+      expect(subject["free"]).to eq("hugs")
     end
 
     sample({"bar" => "baz"}) do
-      insist { subject["always"] } == "awesome"
-      insist { subject["hello"] }.nil?
-      insist { subject["fancy"] } == "pants"
-      insist { subject["free"] }.nil?
+      expect(subject["always"]).to eq("awesome")
+      expect(subject["hello"]).to be_nil
+      expect(subject["fancy"]).to eq("pants")
+      expect(subject["free"]).to be_nil
     end
   end
 
@@ -101,31 +101,31 @@ def conditional(expression, &block)
     CONFIG
 
     sample("foo" => "bar", "nest" => 124) do
-      insist { subject["always"] }.nil?
-      insist { subject["hello"] }.nil?
-      insist { subject["fancy"] }.nil?
-      insist { subject["free"] }.nil?
+      expect(subject["always"]).to be_nil
+      expect(subject["hello"]).to be_nil
+      expect(subject["fancy"]).to be_nil
+      expect(subject["free"]).to be_nil
     end
 
     sample("foo" => "bar", "nest" => 123) do
-      insist { subject["always"] } == "awesome"
-      insist { subject["hello"] } == "world"
-      insist { subject["fancy"] }.nil?
-      insist { subject["free"] }.nil?
+      expect(subject["always"]).to eq("awesome")
+      expect(subject["hello"]).to eq("world")
+      expect(subject["fancy"]).to be_nil
+      expect(subject["free"]).to be_nil
     end
 
     sample("notfoo" => "bar", "nest" => 123) do
-      insist { subject["always"] } == "awesome"
-      insist { subject["hello"] }.nil?
-      insist { subject["fancy"] }.nil?
-      insist { subject["free"] } == "hugs"
+      expect(subject["always"]).to eq("awesome")
+      expect(subject["hello"]).to be_nil
+      expect(subject["fancy"]).to be_nil
+      expect(subject["free"]).to eq("hugs")
     end
 
     sample("bar" => "baz", "nest" => 123) do
-      insist { subject["always"] } == "awesome"
-      insist { subject["hello"] }.nil?
-      insist { subject["fancy"] } == "pants"
-      insist { subject["free"] }.nil?
+      expect(subject["always"]).to eq("awesome")
+      expect(subject["hello"]).to be_nil
+      expect(subject["fancy"]).to eq("pants")
+      expect(subject["free"]).to be_nil
     end
   end
 
@@ -139,7 +139,7 @@ def conditional(expression, &block)
     CONFIG
 
     sample("foo" => 123, "bar" => 123) do
-      insist { subject["tags"] }.include?("woot")
+      expect(subject["tags"] ).to include("woot")
     end
   end
 
@@ -168,12 +168,12 @@ def conditional(expression, &block)
     CONFIG
 
     sample("foo" => "foo", "foobar" => "foobar", "greeting" => "hello world") do
-      insist { subject["tags"] }.include?("field in field")
-      insist { subject["tags"] }.include?("field in string")
-      insist { subject["tags"] }.include?("string in field")
-      insist { subject["tags"] }.include?("field in list")
-      reject { subject["tags"] }.include?("shouldnotexist")
-      insist { subject["tags"] }.include?("shouldexist")
+      expect(subject["tags"]).to include("field in field")
+      expect(subject["tags"]).to include("field in string")
+      expect(subject["tags"]).to include("string in field")
+      expect(subject["tags"]).to include("field in list")
+      expect(subject["tags"]).not_to include("shouldnotexist")
+      expect(subject["tags"]).to include("shouldexist")
     end
   end
 
@@ -191,107 +191,107 @@ def conditional(expression, &block)
 
     sample("foo" => "foo", "somelist" => [ "one", "two" ], "foobar" => "foobar", "greeting" => "hello world", "tags" => [ "fancypantsy" ]) do
       # verify the original exists
-      insist { subject["tags"] }.include?("fancypantsy")
+      expect(subject["tags"]).to include("fancypantsy")
 
-      insist { subject["tags"] }.include?("baz")
-      reject { subject["tags"] }.include?("foo")
-      insist { subject["tags"] }.include?("notfoo")
-      insist { subject["tags"] }.include?("notsomelist")
-      reject { subject["tags"] }.include?("somelist")
-      insist { subject["tags"] }.include?("no string in missing field")
+      expect(subject["tags"]).to include("baz")
+      expect(subject["tags"]).not_to include("foo")
+      expect(subject["tags"]).to include("notfoo")
+      expect(subject["tags"]).to include("notsomelist")
+      expect(subject["tags"]).not_to include("somelist")
+      expect(subject["tags"]).to include("no string in missing field")
     end
   end
 
   describe "operators" do
     conditional "[message] == 'sample'" do
-      sample("sample") { insist { subject["tags"] }.include?("success") }
-      sample("different") { insist { subject["tags"] }.include?("failure") }
+      sample("sample") { expect(subject["tags"] ).to include("success") }
+      sample("different") { expect(subject["tags"] ).to include("failure") }
     end
 
     conditional "[message] != 'sample'" do
-      sample("sample") { insist { subject["tags"] }.include?("failure") }
-      sample("different") { insist { subject["tags"] }.include?("success") }
+      sample("sample") { expect(subject["tags"] ).to include("failure") }
+      sample("different") { expect(subject["tags"] ).to include("success") }
     end
 
     conditional "[message] < 'sample'" do
-      sample("apple") { insist { subject["tags"] }.include?("success") }
-      sample("zebra") { insist { subject["tags"] }.include?("failure") }
+      sample("apple") { expect(subject["tags"] ).to include("success") }
+      sample("zebra") { expect(subject["tags"] ).to include("failure") }
     end
 
     conditional "[message] > 'sample'" do
-      sample("zebra") { insist { subject["tags"] }.include?("success") }
-      sample("apple") { insist { subject["tags"] }.include?("failure") }
+      sample("zebra") { expect(subject["tags"] ).to include("success") }
+      sample("apple") { expect(subject["tags"] ).to include("failure") }
     end
 
     conditional "[message] <= 'sample'" do
-      sample("apple") { insist { subject["tags"] }.include?("success") }
-      sample("zebra") { insist { subject["tags"] }.include?("failure") }
-      sample("sample") { insist { subject["tags"] }.include?("success") }
+      sample("apple") { expect(subject["tags"] ).to include("success") }
+      sample("zebra") { expect(subject["tags"] ).to include("failure") }
+      sample("sample") { expect(subject["tags"] ).to include("success") }
     end
 
     conditional "[message] >= 'sample'" do
-      sample("zebra") { insist { subject["tags"] }.include?("success") }
-      sample("sample") { insist { subject["tags"] }.include?("success") }
-      sample("apple") { insist { subject["tags"] }.include?("failure") }
+      sample("zebra") { expect(subject["tags"] ).to include("success") }
+      sample("sample") { expect(subject["tags"] ).to include("success") }
+      sample("apple") { expect(subject["tags"] ).to include("failure") }
     end
 
     conditional "[message] =~ /sample/" do
-      sample("apple") { insist { subject["tags"] }.include?("failure") }
-      sample("sample") { insist { subject["tags"] }.include?("success") }
-      sample("some sample") { insist { subject["tags"] }.include?("success") }
+      sample("apple") { expect(subject["tags"] ).to include("failure") }
+      sample("sample") { expect(subject["tags"] ).to include("success") }
+      sample("some sample") { expect(subject["tags"] ).to include("success") }
     end
 
     conditional "[message] !~ /sample/" do
-      sample("apple") { insist { subject["tags"] }.include?("success") }
-      sample("sample") { insist { subject["tags"] }.include?("failure") }
-      sample("some sample") { insist { subject["tags"] }.include?("failure") }
+      sample("apple") { expect(subject["tags"]).to include("success") }
+      sample("sample") { expect(subject["tags"]).to include("failure") }
+      sample("some sample") { expect(subject["tags"]).to include("failure") }
     end
 
   end
 
   describe "negated expressions" do
     conditional "!([message] == 'sample')" do
-      sample("sample") { reject { subject["tags"] }.include?("success") }
-      sample("different") { reject { subject["tags"] }.include?("failure") }
+      sample("sample") { expect(subject["tags"]).not_to include("success") }
+      sample("different") { expect(subject["tags"]).not_to include("failure") }
     end
 
     conditional "!([message] != 'sample')" do
-      sample("sample") { reject { subject["tags"] }.include?("failure") }
-      sample("different") { reject { subject["tags"] }.include?("success") }
+      sample("sample") { expect(subject["tags"]).not_to include("failure") }
+      sample("different") { expect(subject["tags"]).not_to include("success") }
     end
 
     conditional "!([message] < 'sample')" do
-      sample("apple") { reject { subject["tags"] }.include?("success") }
-      sample("zebra") { reject { subject["tags"] }.include?("failure") }
+      sample("apple") { expect(subject["tags"]).not_to include("success") }
+      sample("zebra") { expect(subject["tags"]).not_to include("failure") }
     end
 
     conditional "!([message] > 'sample')" do
-      sample("zebra") { reject { subject["tags"] }.include?("success") }
-      sample("apple") { reject { subject["tags"] }.include?("failure") }
+      sample("zebra") { expect(subject["tags"]).not_to include("success") }
+      sample("apple") { expect(subject["tags"]).not_to include("failure") }
     end
 
     conditional "!([message] <= 'sample')" do
-      sample("apple") { reject { subject["tags"] }.include?("success") }
-      sample("zebra") { reject { subject["tags"] }.include?("failure") }
-      sample("sample") { reject { subject["tags"] }.include?("success") }
+      sample("apple") { expect(subject["tags"]).not_to include("success") }
+      sample("zebra") { expect(subject["tags"]).not_to include("failure") }
+      sample("sample") { expect(subject["tags"]).not_to include("success") }
     end
 
     conditional "!([message] >= 'sample')" do
-      sample("zebra") { reject { subject["tags"] }.include?("success") }
-      sample("sample") { reject { subject["tags"] }.include?("success") }
-      sample("apple") { reject { subject["tags"] }.include?("failure") }
+      sample("zebra") { expect(subject["tags"]).not_to include("success") }
+      sample("sample") { expect(subject["tags"]).not_to include("success") }
+      sample("apple") { expect(subject["tags"]).not_to include("failure") }
     end
 
     conditional "!([message] =~ /sample/)" do
-      sample("apple") { reject { subject["tags"] }.include?("failure") }
-      sample("sample") { reject { subject["tags"] }.include?("success") }
-      sample("some sample") { reject { subject["tags"] }.include?("success") }
+      sample("apple") { expect(subject["tags"]).not_to include("failure") }
+      sample("sample") { expect(subject["tags"]).not_to include("success") }
+      sample("some sample") { expect(subject["tags"]).not_to include("success") }
     end
 
     conditional "!([message] !~ /sample/)" do
-      sample("apple") { reject { subject["tags"] }.include?("success") }
-      sample("sample") { reject { subject["tags"] }.include?("failure") }
-      sample("some sample") { reject { subject["tags"] }.include?("failure") }
+      sample("apple") { expect(subject["tags"]).not_to include("success") }
+      sample("sample") { expect(subject["tags"]).not_to include("failure") }
+      sample("some sample") { expect(subject["tags"]).not_to include("failure") }
     end
 
   end
@@ -299,47 +299,47 @@ def conditional(expression, &block)
   describe "value as an expression" do
     # testing that a field has a value should be true.
     conditional "[message]" do
-      sample("apple") { insist { subject["tags"] }.include?("success") }
-      sample("sample") { insist { subject["tags"] }.include?("success") }
-      sample("some sample") { insist { subject["tags"] }.include?("success") }
+      sample("apple") { expect(subject["tags"]).to include("success") }
+      sample("sample") { expect(subject["tags"]).to include("success") }
+      sample("some sample") { expect(subject["tags"]).to include("success") }
     end
 
     # testing that a missing field has a value should be false.
     conditional "[missing]" do
-      sample("apple") { insist { subject["tags"] }.include?("failure") }
-      sample("sample") { insist { subject["tags"] }.include?("failure") }
-      sample("some sample") { insist { subject["tags"] }.include?("failure") }
+      sample("apple") { expect(subject["tags"]).to include("failure") }
+      sample("sample") { expect(subject["tags"]).to include("failure") }
+      sample("some sample") { expect(subject["tags"]).to include("failure") }
     end
   end
 
   describe "logic operators" do
     describe "and" do
       conditional "[message] and [message]" do
-        sample("whatever") { insist { subject["tags"] }.include?("success") }
+        sample("whatever") { expect(subject["tags"]).to include("success") }
       end
       conditional "[message] and ![message]" do
-        sample("whatever") { insist { subject["tags"] }.include?("failure") }
+        sample("whatever") { expect(subject["tags"]).to include("failure") }
       end
       conditional "![message] and [message]" do
-        sample("whatever") { insist { subject["tags"] }.include?("failure") }
+        sample("whatever") { expect(subject["tags"]).to include("failure") }
       end
       conditional "![message] and ![message]" do
-        sample("whatever") { insist { subject["tags"] }.include?("failure") }
+        sample("whatever") { expect(subject["tags"]).to include("failure") }
       end
     end
 
     describe "or" do
       conditional "[message] or [message]" do
-        sample("whatever") { insist { subject["tags"] }.include?("success") }
+        sample("whatever") { expect(subject["tags"]).to include("success") }
       end
       conditional "[message] or ![message]" do
-        sample("whatever") { insist { subject["tags"] }.include?("success") }
+        sample("whatever") { expect(subject["tags"]).to include("success") }
       end
       conditional "![message] or [message]" do
-        sample("whatever") { insist { subject["tags"] }.include?("success") }
+        sample("whatever") { expect(subject["tags"]).to include("success") }
       end
       conditional "![message] or ![message]" do
-        sample("whatever") { insist { subject["tags"] }.include?("failure") }
+        sample("whatever") { expect(subject["tags"]).to include("failure") }
       end
     end
   end
@@ -347,19 +347,19 @@ def conditional(expression, &block)
   describe "field references" do
     conditional "[field with space]" do
       sample("field with space" => "hurray") do
-        insist { subject["tags"].include?("success") }
+        expect(subject["tags"]).to include("success")
       end
     end
 
     conditional "[field with space] == 'hurray'" do
       sample("field with space" => "hurray") do
-        insist { subject["tags"].include?("success") }
+        expect(subject["tags"]).to include("success")
       end
     end
 
     conditional "[nested field][reference with][some spaces] == 'hurray'" do
       sample({"nested field" => { "reference with" => { "some spaces" => "hurray" } } }) do
-        insist { subject["tags"].include?("success") }
+        expect(subject["tags"]).to include("success")
       end
     end
   end
@@ -381,16 +381,16 @@ def conditional(expression, &block)
     CONFIG
 
     sample({"type" => "original"}) do
-      insist { subject }.is_a?(Array)
-      insist { subject.length } == 2
+      expect(subject).to be_an(Array)
+      expect(subject.length).to eq(2)
 
-      insist { subject[0]["type"] } == "original"
-      insist { subject[0]["cond1"] } == "true"
-      insist { subject[0]["cond2"] } == nil
+      expect(subject[0]["type"]).to eq("original")
+      expect(subject[0]["cond1"]).to eq("true")
+      expect(subject[0]["cond2"]).to eq(nil)
 
-      insist { subject[1]["type"] } == "clone"
-      # insist { subject[1]["cond1"] } == nil
-      # insist { subject[1]["cond2"] } == "true"
+      expect(subject[1]["type"]).to eq("clone")
+      # expect(subject[1]["cond1"]).to eq(nil)
+      # expect(subject[1]["cond2"]).to eq("true")
     end
   end
 end
diff --git a/spec/core/config_spec.rb b/spec/core/config_spec.rb
index 2221540536b..377f26b6861 100644
--- a/spec/core/config_spec.rb
+++ b/spec/core/config_spec.rb
@@ -16,7 +16,7 @@
       }
     ))
 
-    reject { config }.nil?
+    expect(config).not_to be_nil
   end
 
   it "should permit empty plugin sections" do
@@ -26,6 +26,6 @@
       }
     ))
 
-    reject { config }.nil?
+    expect(config).not_to be_nil
   end
 end
diff --git a/spec/core/event_spec.rb b/spec/core/event_spec.rb
index 388d102bb24..465af9870b8 100644
--- a/spec/core/event_spec.rb
+++ b/spec/core/event_spec.rb
@@ -1,7 +1,6 @@
 # encoding: utf-8
 
 require "logstash/event"
-require "insist"
 
 describe LogStash::Event do
   subject do
@@ -30,63 +29,63 @@
 
   context "[]=" do
     it "should raise an exception if you attempt to set @timestamp to a value type other than a Time object" do
-      insist { subject["@timestamp"] = "crash!" }.raises(TypeError)
+      expect{subject["@timestamp"] = "crash!"}.to raise_error(TypeError)
     end
 
     it "should assign simple fields" do
-      insist { subject["foo"] }.nil?
-      insist { subject["foo"] = "bar" } == "bar"
-      insist { subject["foo"] } == "bar"
+      expect(subject["foo"]).to be_nil
+      expect(subject["foo"] = "bar").to eq("bar")
+      expect(subject["foo"]).to eq("bar")
     end
 
     it "should overwrite simple fields" do
-      insist { subject["foo"] }.nil?
-      insist { subject["foo"] = "bar"} == "bar"
-      insist { subject["foo"] } == "bar"
+      expect(subject["foo"]).to be_nil
+      expect(subject["foo"] = "bar").to eq("bar")
+      expect(subject["foo"]).to eq("bar")
 
-      insist { subject["foo"] = "baz"} == "baz"
-      insist { subject["foo"] } == "baz"
+      expect(subject["foo"] = "baz").to eq("baz")
+      expect(subject["foo"]).to eq("baz")
     end
 
     it "should assign deep fields" do
-      insist { subject["[foo][bar]"] }.nil?
-      insist { subject["[foo][bar]"] = "baz"} == "baz"
-      insist { subject["[foo][bar]"] } == "baz"
+      expect(subject["[foo][bar]"]).to be_nil
+      expect(subject["[foo][bar]"] = "baz").to eq("baz")
+      expect(subject["[foo][bar]"]).to eq("baz")
     end
 
     it "should overwrite deep fields" do
-      insist { subject["[foo][bar]"] }.nil?
-      insist { subject["[foo][bar]"] = "baz"} == "baz"
-      insist { subject["[foo][bar]"] } == "baz"
+      expect(subject["[foo][bar]"]).to be_nil
+      expect(subject["[foo][bar]"] = "baz").to eq("baz")
+      expect(subject["[foo][bar]"]).to eq("baz")
 
-      insist { subject["[foo][bar]"] = "zab"} == "zab"
-      insist { subject["[foo][bar]"] } == "zab"
+      expect(subject["[foo][bar]"] = "zab").to eq("zab")
+      expect(subject["[foo][bar]"]).to eq("zab")
     end
   end
 
   context "#sprintf" do
     it "should report a unix timestamp for %{+%s}" do
-      insist { subject.sprintf("%{+%s}") } == "1356998400"
+      expect(subject.sprintf("%{+%s}")).to eq("1356998400")
     end
 
     it "should report a time with %{+format} syntax", :if => RUBY_ENGINE == "jruby" do
-      insist { subject.sprintf("%{+YYYY}") } == "2013"
-      insist { subject.sprintf("%{+MM}") } == "01"
-      insist { subject.sprintf("%{+HH}") } == "00"
+      expect(subject.sprintf("%{+YYYY}")).to eq("2013")
+      expect(subject.sprintf("%{+MM}")).to eq("01")
+      expect(subject.sprintf("%{+HH}")).to eq("00")
     end
 
     it "should report fields with %{field} syntax" do
-      insist { subject.sprintf("%{type}") } == "sprintf"
-      insist { subject.sprintf("%{message}") } == subject["message"]
+      expect(subject.sprintf("%{type}")).to eq("sprintf")
+      expect(subject.sprintf("%{message}")).to eq(subject["message"])
     end
 
     it "should print deep fields" do
-      insist { subject.sprintf("%{[j][k1]}") } == "v"
-      insist { subject.sprintf("%{[j][k2][0]}") } == "w"
+      expect(subject.sprintf("%{[j][k1]}")).to eq("v")
+      expect(subject.sprintf("%{[j][k2][0]}")).to eq("w")
     end
 
     it "should be able to take a non-string for the format" do
-      insist { subject.sprintf(2) } == "2"
+      expect(subject.sprintf(2)).to eq("2")
     end
 
     it "should allow to use the metadata when calling #sprintf" do
@@ -100,18 +99,18 @@
 
   context "#[]" do
     it "should fetch data" do
-      insist { subject["type"] } == "sprintf"
+      expect(subject["type"]).to eq("sprintf")
     end
     it "should fetch fields" do
-      insist { subject["a"] } == "b"
-      insist { subject['c']['d'] } == "f"
+      expect(subject["a"]).to eq("b")
+      expect(subject['c']['d']).to eq("f")
     end
     it "should fetch deep fields" do
-      insist { subject["[j][k1]"] } == "v"
-      insist { subject["[c][d]"] } == "f"
-      insist { subject['[f][g][h]'] } == "i"
-      insist { subject['[j][k3][4]'] } == "m"
-      insist { subject['[j][5]'] } == 7
+      expect(subject["[j][k1]"]).to eq("v")
+      expect(subject["[c][d]"]).to eq("f")
+      expect(subject['[f][g][h]']).to eq("i")
+      expect(subject['[j][k3][4]']).to eq("m")
+      expect(subject['[j][5]']).to eq(7)
 
     end
 
@@ -134,11 +133,11 @@
       )
       subject.overwrite(new_event)
 
-      insist { subject["message"] } == "foo bar"
-      insist { subject["type"] } == "new"
+      expect(subject["message"]).to eq("foo bar")
+      expect(subject["type"]).to eq("new")
 
       ["tags", "source", "a", "c", "f", "j"].each do |field|
-        insist { subject[field] } == nil
+        expect(subject[field]).to be_nil
       end
     end
   end
@@ -146,22 +145,22 @@
   context "#append" do
     it "should append strings to an array" do
       subject.append(LogStash::Event.new("message" => "another thing"))
-      insist { subject["message"] } == [ "hello world", "another thing" ]
+      expect(subject["message"]).to eq([ "hello world", "another thing" ])
     end
 
     it "should concatenate tags" do
       subject.append(LogStash::Event.new("tags" => [ "tag2" ]))
-      insist { subject["tags"] } == [ "tag1", "tag2" ]
+      expect(subject["tags"]).to eq([ "tag1", "tag2" ])
     end
 
     context "when event field is nil" do
       it "should add single value as string" do
         subject.append(LogStash::Event.new({"field1" => "append1"}))
-        insist { subject[ "field1" ] } == "append1"
+        expect(subject[ "field1" ]).to eq("append1")
       end
       it "should add multi values as array" do
         subject.append(LogStash::Event.new({"field1" => [ "append1","append2" ]}))
-        insist { subject[ "field1" ] } == [ "append1","append2" ]
+        expect(subject[ "field1" ]).to eq([ "append1","append2" ])
       end
     end
 
@@ -170,19 +169,19 @@
 
       it "should append string to values, if different from current" do
         subject.append(LogStash::Event.new({"field1" => "append1"}))
-        insist { subject[ "field1" ] } == [ "original1", "append1" ]
+        expect(subject[ "field1" ]).to eq([ "original1", "append1" ])
       end
       it "should not change value, if appended value is equal current" do
         subject.append(LogStash::Event.new({"field1" => "original1"}))
-        insist { subject[ "field1" ] } == "original1"
+        expect(subject[ "field1" ]).to eq("original1")
       end
       it "should concatenate values in an array" do
         subject.append(LogStash::Event.new({"field1" => [ "append1" ]}))
-        insist { subject[ "field1" ] } == [ "original1", "append1" ]
+        expect(subject[ "field1" ]).to eq([ "original1", "append1" ])
       end
       it "should join array, removing duplicates" do
         subject.append(LogStash::Event.new({"field1" => [ "append1","original1" ]}))
-        insist { subject[ "field1" ] } == [ "original1", "append1" ]
+        expect(subject[ "field1" ]).to eq([ "original1", "append1" ])
       end
     end
     context "when event field is an array" do
@@ -190,15 +189,15 @@
 
       it "should append string values to array, if not present in array" do
         subject.append(LogStash::Event.new({"field1" => "append1"}))
-        insist { subject[ "field1" ] } == [ "original1", "original2", "append1" ]
+        expect(subject[ "field1" ]).to eq([ "original1", "original2", "append1" ])
       end
       it "should not append string values, if the array already contains it" do
         subject.append(LogStash::Event.new({"field1" => "original1"}))
-        insist { subject[ "field1" ] } == [ "original1", "original2" ]
+        expect(subject[ "field1" ]).to eq([ "original1", "original2" ])
       end
       it "should join array, removing duplicates" do
         subject.append(LogStash::Event.new({"field1" => [ "append1","original1" ]}))
-        insist { subject[ "field1" ] } == [ "original1", "original2", "append1" ]
+        expect(subject[ "field1" ]).to eq([ "original1", "original2", "append1" ])
       end
     end
   end
@@ -209,7 +208,7 @@
 
     data = { "@timestamp" => "2013-12-21T07:25:06.605Z" }
     event = LogStash::Event.new(data)
-    insist { event["@timestamp"] }.is_a?(LogStash::Timestamp)
+    expect(event["@timestamp"]).to be_a(LogStash::Timestamp)
 
     duration = 0
     [warmup, count].each do |i|
@@ -263,15 +262,15 @@
     it "should coerce timestamp" do
       t = Time.iso8601("2014-06-12T00:12:17.114Z")
       expect(LogStash::Timestamp).to receive(:coerce).exactly(3).times.and_call_original
-      insist{LogStash::Event.new("@timestamp" => t).timestamp.to_i} == t.to_i
-      insist{LogStash::Event.new("@timestamp" => LogStash::Timestamp.new(t)).timestamp.to_i} == t.to_i
-      insist{LogStash::Event.new("@timestamp" => "2014-06-12T00:12:17.114Z").timestamp.to_i} == t.to_i
+      expect(LogStash::Event.new("@timestamp" => t).timestamp.to_i).to eq(t.to_i)
+      expect(LogStash::Event.new("@timestamp" => LogStash::Timestamp.new(t)).timestamp.to_i).to eq(t.to_i)
+      expect(LogStash::Event.new("@timestamp" => "2014-06-12T00:12:17.114Z").timestamp.to_i).to eq(t.to_i)
     end
 
     it "should assign current time when no timestamp" do
       ts = LogStash::Timestamp.now
       expect(LogStash::Timestamp).to receive(:now).and_return(ts)
-      insist{LogStash::Event.new({}).timestamp.to_i} == ts.to_i
+      expect(LogStash::Event.new({}).timestamp.to_i).to eq(ts.to_i)
     end
 
     it "should tag and warn for invalid value" do
@@ -281,14 +280,14 @@
       expect(logger).to receive(:warn).twice
 
       event = LogStash::Event.new("@timestamp" => :foo)
-      insist{event.timestamp.to_i} == ts.to_i
-      insist{event["tags"]} == [LogStash::Event::TIMESTAMP_FAILURE_TAG]
-      insist{event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]} == :foo
+      expect(event.timestamp.to_i).to eq(ts.to_i)
+      expect(event["tags"]).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
+      expect(event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]).to eq(:foo)
 
       event = LogStash::Event.new("@timestamp" => 666)
-      insist{event.timestamp.to_i} == ts.to_i
-      insist{event["tags"]} == [LogStash::Event::TIMESTAMP_FAILURE_TAG]
-      insist{event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]} == 666
+      expect(event.timestamp.to_i).to eq(ts.to_i)
+      expect(event["tags"]).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
+      expect(event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]).to eq(666)
     end
 
     it "should tag and warn for invalid string format" do
@@ -298,9 +297,9 @@
       expect(logger).to receive(:warn)
 
       event = LogStash::Event.new("@timestamp" => "foo")
-      insist{event.timestamp.to_i} == ts.to_i
-      insist{event["tags"]} == [LogStash::Event::TIMESTAMP_FAILURE_TAG]
-      insist{event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]} == "foo"
+      expect(event.timestamp.to_i).to eq(ts.to_i)
+      expect(event["tags"]).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
+      expect(event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]).to eq("foo")
     end
   end
 
@@ -312,7 +311,7 @@
       )
       json = new_event.to_json
 
-      insist { json } ==  "{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}"
+      expect(json).to eq( "{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}")
     end
 
     it "should support to_json and ignore arguments" do
@@ -322,7 +321,7 @@
       )
       json = new_event.to_json(:foo => 1, :bar => "baz")
 
-      insist { json } ==  "{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}"
+      expect(json).to eq( "{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}")
     end
   end
 
@@ -331,14 +330,14 @@
       subject { LogStash::Event.new("hello" => "world", "@metadata" => { "fancy" => "pants" }) }
 
       it "should not include metadata in to_hash" do
-        reject { subject.to_hash.keys }.include?("@metadata")
+        expect(subject.to_hash.keys).not_to include("@metadata")
 
         # 'hello', '@timestamp', and '@version'
-        insist { subject.to_hash.keys.count } == 3
+        expect(subject.to_hash.keys.count).to eq(3)
       end
 
       it "should still allow normal field access" do
-        insist { subject["hello"] } == "world"
+        expect(subject["hello"]).to eq("world")
       end
     end
 
@@ -348,44 +347,44 @@
       subject { LogStash::Event.new("normal" => "normal") }
       before do
         # Verify the test is configured correctly.
-        insist { fieldref }.start_with?("[@metadata]")
+        expect(fieldref).to start_with("[@metadata]")
 
         # Set it.
         subject[fieldref] = value
       end
 
       it "should still allow normal field access" do
-        insist { subject["normal"] } == "normal"
+        expect(subject["normal"]).to eq("normal")
       end
 
       it "should allow getting" do
-        insist { subject[fieldref] } == value
+        expect(subject[fieldref]).to eq(value)
       end
 
       it "should be hidden from .to_json" do
         require "json"
         obj = JSON.parse(subject.to_json)
-        reject { obj }.include?("@metadata")
+        expect(obj).not_to include("@metadata")
       end
 
       it "should be hidden from .to_hash" do
-        reject { subject.to_hash }.include?("@metadata")
+        expect(subject.to_hash).not_to include("@metadata")
       end
 
       it "should be accessible through #to_hash_with_metadata" do
         obj = subject.to_hash_with_metadata
-        insist { obj }.include?("@metadata")
-        insist { obj["@metadata"]["foo"]["bar"] } == value
+        expect(obj).to include("@metadata")
+        expect(obj["@metadata"]["foo"]["bar"]).to eq(value)
       end
     end
-    
+
     context "with no metadata" do
       subject { LogStash::Event.new("foo" => "bar") }
       it "should have no metadata" do
-        insist { subject["@metadata"] }.empty?
+        expect(subject["@metadata"]).to be_empty
       end
       it "should still allow normal field access" do
-        insist { subject["foo"] } == "bar"
+        expect(subject["foo"]).to eq("bar")
       end
     end
 
diff --git a/spec/core/pipeline_spec.rb b/spec/core/pipeline_spec.rb
index 127b8326665..8ac4a6c786a 100644
--- a/spec/core/pipeline_spec.rb
+++ b/spec/core/pipeline_spec.rb
@@ -98,19 +98,19 @@ class TestPipeline < LogStash::Pipeline
       pipeline = TestPipeline.new(test_config_without_output_workers)
       pipeline.run
 
-      insist { pipeline.outputs.size } == 1
-      insist { pipeline.outputs.first.worker_plugins.size } == 1
-      insist { pipeline.outputs.first.worker_plugins.first.num_teardowns } == 1
+      expect(pipeline.outputs.size ).to eq(1)
+      expect(pipeline.outputs.first.worker_plugins.size ).to eq(1)
+      expect(pipeline.outputs.first.worker_plugins.first.num_teardowns ).to eq(1)
     end
 
     it "should call output teardown correctly with output workers" do
       pipeline = TestPipeline.new(test_config_with_output_workers)
       pipeline.run
 
-      insist { pipeline.outputs.size } == 1
-      insist { pipeline.outputs.first.num_teardowns } == 0
+      expect(pipeline.outputs.size ).to eq(1)
+      expect(pipeline.outputs.first.num_teardowns).to eq(0)
       pipeline.outputs.first.worker_plugins.each do |plugin|
-        insist { plugin.num_teardowns } == 1
+        expect(plugin.num_teardowns ).to eq(1)
       end
     end
   end
diff --git a/spec/core/web_spec.rb b/spec/core/web_spec.rb
index 2a5947546a2..e3686a24a1a 100644
--- a/spec/core/web_spec.rb
+++ b/spec/core/web_spec.rb
@@ -1,5 +1,3 @@
-require "insist"
-
 describe "web tests" do
   context "rack rubygem" do
     it "must be available" do
diff --git a/spec/inputs/base_spec.rb b/spec/inputs/base_spec.rb
index e53280f86a0..29e3bf151ba 100644
--- a/spec/inputs/base_spec.rb
+++ b/spec/inputs/base_spec.rb
@@ -8,6 +8,6 @@
     plain = LogStash::Codecs::Plain.new("charset" => "CP1252")
     tcp = LogStash::Inputs::Tcp.new("codec" => plain, "port" => 3333)
     tcp.instance_eval { fix_streaming_codecs }
-    insist { tcp.codec.charset } == "CP1252"
+    expect(tcp.codec.charset).to eq("CP1252")
   end
 end
diff --git a/spec/util/accessors_spec.rb b/spec/util/accessors_spec.rb
index bd5e96cff95..2ae526d3de0 100644
--- a/spec/util/accessors_spec.rb
+++ b/spec/util/accessors_spec.rb
@@ -11,45 +11,45 @@
       str = "hello"
       data = { "hello" => "world" }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.get(str) } == data[str]
+      expect(accessors.get(str)).to eq(data[str])
     end
 
     it "should get value of key with spaces" do
       str = "hel lo"
       data = { "hel lo" => "world" }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.get(str) } == data[str]
+      expect(accessors.get(str)).to eq(data[str])
     end
 
     it "should get value of numeric key string" do
       str = "1"
       data = { "1" => "world" }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.get(str) } == data[str]
+      expect(accessors.get(str)).to eq(data[str])
     end
 
     it "should handle delete" do
       str = "simple"
       data = { "simple" => "things" }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.del(str) } == "things"
-      insist { data }.empty?
+      expect(accessors.del(str)).to eq("things")
+      expect(data).to be_empty
     end
 
     it "should set string value" do
       str = "simple"
       data = {}
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.set(str, "things") } == "things"
-      insist { data } == { "simple" => "things" }
+      expect(accessors.set(str, "things")).to eq("things")
+      expect(data).to eq({ "simple" => "things" })
     end
 
     it "should set array value" do
       str = "simple"
       data = {}
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.set(str, ["foo", "bar"]) } == ["foo", "bar"]
-      insist { data } == { "simple" => ["foo", "bar"]}
+      expect(accessors.set(str, ["foo", "bar"])).to eq(["foo", "bar"])
+      expect(data).to eq({ "simple" => ["foo", "bar"]})
     end
   end
 
@@ -59,118 +59,118 @@
       str = "[hello]"
       data = { "hello" =>  "world" }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.get(str) } == "world"
+      expect(accessors.get(str)).to eq("world")
     end
 
     it "should get shallow string value of key with spaces" do
       str = "[hel lo]"
       data = { "hel lo" =>  "world" }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.get(str) } == "world"
+      expect(accessors.get(str)).to eq("world")
     end
 
     it "should get shallow string value of numeric key string" do
       str = "[1]"
       data = { "1" =>  "world" }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.get(str) } == "world"
+      expect(accessors.get(str)).to eq("world")
     end
 
     it "should get deep string value" do
       str = "[hello][world]"
       data = { "hello" => { "world" => "foo", "bar" => "baz" } }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.get(str) } == data["hello"]["world"]
+      expect(accessors.get(str)).to eq(data["hello"]["world"])
     end
 
     it "should return nil when getting a non-existant field (with no side-effects on original data)" do
       str = "[hello][world]"
       data = {}
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.get(str) }.nil?
-      insist { data } == {}
-      insist { accessors.set(str, "foo") } == "foo"
-      insist { data } == { "hello" => {"world" => "foo"} }
+      expect(accessors.get(str)).to be_nil
+      expect(data).to  be_empty
+      expect(accessors.set(str, "foo")).to eq("foo")
+      expect(data).to eq({ "hello" => {"world" => "foo"} })
     end
 
     it "should handle delete" do
       str = "[hello][world]"
       data = { "hello" => { "world" => "foo", "bar" => "baz" } }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.del(str) } ==  "foo"
+      expect(accessors.del(str)).to eq("foo")
 
       # Make sure the "world" key is removed.
-      insist { data["hello"] } == { "bar" => "baz" }
+      expect(data["hello"]).to eq({ "bar" => "baz" })
     end
 
     it "should set shallow string value" do
       str = "[hello]"
       data = {}
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.set(str, "foo") } == "foo"
-      insist { data } == { "hello" => "foo" }
+      expect(accessors.set(str, "foo")).to eq("foo")
+      expect(data).to eq({ "hello" => "foo" })
     end
 
     it "should strict_set shallow string value" do
       str = "[hello]"
       data = {}
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.strict_set(str, "foo") } == "foo"
-      insist { data } == { "hello" => "foo" }
+      expect(accessors.strict_set(str, "foo")).to eq("foo")
+      expect(data).to eq({ "hello" => "foo"})
     end
 
     it "should set deep string value" do
       str = "[hello][world]"
       data = {}
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.set(str, "foo") } == "foo"
-      insist { data } == { "hello" => { "world" => "foo" } }
+      expect(accessors.set(str, "foo")).to eq("foo")
+      expect(data).to eq({ "hello" => { "world" => "foo" } })
     end
 
     it "should set deep array value" do
       str = "[hello][world]"
       data = {}
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.set(str, ["foo", "bar"]) } == ["foo", "bar"]
-      insist { data } == { "hello" => { "world" => ["foo", "bar"] } }
+      expect(accessors.set(str, ["foo", "bar"])).to eq(["foo", "bar"])
+      expect(data).to eq({ "hello" => { "world" => ["foo", "bar"] } })
     end
 
     it "should strict_set deep array value" do
       str = "[hello][world]"
       data = {}
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.strict_set(str, ["foo", "bar"]) } == ["foo", "bar"]
-      insist { data } == { "hello" => { "world" => ["foo", "bar"] } }
+      expect(accessors.strict_set(str, ["foo", "bar"]) ).to eq(["foo", "bar"])
+      expect(data).to eq({ "hello" => { "world" => ["foo", "bar"] } })
     end
 
     it "should set element within array value" do
       str = "[hello][0]"
       data = {"hello" => ["foo", "bar"]}
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.set(str, "world") } == "world"
-      insist { data } == {"hello" => ["world", "bar"]}
+      expect(accessors.set(str, "world") ).to eq("world")
+      expect(data).to eq({"hello" => ["world", "bar"]})
     end
 
     it "should retrieve array item" do
       data = { "hello" => { "world" => ["a", "b"], "bar" => "baz" } }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.get("[hello][world][0]") } == data["hello"]["world"][0]
-      insist { accessors.get("[hello][world][1]") } == data["hello"]["world"][1]
+      expect(accessors.get("[hello][world][0]")).to eq(data["hello"]["world"][0])
+      expect(accessors.get("[hello][world][1]")).to eq(data["hello"]["world"][1])
     end
 
     it "should retrieve array item containing hash" do
       data = { "hello" => { "world" => [ { "a" => 123 }, { "b" => 345 } ], "bar" => "baz" } }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.get("[hello][world][0][a]") } == data["hello"]["world"][0]["a"]
-      insist { accessors.get("[hello][world][1][b]") } == data["hello"]["world"][1]["b"]
+      expect(accessors.get("[hello][world][0][a]")).to eq(data["hello"]["world"][0]["a"])
+      expect(accessors.get("[hello][world][1][b]")).to eq(data["hello"]["world"][1]["b"])
     end
 
     it "should handle delete of array element" do
       str = "[geocoords][0]"
       data = { "geocoords" => [4, 2] }
       accessors = LogStash::Util::Accessors.new(data)
-      insist { accessors.del(str) } == 4
-      insist { data } == { "geocoords" => [2] }
+      expect(accessors.del(str)).to eq(4)
+      expect(data).to eq({ "geocoords" => [2] })
     end  end
 
   context "using invalid encoding" do
diff --git a/spec/util/charset_spec.rb b/spec/util/charset_spec.rb
index 97d85494bf7..171087a3b42 100644
--- a/spec/util/charset_spec.rb
+++ b/spec/util/charset_spec.rb
@@ -11,9 +11,9 @@
 
     it "should return untouched data" do
       ["foobar", "κόσμε"].each do |data|
-        insist { data.encoding.name } == "UTF-8"
-        insist { subject.convert(data) } == data
-        insist { subject.convert(data).encoding.name } == "UTF-8"
+        expect(data.encoding.name).to eq("UTF-8")
+        expect(subject.convert(data)).to eq(data)
+        expect(subject.convert(data).encoding.name).to eq("UTF-8")
       end
     end
   end
@@ -27,12 +27,12 @@
 
     it "should escape invalid sequences" do
       ["foo \xED\xB9\x81\xC3", "bar \xAD"].each do |data|
-        insist { data.encoding.name } == "UTF-8"
-        insist { data.valid_encoding? } == false
+        expect(data.encoding.name).to eq("UTF-8")
+        expect(data.valid_encoding?).to eq(false)
         expect(logger).to receive(:warn).exactly(2).times
-#logger.should_receive(:warn).twice
-        insist { subject.convert(data) } == data.inspect[1..-2]
-        insist { subject.convert(data).encoding.name } == "UTF-8"
+        #logger.should_receive(:warn).twice
+        expect(subject.convert(data)).to eq(data.inspect[1..-2])
+        expect(subject.convert(data).encoding.name).to eq("UTF-8")
       end
     end
 
@@ -47,11 +47,11 @@
         ["\xE0 Montr\xE9al", "à Montréal"],
       ]
       samples.map{|(a, b)| [a.force_encoding("ISO-8859-1"), b]}.each do |(a, b)|
-        insist { a.encoding.name } == "ISO-8859-1"
-        insist { b.encoding.name } == "UTF-8"
-        insist { a.valid_encoding? } == true
-        insist { subject.convert(a).encoding.name } == "UTF-8"
-        insist { subject.convert(a) } == b
+        expect(a.encoding.name).to eq("ISO-8859-1")
+        expect(b.encoding.name).to eq("UTF-8")
+        expect(a.valid_encoding?).to eq(true)
+        expect(subject.convert(a).encoding.name).to eq("UTF-8")
+        expect(subject.convert(a)).to eq(b)
       end
     end
   end
@@ -65,10 +65,10 @@
         ["\xCE\xBA\xCF\x8C\xCF\x83\xCE\xBC\xCE\xB5", "����������"],
       ]
       samples.map{|(a, b)| [a.force_encoding("ASCII-8BIT"), b]}.each do |(a, b)|
-        insist { a.encoding.name } == "ASCII-8BIT"
-        insist { b.encoding.name } == "UTF-8"
-        insist { subject.convert(a).encoding.name } == "UTF-8"
-        insist { subject.convert(a) } == b
+        expect(a.encoding.name).to eq("ASCII-8BIT")
+        expect(b.encoding.name).to eq("UTF-8")
+        expect(subject.convert(a).encoding.name).to eq("UTF-8")
+        expect(subject.convert(a)).to eq(b)
       end
     end
   end
diff --git a/spec/util/fieldeval_spec.rb b/spec/util/fieldeval_spec.rb
index 1b8d5304211..80226bc0f9c 100644
--- a/spec/util/fieldeval_spec.rb
+++ b/spec/util/fieldeval_spec.rb
@@ -9,7 +9,7 @@
       str = "hello"
       m = eval(subject.compile(str))
       data = { "hello" => "world" }
-      insist { m.call(data) } == data[str]
+      expect(m.call(data)).to eq(data[str])
     end
 
     it "should handle delete in block" do
@@ -17,22 +17,22 @@
       m = eval(subject.compile(str))
       data = { "simple" => "things" }
       m.call(data) { |obj, key| obj.delete(key) }
-      insist { data }.empty?
+      expect(data).to be_empty
     end
 
     it "should handle assignment in block" do
       str = "simple"
       m = eval(subject.compile(str))
       data = {}
-      insist { m.call(data) { |obj, key| obj[key] = "things" }} == "things"
-      insist { data } == { "simple" => "things" }
+      expect(m.call(data) { |obj, key| obj[key] = "things" }).to eq("things")
+      expect(data).to eq({ "simple" => "things" })
     end
 
     it "should handle assignment using set" do
       str = "simple"
       data = {}
-      insist { subject.set(str, "things", data) } == "things"
-      insist { data } == { "simple" => "things" }
+      expect(subject.set(str, "things", data)).to eq("things")
+      expect(data).to eq({ "simple" => "things" })
     end
   end
 
@@ -42,14 +42,14 @@
       str = "[hello]"
       m = eval(subject.compile(str))
       data = { "hello" =>  "world" }
-      insist { m.call(data) } == "world"
+      expect(m.call(data)).to eq("world")
     end
 
     it "should retrieve deep value" do
       str = "[hello][world]"
       m = eval(subject.compile(str))
       data = { "hello" => { "world" => "foo", "bar" => "baz" } }
-      insist { m.call(data) } == data["hello"]["world"]
+      expect(m.call(data)).to eq(data["hello"]["world"])
     end
 
     it "should handle delete in block" do
@@ -59,38 +59,38 @@
       m.call(data) { |obj, key| obj.delete(key) }
 
       # Make sure the "world" key is removed.
-      insist { data["hello"] } == { "bar" => "baz" }
+      expect(data["hello"]).to eq({ "bar" => "baz" })
     end
 
     it "should not handle assignment in block" do
       str = "[hello][world]"
       m = eval(subject.compile(str))
       data = {}
-      insist { m.call(data) { |obj, key| obj[key] = "things" }}.nil?
-      insist { data } == { }
+      expect(m.call(data) { |obj, key| obj[key] = "things" }).to be_nil
+      expect(data).to be_empty
     end
 
     it "should set shallow value" do
       str = "[hello]"
       data = {}
-      insist { subject.set(str, "foo", data) } == "foo"
-      insist { data } == { "hello" => "foo" }
+      expect(subject.set(str, "foo", data)).to eq("foo")
+      expect(data).to eq({ "hello" => "foo" })
     end
 
     it "should set deep value" do
       str = "[hello][world]"
       data = {}
-      insist { subject.set(str, "foo", data) } == "foo"
-      insist { data } == { "hello" => { "world" => "foo" } }
+      expect(subject.set(str, "foo", data)).to eq("foo")
+      expect(data).to eq({ "hello" => { "world" => "foo" } })
     end
 
     it "should retrieve array item" do
       data = { "hello" => { "world" => ["a", "b"], "bar" => "baz" } }
       m = eval(subject.compile("[hello][world][0]"))
-      insist { m.call(data) } == data["hello"]["world"][0]
+      expect(m.call(data)).to eq(data["hello"]["world"][0])
 
       m = eval(subject.compile("[hello][world][1]"))
-      insist { m.call(data) } == data["hello"]["world"][1]
+      expect(m.call(data)).to eq(data["hello"]["world"][1])
     end
   end
 end
diff --git a/spec/util/jar_spec.rb b/spec/util/jar_spec.rb
deleted file mode 100644
index b644580bda5..00000000000
--- a/spec/util/jar_spec.rb
+++ /dev/null
@@ -1,27 +0,0 @@
-require "insist"
-
-describe "logstash jar features", :if => (__FILE__ =~ /file:.*!/) do
-  let(:jar_root) { __FILE__.split("!").first + "!" }
-
-  it "must be only run from a jar" do
-    insist { __FILE__ } =~ /file:.*!/
-  end
-
-  it "must contain GeoLiteCity.dat" do
-    path = File.join(jar_root, "GeoLiteCity.dat")
-    insist { File }.exists?(path)
-  end
-
-  it "must contain vendor/ua-parser/regexes.yaml" do
-    path = File.join(jar_root, "vendor/ua-parser/regexes.yaml")
-    insist { File }.exists?(path)
-  end
-
-  it "must successfully load aws-sdk (LOGSTASH-1718)" do
-    require "aws-sdk"
-    # trigger autoload
-    AWS::Errors
-    AWS::Record
-    AWS::Core::AsyncHandle
-  end
-end
