diff --git a/buildSrc/src/main/groovy/org/logstash/gradle/dra/LocalBuildTask.groovy b/buildSrc/src/main/groovy/org/logstash/gradle/dra/LocalBuildTask.groovy
new file mode 100644
index 00000000000..66b590b49dc
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/logstash/gradle/dra/LocalBuildTask.groovy
@@ -0,0 +1,89 @@
+package org.logstash.gradle.dra
+
+import groovy.transform.CompileStatic
+import org.gradle.api.DefaultTask
+import org.gradle.api.tasks.Input
+import org.gradle.api.tasks.Internal
+import org.gradle.api.tasks.TaskAction
+import org.gradle.process.ExecSpec
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
+
+@CompileStatic
+class LocalBuildTask extends DefaultTask {
+
+    private final Logger logger = LoggerFactory.getLogger(this.class.name)
+
+    @Input
+    List<Object> commands
+
+    @Input
+    List<String> dslCommands = List.of()
+
+    @Input
+    String projectName
+
+    @Input
+    String localBuildName
+
+    @Input
+    String type
+
+    @Internal
+    File projectBuildDirectory
+
+    LocalBuildTask() {
+        outputs.upToDateWhen {
+            false
+        }
+    }
+
+    @TaskAction
+    private void action() {
+        logger.info("[release-manager] The following DSL specified shell commands will be executed:")
+        logger.info(dslCommands.join('\n'))
+        logger.info("[release-manager] End of listing DSL specified shell commands.")
+
+        List<Object> wrappedScript = []
+
+        // script init
+        wrappedScript.addAll([
+                '#!/usr/bin/env bash',
+                'set -e'
+        ])
+
+        // configure golang settings
+        wrappedScript.addAll([
+                "export GOPATH='${project.getBuildDir().absolutePath + '/projects/gopath'}'",
+                'export PATH="$GOPATH/bin:$PATH"',
+        ].collect({it.toString()}))
+
+        // Add the commands we were given to the set of commands
+        wrappedScript.addAll(commands)
+
+        // make a script and execute it
+        final String scriptPath = "build/scripts/local-build-${projectName}-${type}-${localBuildName}.sh"
+        final File scriptFile = project.file(scriptPath)
+
+        // check if the directory where the script is going to go exists
+        if (scriptFile.parentFile.exists() == false) {
+
+            // make the directory and check if it was successful
+            if (scriptFile.parentFile.mkdirs() == false) {
+                throw new Exception("Could not make the directories for '${scriptFile.parentFile.absolutePath}', something is up with the directories being used, possible permissions / writeability.")
+            }
+
+        }
+
+        scriptFile.setText(wrappedScript.join('\n'), 'UTF-8')
+        scriptFile.setExecutable(true)
+
+        execute(List.of(scriptFile.absolutePath))
+    }
+
+    private void execute(final List<String> commands) {
+        project.exec { final ExecSpec execSpec ->
+            execSpec.commandLine = commands
+        }
+    }
+}
\ No newline at end of file
diff --git a/buildSrc/src/main/groovy/org/logstash/gradle/dra/LogstashDraPlugin.groovy b/buildSrc/src/main/groovy/org/logstash/gradle/dra/LogstashDraPlugin.groovy
new file mode 100644
index 00000000000..33cb136da0f
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/logstash/gradle/dra/LogstashDraPlugin.groovy
@@ -0,0 +1,26 @@
+package org.logstash.gradle.dra
+
+import groovy.transform.CompileStatic
+import org.gradle.api.Plugin
+import org.gradle.api.Project
+import org.gradle.api.Task
+
+/**
+ * Extensions and tasks to build Logstash artifacts.
+ * */
+@CompileStatic
+class LogstashDraPlugin implements Plugin<Project> {
+
+    // name used in the extension DSL
+    private static final String EXTENSION_NAME = "logstash"
+
+    @Override
+    void apply(Project project) {
+//        Task checkTasks = project.tasks.create('checks')
+//        checkTasks.group = 'preBuild'
+//        checkTasks.description = 'Execute some verification before starting to build artifacts'
+
+        StackProject stackProject = new StackProject(project)
+        project.extensions.add(EXTENSION_NAME, stackProject)
+    }
+}
diff --git a/buildSrc/src/main/groovy/org/logstash/gradle/dra/StackArtifact.groovy b/buildSrc/src/main/groovy/org/logstash/gradle/dra/StackArtifact.groovy
new file mode 100644
index 00000000000..bb4658f1494
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/logstash/gradle/dra/StackArtifact.groovy
@@ -0,0 +1,339 @@
+package org.logstash.gradle.dra
+
+import groovy.transform.CompileStatic
+
+/**
+ * An artifact to be deployed on the elastic download service.
+ */
+@CompileStatic
+class StackArtifact {
+
+    /** The dir of the artifact in the built project. */
+    private final String dir
+
+    /** The name of the artifact in the built project. */
+    private final String name
+
+    /** The type of the artifact (i.e: maven, docker, deb, rpm, tar...) */
+    private final String type
+
+    /** A classifier for the artifact, which appears after the version */
+    private final String classifier
+
+    /** The CPU architecture (i.e: amd64, 386, x86, x86-64...) */
+    private final String architecture
+
+    /** The operating systems this artifact can be used with (i.e: linux, windows, darwin, templeOS...) */
+    private final List<String> operatingSystems
+
+    /** The licenses under which this artifact is distributed (i.e: apache-2.0, elastic-1.0, elastic-2.0, sspl-1.0) */
+    private final List<License> licenses
+
+    /** The project this artifact is associated with, or null if it does not matter. */
+    private final String project
+
+    /** The local build name this artifact came from, or null if it is not part of a local build definition */
+    private final String localBuildName
+
+    /** The file extension of the artifact. */
+    private final String extension
+
+    /** Whether the OS should be included in the file name of the artifact or not. */
+    private final boolean includeOSInFileName
+
+    /** Additional properties for the artifact which may be necessary when publishing. */
+    private final Map<String, String> attributes
+
+    /**
+     * Licenses under which Elastic artifacts can be distributed.
+     */
+    enum License {
+        APACHE_2("apache-2.0", "The Apache Software License, Version 2.0"),
+        SSPL_1("sspl-1.0", "Server Side Public License, v 1"),
+        ELASTIC_1_0 ("elastic-1.0", "Elastic License"),
+        ELASTIC_2_0 ("elastic-2.0", "Elastic License 2.0")
+
+        /** the value to add in the DSL (when possible the SPDX short identifier) */
+        private String id
+        /** the value expected in the file to check (when possible the SPDX full name)  */
+        private String name
+
+        public String getName() {
+            return name
+        }
+
+        License (String id, String name) {
+            this.name = name
+            this.id = id
+        }
+
+        public static License getLicenseById(String id) {
+            for (License license : values()) {
+                if (license.id.equalsIgnoreCase(id)) {
+                    return license
+                }
+            }
+            throw new IllegalArgumentException("${id} is not a license handled by the unified release process.")
+        }
+    }
+
+    private StackArtifact(String dir,
+                          String name,
+                          String type,
+                          String classifier,
+                          String project,
+                          String localBuildName,
+                          String extension,
+                          String architecture,
+                          List<String> operatingSystems,
+                          List<License> licenses,
+                          boolean includeOSInFileName,
+                          Map<String, String> attributes)
+    {
+        this.dir = dir
+        this.name = name
+        this.type = type
+        this.classifier = classifier
+        this.project = project
+        this.localBuildName = localBuildName
+        this.extension = extension
+        this.architecture = architecture
+        this.operatingSystems = operatingSystems
+        this.licenses = licenses
+        this.includeOSInFileName = includeOSInFileName
+        this.attributes = attributes != null ? Collections.unmodifiableMap(attributes) : Collections.<String, String>emptyMap()
+
+        if (operatingSystems?.size() > 1 && includeOSInFileName) {
+            throw new IllegalArgumentException("Cannot include multiple operating systems in a file name. ${this.toString()}")
+        }
+    }
+
+    public String getPath(String version) {
+        return "${dir}/${getName(version)}"
+    }
+
+    /**
+     * The artifact name is based on the following pattern
+     * (where the name ,version and extension are mandatory):
+     *
+     *  <pre>
+     *      ${name}-${version}-${classifier}-${os}-${architecture}.${extension}
+     *  <pre>
+     */
+    public String getName(String version) {
+        if (type.equals('gem')) {
+            // gems do not allow dashes in versions, so for prerelease we must adjust to their standard
+            version = version.replace("-", ".")
+        }
+
+        String suffix = ""
+        if (classifier != null) {
+            suffix += "-${classifier}"
+        }
+        if (operatingSystems != null && includeOSInFileName && operatingSystems.size() == 1) {
+            suffix += "-${operatingSystems[0]}"
+        }
+        if (architecture != null) {
+            suffix += "-${architecture}"
+        }
+        return "${name}-${version}${suffix}.${extension}"
+    }
+
+    public String getDir() {
+        return dir
+    }
+
+    public String getName() {
+        return name
+    }
+
+    public String getType() {
+        return type
+    }
+
+    public String getClassifier() {
+        return classifier
+    }
+
+    public String getProject() {
+        return project
+    }
+
+    public String getLocalBuildName() {
+        return localBuildName
+    }
+
+    public String getExtension() {
+        return extension
+    }
+
+    public String getArchitecture() {
+        return architecture
+    }
+
+    public List<String> getOperatingSystems() {
+        return operatingSystems
+    }
+
+    public List<License> getLicenses() {
+        return licenses
+    }
+
+    public Map<String,String> getAttributes() {
+        return attributes
+    }
+
+    public boolean isOss() {
+        return attributes.get('oss') != null ?  Boolean.valueOf(attributes.get('oss')) : false
+    }
+
+    /**
+     * Is it an artifact that aims to be used only internally?
+     */
+    public boolean isInternal() {
+        return attributes.get('internal') != null ? Boolean.valueOf(attributes.get('internal')) : false
+    }
+
+    /**
+     * Is this artifact included in the package repository?
+     */
+    public boolean isIncludeInRepo() {
+        return attributes.get('include_in_repo') != null ? Boolean.valueOf(attributes.get('include_in_repo')) : true
+    }
+
+    @Override
+    public boolean equals(o) {
+        if (this.is(o)) return true
+        if (getClass() != o.class) return false
+
+        StackArtifact that = (StackArtifact) o
+
+        if (attributes != that.attributes) return false
+        if (classifier != that.classifier) return false
+        if (dir != that.dir) return false
+        if (name != that.name) return false
+        if (project != that.project) return false
+        if (localBuildName != that.localBuildName) return false
+        if (type != that.type) return false
+        if (extension != that.extension) return false
+        if (architecture != that.architecture) return false
+        if (operatingSystems != that.operatingSystems) return false
+        if (licenses != that.licenses) return false
+        if (includeOSInFileName != that.includeOSInFileName) return false
+
+        return true
+    }
+
+    @Override
+    public int hashCode() {
+        int result
+        result = (dir != null ? dir.hashCode() : 0)
+        result = 31 * result + (name != null ? name.hashCode() : 0)
+        result = 31 * result + (type != null ? type.hashCode() : 0)
+        result = 31 * result + (classifier != null ? classifier.hashCode() : 0)
+        result = 31 * result + (project != null ? project.hashCode() : 0)
+        result = 31 * result + (localBuildName != null ? localBuildName.hashCode() : 0)
+        result = 31 * result + (attributes != null ? attributes.hashCode() : 0)
+        result = 31 * result + (extension != null ? extension.hashCode() : 0)
+        result = 31 * result + (architecture != null ? architecture.hashCode() : 0)
+        result = 31 * result + (operatingSystems != null ? operatingSystems.hashCode() : 0)
+        result = 31 * result + (licenses != null ? licenses.hashCode() : 0)
+        result = 31 * result + (includeOSInFileName ? includeOSInFileName.hashCode() : 0)
+
+        return result
+    }
+
+    public String toString() {
+        return "[name: '${name}', " +
+                "dir: '${dir}', " +
+                "type: '${type}', " +
+                "classifier: '${classifier}', " +
+                "project: '${project}', " +
+                "localBuildName: '${localBuildName}', " +
+                "attributes: '${attributes}', " +
+                "extension: '${extension}', " +
+                "architecture: '${architecture}', " +
+                "operatingSystems: '${operatingSystems}', " +
+                "licenses: '${licenses}', " +
+                "includeOSInFileName: '${includeOSInFileName}']"
+    }
+
+    public static class Builder {
+        private String dir
+        private String name
+        private String type
+        private String classifier
+        private String project
+        private String localBuildName
+        private Map<String, String> attributes
+        private String extension
+        private String architecture
+        private List<String> operatingSystems
+        private List<License> licenses
+        private boolean includeOSInFileName
+        public Builder(String name) {
+            this.name = name
+        }
+        public Builder dir(String dir){
+            this.dir = dir
+            return this
+        }
+        public Builder type(String type){
+            this.type = type
+            return this
+        }
+        public Builder classifier(String classifier){
+            this.classifier = classifier
+            return this
+        }
+        public Builder project(String project){
+            this.project = project
+            return this
+        }
+        public Builder localBuildName(String localBuildName){
+            this.localBuildName = localBuildName
+            return this
+        }
+        public Builder extension(String extension){
+            this.extension = extension
+            return this
+        }
+        public Builder attributes(Map<String, String> attributes){
+            this.attributes = attributes
+            return this
+        }
+        public Builder architecture(String architecture){
+            this.architecture = architecture
+            return this
+        }
+        public Builder operatingSystems(List<String> operatingSystems){
+            this.operatingSystems = operatingSystems
+            return this
+        }
+        public Builder licenses(List<License> licenses){
+            this.licenses = licenses
+            return this
+        }
+        public Builder includeOSInFileName(boolean includeOSInFileName){
+            this.includeOSInFileName = includeOSInFileName
+            return this
+        }
+        public StackArtifact build() {
+            return new StackArtifact(
+                    this.dir,
+                    this.name,
+                    this.type,
+                    this.classifier,
+                    this.project,
+                    this.localBuildName,
+                    this.extension,
+                    this.architecture,
+                    this.operatingSystems,
+                    this.licenses,
+                    this.includeOSInFileName,
+                    this.attributes
+            )
+        }
+    }
+}
+
diff --git a/buildSrc/src/main/groovy/org/logstash/gradle/dra/StackArtifactHandler.groovy b/buildSrc/src/main/groovy/org/logstash/gradle/dra/StackArtifactHandler.groovy
new file mode 100644
index 00000000000..822799be812
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/logstash/gradle/dra/StackArtifactHandler.groovy
@@ -0,0 +1,873 @@
+package org.logstash.gradle.dra
+
+import groovy.transform.CompileStatic
+import org.gradle.api.tasks.Input
+/**
+ * A wrapper around configuring artifacts for a project.
+ *
+ * The type of artifacts handled by this wrapper are the following:
+ * <ul>
+ *     <li>maven</li>
+ *     <li>javadoc</li>
+ *     <li>gem</li>
+ *     <li>docker</li>
+ *     <li>msi</li>
+ *     <li>rpm</li>
+ *     <li>deb</li>
+ *     <li>zip</li>
+ *     <li>tar</li>
+ * </ul>
+ *
+ * There is a specific one named <strong>pkg</strong> which generates <strong>rpm, tar (darwin, linux), zip and deb</strong>
+ * files.
+ *
+ * The name, version and extension are the three mandatory fields for all the artifacts.
+ * The filename, to get access to the generated file, is built following this pattern: <br/>
+ *  <em>
+ *      ${name}-${version}-${classifier}-${os}-${architecture}.${extension}
+ *  </em>
+ *
+ */
+@CompileStatic
+class StackArtifactHandler implements Iterable<StackArtifact> {
+
+    private final Set<StackArtifact> artifacts = new LinkedHashSet<>()
+
+    private final List<StackArtifact> mavenArtifacts = []
+
+    private final List<StackArtifact> javadocArtifacts = []
+
+    private final List<StackArtifact> gemArtifacts = []
+
+    private final List<StackArtifact> dockerArtifacts = []
+
+    private final List<StackArtifact> packageArtifacts = []
+
+    private final List<StackArtifact> zipArtifacts = []
+
+    private final List<StackArtifact> tarArtifacts = []
+
+    private final List<StackArtifact> debArtifacts = []
+
+    private final List<StackArtifact> rpmArtifacts = []
+
+    private final List<StackArtifact> pluginArtifacts = []
+
+    private final List<StackArtifact> patchArtifacts = []
+
+    private final List<StackArtifact> csvDependencyReportArtifacts = []
+
+    /** The project these artifacts are for */
+    @Input
+    String project
+
+    /** The local build these artifacts are for */
+    String localBuildName
+
+    /** The directory within a project to find the built artifact, or null no extra dir */
+    @Input
+    String buildDir
+
+    /** Whether the artifacts for the project are generic or architecture specific */
+    @Input
+    boolean generic = true
+
+    /** Classifier to use as part of the filename for a tarball Docker image file **/
+    final static String DOCKER_IMAGE_CLASSIFIER = 'docker-image'
+
+    @Override
+    public Iterator<StackArtifact> iterator() {
+        return artifacts.iterator()
+    }
+
+    public Set<StackArtifact> getArtifacts() {
+        return artifacts
+    }
+
+    /** Return the artifacts for elastic's maven service and maven central. */
+    public Collection<StackArtifact> getMavenArtifacts() {
+        return mavenArtifacts
+    }
+
+    /** Return the javadoc jars to unzip and publish to javadoc.elastic.co. */
+    public Collection<StackArtifact> getJavadocArtifacts() {
+        return javadocArtifacts
+    }
+
+    /** Return the artifacts for rubygems.org. */
+    public Collection<StackArtifact> getGemArtifacts() {
+        return gemArtifacts
+    }
+
+    /** Return the artifacts for docker.elastic.co. */
+    public Collection<StackArtifact> getDockerArtifacts() {
+        return dockerArtifacts
+    }
+
+    /** Return the artifacts for all package files. */
+    public Collection<StackArtifact> getPackageArtifacts() {
+        return packageArtifacts
+    }
+
+    /** Return the zip artifacts */
+    public Collection<StackArtifact> getZipArtifacts() {
+        return zipArtifacts
+    }
+
+    /** Return the tar artifacts */
+    public Collection<StackArtifact> getTarArtifacts() {
+        return tarArtifacts
+    }
+
+    /** Return the artifacts for plugins for this project. */
+    public Collection<StackArtifact> getPluginArtifacts() {
+        return pluginArtifacts
+    }
+
+    public Collection<StackArtifact> getPatchArtifacts() {
+        return patchArtifacts
+    }
+
+    public Collection<StackArtifact> getCsvDependencyReportArtifacts() {
+        return csvDependencyReportArtifacts
+    }
+
+    /** Return the docker images artifacts alongside all the docker artifacts. */
+    public Collection<StackArtifact> getDockerImagesArtifacts() {
+        return dockerArtifacts.findAll{
+            it -> it.getClassifier().contains(DOCKER_IMAGE_CLASSIFIER) == true
+        }
+    }
+
+    /**
+     * A maven artifact:
+     * <ul>
+     *     <li>is by default a file with .jar extension</li>
+     *     <li></li>
+     * </ul>
+     */
+    public void maven(Map<String,?> props) {
+        // required values
+        String type = 'maven'
+        String name = getName(props)
+        String dir = getDir(props)
+        String extension = getOrDefault(props, 'extension', 'jar')
+        List<StackArtifact.License> licenses = getLicenses(props)
+
+        String group = getOrNull(props, 'group')
+        if (group == null) {
+            throw new IllegalArgumentException("Missing property 'group' for ${type} artifact ${name}")
+        }
+
+        // check properties not allowed for this kind of artifact
+        checkPropertyNotAllowed(props, type, 'architecture')
+        checkPropertyNotAllowed(props, type, 'os')
+        checkPropertyNotAllowed(props, type, 'os32bit')
+
+        // optional property
+        String classifier = getOrNull(props, 'classifier')
+
+        boolean oss = props.get('oss') != null ? props.get('oss') : false
+        boolean internal = props.get('internal') != null ? props.get('internal') : false
+        Map<String, String> attrs = new HashMap<String, String>() {{
+            put("group", group)
+            put("oss", Boolean.toString(oss))
+            put("internal", Boolean.toString(internal))
+            put("artifact_id", name)
+            put("artifactNoKpi", Boolean.toString(true))
+        }}
+
+        List<StackArtifact> maven = new ArrayList<>()
+        final StackArtifact pom = new StackArtifact.Builder(name)
+                .dir(dir)
+                .type(type)
+                .classifier(classifier)
+                .project(project)
+                .localBuildName(localBuildName)
+                .extension('pom')
+                .licenses(licenses)
+                .attributes(attrs)
+                .build()
+        maven.add(pom)
+        final StackArtifact mainArtifact = new StackArtifact.Builder(name)
+                .dir(dir)
+                .type(type)
+                .classifier(classifier)
+                .project(project)
+                .localBuildName(localBuildName)
+                .extension(extension)
+                .licenses(licenses)
+                .attributes(attrs)
+                .build()
+        maven.add(mainArtifact)
+
+        if (extension == 'jar') {
+            // Automatically add any maven javadoc artifacts to the list of javadoc to be deployed
+            StackArtifact javadoc = new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier('javadoc')
+                    .project(project)
+                    .localBuildName(localBuildName)
+                    .extension(extension)
+                    .licenses(licenses)
+                    .attributes(attrs)
+                    .build()
+
+            maven.add(javadoc)
+            javadocArtifacts.add(javadoc)
+            maven.add(new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier('sources')
+                    .project(project)
+                    .localBuildName(localBuildName)
+                    .extension(extension)
+                    .licenses(licenses)
+                    .attributes(attrs)
+                    .build())
+        }
+        mavenArtifacts.addAll(maven)
+        artifacts.addAll(maven)
+    }
+
+    public void javadoc(Map<String,?> props) {
+        // required values
+        String type = 'javadoc'
+        String name = getName(props)
+        String dir = getDir(props)
+        String extension = getOrDefault(props, 'extension', 'jar')
+
+        String group = getOrNull(props, 'group')
+        if (group == null) {
+            throw new IllegalArgumentException("Missing property 'group' for ${type} artifact ${name}")
+        }
+
+        // check properties not allowed for this kind of artifact
+        checkPropertyNotAllowed(props, type, 'architecture')
+        checkPropertyNotAllowed(props, type, 'os')
+        checkPropertyNotAllowed(props, type, 'os32bit')
+
+        // optional values
+        String classifier = getOrDefault(props, 'classifier', 'javadoc')
+        // default to false so we do not accidentally publish sources for commercial stuff
+        boolean oss = props.get('oss') != null ? props.get('oss') : false
+
+        Map<String, String> attrs = new HashMap<String, String>() {{
+            put("group", group)
+            put("oss", Boolean.toString(oss))
+            put("artifactNoKpi", Boolean.toString(true))
+        }}
+
+        StackArtifact javadocs = new StackArtifact.Builder(name)
+                .dir(dir)
+                .type(type)
+                .classifier(classifier)
+                .project(project)
+                .localBuildName(localBuildName)
+                .extension(extension)
+                .attributes(attrs)
+                .build()
+        artifacts.add(javadocs)
+        javadocArtifacts.add(javadocs)
+    }
+
+    public void gem(Map<String,?> props) {
+        // required values
+        String type = 'gem'
+        String name = getName(props)
+        String dir = getDir(props)
+        String extension = getOrDefault(props, 'extension', 'gem')
+
+        checkPropertyNotAllowed(props, type, 'os32bit')
+
+        Map<String, String> attrs = new HashMap<String, String>() {{
+            put("artifactNoKpi", Boolean.toString(true))
+        }}
+
+        // optional values
+        String architecture = getOrNull(props, 'architecture')
+        List<String> operatingSystems = getOperatingSystems(props)
+        String classifier = getOrNull(props, 'classifier')
+
+        StackArtifact gem = new StackArtifact.Builder(name)
+                .dir(dir)
+                .type(type)
+                .classifier(classifier)
+                .project(project)
+                .localBuildName(localBuildName)
+                .extension(extension)
+                .attributes(attrs)
+                .architecture(architecture)
+                .operatingSystems(operatingSystems)
+                .includeOSInFileName(true)
+                .build()
+        artifacts.add(gem)
+        gemArtifacts.add(gem)
+        packageArtifacts.add(gem)
+    }
+
+    /**
+     *
+     * A docker type artifact could represent the image or a the build context.
+     * If there is no classifier defined, by default it's @link{#DOCKER_IMAGE_CLASSIFIER}
+     */
+    public void docker(Map<String,?> props) {
+        // required values
+        String type = 'docker'
+        String name = getName(props)
+        String dir = getDir(props)
+        String extension = getOrDefault(props, 'extension', 'tar.gz')
+
+        checkPropertyNotAllowed(props, type, 'os32bit')
+
+        // optional values
+        String projectName = getOrDefault(props, 'project', project)
+        String classifier = getOrDefault(props, 'classifier', DOCKER_IMAGE_CLASSIFIER)
+        String architecture = getOrNull(props, 'architecture')
+        List<String> operatingSystems = getOperatingSystems(props)
+
+        // Docker image URL attributes
+        String org = props.get('org')
+        String repo = props.get('repo')
+        String url = "${repo}/${org}/${name}"
+
+        boolean internal = props.get('internal') != null ? props.get('internal') : false
+        Map<String, String> attrs = new HashMap<String, String>() {{
+            put("org", org)
+            put("repo", repo)
+            put("url", url)
+            put("internal", Boolean.toString(internal))
+            put("artifactNoKpi", Boolean.toString(true))
+        }}
+
+        StackArtifact docker = new StackArtifact.Builder(name)
+                .dir(dir)
+                .type(type)
+                .classifier(classifier)
+                .project(projectName)
+                .localBuildName(localBuildName)
+                .extension(extension)
+                .architecture(architecture)
+                .operatingSystems(operatingSystems)
+                .includeOSInFileName(true)
+                .attributes(attrs)
+                .build()
+        artifacts.add(docker)
+        dockerArtifacts.add(docker)
+        // Add the tar.gz docker artifacts to the package artifacts list
+        packageArtifacts.addAll(docker)
+    }
+
+    public void zip(Map<String,?> props) {
+        // required values
+        String type = 'zip'
+        String name = getName(props)
+        String dir = getDir(props)
+        String extension = getOrDefault(props, 'extension', 'zip')
+        String projectName = getOrDefault(props, 'project', project)
+
+        // optional values
+        String classifier = getOrNull(props, 'classifier')
+        String architecture = getOrDefault(props, 'architecture', 'x86_64')
+        List<String> operatingSystems = getOperatingSystems(props, ['windows'])
+
+        List<StackArtifact> zip = []
+        if (artifactIsGeneric(props)) {
+            zip.add(new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier(classifier)
+                    .project(projectName)
+                    .localBuildName(localBuildName)
+                    .operatingSystems(operatingSystems)
+                    .extension(extension)
+                    .build())
+        } else {
+            zip.add(new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier(classifier)
+                    .project(projectName)
+                    .localBuildName(localBuildName)
+                    .extension(extension)
+                    .architecture(architecture)
+                    .operatingSystems(operatingSystems)
+                    .includeOSInFileName(true)
+                    .build())
+            if (artifactIsFor32BitOS(props)) {
+                zip.add(new StackArtifact.Builder(name)
+                        .dir(dir)
+                        .type(type)
+                        .classifier(classifier)
+                        .project(projectName)
+                        .localBuildName(localBuildName)
+                        .extension(extension)
+                        .architecture('x86')
+                        .operatingSystems(operatingSystems)
+                        .includeOSInFileName(true)
+                        .build())
+            }
+        }
+        artifacts.addAll(zip)
+        packageArtifacts.addAll(zip)
+        zipArtifacts.addAll(zip)
+    }
+
+    public void tar(Map<String,?> props) {
+        // required values
+        String type = 'tar'
+        String name = getName(props)
+        String dir = getDir(props)
+        String extension = getOrDefault(props, 'extension', 'tar.gz')
+
+        // optional
+        String projectName = getOrDefault(props, 'project', project)
+        String classifier = getOrNull(props, 'classifier')
+        String architecture = getOrDefault(props, 'architecture', 'x86_64')
+        List<String> operatingSystems = getOperatingSystems(props)
+
+        List<StackArtifact> tar = []
+        if (artifactIsGeneric(props)) {
+            tar.add(new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier(classifier)
+                    .project(projectName)
+                    .localBuildName(localBuildName)
+                    .extension(extension)
+                    .operatingSystems(operatingSystems)
+                    .build())
+        } else {
+            if (artifactIsFor32BitOS(props)) {
+                tar.add(new StackArtifact.Builder(name)
+                        .dir(dir)
+                        .type(type)
+                        .classifier(classifier)
+                        .project(projectName)
+                        .localBuildName(localBuildName)
+                        .extension(extension)
+                        .architecture('x86')
+                        .operatingSystems(operatingSystems)
+                        .includeOSInFileName(true)
+                        .build())
+            }
+            tar.add(new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier(classifier)
+                    .project(projectName)
+                    .localBuildName(localBuildName)
+                    .extension(extension)
+                    .architecture(architecture)
+                    .operatingSystems(operatingSystems)
+                    .includeOSInFileName(true)
+                    .build())
+        }
+        artifacts.addAll(tar)
+        packageArtifacts.addAll(tar)
+        tarArtifacts.addAll(tar)
+    }
+
+    public void deb(Map<String,?> props) {
+        // required values
+        String type = 'deb'
+        String name = getName(props)
+        String dir = getDir(props)
+        String extension = 'deb'
+
+        // check properties not allowed for this kind of artifact
+        checkPropertyNotAllowed(props, type, 'os')
+
+        // optional
+        String projectName = getOrDefault(props, 'project', project)
+        String classifier = getOrNull(props, 'classifier')
+        String architecture = getOrDefault(props, 'architecture', 'amd64')
+
+        boolean oss = props.getOrDefault('oss', false)
+        boolean include_in_repo = props.getOrDefault('include_in_repo', true)
+        Map<String, String> attrs = new HashMap<String, String>() {{
+            put("oss", Boolean.toString(oss))
+            put("include_in_repo", Boolean.toString(include_in_repo))
+        }}
+        List<StackArtifact> deb = []
+        if (artifactIsGeneric(props)) {
+            deb.add(new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier(classifier)
+                    .project(projectName)
+                    .localBuildName(localBuildName)
+                    .extension(extension)
+                    .attributes(attrs)
+                    .build())
+        } else {
+            if (artifactIsFor32BitOS(props)) {
+                deb.add(new StackArtifact.Builder(name)
+                        .dir(dir)
+                        .type(type)
+                        .classifier(classifier)
+                        .project(projectName)
+                        .localBuildName(localBuildName)
+                        .extension(extension)
+                        .architecture('i386')
+                        .attributes(attrs)
+                        .build())
+            }
+            deb.add(new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier(classifier)
+                    .project(projectName)
+                    .localBuildName(localBuildName)
+                    .extension(extension)
+                    .architecture(architecture)
+                    .attributes(attrs)
+                    .build())
+        }
+        artifacts.addAll(deb)
+        packageArtifacts.addAll(deb)
+        debArtifacts.addAll(deb)
+    }
+
+    public void rpm(Map<String,?> props) {
+        // required values
+        String type = 'rpm'
+        String name = getName(props)
+        String dir = getDir(props)
+        String extension = 'rpm'
+
+        // check properties not allowed for this kind of artifact
+        checkPropertyNotAllowed(props, type, 'os')
+
+        // optional
+        String projectName = getOrDefault(props, 'project', project)
+        String classifier = getOrNull(props, 'classifier')
+        String architecture = getOrDefault(props, 'architecture', 'x86_64')
+
+        boolean oss = props.getOrDefault('oss', false)
+        boolean include_in_repo = props.getOrDefault('include_in_repo', true)
+        Map<String, String> attrs = new HashMap<String, String>() {{
+            put("oss", Boolean.toString(oss))
+            put("include_in_repo", Boolean.toString(include_in_repo))
+        }}
+
+        List<StackArtifact> rpm = []
+        if (artifactIsGeneric(props)) {
+            rpm.add(new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier(classifier)
+                    .project(projectName)
+                    .localBuildName(localBuildName)
+                    .extension(extension)
+                    .attributes(attrs)
+                    .build())
+        } else {
+            if (artifactIsFor32BitOS(props)) {
+                rpm.add(new StackArtifact.Builder(name)
+                        .dir(dir)
+                        .type(type)
+                        .classifier(classifier)
+                        .project(projectName)
+                        .localBuildName(localBuildName)
+                        .extension(extension)
+                        .architecture('i686')
+                        .attributes(attrs)
+                        .build())
+            }
+            rpm.add(new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier(classifier)
+                    .project(projectName)
+                    .localBuildName(localBuildName)
+                    .extension(extension)
+                    .architecture(architecture)
+                    .attributes(attrs)
+                    .build())
+        }
+        artifacts.addAll(rpm)
+        packageArtifacts.addAll(rpm)
+        rpmArtifacts.addAll(rpm)
+    }
+
+    public void msi(Map<String,?> props) {
+        // required values
+        String type = 'msi'
+        String name = getName(props)
+        String dir = getDir(props)
+        String extension = 'msi'
+
+        // optional
+        String projectName = getOrDefault(props, 'project', project)
+        String classifier = getOrNull(props, 'classifier')
+        String architecture = getOrNull(props, 'architecture')
+
+        // keep operatingSystems here because the project esodbc uses windows in the msi filename
+        List<String> operatingSystems = getOperatingSystems(props)
+
+        List<StackArtifact> msi = []
+        if (artifactIsGeneric(props)) {
+            msi.add(new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier(classifier)
+                    .project(projectName)
+                    .localBuildName(localBuildName)
+                    .extension(extension)
+                    .operatingSystems(operatingSystems)
+                    .build())
+        } else {
+            msi.add(new StackArtifact.Builder(name)
+                    .dir(dir)
+                    .type(type)
+                    .classifier(classifier)
+                    .project(projectName)
+                    .localBuildName(localBuildName)
+                    .extension(extension)
+                    .architecture(architecture)
+                    .operatingSystems(operatingSystems)
+                    .includeOSInFileName(true)
+                    .build())
+            if (artifactIsFor32BitOS(props)) {
+                msi.add(new StackArtifact.Builder(name)
+                        .dir(dir)
+                        .type(type)
+                        .classifier(classifier)
+                        .project(projectName)
+                        .localBuildName(localBuildName)
+                        .extension(extension)
+                        .architecture('x86')
+                        .operatingSystems(operatingSystems)
+                        .includeOSInFileName(true)
+                        .build())
+            }
+        }
+        artifacts.addAll(msi)
+        packageArtifacts.addAll(msi)
+    }
+
+    public void cppComponent(Map<String,?> props) {
+        // required values
+        String type = 'cppComponent'
+        String name = getName(props)
+        String dir = getDir(props)
+        String extension = getOrDefault(props, 'extension', 'zip')
+        String buildHost = props.get('buildhost')
+        if (buildHost == null) {
+            throw new IllegalArgumentException("Must specify buildhost for C++ artifact")
+        }
+        Map<String, String> attrs = ['buildhost': buildHost]
+
+        checkPropertyNotAllowed(props, type, 'os32bit')
+
+        // optional
+        String projectName = getOrDefault(props, 'project', project)
+        String classifier = getOrNull(props, 'classifier')
+        String architecture = getOrNull(props, 'architecture')
+        String artifactNoKpi = getOrNull(props, 'artifactNoKpi')
+        List<String> operatingSystems = getOperatingSystems(props)
+
+        if (artifactNoKpi != null) {
+            if (artifactNoKpi != 'true' && artifactNoKpi != 'false') {
+                throw new IllegalArgumentException("Invalid 'artifactNoKpi' of '${artifactNoKpi}', it must be 'true' or 'false'.")
+            }
+            attrs.put('artifactNoKpi', artifactNoKpi)
+        }
+
+        StackArtifact cppComponent = new StackArtifact.Builder(name)
+                .dir(dir)
+                .type(type)
+                .classifier(classifier)
+                .project(projectName)
+                .localBuildName(localBuildName)
+                .extension(extension)
+                .architecture(architecture)
+                .operatingSystems(operatingSystems)
+                .includeOSInFileName(true)
+                .attributes(attrs)
+                .build()
+        artifacts.add(cppComponent)
+        packageArtifacts.addAll(cppComponent)
+    }
+
+    public void plugin(Map<String,?> props) {
+        // required values
+        String type = 'plugin'
+        String name = getName(props)
+        String dir = getDir(props)
+        String extension = getOrDefault(props, 'extension', 'zip')
+
+        checkPropertyNotAllowed(props, type, 'os32bit')
+
+        // optional
+        String projectName = getOrDefault(props, 'project', project)
+        String classifier = getOrNull(props, 'classifier')
+        String architecture = getOrNull(props, 'architecture')
+        List<String> operatingSystems = getOperatingSystems(props)
+
+        StackArtifact plugin = new StackArtifact.Builder(name)
+                .dir(dir)
+                .type(type)
+                .classifier(classifier)
+                .project(projectName)
+                .localBuildName(localBuildName)
+                .extension(extension)
+                .architecture(architecture)
+                .operatingSystems(operatingSystems)
+                .includeOSInFileName(true)
+                .build()
+        artifacts.add(plugin)
+        pluginArtifacts.add(plugin)
+    }
+
+    /**
+     * <em>pkg</em> is a specific type to generate zip, deb, rpm and tar (linux 64/32 bits, darwin 64)
+     * artifacts by declaring only one line in the DSL:
+     *
+     * <pre>
+     *    pkg dir: 'greeting-library/build/pkg', name: 'my-artifact'
+     * </pre>
+     */
+    public void pkg(Map<String,?> props) {
+        zip(props)
+        deb(props)
+        rpm(props)
+
+        if (artifactIsGeneric(props)) {
+            props.put('os', ['linux', 'darwin'])
+            tar(props)
+        } else {
+            props.put('os', ['linux'])
+            tar(props)
+
+            // no os32bit archive for darwin for pkg
+            props.put('os', ['darwin'])
+            props.put('os32bit', false)
+            tar(props)
+        }
+    }
+
+
+    public void patch(Map<String,?> props) {
+        if (patchArtifacts.size() > 0) {
+            throw new IllegalArgumentException("Only one patch artifact per project is currently supported.")
+        }
+        // required values
+        final String type = 'patch'
+        String name = getName(props)
+        String dir = getDir(props)
+
+        Map<String, String> attrs = new HashMap<String, String>() {{
+            put("artifactNoKpi", Boolean.toString(true))
+        }}
+
+        final StackArtifact patch = new StackArtifact.Builder(name)
+                .type(type)
+                .dir(dir)
+                .extension('patch')
+                .attributes(attrs)
+                .localBuildName(localBuildName)
+                .build()
+        artifacts.add(patch)
+        patchArtifacts.add(patch)
+    }
+
+    public void csvDependencyReport(final Map<String,?> props) {
+        // required values
+        final String type = 'csvDependencyReport'
+        final String name = getName(props)
+        final String dir = getDir(props)
+
+        // default internal to true
+        final boolean internal = props.get('internal') != null ? props.get('internal') : true
+        final Map<String, String> attrs = new HashMap<String, String>() {{
+            put('internal', Boolean.toString(internal))
+            put('artifactNoKpi', Boolean.toString(true))
+        }}
+
+        final StackArtifact csvDependencyReport = new StackArtifact.Builder(name)
+                .type(type)
+                .dir(dir)
+                .extension('csv')
+                .attributes(attrs)
+                .localBuildName(localBuildName)
+                .build()
+        artifacts.add(csvDependencyReport)
+        csvDependencyReportArtifacts.add(csvDependencyReport)
+    }
+
+    private static List<String> getOperatingSystems(final Map<String,?> props) {
+        if (props?.get('os')) {
+            return (List)props.get('os')
+        } else {
+            return Collections.emptyList()
+        }
+    }
+
+    private static List<String> getOperatingSystems(final Map<String,?> props, final List<String> defaultValue) {
+        if (getOperatingSystems(props)) {
+            return getOperatingSystems(props)
+        } else {
+            return defaultValue
+        }
+    }
+
+    private static List<StackArtifact.License> getLicenses(final Map<String,?> props) {
+        List<StackArtifact.License> licenses = new ArrayList<>()
+        if (props?.get('licenses')) {
+            ((List<String>) props.get('licenses')).each { String id ->
+                licenses.add(StackArtifact.License.getLicenseById(id))
+            }
+        }
+        return licenses
+    }
+
+    private static String getName(Map<String,?> props) {
+        String name = props.get('name')
+        if (name == null) {
+            throw new IllegalArgumentException("Must specify name for artifact")
+        }
+        return name
+    }
+
+    private String getDir(Map<String,?> props) {
+        String dir = props.get('dir')
+        if (dir == null) {
+            dir = buildDir
+        } else if (buildDir != null) {
+            dir = "${dir}/${buildDir}"
+        }
+        return dir
+    }
+
+    private static String getOrNull(Map<String,?> props, String key) {
+        getOrDefault(props, key, null)
+    }
+
+    private static String getOrDefault(Map<String,?> props, String key, String defaultValue) {
+        if (props.get(key) != null) {
+            return props.get(key)
+        } else {
+            return defaultValue
+        }
+    }
+
+    private static void checkPropertyNotAllowed(Map<String,?> props, String type, String key) {
+        if (props.get(key) != null) {
+            throw new IllegalArgumentException("${key} is not allowed for ${type} artifact.")
+        }
+    }
+
+    private boolean artifactIsGeneric(final Map<String,?> props) {
+        boolean g = props.get('generic') != null ? props.get('generic') : false
+        return (generic || g)
+    }
+
+    private static boolean artifactIsFor32BitOS(final Map<String,?> props) {
+        boolean os32bit = props.get('os32bit') != null ? props.get('os32bit') : false
+        return os32bit
+    }
+}
+
diff --git a/buildSrc/src/main/groovy/org/logstash/gradle/dra/StackProject.groovy b/buildSrc/src/main/groovy/org/logstash/gradle/dra/StackProject.groovy
new file mode 100644
index 00000000000..e8b3986f3bb
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/logstash/gradle/dra/StackProject.groovy
@@ -0,0 +1,412 @@
+package org.logstash.gradle.dra
+
+import groovy.transform.CompileStatic
+import org.gradle.api.Project
+import org.gradle.api.Task
+import org.logstash.gradle.dra.artifactset.ArtifactSet
+import org.logstash.gradle.dra.artifactset.ArtifactSetHandler
+import org.logstash.gradle.dra.configuration.StackConfigurationPluginExtension
+import org.logstash.gradle.dra.localbuild.LocalBuild
+import org.logstash.gradle.dra.localbuild.LocalBuildHandler
+
+import java.nio.file.Paths
+
+@CompileStatic
+class StackProject {
+
+    public static final String DEPENDENCIES_REPORTS_CSV_LOCAL_PATH = "reports/dependencies-reports"
+
+    String releaseName
+
+    /** The qualifier to pass to builds, i.e. 'alpha1' */
+    public static String versionQualifier
+
+    /** artifacts of this project */
+    private final StackArtifactHandler stackArtifactHandler = new StackArtifactHandler()
+
+    private final LocalBuildHandler localBuildHandler = new LocalBuildHandler()
+
+    private final ArtifactSetHandler artifactSetHandler = new ArtifactSetHandler()
+
+    private Map<String, String> statusMessages = [:]
+
+    /** The gradle project we are attached to */
+    private final Project gradleProject
+
+    public String projectName = "logstash"
+
+    StackConfigurationPluginExtension stackConfiguration
+
+    private String workspacePath
+
+    /** Task names for the build steps for the project. This is used to get metadata from the gradle tasks. */
+    public List<String> buildTaskNames = new ArrayList<String>()
+
+    public StackProject(Project gradleProject) {
+        versionQualifier = "test-TODO-change"
+        workspacePath = gradleProject.rootDir
+        this.gradleProject = gradleProject
+        this.stackConfiguration = new StackConfigurationPluginExtension(gradleProject)
+        // TODO just for test, should be read by env properties with the help of StackConfigPluginExtension
+        this.stackConfiguration.localBuild = "local"
+        gradleProject.afterEvaluate {
+            setupSnapshotTasks()
+        }
+    }
+
+    /** Create and configure tasks for this project to build a snapshot version. */
+    protected void setupSnapshotTasks() {
+        final SharedBuildTasks sharedBuildTasks = setupCommonTasks(
+                "snapshot",
+                /*snapshotVersion*/ "8.0.0"
+        )
+        final Task buildTask = sharedBuildTasks.buildTask
+    }
+
+    public void localBuild(String name, Closure closure) {
+        // only configure artifacts if we're actually building this localBuild
+        boolean configureArtifacts = true/*stackConfiguration.localBuild == name*/
+        localBuildHandler.localBuild(name, stackArtifactHandler, configureArtifacts, closure)
+    }
+
+    public void artifactSet(final String name, final Closure closure) {
+        // only configure artifacts if we're actually handling this artifactSet
+        final boolean configureArtifacts = true/*stackConfiguration.artifactSet == name*/
+        artifactSetHandler.artifactSet(name, stackArtifactHandler, configureArtifacts, closure)
+    }
+
+    /** Set the shell commands to build a release of the project. */
+    public void setStatusMessages(Map<String, String> statusMessages) {
+        this.statusMessages = statusMessages
+    }
+
+    private SharedBuildTasks setupCommonTasks(final String type, final String version) {
+        // if this project has local build command specified, and they are enabled with -Pconfiguration.localBuild=name
+        boolean localBuildCommandsDefinedAndSpecified = false
+
+        // if this project has an artifact set defined and enabled with -Pconfiguration.artifactSet=name
+        boolean artifactSetDefinedAndSpecified = false
+
+        String artifactsDirectory
+
+        if (type == 'snapshot') {
+            artifactsDirectory = "build"/*snapshotArtifactsDir*/
+        } else if (type == 'release') {
+            artifactsDirectory = "build"/*releaseArtifactsDir*/
+        } else {
+            throw new IllegalArgumentException("Unhandled type '${type}'.")
+        }
+
+        Collection<LocalBuild> specifiedLocalBuilds = List.of()
+
+        if (localBuildHandler.getLocalBuilds().size() > 0) {
+            specifiedLocalBuilds = localBuildHandler.getLocalBuilds().values().findAll({LocalBuild localBuild ->
+                localBuild.name == stackConfiguration.localBuild
+            })
+
+            // if a local build is set, but we didn't find one, it does not exist so throw an exception
+            if (stackConfiguration.localBuild != '' && specifiedLocalBuilds.size() == 0) {
+                throw new IllegalArgumentException("The local build '${stackConfiguration.localBuild}' does not appear to exist.")
+            }
+
+            if (specifiedLocalBuilds.isEmpty()) {
+                localBuildCommandsDefinedAndSpecified = false
+            } else {
+                localBuildCommandsDefinedAndSpecified = specifiedLocalBuilds.every { LocalBuild localBuild ->
+                    if (type == 'snapshot') {
+                        localBuild.buildSnapshotCommands != null && localBuild.buildSnapshotCommands.size() > 0
+                    } else if (type == 'release') {
+                        localBuild.buildReleaseCommands != null && localBuild.buildReleaseCommands.size() > 0
+                    }
+                }
+            }
+        }
+
+        Collection<ArtifactSet> specifiedArtifactSets = List.of()
+
+        if (artifactSetHandler.getArtifactSets().size() > 0) {
+            specifiedArtifactSets = artifactSetHandler.getArtifactSets().values().findAll({ final ArtifactSet artifactSet ->
+                artifactSet.name == stackConfiguration.artifactSet
+            })
+
+            // if an artifact set is set, but we didn't find one, it does not exist so throw an exception
+            if (stackConfiguration.artifactSet != '' && specifiedArtifactSets.size() == 0) {
+                throw new IllegalArgumentException("The artifact set '${stackConfiguration.artifactSet}' does not appear to exist.")
+            }
+
+            artifactSetDefinedAndSpecified = specifiedArtifactSets.size() > 0
+        }
+
+        if (!localBuildCommandsDefinedAndSpecified && !artifactSetDefinedAndSpecified) {
+            throw new IllegalArgumentException("local builds and artifacts are not configured for '${projectName}'. There is not any DSL that release-manager needs in order to do anything for this project.")
+        }
+
+        Task buildTask = null
+
+        if (specifiedArtifactSets.size() > 0) {
+            final List<Task> artifactSetTasks = new ArrayList<>()
+
+            for (final ArtifactSet artifactSet in specifiedArtifactSets) {
+                // an artifactSetTask doesn't do anything, it just needs to end up being the buildTask
+                final Task artifactSetTask = gradleProject.tasks.create("artifactSet-${projectName}-${artifactSet.name}-${type}")
+                artifactSetTasks.add(artifactSetTask)
+            }
+
+            // boilerplate to be in control of task ordering
+            for (int i = artifactSetTasks.size() - 1; i > 0; i--) {
+                artifactSetTasks.get(i).shouldRunAfter(artifactSetTasks.get(i - 1))
+            }
+            // set the single "buildTask" to the last task in our set of artifact set tasks
+            buildTask = artifactSetTasks.get(artifactSetTasks.size() - 1)
+        }
+
+        if (localBuildCommandsDefinedAndSpecified && specifiedLocalBuilds.size() > 0) {
+            List<LocalBuildTask> localBuildTasks = new ArrayList<>()
+
+            for (LocalBuild build : specifiedLocalBuilds) {
+                LocalBuildTask localBuildTask = createLocalBuildTask(type, build, version, artifactsDirectory)
+                buildTaskNames.add(localBuildTask.name)
+                localBuildTasks.add(localBuildTask)
+            }
+
+            // set task order
+            for (int i = localBuildTasks.size() - 1; i > 0; i--) {
+                localBuildTasks.get(i).shouldRunAfter(localBuildTasks.get(i - 1))
+            }
+            // set the single "buildTask" to the last task in our set of local build tasks
+            buildTask = localBuildTasks.get(localBuildTasks.size() - 1)
+        }
+
+        // All build tasks must depend on all check tasks
+        // TODO re-enable when checks task is included
+//        buildTask.dependsOn(gradleProject.tasks.findByName('checks'))
+
+//        Task checksumTask = createChecksumTask(type, artifactsDirectory, version, 'SHA-512')
+//        // calculate checksums after signing, because signing can modify some artifacts, like .deb packages
+//        dependOnNullableTasks(checksumTask, [buildTask])
+
+        SharedBuildTasks buildTasks = new SharedBuildTasks()
+//        buildTasks.checksumTask = checksumTask
+        buildTasks.buildTask = buildTask
+        return buildTasks
+    }
+
+    private class SharedBuildTasks {
+        public Task checksumTask
+        public Task buildTask
+    }
+
+    /**
+     * Generate the shell commands to run before a build process in a vagrant VM or a local build.
+     */
+    public static List<Object> linuxAndMacPreBuildCommands(final String projectDirectory, final String projectName,
+                                                           final String type, final String syncDirectory,
+                                                           final String version, final String expectedExternalArtifactPath) {
+        List<Object> commands = []
+        commands.addAll(
+                // set variables in strings that support interpolation
+
+                // PROJECT_CHECKOUT is where the git repository has been checked out
+                "PROJECT_CHECKOUT=\"${syncDirectory}/checkouts/${projectName}/\"",
+
+                // PROJECT_DIR is the directory where the build will be performed, avoid surrounding with "" since ~
+                // needs to be expanded by the shell at runtime
+                "PROJECT_DIR=${projectDirectory}",
+
+                // EXTERNAL_ARTIFACTS_PATH is where downloaded artifacts should have ended up if there were any
+                "EXTERNAL_ARTIFACTS_PATH=\"${expectedExternalArtifactPath}\"",
+                "export ARTIFACTS_DIR=\"${syncDirectory}/build/${type}-artifacts\"",
+                "export DEPENDENCIES_REPORTS_DIR=\"${syncDirectory}/build/${DEPENDENCIES_REPORTS_CSV_LOCAL_PATH}/\"",
+                "export DEPENDENCIES_REPORT=\"${projectName}-${version}.csv\"",
+
+                // now use single-quote strings for shell scripting to avoid needing a lot of confusing \ escapes
+
+                // make the directories we'll be using and make sure they're clean
+                'mkdir -p "$DEPENDENCIES_REPORTS_DIR"',
+                // avoid "" to ensure ~ is expanded correctly
+                'rm -rf $PROJECT_DIR',
+                'mkdir -p $PROJECT_DIR',
+
+                // now that project dir must exist get it's real path
+                'PROJECT_DIR_ABSOLUTE_PATH="$(cd $PROJECT_DIR ; pwd)"',
+
+                // only copy the checkout directory if it exists, this enables performing "builds" without a checked out
+                // repository
+                'if test -d "$PROJECT_CHECKOUT"',
+                'then',
+                '  rsync --recursive --links "$PROJECT_CHECKOUT" "$PROJECT_DIR_ABSOLUTE_PATH"',
+                'else',
+                '  echo "The directory \"$PROJECT_CHECKOUT\" does not exist, skipping copying repository to the build directory."',
+                'fi',
+
+
+                // if there are artifacts that were downloaded from somewhere else (external artifacts), move them into
+                // the project directory
+                'cd "$PROJECT_DIR_ABSOLUTE_PATH"',
+                'shopt -s dotglob',
+                'if ls "$EXTERNAL_ARTIFACTS_PATH"/* >/dev/null 2>&1',
+                'then',
+                '  mv "$EXTERNAL_ARTIFACTS_PATH"/* "$PROJECT_DIR_ABSOLUTE_PATH"',
+                'fi',
+                'shopt -u dotglob',
+        )
+        return commands
+    }
+
+    /**
+     * Generate the shell commands to run after a build process in a vagrant VM or a local build.
+     */
+    public static List<Object> linuxAndMacPostBuildCommands(final String artifactDestinationPath,
+                                                            final Set<StackArtifact> artifacts, final String version,
+                                                            final String buildHostname, final String type) {
+        List<Object> commands = []
+        commands.addAll([
+                // unset bash debugging and verbose mode to avoid logging of all the post build commands
+                'set +x',
+                'set +v',
+
+                // a 'realpath' helper function to find the absolute path of files for better debugging output
+                'rm_realpath() {',
+                '  DIRECTORY_NAME="$(dirname "$1")"',
+                '  if test -d "$DIRECTORY_NAME"',
+                '  then',
+                '    echo "$(cd "$DIRECTORY_NAME"; pwd)/$(basename "$1")"',
+                '  else',
+                // if the directory given does not exist, we can't use 'cd' and 'pwd' to get the real path, just
+                // return what we were given to give some idea of what this thing was supposed to be
+                '    echo "The directory \"$DIRECTORY_NAME\" does not exist. Returning a path that does not exist." >&2',
+                '    echo "$1"',
+                '  fi',
+                '}',
+
+
+                "rm -rf '${artifactDestinationPath}'",
+                "mkdir -p '${artifactDestinationPath}'",
+
+                // ARTIFACTS_MISSING is a flag that indicates expected artifacts were not found
+                'ARTIFACTS_MISSING="false"',
+        ])
+
+        for (StackArtifact artifact : artifacts) {
+            final String artifactPath = artifact.getPath(version)
+            String artifactBuildHost = artifact.getAttributes().get('buildhost')
+            if (artifactBuildHost != null && artifactBuildHost != buildHostname) {
+                continue
+            }
+            // TODO: a hack to remove when 6.8.x will stop being released
+            if (artifact.type == 'gem' && type == 'snapshot') {
+                // a horrible hack for gems, which do not have a snapshot. without this, we would fail to
+                // find the gems (which were not built for a snapshot build) when copying build artifacts
+                continue
+            }
+
+            if (artifact.type == 'docker' && artifact.classifier == StackArtifactHandler.DOCKER_IMAGE_CLASSIFIER ) {
+                final String image = "${artifact.attributes.get('url')}:${version}"
+                commands.addAll([
+                        // With async builds, Docker image tarballs are retrieved from the artifact bucket.
+                        // Do not run 'docker save' if the image tarball exists on disk.
+                        "if [ ! -f ${artifactPath} ]; then",
+                        "echo 'Expecting the image ${image} to be present in the docker daemon.'",
+                        "docker images ${image}",
+                        // Ensure 'docker save' will fail even when piped into gzip
+                        "set -o pipefail",
+                        "mkdir -p \$(dirname '${artifactPath}')",
+                        "docker save ${image} | gzip -c > '${artifactPath}'",
+                        "else",
+                        "echo '${artifactPath} already exists on disk, no need to execute docker save'.",
+                        "fi"
+                ])
+            }
+
+            final String fileDestination = "${artifactDestinationPath}/${artifactPath}"
+            commands.addAll([
+                    // set variables in strings that support interpolation
+                    "ARTIFACT_PATH=\"${artifactPath}\"",
+                    "FILE_DESTINATION=\"${fileDestination}\"",
+
+
+                    // now use single-quote strings for shell scripting to avoid needing a lot of confusing \ escapes
+
+                    'FULL_ARTIFACT_LOCATION="$(rm_realpath "$ARTIFACT_PATH")"',
+
+                    'mkdir -p "$(dirname "$FILE_DESTINATION")"',
+
+                    // if the file exists, copy it to the the destination
+                    'if test -f "$FULL_ARTIFACT_LOCATION"',
+                    'then',
+                    '  cp "$FULL_ARTIFACT_LOCATION" "$FILE_DESTINATION"',
+                    'else',
+                    '  echo "Expected but did not find: \'$FULL_ARTIFACT_LOCATION\'."',
+                    '  ARTIFACTS_MISSING="true"',
+                    'fi'
+            ])
+        }
+
+        commands.addAll([
+                // fail if there are missing artifacts
+                'if [[ "$ARTIFACTS_MISSING" == "true" ]]',
+                'then',
+                '  echo "There is a mismatch between the artifacts on disk and the artifacts DSL in release-manager, aborting."',
+                '  exit 1',
+                'fi',
+        ])
+
+        return commands
+    }
+
+    private LocalBuildTask createLocalBuildTask(final String type, final LocalBuild build,
+                                                final String version, final String artifactResultDirectory) {
+        LocalBuildTask task = gradleProject.tasks.create(taskName('localBuild', "${type.capitalize()}-${build.name}"), LocalBuildTask.class)
+        task.projectName = projectName
+        task.localBuildName = build.name
+        task.type = type
+        List<Object> commands = []
+
+        final String gradleBuildDirectory = gradleProject.buildDir.absolutePath
+//        if (parentDir != null) {
+//            task.projectBuildDirectory = Paths.get(gradleBuildDirectory, 'projects', parentDir, projectName).toFile()
+//        } else {
+//            task.projectBuildDirectory = Paths.get(gradleBuildDirectory, 'projects', projectName).toFile()
+//        }
+        task.projectBuildDirectory = Paths.get(gradleBuildDirectory).toFile()
+        // there isn't a sync directory, it's just the gradle directory since things are happening on the local filesystem
+        final String gradleRootDirectory = gradleProject.getRootDir().absolutePath
+
+        final String expectedExternalArtifactPath = "${workspacePath}/build/external-artifacts/${projectName}"
+
+        // pre-build commands
+        commands.addAll(
+                linuxAndMacPreBuildCommands(task.projectBuildDirectory.absolutePath, projectName, type, gradleRootDirectory, version, expectedExternalArtifactPath)
+        )
+
+        // add dsl commands
+        if (type == 'snapshot') {
+            task.dslCommands = build.buildSnapshotCommands
+            commands.addAll(build.buildSnapshotCommands)
+        } else if (type == 'release') {
+            task.dslCommands = build.buildReleaseCommands
+            commands.addAll(build.buildReleaseCommands)
+        } else {
+            throw new IllegalArgumentException("Unhandled type '${type}' for local build task.")
+        }
+
+        // find the artifacts that are for this local build
+        Set<StackArtifact> localBuildArtifacts = stackArtifactHandler.getArtifacts().findAll { StackArtifact artifact ->
+            artifact.localBuildName == build.name
+        }
+
+        // post-build commands
+        commands.addAll(
+                linuxAndMacPostBuildCommands("${gradleRootDirectory}/${artifactResultDirectory}", localBuildArtifacts, version, '', type)
+        )
+
+        task.commands = commands
+
+        return task
+    }
+
+    /** Returns a task name specific for this project */
+    private String taskName(String action, String suffix) {
+        return "${action}${projectName.replace('-', '').capitalize()}${suffix.capitalize()}"
+    }
+}
diff --git a/buildSrc/src/main/groovy/org/logstash/gradle/dra/artifactset/ArtifactSet.groovy b/buildSrc/src/main/groovy/org/logstash/gradle/dra/artifactset/ArtifactSet.groovy
new file mode 100644
index 00000000000..a6f33a3d881
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/logstash/gradle/dra/artifactset/ArtifactSet.groovy
@@ -0,0 +1,33 @@
+package org.logstash.gradle.dra.artifactset
+
+
+import groovy.transform.CompileStatic
+import org.gradle.util.ConfigureUtil
+import org.logstash.gradle.dra.StackArtifactHandler
+
+@CompileStatic
+class ArtifactSet {
+    String name
+    StackArtifactHandler stackArtifactHandler
+    boolean configureArtifacts
+
+    public ArtifactSet(final String name, final StackArtifactHandler stackArtifactHandler, final boolean configureArtifacts) {
+        this.name = name
+        this.stackArtifactHandler = stackArtifactHandler
+        this.configureArtifacts = configureArtifacts
+    }
+
+    public void configure(Closure closure) {
+        closure.delegate = this
+        // ensure the artifacts closure goes to the method we have defined in this class
+        closure.resolveStrategy = Closure.DELEGATE_FIRST
+        closure.call()
+    }
+
+    public void artifacts(Closure closure) {
+        if (configureArtifacts) {
+            ConfigureUtil.configure(closure, stackArtifactHandler)
+        }
+    }
+
+}
diff --git a/buildSrc/src/main/groovy/org/logstash/gradle/dra/artifactset/ArtifactSetHandler.groovy b/buildSrc/src/main/groovy/org/logstash/gradle/dra/artifactset/ArtifactSetHandler.groovy
new file mode 100644
index 00000000000..8fc52827b95
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/logstash/gradle/dra/artifactset/ArtifactSetHandler.groovy
@@ -0,0 +1,21 @@
+package org.logstash.gradle.dra.artifactset
+
+import groovy.transform.CompileStatic
+import org.logstash.gradle.dra.StackArtifactHandler
+
+@CompileStatic
+class ArtifactSetHandler {
+
+    private final Map<String, ArtifactSet> artifactSets = new LinkedHashMap<>()
+
+    void artifactSet(final String name, final StackArtifactHandler stackArtifactHandler, final boolean configureArtifacts, Closure closure) {
+        ArtifactSet build = new ArtifactSet(name, stackArtifactHandler, configureArtifacts)
+        build.configure(closure)
+        artifactSets[name] = build
+    }
+
+    public Map<String, ArtifactSet> getArtifactSets() {
+        return artifactSets
+    }
+
+}
diff --git a/buildSrc/src/main/groovy/org/logstash/gradle/dra/configuration/StackConfigurationPluginExtension.groovy b/buildSrc/src/main/groovy/org/logstash/gradle/dra/configuration/StackConfigurationPluginExtension.groovy
new file mode 100644
index 00000000000..67f71cb1f58
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/logstash/gradle/dra/configuration/StackConfigurationPluginExtension.groovy
@@ -0,0 +1,408 @@
+package org.logstash.gradle.dra.configuration
+
+import groovy.transform.CompileStatic
+import org.gradle.api.Action
+import org.gradle.api.Project
+import org.gradle.api.model.ObjectFactory
+import org.gradle.api.provider.ListProperty
+import org.gradle.api.provider.Property
+import org.gradle.api.tasks.Nested
+import org.gradle.api.tasks.Optional
+
+@CompileStatic
+class StackConfigurationPluginExtension {
+
+    /** A random suffix intended to help uniquely identify a given build */
+    private static String buildIdRandomSuffix
+
+    /** Comma separated list of what projects to generate tasks for, when unset use all projects. */
+    private Property<String> projects
+
+    /**
+     * If true, read the DSL for all projects, overriding the 'projects' property, and cause build task generation to be
+     * skipped. This is used to enable tasks that require all the projects to be present at runtime, like report
+     * generation and generating the trigger manifest, but no build commands or build command restrictions should be processed.
+     *
+     * Defaults to false.
+     */
+    private Property<Boolean> readAllProjectsAndSkipBuildTaskGeneration
+
+    /** What local build to run */
+    private Property<String> localBuild
+
+    /** What artifact set to process */
+    private Property<String> artifactSet
+
+    /** The default base git URL to checkout projects codebase */
+    private Property<String> defaultGitBaseURL
+
+    /**
+     * The conceptual branch that the release is based on. This normally corresponds to the git branch for the projects,
+     * but it is possible for projects to use different branching strategies.
+     */
+    private Property<String> releaseBranch
+
+    /** Comma separated list of manifest URLs for merging into a build */
+    private Property<String> externalManifests
+
+    /**
+     * Comma separated list of projects to exclude external artifacts manifest urls for and ignore commit pinning from
+     * external manifests and command line commit hash properties. For use when creating a Build Candidate using
+     * non-latest artifacts. Default to empty string "".
+     */
+    private Property <String> projectsThatShouldIgnoreCommitPinning
+
+    /**
+     * The GitHub organization to add tags to when releasing.
+     */
+    private Property<String> gitHubOrganization
+
+    /**
+     * The author of commits when adding git tags.
+     */
+    private Property<String> gitTagAuthor
+
+    /**
+     * The email of commits when adding git tags.
+     */
+    private Property<String> gitTagEmail
+
+    /** A flag to indicate whether the release-manager itself is running in a container (false by default) */
+    private Property<Boolean> runInContainer
+
+    /** A flag to indicate whether git checkouts of projects are required or not (true by default). */
+    private Property<Boolean> scmCheckoutsRequired
+
+    /**
+     * The path where the artifacts are managed by the release-manager,
+     * by default relative to the Gradle Project path.
+     */
+    private Property<String> workspacePath
+
+    /** The folder where manifest files are uploaded to, defaults to an empty string */
+    private Property<String> manifestsPath
+
+    /** The folder where manifest files are downloaded from, default to "manifests" */
+    private Property<String> downloadManifestsPath
+
+    /**
+     * The name of the manifest file to generate locally and upload to the bucket.
+     *
+     * Note that the final filename in the bucket gets the version appended. For example, if this property is set to
+     *  manifest-A.json, the related file uploaded to the bucket would be named manifest-A-8.0.0-SNAPSHOT.json
+     *
+     *  The default value is: manifest
+     */
+    private Property<String> manifestFileName
+
+    /** DownloadManifestArtifacts task will check and avoid downloading artifact .zip if one is already on disk. False by default */
+    private Property<Boolean> skipDownloadWhenArtifactZipExists
+
+    /**
+     * The folder where artifacts should be expected for both snapshot and staging builds. For use with ArtifactsSets
+     * from docker. Default is "" (empty string).
+     */
+    private Property<String> expectedArtifactsPathOverride
+
+//    /** The instance for handling the versionConfiguration {} block */
+//    private VersionConfiguration versionConfiguration
+
+    /** Gradle project */
+    private Project project
+
+//    private TriggerConfiguration trigger
+
+    public String stackVersion
+    public String versionQualifier
+    public String qualifiedVersion
+    public String buildId
+
+    StackConfigurationPluginExtension(final Project project) {
+        this.project = project
+        projects = project.getObjects().property(String.class)
+        readAllProjectsAndSkipBuildTaskGeneration = project.getObjects().property(Boolean.class)
+        localBuild = project.getObjects().property(String.class)
+        artifactSet = project.getObjects().property(String.class)
+        defaultGitBaseURL = project.getObjects().property(String.class)
+        releaseBranch = project.getObjects().property(String.class)
+        externalManifests = project.getObjects().property(String.class)
+        projectsThatShouldIgnoreCommitPinning = project.getObjects().property(String.class)
+        gitHubOrganization = project.getObjects().property(String.class)
+        gitTagAuthor = project.getObjects().property(String.class)
+        gitTagEmail = project.getObjects().property(String.class)
+        runInContainer = project.getObjects().property(Boolean.class)
+        scmCheckoutsRequired = project.getObjects().property(Boolean.class)
+        workspacePath = project.getObjects().property(String.class)
+        manifestsPath = project.getObjects().property(String.class)
+        downloadManifestsPath = project.getObjects().property(String.class)
+        manifestFileName = project.getObjects().property(String.class)
+        skipDownloadWhenArtifactZipExists = project.getObjects().property(Boolean.class)
+        expectedArtifactsPathOverride = project.getObjects().property(String.class)
+
+        ObjectFactory objectFactory = project.getObjects()
+//        trigger = objectFactory.newInstance(TriggerConfiguration.class)
+//
+//        versionConfiguration = new VersionConfiguration(project.properties, getBuildIdOverride())
+    }
+
+    void setProjects(final String projects) {
+        this.projects.set(projects)
+    }
+
+    void setReadAllProjectsAndSkipBuildTaskGeneration(final Boolean readAllProjectsAndSkipBuildTaskGeneration) {
+        this.readAllProjectsAndSkipBuildTaskGeneration.set(readAllProjectsAndSkipBuildTaskGeneration)
+    }
+
+    Boolean getReadAllProjectsAndSkipBuildTaskGeneration() {
+        return getValue(readAllProjectsAndSkipBuildTaskGeneration.getOrElse(false), 'readAllProjectsAndSkipBuildTaskGeneration')
+    }
+
+    String getLocalBuild() {
+        return getValue(localBuild.getOrElse(''), 'localBuild')
+    }
+
+    void setLocalBuild(final String localBuild) {
+        this.localBuild.set(localBuild)
+    }
+
+    String getArtifactSet() {
+        return getValue(artifactSet.getOrElse(''), 'artifactSet')
+    }
+
+    void setArtifactSet(final String artifactSet) {
+        this.artifactSet.set(artifactSet)
+    }
+
+    String getDefaultGitBaseURL() {
+        return getValue(defaultGitBaseURL.getOrNull(), 'defaultGitBaseURL')
+    }
+
+    void setDefaultGitBaseURL(final String defaultGitBaseURL) {
+        this.defaultGitBaseURL.set(defaultGitBaseURL)
+    }
+
+    String getReleaseBranch() {
+        return getValue(releaseBranch.getOrNull(), 'releaseBranch')
+    }
+
+    void setReleaseBranch(final String releaseBranch) {
+        this.releaseBranch.set(releaseBranch)
+    }
+
+
+    String getExternalManifests() {
+        return getValue(externalManifests.getOrElse(''), 'externalManifests')
+    }
+
+    void setExternalManifests(final String externalManifests) {
+        this.externalManifests.set(externalManifests)
+    }
+
+    String getProjectsThatShouldIgnoreCommitPinning() {
+        return getValue(projectsThatShouldIgnoreCommitPinning.getOrElse(''), 'projectsThatShouldIgnoreCommitPinning')
+    }
+
+    void setProjectsThatShouldIgnoreCommitPinning(final String projectsThatShouldIgnoreCommitPinning) {
+        this.projectsThatShouldIgnoreCommitPinning.set(projectsThatShouldIgnoreCommitPinning)
+    }
+
+    Boolean getRunInContainer() {
+        return getValue(runInContainer.getOrElse(false), 'runInContainer')
+    }
+
+    void setRunInContainer(final Boolean runInContainer) {
+        this.runInContainer.set(runInContainer)
+    }
+
+    Boolean getScmCheckoutsRequired() {
+        return getValue(scmCheckoutsRequired.getOrElse(true), 'scmCheckoutsRequired')
+    }
+
+    void setScmCheckoutsRequired(final Boolean scmCheckoutsRequired) {
+        this.scmCheckoutsRequired.set(scmCheckoutsRequired)
+    }
+
+    String getWorkspacePath() {
+        return getValue(workspacePath.getOrNull(), 'workspacePath')
+    }
+
+    void setWorkspacePath(final String workspacePath) {
+        this.workspacePath.set(workspacePath)
+    }
+
+    String gitHubOrganization() {
+        return getValue(gitHubOrganization.get(), 'gitHubOrganization')
+    }
+
+    void setGitHubOrganization(final String gitHubOrganization) {
+        this.gitHubOrganization.set(gitHubOrganization)
+    }
+
+    String getGitTagAuthor() {
+        return getValue(gitTagAuthor.get(), 'gitTagAuthor')
+    }
+
+    void setGitTagAuthor(final String gitTagAuthor) {
+        this.gitTagAuthor.set(gitTagAuthor)
+    }
+
+    String getGitTagEmail() {
+        return getValue(gitTagEmail.get(), 'gitTagEmail')
+    }
+
+    void setGitTagEmail(final String gitTagEmail) {
+        this.gitTagEmail.set(gitTagEmail)
+    }
+
+    String getManifestsPath() {
+        return getValue(manifestsPath.getOrElse(''), 'manifestsPath')
+    }
+
+    void setManifestsPath(final String manifestsPath) {
+        this.manifestsPath.set(manifestsPath)
+    }
+
+    String getDownloadManifestsPath() {
+        return getValue(downloadManifestsPath.getOrElse('manifests'), 'downloadManifestsPath')
+    }
+
+    void setDownloadManifestsPath(final String downloadManifestsPath) {
+        this.downloadManifestsPath.set(downloadManifestsPath)
+    }
+
+    String getManifestFileName() {
+        return getValue(manifestFileName.getOrElse("manifest"), 'manifestFileName')
+    }
+
+    void setManifestFileName(final String manifestsPath) {
+        this.manifestFileName.set(manifestFileName)
+    }
+
+    String getExpectedArtifactsPathOverride() {
+        return getValue(expectedArtifactsPathOverride.getOrElse(''), 'expectedArtifactsPathOverride')
+    }
+
+    void setExpectedArtifactsPathOverride(final String expectedArtifactsPathOverride) {
+        this.expectedArtifactsPathOverride.set(expectedArtifactsPathOverride)
+    }
+
+//    public void trigger(Action<? super TriggerConfiguration> action) {
+//        action.execute(trigger)
+//    }
+//
+//    @Nested
+//    @Optional
+//    public TriggerConfiguration getTrigger() {
+//        trigger.setEnable(getValue(Boolean.valueOf(trigger.getEnable()), 'trigger.enable'))
+//        return trigger
+//    }
+//
+//    void versionConfiguration(Action<? super VersionConfiguration> action) {
+//        action.execute(versionConfiguration)
+//        stackVersion = versionConfiguration.getVersion()
+//        versionQualifier = versionConfiguration.getQualifier()
+//        qualifiedVersion = versionConfiguration.qualifiedVersion()
+//        buildId = getBuildId(qualifiedVersion)
+//    }
+
+    Boolean getSkipDownloadWhenArtifactZipExists() {
+        return getValue(skipDownloadWhenArtifactZipExists.getOrElse(false), 'skipDownloadWhenArtifactZipExists')
+    }
+
+    void setSkipDownloadWhenArtifactZipExists(final Boolean skip) {
+        this.skipDownloadWhenArtifactZipExists.set(skip)
+    }
+
+    public static String getBuildIdOverride() {
+        final String buildIdProperty = System.getProperty('buildId')
+        if (buildIdProperty == '') {
+            return null
+        } else if (buildIdProperty != null) {
+            println("The system property 'buildId' is set to ${buildIdProperty}")
+            return buildIdProperty
+        } else {
+            return null
+        }
+    }
+
+    /** Returns a random 8 character hex value, intending to uniquely identify this build. */
+    public static String getBuildIdRandomSuffix() {
+        String buildIdOverride = getBuildIdOverride()
+
+//        // Use the override if it exists. This must be checked every time so that the test framework is able to change
+//        // the build id.
+//        if (buildIdOverride != null) {
+//            // There is a build id override set, get the random suffix from the specified build id.
+//            buildIdRandomSuffix = new VersionConfiguration.BuildIdParser(buildIdOverride).getRandomSuffix()
+//            return buildIdRandomSuffix
+//        }
+
+        // Make sure subsequent calls to this method return the same value.
+        if (buildIdRandomSuffix != null) {
+            return buildIdRandomSuffix
+        }
+
+        // there is not a build override set, and we haven't come up with a value yet, so generate one
+        final char[] hexChars = '0123456789abcdef'.toCharArray()
+        final Random r = new Random()
+        final StringBuffer sb = new StringBuffer()
+        while(sb.length() < 8) {
+            final char randomChar = hexChars[r.nextInt(hexChars.length)]
+            sb.append(randomChar)
+        }
+        buildIdRandomSuffix = sb.toString()
+
+        return buildIdRandomSuffix
+    }
+
+    /** Returns a unique identifier for this build, based on the version and build hash. */
+    public static String getBuildId(final String qualifiedVersion) {
+        return "${qualifiedVersion}-${getBuildIdRandomSuffix()}"
+    }
+
+    /**
+     *  A property can be defined in a DSL and overridden via the command line, e.g.
+     *
+     *  <pre>
+     *
+     *     configuration {
+     *
+     *       // Default base URL to checkout git projects
+     *       defaultGitBaseURL = 'git@github.com:elastic'
+     *       ...
+     *     }
+     *
+     *  </pre>
+     *
+     *  This value can be overridden through the command line:
+     *
+     *  <pre>./gradlew clean -Pconfiguration.defaultGitBaseURL=https://github.com/elastic </pre>
+     *
+     * @param valueFromDSL value for a propertyName defined in the DSL
+     * @param propertyName value defined via the command line -Pconfiguration.<propertyName>
+     * @return the final value
+     */
+    private String getValue(final String valueFromDSL, final String propertyName) {
+        if (getConfigurationProperty(propertyName)) {
+            return getConfigurationProperty(propertyName)
+        } else {
+            return valueFromDSL
+        }
+    }
+
+    private Boolean getValue(final Boolean valueFromDSL, final String propertyName) {
+        if (getConfigurationProperty(propertyName)) {
+            return Boolean.valueOf(getConfigurationProperty(propertyName))
+        } else {
+            return valueFromDSL
+        }
+    }
+
+    private String getConfigurationProperty(final String propertyName) {
+        if (project.hasProperty("configuration.${propertyName}")) {
+            return project.property("configuration.${propertyName}").toString()
+        } else {
+            return null
+        }
+    }
+}
diff --git a/buildSrc/src/main/groovy/org/logstash/gradle/dra/localbuild/LocalBuild.groovy b/buildSrc/src/main/groovy/org/logstash/gradle/dra/localbuild/LocalBuild.groovy
new file mode 100644
index 00000000000..b06345bf652
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/logstash/gradle/dra/localbuild/LocalBuild.groovy
@@ -0,0 +1,34 @@
+package org.logstash.gradle.dra.localbuild
+
+import groovy.transform.CompileStatic
+import org.logstash.gradle.dra.StackArtifactHandler
+import org.gradle.util.ConfigureUtil
+
+@CompileStatic
+class LocalBuild {
+    String name
+    List<String> buildSnapshotCommands
+    List<String> buildReleaseCommands
+    StackArtifactHandler stackArtifactHandler
+    boolean configureArtifacts
+
+    public LocalBuild(final String name, final StackArtifactHandler stackArtifactHandler, final boolean configureArtifacts) {
+        this.name = name
+        this.stackArtifactHandler = stackArtifactHandler
+        this.configureArtifacts = configureArtifacts
+    }
+
+    public void configure(Closure closure) {
+        closure.delegate = this
+        // ensure the artifacts closure goes to the method we have defined in this class
+        closure.resolveStrategy = Closure.DELEGATE_FIRST
+        closure.call()
+    }
+
+    public void artifacts(Closure closure) {
+        if (configureArtifacts) {
+            stackArtifactHandler.localBuildName = name
+            ConfigureUtil.configure(closure, stackArtifactHandler)
+        }
+    }
+}
diff --git a/buildSrc/src/main/groovy/org/logstash/gradle/dra/localbuild/LocalBuildHandler.groovy b/buildSrc/src/main/groovy/org/logstash/gradle/dra/localbuild/LocalBuildHandler.groovy
new file mode 100644
index 00000000000..3218c0f4864
--- /dev/null
+++ b/buildSrc/src/main/groovy/org/logstash/gradle/dra/localbuild/LocalBuildHandler.groovy
@@ -0,0 +1,20 @@
+package org.logstash.gradle.dra.localbuild
+
+import groovy.transform.CompileStatic
+import org.logstash.gradle.dra.StackArtifactHandler
+
+@CompileStatic
+class LocalBuildHandler {
+
+    private final Map<String, LocalBuild> localBuilds = new LinkedHashMap<>()
+
+    void localBuild(final String name, final StackArtifactHandler stackArtifactHandler, final boolean configureArtifacts, Closure closure) {
+        LocalBuild build = new LocalBuild(name, stackArtifactHandler, configureArtifacts)
+        build.configure(closure)
+        localBuilds[name] = build
+    }
+
+    public Map<String, LocalBuild> getLocalBuilds() {
+        return localBuilds
+    }
+}
\ No newline at end of file
diff --git a/buildSrc/src/main/resources/META-INF/gradle-plugins/logstash-dra.properties b/buildSrc/src/main/resources/META-INF/gradle-plugins/logstash-dra.properties
new file mode 100644
index 00000000000..f1169bec625
--- /dev/null
+++ b/buildSrc/src/main/resources/META-INF/gradle-plugins/logstash-dra.properties
@@ -0,0 +1 @@
+implementation-class=org.logstash.gradle.dra.LogstashDraPlugin
\ No newline at end of file
diff --git a/dra.gradle b/dra.gradle
new file mode 100644
index 00000000000..9af15aee890
--- /dev/null
+++ b/dra.gradle
@@ -0,0 +1,122 @@
+
+apply plugin: 'logstash-dra'
+
+logstash {
+  releaseName = "Logstash"
+//  downloadName = "logstash"
+//  releaseNotes = { String b, String v -> "https://www.elastic.co/guide/en/logstash/${b}/logstash-${v.replaceAll("\\.", "-")}.html" }
+//
+  Closure logstashArtifacts =  {
+      generic = false
+
+      // no-jdk artifacts
+      tar dir:'build', name: 'logstash',     classifier: 'no-jdk', generic: true
+      tar dir:'build', name: 'logstash-oss', classifier: 'no-jdk', generic: true, oss: true
+      zip dir:'build', name: 'logstash',     classifier: 'no-jdk', generic: true
+      zip dir:'build', name: 'logstash-oss', classifier: 'no-jdk', generic: true, oss: true
+      deb dir:'build', name: 'logstash',     classifier: 'no-jdk', generic: true, include_in_repo: false
+      deb dir:'build', name: 'logstash-oss', classifier: 'no-jdk', generic: true, oss: true, include_in_repo: false
+      rpm dir:'build', name: 'logstash',     classifier: 'no-jdk', generic: true, include_in_repo: false
+      rpm dir:'build', name: 'logstash-oss', classifier: 'no-jdk', generic: true, oss: true, include_in_repo: false
+
+      // x86_64
+      tar dir:'build', name: 'logstash',     architecture: 'x86_64', os: ['linux']
+      tar dir:'build', name: 'logstash-oss', architecture: 'x86_64', os: ['linux'], oss: true
+      tar dir:'build', name: 'logstash',     architecture: 'x86_64', os: ['darwin']
+      tar dir:'build', name: 'logstash-oss', architecture: 'x86_64', os: ['darwin'], oss: true
+      zip dir:'build', name: 'logstash',     architecture: 'x86_64', os: ['windows']
+      zip dir:'build', name: 'logstash-oss', architecture: 'x86_64', os: ['windows'], oss: true
+      deb dir:'build', name: 'logstash',     architecture: 'amd64'
+      deb dir:'build', name: 'logstash-oss', architecture: 'amd64', oss: true
+      rpm dir:'build', name: 'logstash',     architecture: 'x86_64'
+      rpm dir:'build', name: 'logstash-oss', architecture: 'x86_64', oss: true
+
+      // arm64
+      tar dir:'build', name: 'logstash',     architecture: 'aarch64', os: ['linux']
+      tar dir:'build', name: 'logstash-oss', architecture: 'aarch64', os: ['linux'], oss: true
+      tar dir:'build', name: 'logstash',     architecture: 'aarch64', os: ['darwin']
+      tar dir:'build', name: 'logstash-oss', architecture: 'aarch64', os: ['darwin'], oss: true
+      deb dir:'build', name: 'logstash',     architecture: 'arm64'
+      deb dir:'build', name: 'logstash-oss', architecture: 'arm64',   oss: true
+      rpm dir:'build', name: 'logstash',     architecture: 'aarch64'
+      rpm dir:'build', name: 'logstash-oss', architecture: 'aarch64', oss: true
+
+      docker dir: '.', repo: 'docker.elastic.co', org: 'logstash', name: 'logstash', classifier: 'docker-image', architecture: 'x86_64'
+      docker dir: '.', repo: 'docker.elastic.co', org: 'logstash', name: 'logstash-oss', classifier: 'docker-image', architecture: 'x86_64'
+      docker dir: '.', repo: 'docker.elastic.co', org: 'logstash', name: 'logstash-ubi8', classifier: 'docker-image', architecture: 'x86_64'
+      docker dir: "build", name: 'logstash', classifier: 'docker-build-context'
+      docker dir: "build", name: 'logstash-oss', classifier: 'docker-build-context'
+      docker dir: "build", name: 'logstash-ubi8', classifier: 'docker-build-context'
+      docker dir: "build", name: 'logstash-ironbank', classifier: 'docker-build-context'
+  }
+
+  Closure logstashArmArtifacts =  {
+      generic = false
+      docker dir: '.', repo: 'docker.elastic.co', org: 'logstash', name: 'logstash', classifier: 'docker-image', architecture: 'aarch64'
+      docker dir: '.', repo: 'docker.elastic.co', org: 'logstash', name: 'logstash-oss', classifier: 'docker-image', architecture: 'aarch64'
+  }
+
+  // Artifact set configuration for use from logstash-ci.
+  artifactSet('main') {
+    artifacts(logstashArtifacts)
+    artifacts(logstashArmArtifacts)
+    artifacts {
+      csvDependencyReport dir: 'build/distributions', name: 'dependencies'
+    }
+  }
+
+  String buildArgs = ""
+  if (versionQualifier) {
+    buildArgs = "VERSION_QUALIFIER=${versionQualifier}"
+  }
+
+  localBuild('local') {
+    buildSnapshotCommands = [
+//      'export JAVA_HOME="$HOME/.java/adoptopenjdk11"',
+//      'export LS_JAVA_HOME="$HOME/.java/adoptopenjdk11"',
+      'export JAVA_HOME="/home/andrea/.sdkman/candidates/java/11.0.15-tem/"',
+      'export LS_JAVA_HOME="/home/andrea/.sdkman/candidates/java/11.0.15-tem/"',
+      'export PATH=$HOME/.rbenv/shims:$PATH', // Logstash build use rbenv but rbenv shims aren't in jenkins user PATH
+      "${buildArgs} rake artifact:all",
+      'bin/dependencies-report --csv=$DEPENDENCIES_REPORTS_DIR/$DEPENDENCIES_REPORT'
+    ]
+    buildReleaseCommands = [
+      'export JAVA_HOME="$HOME/.java/adoptopenjdk11"',
+      'export LS_JAVA_HOME="$HOME/.java/adoptopenjdk11"',
+      'export PATH=$HOME/.rbenv/shims:$PATH', // Logstash build use rbenv but rbenv shims aren't in jenkins user PATH
+      "${buildArgs} RELEASE=1 rake artifact:all",
+      'bin/dependencies-report --csv=$DEPENDENCIES_REPORTS_DIR/$DEPENDENCIES_REPORT'
+    ]
+
+    artifacts(logstashArtifacts)
+  }
+
+  localBuild('aarch64') {
+    buildSnapshotCommands = [
+            'export JAVA_HOME="$HOME/.java/adoptopenjdk11"',
+            'export LS_JAVA_HOME="$HOME/.java/adoptopenjdk11"',
+            'export PATH=$PATH:/opt/jruby/jruby-9.1.12.0/bin',
+            "${buildArgs} rake artifact:docker",
+            "${buildArgs} rake artifact:docker_oss",
+            "${buildArgs} rake artifact:dockerfiles",
+            'bin/dependencies-report --csv=$DEPENDENCIES_REPORTS_DIR/$DEPENDENCIES_REPORT'
+    ]
+    buildReleaseCommands = [
+            'export JAVA_HOME="$HOME/.java/adoptopenjdk11"',
+            'export LS_JAVA_HOME="$HOME/.java/adoptopenjdk11"',
+            'export PATH=$PATH:/opt/jruby/jruby-9.1.12.0/bin',
+            "${buildArgs} RELEASE=1 rake artifact:docker",
+            "${buildArgs} RELEASE=1 rake artifact:docker_oss",
+            "${buildArgs} rake artifact:dockerfiles",
+            'bin/dependencies-report --csv=$DEPENDENCIES_REPORTS_DIR/$DEPENDENCIES_REPORT'
+    ]
+
+    statusMessages = [
+            '[bootstrap]' : 'bootstrapping dependencies',
+            '[plugin:install-default]' : 'fetching plugins',
+            '[artifact:' : 'building distributions'
+    ]
+
+    artifacts(logstashArmArtifacts)
+  }
+}
