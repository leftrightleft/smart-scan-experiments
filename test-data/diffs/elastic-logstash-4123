diff --git a/Gemfile b/Gemfile
index cef2642798b..70d17c8350e 100644
--- a/Gemfile
+++ b/Gemfile
@@ -2,7 +2,9 @@
 # If you modify this file manually all comments and formatting will be lost.
 
 source "https://rubygems.org"
-gem "logstash-core", "3.0.0.dev", :path => "."
+gem "logstash-core", "3.0.0.dev", :path => "./logstash-core"
+gem "logstash-core-event", "3.0.0.dev", :path => "./logstash-core-event"
+# gem "logstash-core-event-java", "3.0.0.dev", :path => "./logstash-core-event-java"
 gem "file-dependencies", "0.1.6"
 gem "ci_reporter_rspec", "1.0.0", :group => :development
 gem "simplecov", :group => :development
diff --git a/Gemfile.jruby-1.9.lock b/Gemfile.jruby-1.9.lock
index a2accef2d25..8f0779a5968 100644
--- a/Gemfile.jruby-1.9.lock
+++ b/Gemfile.jruby-1.9.lock
@@ -1,14 +1,14 @@
 PATH
-  remote: .
+  remote: ./logstash-core
   specs:
     logstash-core (3.0.0.dev-java)
       cabin (~> 0.7.0)
       clamp (~> 0.6.5)
-      concurrent-ruby (~> 0.9.1)
+      concurrent-ruby (= 0.9.1)
       filesize (= 0.0.4)
       gems (~> 0.8.3)
       i18n (= 0.6.9)
-      jrjackson (~> 0.3.5)
+      jrjackson (~> 0.3.6)
       jruby-openssl (>= 0.9.11)
       minitar (~> 0.5.4)
       pry (~> 0.10.1)
@@ -16,17 +16,23 @@ PATH
       thread_safe (~> 0.3.5)
       treetop (< 1.5.0)
 
+PATH
+  remote: ./logstash-core-event
+  specs:
+    logstash-core-event (3.0.0.dev-java)
+      logstash-core (>= 2.0.0.beta2, < 3.0.0)
+
 GEM
   remote: https://rubygems.org/
   specs:
     addressable (2.3.8)
     arr-pm (0.0.10)
       cabin (> 0)
-    backports (3.6.6)
+    backports (3.6.7)
     benchmark-ips (2.3.0)
     builder (3.2.2)
-    cabin (0.7.1)
-    childprocess (0.5.6)
+    cabin (0.7.2)
+    childprocess (0.5.7)
       ffi (~> 1.0, >= 1.0.11)
     ci_reporter (2.0.0)
       builder (>= 2.1.2)
@@ -67,7 +73,7 @@ GEM
       domain_name (~> 0.5)
     i18n (0.6.9)
     insist (1.0.0)
-    jrjackson (0.3.5)
+    jrjackson (0.3.6)
     jruby-openssl (0.9.12-java)
     json (1.8.3-java)
     kramdown (1.9.0)
@@ -84,11 +90,11 @@ GEM
     mime-types (2.6.2)
     minitar (0.5.4)
     multipart-post (2.0.0)
-    netrc (0.10.3)
+    netrc (0.11.0)
     octokit (3.8.0)
       sawyer (~> 0.6.0, >= 0.5.3)
     polyglot (0.3.5)
-    pry (0.10.2-java)
+    pry (0.10.3-java)
       coderay (~> 1.1.0)
       method_source (~> 0.8.1)
       slop (~> 3.4)
@@ -147,6 +153,7 @@ DEPENDENCIES
   fpm (~> 1.3.3)
   gems (~> 0.8.3)
   logstash-core (= 3.0.0.dev)!
+  logstash-core-event (= 3.0.0.dev)!
   logstash-devutils (~> 0.0.15)
   octokit (= 3.8.0)
   rspec (~> 3.1.0)
diff --git a/lib/bootstrap/environment.rb b/lib/bootstrap/environment.rb
index 9f3e59f5b08..0206959a400 100644
--- a/lib/bootstrap/environment.rb
+++ b/lib/bootstrap/environment.rb
@@ -35,6 +35,15 @@ def ruby_engine
     def logstash_gem_home
       ::File.join(BUNDLE_DIR, ruby_engine, gem_ruby_version)
     end
+
+    def vendor_path(path)
+      return ::File.join(LOGSTASH_HOME, "vendor", path)
+    end
+
+    def pattern_path(path)
+      return ::File.join(LOGSTASH_HOME, "patterns", path)
+    end
+
   end
 end
 
diff --git a/lib/logstash-event.rb b/lib/logstash-event.rb
deleted file mode 100644
index 0f44322944b..00000000000
--- a/lib/logstash-event.rb
+++ /dev/null
@@ -1,2 +0,0 @@
-# encoding: utf-8
-require "logstash/event"
diff --git a/lib/logstash/patches/bundler.rb b/lib/logstash/patches/bundler.rb
deleted file mode 100644
index 25d93a09148..00000000000
--- a/lib/logstash/patches/bundler.rb
+++ /dev/null
@@ -1,36 +0,0 @@
-# encoding: utf-8
-# Bundler monkey patches
-module ::Bundler
-  # Patch bundler to write a .lock file specific to the version of ruby.
-  # This keeps MRI/JRuby/RBX from conflicting over the Gemfile.lock updates
-  module SharedHelpers
-    def default_lockfile
-      ruby = "#{LogStash::Environment.ruby_engine}-#{LogStash::Environment.ruby_abi_version}"
-      Pathname.new("#{default_gemfile}.#{ruby}.lock")
-    end
-  end
-
-  # Patch to prevent Bundler to save a .bundle/config file in the root 
-  # of the application
-  class Settings
-    def set_key(key, value, hash, file)
-      key = key_for(key)
-
-      unless hash[key] == value
-        hash[key] = value
-        hash.delete(key) if value.nil?
-      end
-
-      value
-    end
-  end
-
-  # Add the Bundler.reset! method which has been added in master but is not in 1.7.9.
-  class << self
-    unless self.method_defined?("reset!")
-      def reset!
-        @definition = nil
-      end
-    end
-  end
-end
diff --git a/logstash-core-event-java/.gitignore b/logstash-core-event-java/.gitignore
new file mode 100644
index 00000000000..a453cb95034
--- /dev/null
+++ b/logstash-core-event-java/.gitignore
@@ -0,0 +1,9 @@
+*.class
+
+# build dirs
+build
+.gradle
+
+# Intellij
+.idea
+*.iml
diff --git a/logstash-core-event-java/README.md b/logstash-core-event-java/README.md
new file mode 100644
index 00000000000..7b12d19f135
--- /dev/null
+++ b/logstash-core-event-java/README.md
@@ -0,0 +1,63 @@
+# logstash-core-event-java
+
+## dev install
+
+1- build code with
+
+```
+$ cd logstash-core-event-java
+$ gradle build
+```
+
+A bunch of warning are expected, it should end with:
+
+```
+BUILD SUCCESSFUL
+```
+
+2- update root logstash `Gemfile` to use this gem with:
+
+```
+# gem "logstash-core-event", "x.y.z", :path => "./logstash-core-event"
+gem "logstash-core-event-java", "x.y.z", :path => "./logstash-core-event-java"
+```
+
+3- update `logstash-core/logstash-core.gemspec` with:
+
+```
+# gem.add_runtime_dependency "logstash-core-event", "x.y.z"
+gem.add_runtime_dependency "logstash-core-event-java", "x.y.z"
+```
+
+4- and install:
+
+```
+$ bin/bundle
+```
+
+- install core plugins for tests
+
+```
+$ rake test:install-core
+```
+
+## specs
+
+```
+$ bin/rspec spec
+$ bin/rspec logstash-core/spec
+$ bin/rspec logstash-core-event/spec
+$ bin/rspec logstash-core-event-java/spec
+```
+
+or
+
+```
+$ rake test:core
+```
+
+also
+
+```
+$ rake test:plugins
+```
\ No newline at end of file
diff --git a/logstash-core-event-java/build.gradle b/logstash-core-event-java/build.gradle
new file mode 100644
index 00000000000..6e4c299a79d
--- /dev/null
+++ b/logstash-core-event-java/build.gradle
@@ -0,0 +1,104 @@
+buildscript {
+  repositories {
+    mavenLocal()
+    mavenCentral()
+    jcenter()
+  }
+  dependencies {
+    classpath 'net.saliman:gradle-cobertura-plugin:2.2.8'
+    classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.2'
+  }
+}
+
+//allprojects {
+
+  repositories {
+    mavenLocal()
+    mavenCentral()
+  }
+
+  gradle.projectsEvaluated {
+    tasks.withType(JavaCompile) {
+      options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
+    }
+  }
+
+//}
+
+//subprojects { project ->
+
+  apply plugin: 'java'
+  apply plugin: 'idea'
+  apply plugin: 'com.github.johnrengelman.shadow'
+
+  group = 'org.logstash'
+
+  project.sourceCompatibility = 1.7
+
+  task sourcesJar(type: Jar, dependsOn:classes) {
+    from sourceSets.main.allSource
+    classifier 'sources'
+    extension 'jar'
+  }
+
+  task javadocJar(type: Jar, dependsOn:javadoc) {
+    from javadoc.destinationDir
+    classifier 'javadoc'
+    extension 'jar'
+  }
+
+  configurations.create('sources')
+  configurations.create('javadoc')
+  configurations.archives {
+    extendsFrom configurations.sources
+    extendsFrom configurations.javadoc
+  }
+
+  artifacts {
+    sources(sourcesJar) {
+      // Weird Gradle quirk where type will be used for the extension, but only for sources
+      type 'jar'
+    }
+
+    javadoc(javadocJar) {
+      type 'javadoc'
+    }
+  }
+
+  configurations {
+    provided
+  }
+
+  project.sourceSets {
+    main.compileClasspath += project.configurations.provided
+    main.runtimeClasspath += project.configurations.provided
+    test.compileClasspath += project.configurations.provided
+    test.runtimeClasspath += project.configurations.provided
+  }
+  project.javadoc.classpath += project.configurations.provided
+
+  idea {
+    module {
+      scopes.PROVIDED.plus += [ project.configurations.provided ]
+    }
+  }
+
+  dependencies {
+    compile     'org.codehaus.jackson:jackson-mapper-asl:1.9.13'
+    compile     'org.codehaus.jackson:jackson-core-asl:1.9.13'
+    compile     'joda-time:joda-time:2.8.2'
+    compile     'com.google.guava:guava:18.0'
+    compile     'org.slf4j:slf4j-api:1.7.12'
+    provided    'org.jruby:jruby-core:1.7.22'
+    testCompile 'org.testng:testng:6.9.6'
+    testCompile 'org.mockito:mockito-core:1.10.19'
+  }
+
+//}
+
+// See http://www.gradle.org/docs/current/userguide/gradle_wrapper.html
+task wrapper(type: Wrapper) {
+  description = 'Install Gradle wrapper'
+  gradleVersion = '2.7'
+}
+
diff --git a/logstash-core-event-java/gradle.properties b/logstash-core-event-java/gradle.properties
new file mode 100644
index 00000000000..b5cdaba6a69
--- /dev/null
+++ b/logstash-core-event-java/gradle.properties
@@ -0,0 +1 @@
+VERSION=0.0.1-SNAPSHOT
diff --git a/logstash-core-event-java/gradle/wrapper/gradle-wrapper.jar b/logstash-core-event-java/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000000..085a1cdc27d
Binary files /dev/null and b/logstash-core-event-java/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/logstash-core-event-java/gradle/wrapper/gradle-wrapper.properties b/logstash-core-event-java/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000000..bd7deb6d61c
--- /dev/null
+++ b/logstash-core-event-java/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Tue Mar 17 11:58:32 PDT 2015
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.3-bin.zip
diff --git a/logstash-core-event-java/gradlew b/logstash-core-event-java/gradlew
new file mode 100755
index 00000000000..91a7e269e19
--- /dev/null
+++ b/logstash-core-event-java/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/logstash-core-event-java/gradlew.bat b/logstash-core-event-java/gradlew.bat
new file mode 100644
index 00000000000..aec99730b4e
--- /dev/null
+++ b/logstash-core-event-java/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/logstash-core-event-java/lib/logstash-core-event-java.rb b/logstash-core-event-java/lib/logstash-core-event-java.rb
new file mode 100644
index 00000000000..29b487aa192
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash-core-event-java.rb
@@ -0,0 +1 @@
+require "logstash-core-event-java/logstash-core-event-java"
\ No newline at end of file
diff --git a/logstash-core-event-java/lib/logstash-core-event-java/logstash-core-event-java.rb b/logstash-core-event-java/lib/logstash-core-event-java/logstash-core-event-java.rb
new file mode 100644
index 00000000000..7bf90a9bc0b
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash-core-event-java/logstash-core-event-java.rb
@@ -0,0 +1,31 @@
+# encoding: utf-8
+
+require "java"
+
+module LogStash
+end
+
+# TODO: (colin) integrate jar loading with gradle and verify dev vs prod environment setups
+
+# insert all jars in this directory into CLASSPATH
+Dir.glob(File.join(File.expand_path("..", __FILE__), "*.jar")).each do |jar|
+  $CLASSPATH << jar unless $CLASSPATH.include?(jar)
+end
+
+# TODO: (colin) correctly handle dev env build/ dir and local jar
+
+# local dev setup
+classes_dir = File.expand_path("../../../build/classes/main", __FILE__)
+
+if File.directory?(classes_dir)
+  # if in local dev setup, add target to classpath
+  $CLASSPATH << classes_dir unless $CLASSPATH.include?(classes_dir)
+else
+  # otherwise use included jar
+  raise("TODO build dir not found and no jar file")
+end
+
+require "jruby_event_ext"
+require "jruby_timestamp_ext"
+require "logstash/event"
+require "logstash/timestamp"
\ No newline at end of file
diff --git a/logstash-core-event-java/lib/logstash-core-event-java/version.rb b/logstash-core-event-java/lib/logstash-core-event-java/version.rb
new file mode 100644
index 00000000000..6c297b7c2fd
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash-core-event-java/version.rb
@@ -0,0 +1,8 @@
+# encoding: utf-8
+
+# The version of logstash core event java gem.
+#
+# Note to authors: this should not include dashes because 'gem' barfs if
+# you include a dash in the version string.
+
+LOGSTASH_CORE_EVENT_JAVA_VERSION = "3.0.0.dev"
diff --git a/logstash-core-event-java/lib/logstash-core-event.rb b/logstash-core-event-java/lib/logstash-core-event.rb
new file mode 100644
index 00000000000..29b487aa192
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash-core-event.rb
@@ -0,0 +1 @@
+require "logstash-core-event-java/logstash-core-event-java"
\ No newline at end of file
diff --git a/logstash-core-event-java/lib/logstash/event.rb b/logstash-core-event-java/lib/logstash/event.rb
new file mode 100644
index 00000000000..a2e6950885d
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash/event.rb
@@ -0,0 +1,24 @@
+# encoding: utf-8
+
+require "logstash/namespace"
+require "logstash/json"
+
+# transcient pipeline events for normal in-flow signaling as opposed to
+# flow altering exceptions. for now having base classes is adequate and
+# in the future it might be necessary to refactor using like a BaseEvent
+# class to have a common interface for all pileline events to support
+# eventual queueing persistence for example, TBD.
+class LogStash::ShutdownEvent; end
+class LogStash::FlushEvent; end
+
+module LogStash
+  FLUSH = LogStash::FlushEvent.new
+
+  # LogStash::SHUTDOWN is used by plugins
+  SHUTDOWN = LogStash::ShutdownEvent.new
+end
+
+# for backward compatibility, require "logstash/event" is used a lots of places so let's bootstrap the
+# Java code loading from here.
+# TODO: (colin) I think we should mass replace require "logstash/event" with require "logstash-core-event"
+require "logstash-core-event"
\ No newline at end of file
diff --git a/logstash-core-event-java/lib/logstash/timestamp.rb b/logstash-core-event-java/lib/logstash/timestamp.rb
new file mode 100644
index 00000000000..0a4661a2d19
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash/timestamp.rb
@@ -0,0 +1,28 @@
+# encoding: utf-8
+
+require "logstash/namespace"
+require "logstash-core-event"
+
+module LogStash
+  class TimestampParserError < StandardError; end
+
+  class Timestamp
+    include Comparable
+
+    # TODO (colin) implement in Java
+    def <=>(other)
+      self.time <=> other.time
+    end
+
+    # TODO (colin) implement in Java
+    def +(other)
+      self.time + other
+    end
+
+    # TODO (colin) implement in Java
+    def -(value)
+      self.time - (value.is_a?(Timestamp) ? value.time : value)
+    end
+
+  end
+end
diff --git a/logstash-core-event-java/logstash-core-event-java.gemspec b/logstash-core-event-java/logstash-core-event-java.gemspec
new file mode 100644
index 00000000000..77667f66e40
--- /dev/null
+++ b/logstash-core-event-java/logstash-core-event-java.gemspec
@@ -0,0 +1,23 @@
+# -*- encoding: utf-8 -*-
+lib = File.expand_path('../lib', __FILE__)
+$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
+require 'logstash-core-event-java/version'
+
+Gem::Specification.new do |gem|
+  gem.authors       = ["Jordan Sissel", "Pete Fritchman", "Elasticsearch"]
+  gem.email         = ["jls@semicomplete.com", "petef@databits.net", "info@elasticsearch.com"]
+  gem.description   = %q{The core event component of logstash, the scalable log and event management tool}
+  gem.summary       = %q{logstash-core-event-java - The core event component of logstash}
+  gem.homepage      = "http://www.elastic.co/guide/en/logstash/current/index.html"
+  gem.license       = "Apache License (2.0)"
+
+  gem.files         = Dir.glob(["logstash-core-event-java.gemspec", "lib/**/*.rb", "spec/**/*.rb"])
+  gem.test_files    = gem.files.grep(%r{^(test|spec|features)/})
+  gem.name          = "logstash-core-event-java"
+  gem.require_paths = ["lib"]
+  gem.version       = LOGSTASH_CORE_EVENT_JAVA_VERSION
+
+  if RUBY_PLATFORM == 'java'
+    gem.platform = RUBY_PLATFORM
+  end
+end
diff --git a/logstash-core-event-java/settings.gradle b/logstash-core-event-java/settings.gradle
new file mode 100644
index 00000000000..3885bfa1686
--- /dev/null
+++ b/logstash-core-event-java/settings.gradle
@@ -0,0 +1,2 @@
+rootProject.name = 'logstash-core-event-java'
+
diff --git a/logstash-core-event-java/spec/event_spec.rb b/logstash-core-event-java/spec/event_spec.rb
new file mode 100644
index 00000000000..a4866ad21db
--- /dev/null
+++ b/logstash-core-event-java/spec/event_spec.rb
@@ -0,0 +1,138 @@
+# encoding: utf-8
+
+require "spec_helper"
+require "logstash/util"
+require "logstash/event"
+require "json"
+
+TIMESTAMP = "@timestamp"
+
+describe LogStash::Event do
+  context "to_json" do
+    it "should serialize simple values" do
+      e = LogStash::Event.new({"foo" => "bar", "bar" => 1, "baz" => 1.0, TIMESTAMP => "2015-05-28T23:02:05.350Z"})
+      expect(JSON.parse(e.to_json)).to eq(JSON.parse("{\"foo\":\"bar\",\"bar\":1,\"baz\":1.0,\"@timestamp\":\"2015-05-28T23:02:05.350Z\",\"@version\":\"1\"}"))
+    end
+
+    it "should serialize deep hash values" do
+      e = LogStash::Event.new({"foo" => {"bar" => 1, "baz" => 1.0, "biz" => "boz"}, TIMESTAMP => "2015-05-28T23:02:05.350Z"})
+      expect(JSON.parse(e.to_json)).to eq(JSON.parse("{\"foo\":{\"bar\":1,\"baz\":1.0,\"biz\":\"boz\"},\"@timestamp\":\"2015-05-28T23:02:05.350Z\",\"@version\":\"1\"}"))
+    end
+
+    it "should serialize deep array values" do
+      e = LogStash::Event.new({"foo" => ["bar", 1, 1.0], TIMESTAMP => "2015-05-28T23:02:05.350Z"})
+      expect(JSON.parse(e.to_json)).to eq(JSON.parse("{\"foo\":[\"bar\",1,1.0],\"@timestamp\":\"2015-05-28T23:02:05.350Z\",\"@version\":\"1\"}"))
+    end
+
+    it "should serialize deep hash from field reference assignments" do
+      e = LogStash::Event.new({TIMESTAMP => "2015-05-28T23:02:05.350Z"})
+      e["foo"] = "bar"
+      e["bar"] = 1
+      e["baz"] = 1.0
+      e["[fancy][pants][socks]"] = "shoes"
+      expect(JSON.parse(e.to_json)).to eq(JSON.parse("{\"@timestamp\":\"2015-05-28T23:02:05.350Z\",\"@version\":\"1\",\"foo\":\"bar\",\"bar\":1,\"baz\":1.0,\"fancy\":{\"pants\":{\"socks\":\"shoes\"}}}"))
+    end
+  end
+
+  context "[]" do
+    it "should get simple values" do
+      e = LogStash::Event.new({"foo" => "bar", "bar" => 1, "baz" => 1.0, TIMESTAMP => "2015-05-28T23:02:05.350Z"})
+      expect(e["foo"]).to eq("bar")
+      expect(e["[foo]"]).to eq("bar")
+      expect(e["bar"]).to eq(1)
+      expect(e["[bar]"]).to eq(1)
+      expect(e["baz"]).to eq(1.0)
+      expect(e["[baz]"]).to eq(1.0)
+      expect(e[TIMESTAMP].to_s).to eq("2015-05-28T23:02:05.350Z")
+      expect(e["[#{TIMESTAMP}]"].to_s).to eq("2015-05-28T23:02:05.350Z")
+    end
+
+    it "should get deep hash values" do
+      e = LogStash::Event.new({"foo" => {"bar" => 1, "baz" => 1.0}})
+      expect(e["[foo][bar]"]).to eq(1)
+      expect(e["[foo][baz]"]).to eq(1.0)
+    end
+
+    it "should get deep array values" do
+      e = LogStash::Event.new({"foo" => ["bar", 1, 1.0]})
+      expect(e["[foo][0]"]).to eq("bar")
+      expect(e["[foo][1]"]).to eq(1)
+      expect(e["[foo][2]"]).to eq(1.0)
+      expect(e["[foo][3]"]).to be_nil
+    end
+  end
+
+  context "[]=" do
+    it "should set simple values" do
+      e = LogStash::Event.new()
+      expect(e["foo"] = "bar").to eq("bar")
+      expect(e["foo"]).to eq("bar")
+
+      e = LogStash::Event.new({"foo" => "test"})
+      expect(e["foo"] = "bar").to eq("bar")
+      expect(e["foo"]).to eq("bar")
+    end
+
+    it "should set deep hash values" do
+      e = LogStash::Event.new()
+      expect(e["[foo][bar]"] = "baz").to eq("baz")
+      expect(e["[foo][bar]"]).to eq("baz")
+      expect(e["[foo][baz]"]).to be_nil
+    end
+
+    it "should set deep array values" do
+      e = LogStash::Event.new()
+      expect(e["[foo][0]"] = "bar").to eq("bar")
+      expect(e["[foo][0]"]).to eq("bar")
+      expect(e["[foo][1]"] = 1).to eq(1)
+      expect(e["[foo][1]"]).to eq(1)
+      expect(e["[foo][2]"] = 1.0 ).to eq(1.0)
+      expect(e["[foo][2]"]).to eq(1.0)
+      expect(e["[foo][3]"]).to be_nil
+    end
+  end
+
+  context "timestamp" do
+    it "getters should present a Ruby LogStash::Timestamp" do
+      e = LogStash::Event.new()
+      expect(e.timestamp.class).to eq(LogStash::Timestamp)
+      expect(e[TIMESTAMP].class).to eq(LogStash::Timestamp)
+    end
+
+    it "to_hash should inject a Ruby LogStash::Timestamp" do
+      e = LogStash::Event.new()
+
+      expect(e.to_java).to be_kind_of(Java::ComLogstash::Event)
+      expect(e.to_java.get_field(TIMESTAMP)).to be_kind_of(Java::ComLogstash::Timestamp)
+
+      expect(e.to_hash[TIMESTAMP]).to be_kind_of(LogStash::Timestamp)
+      # now make sure the original map was not touched
+      expect(e.to_java.get_field(TIMESTAMP)).to be_kind_of(Java::ComLogstash::Timestamp)
+    end
+
+    it "should set timestamp" do
+      e = LogStash::Event.new
+      now = Time.now
+      e["@timestamp"] = LogStash::Timestamp.at(now.to_i)
+      expect(e.timestamp.to_i).to eq(now.to_i)
+      expect(e["@timestamp"].to_i).to eq(now.to_i)
+    end
+  end
+
+  context "append" do
+    it "should append" do
+      event = LogStash::Event.new("message" => "hello world")
+      event.append(LogStash::Event.new("message" => "another thing"))
+      expect(event["message"]).to eq(["hello world", "another thing"])
+    end
+  end
+
+  context "tags" do
+    it "should tag" do
+      event = LogStash::Event.new("message" => "hello world")
+      expect(event["tags"]).to be_nil
+      event["tags"] = ["foo"]
+      expect(event["tags"]).to eq(["foo"])
+    end
+  end
+end
diff --git a/logstash-core-event-java/spec/timestamp_spec.rb b/logstash-core-event-java/spec/timestamp_spec.rb
new file mode 100644
index 00000000000..1c092696389
--- /dev/null
+++ b/logstash-core-event-java/spec/timestamp_spec.rb
@@ -0,0 +1,29 @@
+# encoding: utf-8
+
+require "spec_helper"
+require "logstash/timestamp"
+
+describe LogStash::Timestamp do
+  context "constructors" do
+    it "should work" do
+      t = LogStash::Timestamp.new
+      expect(t.time.to_i).to be_within(1).of Time.now.to_i
+
+      t = LogStash::Timestamp.now
+      expect(t.time.to_i).to be_within(1).of Time.now.to_i
+
+      now = Time.now.utc
+      t = LogStash::Timestamp.new(now)
+      expect(t.time).to eq(now)
+
+      t = LogStash::Timestamp.at(now.to_i)
+      expect(t.time.to_i).to eq(now.to_i)
+    end
+
+    it "should raise exception on invalid format" do
+      expect{LogStash::Timestamp.new("foobar")}.to raise_error
+    end
+
+  end
+
+end
diff --git a/logstash-core-event-java/src/main/java/JrubyEventExtService.java b/logstash-core-event-java/src/main/java/JrubyEventExtService.java
new file mode 100644
index 00000000000..306a45f3971
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/JrubyEventExtService.java
@@ -0,0 +1,14 @@
+import com.logstash.ext.JrubyEventExtLibrary;
+import org.jruby.Ruby;
+import org.jruby.runtime.load.BasicLibraryService;
+
+import java.io.IOException;
+
+public class JrubyEventExtService implements BasicLibraryService {
+    public boolean basicLoad(final Ruby runtime)
+        throws IOException
+    {
+        new JrubyEventExtLibrary().load(runtime, false);
+        return true;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/JrubyTimestampExtService.java b/logstash-core-event-java/src/main/java/JrubyTimestampExtService.java
new file mode 100644
index 00000000000..32d8eb2bf98
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/JrubyTimestampExtService.java
@@ -0,0 +1,15 @@
+import com.logstash.ext.JrubyEventExtLibrary;
+import com.logstash.ext.JrubyTimestampExtLibrary;
+import org.jruby.Ruby;
+import org.jruby.runtime.load.BasicLibraryService;
+
+import java.io.IOException;
+
+public class JrubyTimestampExtService implements BasicLibraryService {
+    public boolean basicLoad(final Ruby runtime)
+            throws IOException
+    {
+        new JrubyTimestampExtLibrary().load(runtime, false);
+        return true;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Accessors.java b/logstash-core-event-java/src/main/java/com/logstash/Accessors.java
new file mode 100644
index 00000000000..e9c207b217e
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Accessors.java
@@ -0,0 +1,153 @@
+package com.logstash;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.List;
+
+public class Accessors {
+
+    private Map<String, Object> data;
+    protected Map<String, Object> lut;
+
+    public Accessors(Map<String, Object> data) {
+        this.data = data;
+        this.lut = new HashMap<>(); // reference -> target LUT
+    }
+
+    public Object get(String reference) {
+        FieldReference field = PathCache.getInstance().cache(reference);
+        Object target = findTarget(field);
+        return (target == null) ? null : fetch(target, field.getKey());
+    }
+
+    public Object set(String reference, Object value) {
+        FieldReference field = PathCache.getInstance().cache(reference);
+        Object target = findCreateTarget(field);
+        return store(target, field.getKey(), value);
+    }
+
+    public Object del(String reference) {
+        FieldReference field = PathCache.getInstance().cache(reference);
+        Object target = findTarget(field);
+        if (target != null) {
+            if (target instanceof Map) {
+                return ((Map<String, Object>) target).remove(field.getKey());
+            } else if (target instanceof List) {
+                int i = Integer.parseInt(field.getKey());
+                if (i < 0 || i >= ((List) target).size()) {
+                    return null;
+                }
+                return ((List<Object>) target).remove(i);
+            } else {
+                throw new ClassCastException("expecting List or Map");
+            }
+        }
+        return null;
+    }
+
+    public boolean includes(String reference) {
+        FieldReference field = PathCache.getInstance().cache(reference);
+        Object target = findTarget(field);
+        if (target instanceof Map && foundInMap((Map<String, Object>) target, field.getKey())) {
+            return true;
+        } else if (target instanceof List && foundInList((List<Object>) target, Integer.parseInt(field.getKey()))) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private Object findTarget(FieldReference field) {
+        Object target;
+
+        if ((target = this.lut.get(field.getReference())) != null) {
+            return target;
+        }
+
+        target = this.data;
+        for (String key : field.getPath()) {
+            target = fetch(target, key);
+            if (target == null) {
+                return null;
+            }
+        }
+
+        this.lut.put(field.getReference(), target);
+
+        return target;
+    }
+
+    private Object findCreateTarget(FieldReference field) {
+        Object target;
+
+        if ((target = this.lut.get(field.getReference())) != null) {
+            return target;
+        }
+
+        target = this.data;
+        for (String key : field.getPath()) {
+            Object result = fetch(target, key);
+            if (result == null) {
+                result = new HashMap<String, Object>();
+                if (target instanceof Map) {
+                    ((Map<String, Object>)target).put(key, result);
+                } else if (target instanceof List) {
+                    int i = Integer.parseInt(key);
+                    // TODO: what about index out of bound?
+                    ((List<Object>)target).set(i, result);
+                } else if (target == null) {
+                    // do nothing
+                } else {
+                    throw new ClassCastException("expecting List or Map");
+                }
+            }
+            target = result;
+        }
+
+        this.lut.put(field.getReference(), target);
+
+        return target;
+    }
+
+    private boolean foundInList(List<Object> target, int index) {
+        if (index < 0 || index >= target.size()) {
+            return false;
+        }
+        return target.get(index) != null;
+    }
+
+    private boolean foundInMap(Map<String, Object> target, String key) {
+        return target.containsKey(key);
+    }
+
+    private Object fetch(Object target, String key) {
+        if (target instanceof Map) {
+            Object result = ((Map<String, Object>) target).get(key);
+            return result;
+        } else if (target instanceof List) {
+            int i = Integer.parseInt(key);
+            if (i < 0 || i >= ((List) target).size()) {
+                return null;
+            }
+            Object result = ((List<Object>) target).get(i);
+            return result;
+        } else if (target == null) {
+            return null;
+        } {
+            throw new ClassCastException("expecting List or Map");
+        }
+    }
+
+    private Object store(Object target, String key, Object value) {
+        if (target instanceof Map) {
+            ((Map<String, Object>) target).put(key, value);
+        } else if (target instanceof List) {
+            int i = Integer.parseInt(key);
+            // TODO: what about index out of bound?
+            ((List<Object>) target).set(i, value);
+        } else {
+            throw new ClassCastException("expecting List or Map");
+        }
+        return value;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Cloner.java b/logstash-core-event-java/src/main/java/com/logstash/Cloner.java
new file mode 100644
index 00000000000..4823f10726a
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Cloner.java
@@ -0,0 +1,56 @@
+package com.logstash;
+
+import java.util.*;
+
+public final class Cloner {
+
+    private Cloner(){}
+
+    public static <T> T deep(final T input) {
+        if (input instanceof Map<?, ?>) {
+            return (T) deepMap((Map<?, ?>) input);
+        } else if (input instanceof List<?>) {
+            return (T) deepList((List<?>) input);
+        } else if (input instanceof Collection<?>) {
+            throw new ClassCastException("unexpected Collection type " + input.getClass());
+        }
+
+        return input;
+    }
+
+    private static <E> List<E> deepList(final List<E> list) {
+        List<E> clone;
+        if (list instanceof LinkedList<?>) {
+            clone = new LinkedList<E>();
+        } else if (list instanceof ArrayList<?>) {
+            clone = new ArrayList<E>();
+        } else {
+            throw new ClassCastException("unexpected List type " + list.getClass());
+        }
+
+        for (E item : list) {
+            clone.add(deep(item));
+        }
+
+        return clone;
+    }
+
+    private static <K, V> Map<K, V> deepMap(final Map<K, V> map) {
+        Map<K, V> clone;
+        if (map instanceof LinkedHashMap<?, ?>) {
+            clone = new LinkedHashMap<K, V>();
+        } else if (map instanceof TreeMap<?, ?>) {
+            clone = new TreeMap<K, V>();
+        } else if (map instanceof HashMap<?, ?>) {
+            clone = new HashMap<K, V>();
+        } else {
+            throw new ClassCastException("unexpected Map type " + map.getClass());
+        }
+
+        for (Map.Entry<K, V> entry : map.entrySet()) {
+            clone.put(entry.getKey(), deep(entry.getValue()));
+        }
+
+        return clone;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/DateNode.java b/logstash-core-event-java/src/main/java/com/logstash/DateNode.java
new file mode 100644
index 00000000000..560d9f53d3c
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/DateNode.java
@@ -0,0 +1,24 @@
+package com.logstash;
+
+import org.joda.time.DateTimeZone;
+import org.joda.time.format.DateTimeFormat;
+import org.joda.time.format.DateTimeFormatter;
+
+import java.io.IOError;
+import java.io.IOException;
+
+/**
+ * Created by ph on 15-05-22.
+ */
+public class DateNode implements TemplateNode {
+    private DateTimeFormatter formatter;
+
+    public DateNode(String format) {
+        this.formatter = DateTimeFormat.forPattern(format).withZone(DateTimeZone.UTC);
+    }
+
+    @Override
+    public String evaluate(Event event) throws IOException {
+        return event.getTimestamp().getTime().toString(this.formatter);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/EpochNode.java b/logstash-core-event-java/src/main/java/com/logstash/EpochNode.java
new file mode 100644
index 00000000000..4451ffa73c4
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/EpochNode.java
@@ -0,0 +1,15 @@
+package com.logstash;
+
+import java.io.IOException;
+
+/**
+ * Created by ph on 15-05-22.
+ */
+public class EpochNode implements TemplateNode {
+    public EpochNode(){ }
+
+    @Override
+    public String evaluate(Event event) throws IOException {
+        return String.valueOf(event.getTimestamp().getTime().getMillis() / 1000);
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Event.java b/logstash-core-event-java/src/main/java/com/logstash/Event.java
new file mode 100644
index 00000000000..ccdb6d4eb2d
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Event.java
@@ -0,0 +1,253 @@
+package com.logstash;
+
+import com.logstash.ext.JrubyTimestampExtLibrary;
+import org.codehaus.jackson.map.ObjectMapper;
+import org.joda.time.DateTime;
+import org.jruby.RubyHash;
+import org.jruby.RubySymbol;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.*;
+
+
+public class Event implements Cloneable, Serializable {
+
+    private boolean cancelled;
+    private Map<String, Object> data;
+    private Map<String, Object> metadata;
+    private Timestamp timestamp;
+    private Accessors accessors;
+    private Accessors metadata_accessors;
+
+    public static final String METADATA = "@metadata";
+    public static final String METADATA_BRACKETS = "[" + METADATA + "]";
+    public static final String TIMESTAMP = "@timestamp";
+    public static final String TIMESTAMP_FAILURE_TAG = "_timestampparsefailure";
+    public static final String TIMESTAMP_FAILURE_FIELD = "_@timestamp";
+    public static final String VERSION = "@version";
+    public static final String VERSION_ONE = "1";
+
+    private static final ObjectMapper mapper = new ObjectMapper();
+
+    // TODO: add metadata support
+
+    public Event()
+    {
+        this.metadata = new HashMap<String, Object>();
+        this.data = new HashMap<String, Object>();
+        this.data.put(VERSION, VERSION_ONE);
+        this.cancelled = false;
+        this.timestamp = new Timestamp();
+        this.data.put(TIMESTAMP, this.timestamp);
+        this.accessors = new Accessors(this.data);
+        this.metadata_accessors = new Accessors(this.metadata);
+    }
+
+    public Event(Map data)
+    {
+        this.data = data;
+        this.data.putIfAbsent(VERSION, VERSION_ONE);
+
+        if (this.data.containsKey(METADATA)) {
+            this.metadata = (HashMap<String, Object>) this.data.remove(METADATA);
+        } else {
+            this.metadata = new HashMap<String, Object>();
+        }
+        this.metadata_accessors = new Accessors(this.metadata);
+
+        this.cancelled = false;
+        this.timestamp = initTimestamp(data.get(TIMESTAMP));
+        this.data.put(TIMESTAMP, this.timestamp);
+        this.accessors = new Accessors(this.data);
+    }
+
+    public Map<String, Object> getData() {
+        return this.data;
+    }
+
+    public Map<String, Object> getMetadata() {
+        return this.metadata;
+    }
+
+    public void setData(Map<String, Object> data) {
+        this.data = data;
+    }
+
+    public Accessors getAccessors() {
+        return this.accessors;
+    }
+
+    public Accessors getMetadataAccessors() {
+        return this.metadata_accessors;
+    }
+
+    public void setAccessors(Accessors accessors) {
+        this.accessors = accessors;
+    }
+
+    public void setMetadataAccessors(Accessors accessors) {
+        this.metadata_accessors = accessors;
+    }
+
+    public void cancel() {
+        this.cancelled = true;
+    }
+
+    public void uncancel() {
+        this.cancelled = false;
+    }
+
+    public boolean isCancelled() {
+        return this.cancelled;
+    }
+
+    public Timestamp getTimestamp() throws IOException {
+        if (this.data.containsKey(TIMESTAMP)) {
+            return this.timestamp;
+        } else {
+            throw new IOException("fails");
+        }
+    }
+
+    public void setTimestamp(Timestamp t) {
+        this.timestamp = t;
+        this.data.put(TIMESTAMP, this.timestamp);
+    }
+
+    public Object getField(String reference) {
+        if (reference.equals(METADATA)) {
+            return this.metadata;
+        } else if (reference.startsWith(METADATA_BRACKETS)) {
+            return this.metadata_accessors.get(reference.substring(METADATA_BRACKETS.length()));
+        } else {
+            return this.accessors.get(reference);
+        }
+    }
+
+    public void setField(String reference, Object value) {
+        if (reference.equals(TIMESTAMP)) {
+            // TODO(talevy): check type of timestamp
+            this.accessors.set(reference, value);
+        } else if (reference.equals(METADATA_BRACKETS) || reference.equals(METADATA)) {
+            this.metadata = (HashMap<String, Object>) value;
+            this.metadata_accessors = new Accessors(this.metadata);
+        } else if (reference.startsWith(METADATA_BRACKETS)) {
+            this.metadata_accessors.set(reference.substring(METADATA_BRACKETS.length()), value);
+        } else {
+            this.accessors.set(reference, value);
+        }
+    }
+
+    public boolean includes(String reference) {
+        if (reference.equals(METADATA_BRACKETS) || reference.equals(METADATA)) {
+            return true;
+        } else if (reference.startsWith(METADATA_BRACKETS)) {
+            return this.metadata_accessors.includes(reference.substring(METADATA_BRACKETS.length()));
+        } else {
+            return this.accessors.includes(reference);
+        }
+    }
+
+    public String toJson() throws IOException {
+        return mapper.writeValueAsString((Map<String, Object>)this.data);
+    }
+
+    public Map toMap() {
+        return this.data;
+    }
+
+    public Event overwrite(Event e) {
+        this.data = e.getData();
+        this.accessors = e.getAccessors();
+        this.cancelled = e.isCancelled();
+        try {
+            this.timestamp = e.getTimestamp();
+        } catch (IOException exception) {
+            this.timestamp = new Timestamp();
+        }
+
+        return this;
+    }
+
+
+    public Event append(Event e) {
+        Util.mapMerge(this.data, e.data);
+
+        return this;
+    }
+
+    public Object remove(String path) {
+        return this.accessors.del(path);
+    }
+
+    public String sprintf(String s) throws IOException {
+        return StringInterpolation.getInstance().evaluate(this, s);
+    }
+
+    public Event clone()
+            throws CloneNotSupportedException
+    {
+//        Event clone = (Event)super.clone();
+//        clone.setAccessors(new Accessors(clone.getData()));
+
+        Event clone = new Event(Cloner.deep(getData()));
+        return clone;
+    }
+
+    public String toString() {
+        // TODO: until we have sprintf
+        String host = (String)this.data.getOrDefault("host", "%{host}");
+        String message = (String)this.data.getOrDefault("message", "%{message}");
+        try {
+            return getTimestamp().toIso8601() + " " + host + " " + message;
+        } catch (IOException e) {
+            return host + " " + message;
+        }
+    }
+
+    private Timestamp initTimestamp(Object o) {
+        try {
+            if (o == null) {
+                // most frequent
+                return new Timestamp();
+            } else if (o instanceof String) {
+                // second most frequent
+                return new Timestamp((String) o);
+            } else if (o instanceof JrubyTimestampExtLibrary.RubyTimestamp) {
+                return new Timestamp(((JrubyTimestampExtLibrary.RubyTimestamp) o).getTimestamp());
+            } else if (o instanceof Timestamp) {
+                return new Timestamp((Timestamp) o);
+            } else if (o instanceof DateTime) {
+                return new Timestamp((DateTime) o);
+            } else if (o instanceof Date) {
+                return new Timestamp((Date) o);
+            } else if (o instanceof RubySymbol) {
+                return new Timestamp(((RubySymbol) o).asJavaString());
+            } else {
+                // TODO: add logging
+                //return Timestamp.now();
+                throw new IllegalArgumentException();
+            }
+        } catch (IllegalArgumentException e) {
+            // TODO: add error logging
+            tag(TIMESTAMP_FAILURE_TAG);
+
+            this.data.put(TIMESTAMP_FAILURE_FIELD, o);
+
+            return Timestamp.now();
+        }
+    }
+
+    public void tag(String tag) {
+        List<Object> tags = (List<Object>) this.data.get("tags");
+        if (tags == null) {
+            tags = new ArrayList<>();
+            this.data.put("tags", tags);
+        }
+
+        if (!tags.contains(tag)) {
+            tags.add(tag);
+        }
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/FieldReference.java b/logstash-core-event-java/src/main/java/com/logstash/FieldReference.java
new file mode 100644
index 00000000000..508291693f1
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/FieldReference.java
@@ -0,0 +1,40 @@
+package com.logstash;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+// TODO: implement thread-safe path cache singleton to avoid parsing
+
+public class FieldReference {
+
+    private List<String> path;
+    private String key;
+    private String reference;
+    private static List<String> EMPTY_STRINGS = new ArrayList(Arrays.asList(new String[]{""}));
+
+    public FieldReference(List<String> path, String key, String reference) {
+        this.path = path;
+        this.key = key;
+        this.reference = reference;
+    }
+
+    public List<String> getPath() {
+        return path;
+    }
+
+    public String getKey() {
+        return key;
+    }
+
+    public String getReference() {
+        return reference;
+    }
+
+    public static FieldReference parse(String reference) {
+        List<String> path = new ArrayList(Arrays.asList(reference.split("[\\[\\]]")));
+        path.removeAll(EMPTY_STRINGS);
+        String key = path.remove(path.size() - 1);
+        return new FieldReference(path, key, reference);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/KeyNode.java b/logstash-core-event-java/src/main/java/com/logstash/KeyNode.java
new file mode 100644
index 00000000000..c74902361fd
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/KeyNode.java
@@ -0,0 +1,42 @@
+package com.logstash;
+
+import org.codehaus.jackson.JsonGenerationException;
+import org.codehaus.jackson.map.ObjectMapper;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by ph on 15-05-22.
+ */
+public class KeyNode implements TemplateNode {
+    private String key;
+
+    public KeyNode(String key) {
+        this.key = key;
+    }
+
+    /**
+     This will be more complicated with hash and array.
+     leverage jackson lib to do the actual.
+     */
+    @Override
+    public String evaluate(Event event) throws IOException {
+        Object value = event.getField(this.key);
+
+        if (value != null) {
+            if (value instanceof List) {
+                return String.join(",", (List) value);
+            } else if (value instanceof Map) {
+                ObjectMapper mapper = new ObjectMapper();
+                return mapper.writeValueAsString((Map<String, Object>)value);
+            } else {
+                return event.getField(this.key).toString();
+            }
+
+        } else {
+            return "%{" + this.key + "}";
+        }
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/main/java/com/logstash/PathCache.java b/logstash-core-event-java/src/main/java/com/logstash/PathCache.java
new file mode 100644
index 00000000000..b7beff95b89
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/PathCache.java
@@ -0,0 +1,47 @@
+package com.logstash;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+public class PathCache {
+
+    private static PathCache instance = null;
+    private static ConcurrentHashMap<String, FieldReference> cache = new ConcurrentHashMap<>();
+
+    private FieldReference timestamp;
+
+    // TODO: dry with Event
+    public static final String TIMESTAMP = "@timestamp";
+    public static final String BRACKETS_TIMESTAMP = "[" + TIMESTAMP + "]";
+
+    protected PathCache() {
+        // inject @timestamp
+        this.timestamp = cache(TIMESTAMP);
+        cache(BRACKETS_TIMESTAMP, this.timestamp);
+    }
+
+    public static PathCache getInstance() {
+        if (instance == null) {
+            instance = new PathCache();
+        }
+        return instance;
+    }
+
+    public boolean isTimestamp(String reference) {
+        return (cache(reference) == this.timestamp);
+    }
+
+    public FieldReference cache(String reference) {
+        // atomicity between the get and put is not important
+        FieldReference result = cache.get(reference);
+        if (result == null) {
+            result = FieldReference.parse(reference);
+            cache.put(reference, result);
+        }
+        return result;
+    }
+
+    public FieldReference cache(String reference, FieldReference field) {
+        cache.put(reference, field);
+        return field;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/RubyToJavaConverter.java b/logstash-core-event-java/src/main/java/com/logstash/RubyToJavaConverter.java
new file mode 100644
index 00000000000..2170ad4b5fb
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/RubyToJavaConverter.java
@@ -0,0 +1,45 @@
+package com.logstash;
+
+import org.jruby.RubyArray;
+import org.jruby.RubyHash;
+import org.jruby.RubyString;
+import org.jruby.runtime.builtin.IRubyObject;
+
+import java.util.*;
+
+public class RubyToJavaConverter {
+
+    public static Object convert(IRubyObject obj) {
+        if (obj instanceof RubyArray) {
+            return convertToList((RubyArray) obj);
+        } else if (obj instanceof RubyHash) {
+            return convertToMap((RubyHash) obj);
+        } else if (obj instanceof RubyString) {
+            return convertToString((RubyString) obj);
+        }
+
+        return obj.toJava(obj.getJavaClass());
+    }
+
+    public static HashMap<String, Object> convertToMap(RubyHash hash) {
+        HashMap<String, Object> hashMap = new HashMap();
+        Set<RubyHash.RubyHashEntry> entries = hash.directEntrySet();
+        for (RubyHash.RubyHashEntry e : entries) {
+            hashMap.put(e.getJavaifiedKey().toString(), convert((IRubyObject) e.getValue()));
+        }
+        return hashMap;
+    }
+
+    public static List<Object> convertToList(RubyArray array) {
+        ArrayList<Object> list = new ArrayList();
+        for (IRubyObject obj : array.toJavaArray()) {
+            list.add(convert(obj));
+        }
+
+        return list;
+    }
+
+    public static String convertToString(RubyString string) {
+        return string.decodeString();
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/StaticNode.java b/logstash-core-event-java/src/main/java/com/logstash/StaticNode.java
new file mode 100644
index 00000000000..73b5c160440
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/StaticNode.java
@@ -0,0 +1,19 @@
+package com.logstash;
+
+import java.io.IOException;
+
+/**
+ * Created by ph on 15-05-22.
+ */
+public class StaticNode implements TemplateNode {
+    private String content;
+
+    public StaticNode(String content) {
+        this.content = content;
+    }
+
+    @Override
+    public String evaluate(Event event) throws IOException {
+        return this.content;
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/main/java/com/logstash/StringInterpolation.java b/logstash-core-event-java/src/main/java/com/logstash/StringInterpolation.java
new file mode 100644
index 00000000000..77aea3e41d6
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/StringInterpolation.java
@@ -0,0 +1,94 @@
+package com.logstash;
+
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class StringInterpolation {
+    static Pattern TEMPLATE_TAG = Pattern.compile("%\\{([^}]+)\\}");
+    static Map cache;
+
+    protected static class HoldCurrent {
+        private static final StringInterpolation INSTANCE = new StringInterpolation();
+    }
+
+    private StringInterpolation() {
+        // TODO:
+        // This may need some tweaking for the concurrency level to get better memory usage.
+        // The current implementation doesn't allow the keys to expire, I think under normal usage
+        // the keys will converge to a fixed number.
+        //
+        // If this code make logstash goes OOM, we have the following options:
+        //  - If the key doesn't contains a `%` do not cache it, this will reduce the key size at a performance cost.
+        //  - Use some kind LRU cache
+        //  - Create a new data structure that use weakref or use Google Guava for the cache https://code.google.com/p/guava-libraries/
+        this.cache = new ConcurrentHashMap<>();
+    }
+
+    public String evaluate(Event event, String template) throws IOException {
+        TemplateNode compiledTemplate = (TemplateNode) this.cache.get(template);
+
+        if(compiledTemplate == null) {
+            compiledTemplate = this.compile(template);
+            TemplateNode set = (TemplateNode) this.cache.putIfAbsent(template, compiledTemplate);
+            compiledTemplate = (set != null) ? set : compiledTemplate;
+        }
+
+        return compiledTemplate.evaluate(event);
+    }
+
+    public TemplateNode compile(String template) {
+        Template compiledTemplate = new Template();
+
+        if (template.indexOf('%') == -1) {
+            // Move the nodes to a custom instance
+            // so we can remove the iterator and do one `.evaluate`
+            compiledTemplate.add(new StaticNode(template));
+        } else {
+            Matcher matcher = TEMPLATE_TAG.matcher(template);
+            String tag;
+            int pos = 0;
+
+            while (matcher.find()) {
+                if (matcher.start() > 0) {
+                    compiledTemplate.add(new StaticNode(template.substring(pos, matcher.start())));
+                }
+
+                tag = matcher.group(1);
+                compiledTemplate.add(identifyTag(tag));
+                pos = matcher.end();
+            }
+
+            if(pos <= template.length() - 1) {
+                compiledTemplate.add(new StaticNode(template.substring(pos)));
+            }
+        }
+
+        // if we only have one node return the node directly
+        // and remove the need to loop.
+        if(compiledTemplate.size() == 1) {
+            return compiledTemplate.get(0);
+        } else {
+            return compiledTemplate;
+        }
+    }
+
+    public TemplateNode identifyTag(String tag) {
+        if(tag.equals("+%s")) {
+            return new EpochNode();
+        } else if(tag.charAt(0) == '+') {
+                return new DateNode(tag.substring(1));
+
+        } else {
+            return new KeyNode(tag);
+        }
+    }
+
+    static StringInterpolation getInstance() {
+        return HoldCurrent.INSTANCE;
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Template.java b/logstash-core-event-java/src/main/java/com/logstash/Template.java
new file mode 100644
index 00000000000..a17e69b3946
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Template.java
@@ -0,0 +1,32 @@
+package com.logstash;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class Template implements TemplateNode {
+    public List nodes = new ArrayList<>();
+    public Template() {}
+
+    public void add(TemplateNode node) {
+        nodes.add(node);
+    }
+
+    public int size() {
+        return nodes.size();
+    }
+
+    public TemplateNode get(int index) {
+        return (TemplateNode) nodes.get(index);
+    }
+
+    @Override
+    public String evaluate(Event event) throws IOException {
+        StringBuffer results = new StringBuffer();
+
+        for (int i = 0; i < nodes.size(); i++) {
+            results.append(((TemplateNode) nodes.get(i)).evaluate(event));
+        }
+        return results.toString();
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/main/java/com/logstash/TemplateNode.java b/logstash-core-event-java/src/main/java/com/logstash/TemplateNode.java
new file mode 100644
index 00000000000..c71dbd33e71
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/TemplateNode.java
@@ -0,0 +1,12 @@
+package com.logstash;
+
+import org.codehaus.jackson.JsonGenerationException;
+
+import java.io.IOException;
+
+/**
+ * Created by ph on 15-05-22.
+ */
+public interface TemplateNode {
+    String evaluate(Event event) throws IOException;
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Timestamp.java b/logstash-core-event-java/src/main/java/com/logstash/Timestamp.java
new file mode 100644
index 00000000000..3fc7ff855bd
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Timestamp.java
@@ -0,0 +1,74 @@
+package com.logstash;
+
+import org.codehaus.jackson.map.annotate.JsonSerialize;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeZone;
+import org.joda.time.format.DateTimeFormatter;
+import org.joda.time.format.ISODateTimeFormat;
+import org.jruby.Ruby;
+import org.jruby.RubyString;
+
+import java.util.Date;
+
+@JsonSerialize(using = TimestampSerializer.class)
+public class Timestamp implements Cloneable {
+
+    private DateTime time;
+    // TODO: is this DateTimeFormatter thread safe?
+    private static DateTimeFormatter iso8601Formatter = ISODateTimeFormat.dateTime();
+
+    public Timestamp() {
+        this.time = new DateTime(DateTimeZone.UTC);
+    }
+
+    public Timestamp(String iso8601) {
+        this.time = ISODateTimeFormat.dateTimeParser().parseDateTime(iso8601).toDateTime(DateTimeZone.UTC);
+    }
+
+    public Timestamp(Timestamp t) {
+        this.time = t.getTime();
+    }
+
+    public Timestamp(long epoch_milliseconds) {
+        this.time = new DateTime(epoch_milliseconds, DateTimeZone.UTC);
+    }
+
+    public Timestamp(Long epoch_milliseconds) {
+        this.time = new DateTime(epoch_milliseconds, DateTimeZone.UTC);
+    }
+
+    public Timestamp(Date date) {
+        this.time = new DateTime(date, DateTimeZone.UTC);
+    }
+
+    public Timestamp(DateTime date) {
+        this.time = date.toDateTime(DateTimeZone.UTC);
+    }
+
+    public DateTime getTime() {
+        return time;
+    }
+
+    public void setTime(DateTime time) {
+        this.time = time;
+    }
+
+    public static Timestamp now() {
+        return new Timestamp();
+    }
+
+    public String toIso8601() {
+        return this.iso8601Formatter.print(this.time);
+    }
+
+    public String toString() {
+        return toIso8601();
+    }
+
+    @Override
+    public Timestamp clone() throws CloneNotSupportedException {
+        Timestamp clone = (Timestamp)super.clone();
+        clone.setTime(this.getTime());
+        return clone;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/TimestampSerializer.java b/logstash-core-event-java/src/main/java/com/logstash/TimestampSerializer.java
new file mode 100644
index 00000000000..51385986cad
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/TimestampSerializer.java
@@ -0,0 +1,17 @@
+package com.logstash;
+
+import org.codehaus.jackson.JsonGenerator;
+import org.codehaus.jackson.map.JsonSerializer;
+import org.codehaus.jackson.map.SerializerProvider;
+
+import java.io.IOException;
+
+public class TimestampSerializer extends JsonSerializer<Timestamp> {
+
+    @Override
+    public void serialize(Timestamp value, JsonGenerator jgen, SerializerProvider provider)
+            throws IOException
+    {
+        jgen.writeString(value.toIso8601());
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Util.java b/logstash-core-event-java/src/main/java/com/logstash/Util.java
new file mode 100644
index 00000000000..9d2cc12f89e
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Util.java
@@ -0,0 +1,51 @@
+package com.logstash;
+
+import com.google.common.collect.Lists;
+import org.jruby.RubyHash;
+
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+
+public class Util {
+    private Util() {}
+
+    public static void mapMerge(Map<String, Object> target, Map<String, Object> add) {
+        for (Map.Entry<String, Object> e : add.entrySet()) {
+            if (target.containsKey(e.getKey())) {
+                if (target.get(e.getKey()) instanceof Map && e.getValue() instanceof Map) {
+                    mapMerge((Map<String, Object>) target.get(e.getKey()), (Map<String, Object>) e.getValue());
+                } else if (e.getValue() instanceof List) {
+                    if (target.get(e.getKey()) instanceof List) {
+                        // needs optimizing
+                        List targetList = (List) target.get(e.getKey());
+                        targetList.addAll((List) e.getValue());
+                        target.put(e.getKey(), new ArrayList<Object>(new LinkedHashSet<Object>(targetList)));
+                    } else {
+                        Object targetValue = target.get(e.getKey());
+                        List targetValueList = Lists.newArrayList(targetValue);
+                        for (Object o : (List) e.getValue()) {
+                            if (!targetValue.equals(o)) {
+                                targetValueList.add(o);
+                            }
+                        }
+                        target.put(e.getKey(), targetValueList);
+                    }
+                } else if (target.get(e.getKey()) instanceof List) {
+                    List t = ((List) target.get(e.getKey()));
+                    if (!t.contains(e.getValue())) {
+                        t.add(e.getValue());
+                    }
+                } else if (!target.get(e.getKey()).equals(e.getValue())) {
+                    Object targetValue = target.get(e.getKey());
+                    targetValue = Lists.newArrayList(targetValue);
+                    ((List) targetValue).add(e.getValue());
+                    target.put(e.getKey(), targetValue);
+                }
+            } else {
+                target.put(e.getKey(), e.getValue());
+            }
+        }
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyEventExtLibrary.java b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyEventExtLibrary.java
new file mode 100644
index 00000000000..8ecb434f301
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyEventExtLibrary.java
@@ -0,0 +1,278 @@
+package com.logstash.ext;
+
+import com.logstash.Event;
+import com.logstash.PathCache;
+import com.logstash.RubyToJavaConverter;
+import com.logstash.Timestamp;
+import org.jruby.*;
+import org.jruby.anno.JRubyClass;
+import org.jruby.anno.JRubyConstant;
+import org.jruby.anno.JRubyMethod;
+import org.jruby.exceptions.RaiseException;
+import org.jruby.java.proxies.MapJavaProxy;
+import org.jruby.javasupport.JavaUtil;
+import org.jruby.runtime.Arity;
+import org.jruby.runtime.ObjectAllocator;
+import org.jruby.runtime.ThreadContext;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.jruby.runtime.load.Library;
+
+import java.io.IOException;
+import java.util.*;
+
+
+public class JrubyEventExtLibrary implements Library {
+
+    public void load(Ruby runtime, boolean wrap) throws IOException {
+        RubyModule module = runtime.defineModule("LogStash");
+        RubyClass clazz = runtime.defineClassUnder("Event", runtime.getObject(), new ObjectAllocator() {
+            public IRubyObject allocate(Ruby runtime, RubyClass rubyClass) {
+                return new RubyEvent(runtime, rubyClass);
+            }
+        }, module);
+        clazz.setConstant("LOGGER", runtime.getModule("Cabin").getClass("Channel")
+                .callMethod("get", runtime.getModule("LogStash")));
+        clazz.setConstant("TIMESTAMP", runtime.newString(Event.TIMESTAMP));
+        clazz.setConstant("TIMESTAMP_FAILURE_TAG", runtime.newString(Event.TIMESTAMP_FAILURE_TAG));
+        clazz.setConstant("TIMESTAMP_FAILURE_FIELD", runtime.newString(Event.TIMESTAMP_FAILURE_FIELD));
+        clazz.defineAnnotatedMethods(RubyEvent.class);
+        clazz.defineAnnotatedConstants(RubyEvent.class);
+    }
+
+    @JRubyClass(name = "Event", parent = "Object")
+    public static class RubyEvent extends RubyObject {
+        private Event event;
+
+        public RubyEvent(Ruby runtime, RubyClass klass) {
+            super(runtime, klass);
+        }
+
+        public RubyEvent(Ruby runtime) {
+            this(runtime, runtime.getModule("LogStash").getClass("Event"));
+        }
+
+        public RubyEvent(Ruby runtime, Event event) {
+            this(runtime);
+            this.event = event;
+        }
+
+        public static RubyEvent newRubyEvent(Ruby runtime, Event event) {
+            return new RubyEvent(runtime, event);
+        }
+
+        public Event getEvent() {
+            return event;
+        }
+
+        public void setEvent(Event event) {
+            this.event = event;
+        }
+
+        // def initialize(data = {})
+        @JRubyMethod(name = "initialize", optional = 1)
+        public IRubyObject ruby_initialize(ThreadContext context, IRubyObject[] args)
+        {
+            args = Arity.scanArgs(context.runtime, args, 0, 1);
+            IRubyObject data = args[0];
+
+            if (data.isNil()) {
+                this.event = new Event();
+            } else if (data instanceof RubyHash) {
+                HashMap<String, Object>  newObj = RubyToJavaConverter.convertToMap((RubyHash) data);
+                this.event = new Event(newObj);
+            } else if (data instanceof Map) {
+                this.event = new Event((Map) data);
+            } else if (Map.class.isAssignableFrom(data.getJavaClass())) {
+                this.event = new Event((Map)data.toJava(Map.class));
+            } else {
+                throw context.runtime.newTypeError("wrong argument type " + data.getMetaClass() + " (expected Hash)");
+            }
+
+            return context.nil;
+        }
+
+        @JRubyMethod(name = "[]", required = 1)
+        public IRubyObject ruby_get_field(ThreadContext context, RubyString reference)
+        {
+            String r = reference.asJavaString();
+            Object value = this.event.getField(r);
+            if (value instanceof Timestamp) {
+                return JrubyTimestampExtLibrary.RubyTimestamp.newRubyTimestamp(context.runtime, (Timestamp)value);
+            } else if (value instanceof List) {
+                IRubyObject obj = JavaUtil.convertJavaToRuby(context.runtime, value);
+                return obj.callMethod(context, "to_a");
+            } else {
+                return JavaUtil.convertJavaToRuby(context.runtime, value);
+            }
+        }
+
+        @JRubyMethod(name = "[]=", required = 2)
+        public IRubyObject ruby_set_field(ThreadContext context, RubyString reference, IRubyObject value)
+        {
+            String r = reference.asJavaString();
+            if (PathCache.getInstance().isTimestamp(r)) {
+                if (!(value instanceof JrubyTimestampExtLibrary.RubyTimestamp)) {
+                    throw context.runtime.newTypeError("wrong argument type " + value.getMetaClass() + " (expected LogStash::Timestamp)");
+                }
+                this.event.setTimestamp(((JrubyTimestampExtLibrary.RubyTimestamp)value).getTimestamp());
+            } else {
+                if (value instanceof RubyString) {
+                    String val = ((RubyString) value).asJavaString();
+                    this.event.setField(r, val);
+                } else if (value instanceof RubyInteger) {
+                    this.event.setField(r, ((RubyInteger) value).getLongValue());
+                } else if (value instanceof RubyFloat) {
+                    this.event.setField(r, ((RubyFloat) value).getDoubleValue());
+                } else if (value instanceof JrubyTimestampExtLibrary.RubyTimestamp) {
+                    // RubyTimestamp could be assigned in another field thant @timestamp
+                    this.event.setField(r, ((JrubyTimestampExtLibrary.RubyTimestamp) value).getTimestamp());
+                } else if (value instanceof RubyArray) {
+                    this.event.setField(r, RubyToJavaConverter.convertToList((RubyArray) value));
+                } else if (value instanceof RubyHash) {
+                    this.event.setField(r, RubyToJavaConverter.convertToMap((RubyHash) value));
+                } else {
+                    throw context.runtime.newTypeError("wrong argument type " + value.getMetaClass());
+                }
+            }
+            return value;
+        }
+
+        @JRubyMethod(name = "cancel")
+        public IRubyObject ruby_cancel(ThreadContext context)
+        {
+            this.event.cancel();
+            return RubyBoolean.createTrueClass(context.runtime);
+        }
+
+        @JRubyMethod(name = "uncancel")
+        public IRubyObject ruby_uncancel(ThreadContext context)
+        {
+            this.event.uncancel();
+            return RubyBoolean.createFalseClass(context.runtime);
+        }
+
+        @JRubyMethod(name = "cancelled?")
+        public IRubyObject ruby_cancelled(ThreadContext context)
+        {
+            return RubyBoolean.newBoolean(context.runtime, this.event.isCancelled());
+        }
+
+        @JRubyMethod(name = "include?", required = 1)
+        public IRubyObject ruby_includes(ThreadContext context, RubyString reference)
+        {
+            return RubyBoolean.newBoolean(context.runtime, this.event.includes(reference.asJavaString()));
+        }
+
+        @JRubyMethod(name = "remove", required = 1)
+        public IRubyObject ruby_remove(ThreadContext context, RubyString reference)
+        {
+            return JavaUtil.convertJavaToRuby(context.runtime, this.event.remove(reference.asJavaString()));
+        }
+
+        @JRubyMethod(name = "clone")
+        public IRubyObject ruby_clone(ThreadContext context)
+        {
+            try {
+                return RubyEvent.newRubyEvent(context.runtime, this.event.clone());
+            } catch (CloneNotSupportedException e) {
+                throw context.runtime.newRuntimeError(e.getMessage());
+            }
+        }
+
+        @JRubyMethod(name = "overwrite", required = 1)
+        public IRubyObject ruby_overwrite(ThreadContext context, IRubyObject value)
+        {
+            if (!(value instanceof RubyEvent)) {
+                throw context.runtime.newTypeError("wrong argument type " + value.getMetaClass() + " (expected LogStash::Event)");
+            }
+
+            return RubyEvent.newRubyEvent(context.runtime, this.event.overwrite(((RubyEvent) value).event));
+        }
+
+        @JRubyMethod(name = "append", required = 1)
+        public IRubyObject ruby_append(ThreadContext context, IRubyObject value)
+        {
+            if (!(value instanceof RubyEvent)) {
+                throw context.runtime.newTypeError("wrong argument type " + value.getMetaClass() + " (expected LogStash::Event)");
+            }
+
+            this.event.append(((RubyEvent) value).getEvent());
+
+            return this;
+        }
+
+        @JRubyMethod(name = "sprintf", required = 1)
+        public IRubyObject ruby_sprintf(ThreadContext context, IRubyObject format) throws IOException {
+            try {
+                return RubyString.newString(context.runtime, event.sprintf(format.toString()));
+            } catch (IOException e) {
+                throw new RaiseException(getRuntime(),
+                        (RubyClass) getRuntime().getModule("LogStash").getClass("Error"),
+                        "timestamp field is missing", true);
+            }
+        }
+
+        @JRubyMethod(name = "to_s")
+        public IRubyObject ruby_to_s(ThreadContext context)
+        {
+            return RubyString.newString(context.runtime, event.toString());
+        }
+
+        @JRubyMethod(name = "to_hash")
+        public IRubyObject ruby_to_hash(ThreadContext context) throws IOException
+        {
+            // TODO: is this the most efficient?
+            RubyHash hash = JavaUtil.convertJavaToUsableRubyObject(context.runtime, this.event.toMap()).convertToHash();
+            // inject RubyTimestamp in new hash
+            hash.put(PathCache.TIMESTAMP, JrubyTimestampExtLibrary.RubyTimestamp.newRubyTimestamp(context.runtime, this.event.getTimestamp()));
+            return hash;
+        }
+
+        @JRubyMethod(name = "to_hash_with_metadata")
+        public IRubyObject ruby_to_hash_with_metadata(ThreadContext context) throws IOException
+        {
+            HashMap<String, Object> dataAndMetadata = new HashMap<String, Object>(this.event.getData());
+            if (!this.event.getMetadata().isEmpty()) {
+                dataAndMetadata.put(Event.METADATA, this.event.getMetadata());
+            }
+
+            RubyHash hash = JavaUtil.convertJavaToUsableRubyObject(context.runtime, dataAndMetadata).convertToHash();
+
+            // inject RubyTimestamp in new hash
+            hash.put(PathCache.TIMESTAMP, JrubyTimestampExtLibrary.RubyTimestamp.newRubyTimestamp(context.runtime, this.event.getTimestamp()));
+            return hash;
+        }
+
+        @JRubyMethod(name = "to_java")
+        public IRubyObject ruby_to_java(ThreadContext context)
+        {
+            return JavaUtil.convertJavaToUsableRubyObject(context.runtime, this.event);
+        }
+
+        @JRubyMethod(name = "to_json", rest = true)
+        public IRubyObject ruby_to_json(ThreadContext context, IRubyObject[] args)
+            throws IOException
+        {
+            return RubyString.newString(context.runtime, event.toJson());
+        }
+
+        @JRubyMethod(name = "validate_value", required = 1, meta = true)
+        public static IRubyObject ruby_validate_value(ThreadContext context, IRubyObject recv, IRubyObject value)
+        {
+            // TODO: add UTF-8 validation
+            return value;
+        }
+
+        @JRubyMethod(name = "tag", required = 1)
+        public IRubyObject ruby_tag(ThreadContext context, RubyString value)
+        {
+            this.event.tag(((RubyString) value).asJavaString());
+            return context.runtime.getNil();
+        }
+
+        @JRubyMethod(name = "timestamp")
+        public IRubyObject ruby_timestamp(ThreadContext context) throws IOException {
+            return new JrubyTimestampExtLibrary.RubyTimestamp(context.getRuntime(), this.event.getTimestamp());
+        }
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyTimestampExtLibrary.java b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyTimestampExtLibrary.java
new file mode 100644
index 00000000000..b84aadc9507
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyTimestampExtLibrary.java
@@ -0,0 +1,208 @@
+package com.logstash.ext;
+
+import com.logstash.*;
+import org.codehaus.jackson.map.annotate.JsonSerialize;
+import org.jruby.*;
+import org.jruby.anno.JRubyClass;
+import org.jruby.anno.JRubyMethod;
+import org.jruby.exceptions.RaiseException;
+import org.jruby.javasupport.JavaUtil;
+import org.jruby.runtime.Arity;
+import org.jruby.runtime.ObjectAllocator;
+import org.jruby.runtime.ThreadContext;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.jruby.runtime.load.Library;
+
+import java.io.IOException;
+
+public class JrubyTimestampExtLibrary implements Library {
+    public void load(Ruby runtime, boolean wrap) throws IOException {
+        RubyModule module = runtime.defineModule("LogStash");
+        RubyClass clazz = runtime.defineClassUnder("Timestamp", runtime.getObject(), new ObjectAllocator() {
+            public IRubyObject allocate(Ruby runtime, RubyClass rubyClass) {
+                return new RubyTimestamp(runtime, rubyClass);
+            }
+        }, module);
+        clazz.defineAnnotatedMethods(RubyTimestamp.class);
+    }
+
+    @JRubyClass(name = "Timestamp", parent = "Object")
+    public static class RubyTimestamp extends RubyObject {
+
+        private Timestamp timestamp;
+
+        public RubyTimestamp(Ruby runtime, RubyClass klass) {
+            super(runtime, klass);
+        }
+
+        public RubyTimestamp(Ruby runtime, RubyClass klass, Timestamp timestamp) {
+            this(runtime, klass);
+            this.timestamp = timestamp;
+        }
+
+        public RubyTimestamp(Ruby runtime, Timestamp timestamp) {
+            this(runtime, runtime.getModule("LogStash").getClass("Timestamp"), timestamp);
+        }
+
+        public RubyTimestamp(Ruby runtime) {
+            this(runtime, new Timestamp());
+        }
+
+        public static RubyTimestamp newRubyTimestamp(Ruby runtime) {
+            return new RubyTimestamp(runtime);
+        }
+
+        public static RubyTimestamp newRubyTimestamp(Ruby runtime, long epoch) {
+            // Ruby epoch is in seconds, Java in milliseconds
+            return new RubyTimestamp(runtime, new Timestamp(epoch * 1000));
+        }
+
+        public static RubyTimestamp newRubyTimestamp(Ruby runtime, Timestamp timestamp) {
+            return new RubyTimestamp(runtime, timestamp);
+        }
+
+        public Timestamp getTimestamp() {
+            return timestamp;
+        }
+
+        public void setTimestamp(Timestamp timestamp) {
+            this.timestamp = timestamp;
+        }
+
+        // def initialize(time = Time.new)
+        @JRubyMethod(name = "initialize", optional = 1)
+        public IRubyObject ruby_initialize(ThreadContext context, IRubyObject[] args)
+        {
+            args = Arity.scanArgs(context.runtime, args, 0, 1);
+            IRubyObject time = args[0];
+
+            if (time.isNil()) {
+                this.timestamp = new Timestamp();
+            } else if (time instanceof RubyTime) {
+                this.timestamp = new Timestamp(((RubyTime)time).getDateTime());
+            } else if (time instanceof RubyString) {
+                try {
+                    this.timestamp = new Timestamp(((RubyString) time).toString());
+                } catch (IllegalArgumentException e) {
+                    throw new RaiseException(
+                            getRuntime(),
+                            getRuntime().getModule("LogStash").getClass("TimestampParserError"),
+                            "invalid timestamp string format " + time,
+                            true
+                    );
+
+                }
+            } else {
+                throw context.runtime.newTypeError("wrong argument type " + time.getMetaClass() + " (expected Time)");
+            }
+            return context.nil;
+        }
+
+        @JRubyMethod(name = "time")
+        public IRubyObject ruby_time(ThreadContext context)
+        {
+            return RubyTime.newTime(context.runtime, this.timestamp.getTime());
+        }
+
+        @JRubyMethod(name = "to_i")
+        public IRubyObject ruby_to_i(ThreadContext context)
+        {
+            return RubyFixnum.newFixnum(context.runtime, this.timestamp.getTime().getMillis() / 1000);
+        }
+
+        @JRubyMethod(name = "to_s")
+        public IRubyObject ruby_to_s(ThreadContext context)
+        {
+            return ruby_to_iso8601(context);
+        }
+
+        @JRubyMethod(name = "to_iso8601")
+        public IRubyObject ruby_to_iso8601(ThreadContext context)
+        {
+            return RubyString.newString(context.runtime, this.timestamp.toIso8601());
+        }
+
+        @JRubyMethod(name = "to_java")
+        public IRubyObject ruby_to_java(ThreadContext context)
+        {
+            return JavaUtil.convertJavaToUsableRubyObject(context.runtime, this.timestamp);
+        }
+
+        @JRubyMethod(name = "to_json", rest = true)
+        public IRubyObject ruby_to_json(ThreadContext context, IRubyObject[] args)
+        {
+            return RubyString.newString(context.runtime,  "\"" + this.timestamp.toIso8601() + "\"");
+        }
+
+        public static Timestamp newTimetsamp(IRubyObject time)
+        {
+            if (time.isNil()) {
+                return new Timestamp();
+            } else if (time instanceof RubyTime) {
+                return new Timestamp(((RubyTime)time).getDateTime());
+            } else if (time instanceof RubyString) {
+                return new Timestamp(((RubyString) time).toString());
+            } else if (time instanceof RubyTimestamp) {
+                return new Timestamp(((RubyTimestamp) time).timestamp);
+            } else {
+               return null;
+            }
+        }
+
+
+        @JRubyMethod(name = "coerce", required = 1, meta = true)
+        public static IRubyObject ruby_coerce(ThreadContext context, IRubyObject recv, IRubyObject time)
+        {
+            try {
+                Timestamp ts = newTimetsamp(time);
+                return (ts == null) ? context.runtime.getNil() : RubyTimestamp.newRubyTimestamp(context.runtime, ts);
+             } catch (IllegalArgumentException e) {
+                throw new RaiseException(
+                        context.runtime,
+                        context.runtime.getModule("LogStash").getClass("TimestampParserError"),
+                        "invalid timestamp format " + e.getMessage(),
+                        true
+                );
+
+            }
+         }
+
+        @JRubyMethod(name = "parse_iso8601", required = 1, meta = true)
+        public static IRubyObject ruby_parse_iso8601(ThreadContext context, IRubyObject recv, IRubyObject time)
+        {
+            if (time instanceof RubyString) {
+                try {
+                    return RubyTimestamp.newRubyTimestamp(context.runtime, newTimetsamp(time));
+                } catch (IllegalArgumentException e) {
+                    throw new RaiseException(
+                            context.runtime,
+                            context.runtime.getModule("LogStash").getClass("TimestampParserError"),
+                            "invalid timestamp format " + e.getMessage(),
+                            true
+                    );
+
+                }
+            } else {
+                throw context.runtime.newTypeError("wrong argument type " + time.getMetaClass() + " (expected String)");
+            }
+        }
+
+        @JRubyMethod(name = "at", required = 1, optional = 1, meta = true)
+        public static IRubyObject ruby_at(ThreadContext context, IRubyObject recv, IRubyObject[] args)
+        {
+            RubyTime t;
+            if (args.length == 1) {
+                t = (RubyTime)RubyTime.at(context, context.runtime.getTime(), args[0]);
+            } else {
+                t = (RubyTime)RubyTime.at(context, context.runtime.getTime(), args[0], args[1]);
+            }
+            return RubyTimestamp.newRubyTimestamp(context.runtime,  new Timestamp(t.getDateTime()));
+        }
+
+        @JRubyMethod(name = "now", meta = true)
+        public static IRubyObject ruby_now(ThreadContext context, IRubyObject recv)
+        {
+            return RubyTimestamp.newRubyTimestamp(context.runtime);
+        }
+    }
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/AccessorsTest.java b/logstash-core-event-java/src/test/java/com/logstash/AccessorsTest.java
new file mode 100644
index 00000000000..61855abc34b
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/AccessorsTest.java
@@ -0,0 +1,185 @@
+package com.logstash;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class AccessorsTest {
+
+    public class TestableAccessors extends Accessors {
+
+        public TestableAccessors(Map data) {
+            super(data);
+        }
+
+        public Map<String, Object> getLut() {
+            return lut;
+        }
+
+        public Object lutGet(String reference) {
+            return this.lut.get(reference);
+        }
+    }
+
+    @Test
+    public void testBareGet() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", "bar");
+        String reference = "foo";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), "bar");
+        assertEquals(accessors.lutGet(reference), data);
+    }
+
+    @Test
+    public void testAbsentBareGet() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", "bar");
+        String reference = "baz";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), null);
+        assertEquals(accessors.lutGet(reference), data);
+    }
+
+    @Test
+    public void testBareBracketsGet() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", "bar");
+        String reference = "[foo]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), "bar");
+        assertEquals(accessors.lutGet(reference), data);
+    }
+
+    @Test
+    public void testDeepMapGet() throws Exception {
+        Map data = new HashMap();
+        Map inner = new HashMap();
+        data.put("foo", inner);
+        inner.put("bar", "baz");
+
+        String reference = "[foo][bar]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), "baz");
+        assertEquals(accessors.lutGet(reference), inner);
+    }
+
+    @Test
+    public void testAbsentDeepMapGet() throws Exception {
+        Map data = new HashMap();
+        Map inner = new HashMap();
+        data.put("foo", inner);
+        inner.put("bar", "baz");
+
+        String reference = "[foo][foo]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), null);
+        assertEquals(accessors.lutGet(reference), inner);
+    }
+
+    @Test
+    public void testDeepListGet() throws Exception {
+        Map data = new HashMap();
+        List inner = new ArrayList();
+        data.put("foo", inner);
+        inner.add("bar");
+
+        String reference = "[foo][0]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), "bar");
+        assertEquals(accessors.lutGet(reference), inner);
+    }
+
+    @Test
+    public void testAbsentDeepListGet() throws Exception {
+        Map data = new HashMap();
+        List inner = new ArrayList();
+        data.put("foo", inner);
+        inner.add("bar");
+
+        String reference = "[foo][1]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), null);
+        assertEquals(accessors.lutGet(reference), inner);
+    }
+
+    @Test
+    public void testBarePut() throws Exception {
+        Map data = new HashMap();
+        String reference = "foo";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.set(reference, "bar"), "bar");
+        assertEquals(accessors.lutGet(reference), data);
+        assertEquals(accessors.get(reference), "bar");
+    }
+
+    @Test
+    public void testBareBracketsPut() throws Exception {
+        Map data = new HashMap();
+        String reference = "[foo]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.set(reference, "bar"), "bar");
+        assertEquals(accessors.lutGet(reference), data);
+        assertEquals(accessors.get(reference), "bar");
+    }
+
+    @Test
+    public void testDeepMapSet() throws Exception {
+        Map data = new HashMap();
+
+        String reference = "[foo][bar]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.set(reference, "baz"), "baz");
+        assertEquals(accessors.lutGet(reference), data.get("foo"));
+        assertEquals(accessors.get(reference), "baz");
+    }
+
+    @Test
+    public void testDel() throws Exception {
+        Map data = new HashMap();
+        List inner = new ArrayList();
+        data.put("foo", inner);
+        inner.add("bar");
+        data.put("bar", "baz");
+        TestableAccessors accessors = new TestableAccessors(data);
+
+        assertEquals(accessors.del("[foo][0]"), "bar");
+        assertEquals(accessors.del("[foo][0]"), null);
+        assertEquals(accessors.get("[foo]"), new ArrayList<>());
+        assertEquals(accessors.del("[bar]"), "baz");
+        assertEquals(accessors.get("[bar]"), null);
+    }
+
+    @Test
+    public void testNilInclude() throws Exception {
+        Map data = new HashMap();
+        data.put("nilfield", null);
+        TestableAccessors accessors = new TestableAccessors(data);
+
+        assertEquals(accessors.includes("nilfield"), true);
+    }
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/EventTest.java b/logstash-core-event-java/src/test/java/com/logstash/EventTest.java
new file mode 100644
index 00000000000..46ad8292817
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/EventTest.java
@@ -0,0 +1,124 @@
+package com.logstash;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import org.jruby.RubyHash;
+import org.jruby.ir.operands.Hash;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.junit.Assert.*;
+
+public class EventTest {
+
+    @Test
+    public void testBareToJson() throws Exception {
+        Event e = new Event();
+        assertEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"@version\":\"1\"}", e.toJson());
+    }
+
+    @Test
+    public void testSimpleStringFieldToJson() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", "bar");
+        Event e = new Event(data);
+        assertEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":\"bar\",\"@version\":\"1\"}", e.toJson());
+    }
+
+    @Test
+    public void testSimpleIntegerFieldToJson() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", 1);
+        Event e = new Event(data);
+        assertEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":1,\"@version\":\"1\"}", e.toJson());
+    }
+
+    @Test
+    public void testSimpleDecimalFieldToJson() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", 1.0);
+        Event e = new Event(data);
+        assertEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":1.0,\"@version\":\"1\"}", e.toJson());
+    }
+
+    @Test
+    public void testSimpleMultipleFieldToJson() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", 1.0);
+        data.put("bar", "bar");
+        data.put("baz", 1);
+        Event e = new Event(data);
+        assertEquals("{\"bar\":\"bar\",\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":1.0,\"@version\":\"1\",\"baz\":1}", e.toJson());
+    }
+
+    @Test
+    public void testDeepMapFieldToJson() throws Exception {
+        Event e = new Event();
+        e.setField("[foo][bar][baz]", 1);
+        assertEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":{\"bar\":{\"baz\":1}},\"@version\":\"1\"}", e.toJson());
+
+        e = new Event();
+        e.setField("[foo][0][baz]", 1);
+        assertEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":{\"0\":{\"baz\":1}},\"@version\":\"1\"}", e.toJson());
+    }
+
+    @Test
+    public void testGetFieldList() throws Exception {
+        Map data = new HashMap();
+        List l = new ArrayList();
+        data.put("foo", l);
+        l.add(1);
+        Event e = new Event(data);
+        assertEquals(1, e.getField("[foo][0]"));
+    }
+
+    @Test
+    public void testDeepGetField() throws Exception {
+        Map data = new HashMap();
+        List l = new ArrayList();
+        data.put("foo", l);
+        Map m = new HashMap();
+        m.put("bar", "baz");
+        l.add(m);
+        Event e = new Event(data);
+        assertEquals("baz", e.getField("[foo][0][bar]"));
+    }
+
+
+    @Test
+    public void testClone() throws Exception {
+        Map data = new HashMap();
+        List l = new ArrayList();
+        data.put("array", l);
+
+        Map m = new HashMap();
+        m.put("foo", "bar");
+        l.add(m);
+
+        data.put("foo", 1.0);
+        data.put("bar", "bar");
+        data.put("baz", 1);
+
+        Event e = new Event(data);
+
+        Event f = e.clone();
+        assertEquals("{\"bar\":\"bar\",\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"array\":[{\"foo\":\"bar\"}],\"foo\":1.0,\"@version\":\"1\",\"baz\":1}", f.toJson());
+        assertEquals(f.toJson(), e.toJson());
+    }
+
+    @Test
+    public void testAppend() throws Exception {
+        Map  data1 = Maps.newHashMap(ImmutableMap.of("field1", Lists.newArrayList("original1", "original2")));
+        Map  data2 = Maps.newHashMap(ImmutableMap.of("field1", "original1"));
+        Event e = new Event(data1);
+        Event e2 = new Event(data2);
+        e.append(e2);
+
+        assertEquals(Lists.newArrayList("original1", "original2"), e.getField("field1"));
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/test/java/com/logstash/FieldReferenceTest.java b/logstash-core-event-java/src/test/java/com/logstash/FieldReferenceTest.java
new file mode 100644
index 00000000000..ad17810a72c
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/FieldReferenceTest.java
@@ -0,0 +1,40 @@
+package com.logstash;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.*;
+
+public class FieldReferenceTest {
+
+    @Test
+    public void testParseSingleBareField() throws Exception {
+        FieldReference f = FieldReference.parse("foo");
+        assertTrue(f.getPath().isEmpty());
+        assertEquals(f.getKey(), "foo");
+    }
+
+    @Test
+    public void testParseSingleFieldPath() throws Exception {
+        FieldReference f = FieldReference.parse("[foo]");
+        assertTrue(f.getPath().isEmpty());
+        assertEquals(f.getKey(), "foo");
+    }
+
+    @Test
+    public void testParse2FieldsPath() throws Exception {
+        FieldReference f = FieldReference.parse("[foo][bar]");
+        assertEquals(f.getPath().toArray(), new String[]{"foo"});
+        assertEquals(f.getKey(), "bar");
+    }
+
+    @Test
+    public void testParse3FieldsPath() throws Exception {
+        FieldReference f = FieldReference.parse("[foo][bar]]baz]");
+        assertEquals(f.getPath().toArray(), new String[]{"foo", "bar"});
+        assertEquals(f.getKey(), "baz");
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/test/java/com/logstash/StringInterpolationTest.java b/logstash-core-event-java/src/test/java/com/logstash/StringInterpolationTest.java
new file mode 100644
index 00000000000..52d4563db4b
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/StringInterpolationTest.java
@@ -0,0 +1,143 @@
+package com.logstash;
+
+
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeZone;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.junit.Assert.*;
+
+
+public class StringInterpolationTest {
+    @Test
+    public void testCompletelyStaticTemplate() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/path/awesome";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals(path, si.evaluate(event, path));
+    }
+
+    @Test
+    public void testOneLevelField() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{bar}/awesome";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/foo/awesome", si.evaluate(event, path));
+    }
+
+    @Test
+    public void testMultipleLevelField() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{bar}/%{awesome}";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/foo/logstash", si.evaluate(event, path));
+    }
+
+    @Test
+    public void testMissingKey() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{do-not-exist}";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/%{do-not-exist}", si.evaluate(event, path));
+    }
+
+    @Test
+    public void testDateFormater() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{+YYYY}";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/2015", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestMixDateAndFields() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{+YYYY}/weeee/%{bar}";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/2015/weeee/foo", si.evaluate(event, path));
+    }
+
+    @Test
+    public void testUnclosedTag() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{+YYY/web";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/%{+YYY/web", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestStringIsOneDateTag() throws IOException {
+        Event event = getTestEvent();
+        String path = "%{+YYYY}";
+        StringInterpolation si = StringInterpolation.getInstance();
+        assertEquals("2015", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestFieldRef() throws IOException {
+        Event event = getTestEvent();
+        String path = "%{[j][k1]}";
+        StringInterpolation si = StringInterpolation.getInstance();
+        assertEquals("v", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestEpoch() throws IOException {
+        Event event = getTestEvent();
+        String path = "%{+%s}";
+        StringInterpolation si = StringInterpolation.getInstance();
+        assertEquals("1443657600", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestValueIsArray() throws IOException {
+        ArrayList l = new ArrayList();
+        l.add("Hello");
+        l.add("world");
+
+        Event event = getTestEvent();
+        event.setField("message", l);
+
+        String path = "%{message}";
+        StringInterpolation si = StringInterpolation.getInstance();
+        assertEquals("Hello,world", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestValueIsHash() throws IOException {
+        Event event = getTestEvent();
+
+        String path = "%{j}";
+        StringInterpolation si = StringInterpolation.getInstance();
+        assertEquals("{\"k1\":\"v\"}", si.evaluate(event, path));
+    }
+
+    public Event getTestEvent() {
+        Map data = new HashMap();
+        Map inner = new HashMap();
+
+        inner.put("k1", "v");
+
+        data.put("bar", "foo");
+        data.put("awesome", "logstash");
+        data.put("j", inner);
+        data.put("@timestamp", new DateTime(2015, 10, 1, 0, 0, 0, DateTimeZone.UTC));
+
+
+        Event event = new Event(data);
+
+        return event;
+    }
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/TimestampTest.java b/logstash-core-event-java/src/test/java/com/logstash/TimestampTest.java
new file mode 100644
index 00000000000..539fbe227cb
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/TimestampTest.java
@@ -0,0 +1,46 @@
+package com.logstash;
+
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeZone;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+public class TimestampTest {
+
+
+    @Test
+    public void testCircularIso8601() throws Exception {
+        Timestamp t1 = new Timestamp();
+        Timestamp t2 = new Timestamp(t1.toIso8601());
+        assertEquals(t1.getTime(), t2.getTime());
+    }
+
+    @Test
+    public void testToIso8601() throws Exception {
+        Timestamp t = new Timestamp("2014-09-23T00:00:00-0800");
+        assertEquals("2014-09-23T08:00:00.000Z", t.toIso8601());
+    }
+
+    // Timestamp should always be in a UTC representation
+    @Test
+    public void testUTC() throws Exception {
+        Timestamp t;
+
+        t = new Timestamp();
+        assertEquals(DateTimeZone.UTC, t.getTime().getZone());
+
+        t = new Timestamp("2014-09-23T00:00:00-0800");
+        assertEquals(DateTimeZone.UTC, t.getTime().getZone());
+
+        t = new Timestamp("2014-09-23T08:00:00.000Z");
+        assertEquals(DateTimeZone.UTC, t.getTime().getZone());
+
+        t = new Timestamp(new Timestamp());
+        assertEquals(DateTimeZone.UTC, t.getTime().getZone());
+
+        long ms = DateTime.now(DateTimeZone.forID("EST")).getMillis();
+        t = new Timestamp(ms);
+        assertEquals(DateTimeZone.UTC, t.getTime().getZone());
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core-event/lib/logstash-core-event.rb b/logstash-core-event/lib/logstash-core-event.rb
new file mode 100644
index 00000000000..b2979326dac
--- /dev/null
+++ b/logstash-core-event/lib/logstash-core-event.rb
@@ -0,0 +1 @@
+require "logstash-core-event/logstash-core-event"
\ No newline at end of file
diff --git a/logstash-core-event/lib/logstash-core-event/logstash-core-event.rb b/logstash-core-event/lib/logstash-core-event/logstash-core-event.rb
new file mode 100644
index 00000000000..b0f773e203c
--- /dev/null
+++ b/logstash-core-event/lib/logstash-core-event/logstash-core-event.rb
@@ -0,0 +1,5 @@
+# encoding: utf-8
+module LogStash
+end
+
+require "logstash/event"
\ No newline at end of file
diff --git a/logstash-core-event/lib/logstash-core-event/version.rb b/logstash-core-event/lib/logstash-core-event/version.rb
new file mode 100644
index 00000000000..18e991d6b0c
--- /dev/null
+++ b/logstash-core-event/lib/logstash-core-event/version.rb
@@ -0,0 +1,8 @@
+# encoding: utf-8
+
+# The version of logstash core event gem.
+#
+# Note to authors: this should not include dashes because 'gem' barfs if
+# you include a dash in the version string.
+
+LOGSTASH_CORE_EVENT_VERSION = "3.0.0.dev"
diff --git a/lib/logstash/event.rb b/logstash-core-event/lib/logstash/event.rb
similarity index 100%
rename from lib/logstash/event.rb
rename to logstash-core-event/lib/logstash/event.rb
diff --git a/lib/logstash/string_interpolation.rb b/logstash-core-event/lib/logstash/string_interpolation.rb
similarity index 100%
rename from lib/logstash/string_interpolation.rb
rename to logstash-core-event/lib/logstash/string_interpolation.rb
diff --git a/lib/logstash/timestamp.rb b/logstash-core-event/lib/logstash/timestamp.rb
similarity index 100%
rename from lib/logstash/timestamp.rb
rename to logstash-core-event/lib/logstash/timestamp.rb
diff --git a/lib/logstash/util/accessors.rb b/logstash-core-event/lib/logstash/util/accessors.rb
similarity index 100%
rename from lib/logstash/util/accessors.rb
rename to logstash-core-event/lib/logstash/util/accessors.rb
diff --git a/logstash-core-event/logstash-core-event.gemspec b/logstash-core-event/logstash-core-event.gemspec
new file mode 100644
index 00000000000..5fcddccfdf0
--- /dev/null
+++ b/logstash-core-event/logstash-core-event.gemspec
@@ -0,0 +1,23 @@
+# -*- encoding: utf-8 -*-
+lib = File.expand_path('../lib', __FILE__)
+$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
+require 'logstash-core-event/version'
+
+Gem::Specification.new do |gem|
+  gem.authors       = ["Jordan Sissel", "Pete Fritchman", "Elasticsearch"]
+  gem.email         = ["jls@semicomplete.com", "petef@databits.net", "info@elasticsearch.com"]
+  gem.description   = %q{The core event component of logstash, the scalable log and event management tool}
+  gem.summary       = %q{logstash-core-event - The core event component of logstash}
+  gem.homepage      = "http://www.elastic.co/guide/en/logstash/current/index.html"
+  gem.license       = "Apache License (2.0)"
+
+  gem.files         = Dir.glob(["logstash-core-event.gemspec", "lib/**/*.rb", "spec/**/*.rb"])
+  gem.test_files    = gem.files.grep(%r{^(test|spec|features)/})
+  gem.name          = "logstash-core-event"
+  gem.require_paths = ["lib"]
+  gem.version       = LOGSTASH_CORE_EVENT_VERSION
+
+  if RUBY_PLATFORM == 'java'
+    gem.platform = RUBY_PLATFORM
+  end
+end
diff --git a/spec/core/event_spec.rb b/logstash-core-event/spec/logstash/event_spec.rb
similarity index 94%
rename from spec/core/event_spec.rb
rename to logstash-core-event/spec/logstash/event_spec.rb
index 52b22c3115c..7a8c217658e 100644
--- a/spec/core/event_spec.rb
+++ b/logstash-core-event/spec/logstash/event_spec.rb
@@ -1,5 +1,6 @@
 # encoding: utf-8
 require "spec_helper"
+require "json"
 
 describe LogStash::Event do
 
@@ -317,44 +318,45 @@
 
       it "should coerce timestamp" do
         t = Time.iso8601("2014-06-12T00:12:17.114Z")
-        expect(LogStash::Timestamp).to receive(:coerce).exactly(3).times.and_call_original
         expect(LogStash::Event.new("@timestamp" => t).timestamp.to_i).to eq(t.to_i)
         expect(LogStash::Event.new("@timestamp" => LogStash::Timestamp.new(t)).timestamp.to_i).to eq(t.to_i)
         expect(LogStash::Event.new("@timestamp" => "2014-06-12T00:12:17.114Z").timestamp.to_i).to eq(t.to_i)
       end
 
       it "should assign current time when no timestamp" do
-        ts = LogStash::Timestamp.now
-        expect(LogStash::Timestamp).to receive(:now).and_return(ts)
-        expect(LogStash::Event.new({}).timestamp.to_i).to eq(ts.to_i)
+        expect(LogStash::Event.new({}).timestamp.to_i).to be_within(1).of (Time.now.to_i)
       end
 
-      it "should tag and warn for invalid value" do
-        ts = LogStash::Timestamp.now
-        expect(LogStash::Timestamp).to receive(:now).twice.and_return(ts)
-        expect(LogStash::Event::LOGGER).to receive(:warn).twice
-
+      it "should tag for invalid value" do
         event = LogStash::Event.new("@timestamp" => :foo)
-        expect(event.timestamp.to_i).to eq(ts.to_i)
+        expect(event.timestamp.to_i).to be_within(1).of Time.now.to_i
         expect(event["tags"]).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
         expect(event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]).to eq(:foo)
 
         event = LogStash::Event.new("@timestamp" => 666)
-        expect(event.timestamp.to_i).to eq(ts.to_i)
+        expect(event.timestamp.to_i).to be_within(1).of Time.now.to_i
         expect(event["tags"]).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
         expect(event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]).to eq(666)
       end
 
-      it "should tag and warn for invalid string format" do
-        ts = LogStash::Timestamp.now
-        expect(LogStash::Timestamp).to receive(:now).and_return(ts)
-        expect(LogStash::Event::LOGGER).to receive(:warn)
+      it "should warn for invalid value" do
+        expect(LogStash::Event::LOGGER).to receive(:warn).twice
 
+        LogStash::Event.new("@timestamp" => :foo)
+        LogStash::Event.new("@timestamp" => 666)
+      end
+
+      it "should tag for invalid string format" do
         event = LogStash::Event.new("@timestamp" => "foo")
-        expect(event.timestamp.to_i).to eq(ts.to_i)
+        expect(event.timestamp.to_i).to be_within(1).of Time.now.to_i
         expect(event["tags"]).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
         expect(event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]).to eq("foo")
       end
+
+      it "should warn for invalid string format" do
+        expect(LogStash::Event::LOGGER).to receive(:warn)
+        LogStash::Event.new("@timestamp" => "foo")
+      end
     end
 
     context "to_json" do
@@ -365,7 +367,7 @@
         )
         json = new_event.to_json
 
-        expect(json).to eq( "{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}")
+        expect(JSON.parse(json)).to eq( JSON.parse("{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}"))
       end
 
       it "should support to_json and ignore arguments" do
@@ -375,7 +377,7 @@
         )
         json = new_event.to_json(:foo => 1, :bar => "baz")
 
-        expect(json).to eq( "{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}")
+        expect(JSON.parse(json)).to eq( JSON.parse("{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}"))
       end
     end
 
diff --git a/spec/core/timestamp_spec.rb b/logstash-core-event/spec/logstash/timestamp_spec.rb
similarity index 100%
rename from spec/core/timestamp_spec.rb
rename to logstash-core-event/spec/logstash/timestamp_spec.rb
diff --git a/spec/util/accessors_spec.rb b/logstash-core-event/spec/logstash/util/accessors_spec.rb
similarity index 93%
rename from spec/util/accessors_spec.rb
rename to logstash-core-event/spec/logstash/util/accessors_spec.rb
index af719a32999..e3c1a73e60e 100644
--- a/spec/util/accessors_spec.rb
+++ b/logstash-core-event/spec/logstash/util/accessors_spec.rb
@@ -1,8 +1,17 @@
 # encoding: utf-8
 require "spec_helper"
-require "logstash/util/accessors"
 
-describe LogStash::Util::Accessors, :if => true do
+# this is to skip specs when running agains an alternate logstash-core-event implementation
+# that does not define the Accessors class. For example, in logstash-core-event-java
+# the Accessors class does not exists in the Ruby namespace.
+class_exists = begin
+  require "logstash/util/accessors"
+  true
+rescue LoadError
+  false
+end
+
+describe "LogStash::Util::Accessors", :if => class_exists do
 
   context "using simple field" do
 
diff --git a/logstash-core/lib/logstash-core.rb b/logstash-core/lib/logstash-core.rb
new file mode 100644
index 00000000000..c2e4557afa8
--- /dev/null
+++ b/logstash-core/lib/logstash-core.rb
@@ -0,0 +1 @@
+require "logstash-core/logstash-core"
diff --git a/lib/logstash-core.rb b/logstash-core/lib/logstash-core/logstash-core.rb
similarity index 100%
rename from lib/logstash-core.rb
rename to logstash-core/lib/logstash-core/logstash-core.rb
diff --git a/lib/logstash/version.rb b/logstash-core/lib/logstash-core/version.rb
similarity index 64%
rename from lib/logstash/version.rb
rename to logstash-core/lib/logstash-core/version.rb
index 17a5cd8c15b..fdc9d13f1a4 100644
--- a/lib/logstash/version.rb
+++ b/logstash-core/lib/logstash-core/version.rb
@@ -1,6 +1,8 @@
 # encoding: utf-8
-# The version of logstash.
-LOGSTASH_VERSION = "3.0.0.dev"
 
+# The version of logstash core gem.
+#
 # Note to authors: this should not include dashes because 'gem' barfs if
 # you include a dash in the version string.
+
+LOGSTASH_CORE_VERSION = "3.0.0.dev"
diff --git a/lib/logstash/agent.rb b/logstash-core/lib/logstash/agent.rb
similarity index 100%
rename from lib/logstash/agent.rb
rename to logstash-core/lib/logstash/agent.rb
diff --git a/lib/logstash/certs/cacert.pem b/logstash-core/lib/logstash/certs/cacert.pem
similarity index 100%
rename from lib/logstash/certs/cacert.pem
rename to logstash-core/lib/logstash/certs/cacert.pem
diff --git a/lib/logstash/codecs/base.rb b/logstash-core/lib/logstash/codecs/base.rb
similarity index 100%
rename from lib/logstash/codecs/base.rb
rename to logstash-core/lib/logstash/codecs/base.rb
diff --git a/lib/logstash/config/config_ast.rb b/logstash-core/lib/logstash/config/config_ast.rb
similarity index 100%
rename from lib/logstash/config/config_ast.rb
rename to logstash-core/lib/logstash/config/config_ast.rb
diff --git a/lib/logstash/config/cpu_core_strategy.rb b/logstash-core/lib/logstash/config/cpu_core_strategy.rb
similarity index 100%
rename from lib/logstash/config/cpu_core_strategy.rb
rename to logstash-core/lib/logstash/config/cpu_core_strategy.rb
diff --git a/lib/logstash/config/defaults.rb b/logstash-core/lib/logstash/config/defaults.rb
similarity index 100%
rename from lib/logstash/config/defaults.rb
rename to logstash-core/lib/logstash/config/defaults.rb
diff --git a/lib/logstash/config/file.rb b/logstash-core/lib/logstash/config/file.rb
similarity index 100%
rename from lib/logstash/config/file.rb
rename to logstash-core/lib/logstash/config/file.rb
diff --git a/lib/logstash/config/grammar.rb b/logstash-core/lib/logstash/config/grammar.rb
similarity index 100%
rename from lib/logstash/config/grammar.rb
rename to logstash-core/lib/logstash/config/grammar.rb
diff --git a/lib/logstash/config/grammar.treetop b/logstash-core/lib/logstash/config/grammar.treetop
similarity index 100%
rename from lib/logstash/config/grammar.treetop
rename to logstash-core/lib/logstash/config/grammar.treetop
diff --git a/lib/logstash/config/mixin.rb b/logstash-core/lib/logstash/config/mixin.rb
similarity index 100%
rename from lib/logstash/config/mixin.rb
rename to logstash-core/lib/logstash/config/mixin.rb
diff --git a/lib/logstash/config/registry.rb b/logstash-core/lib/logstash/config/registry.rb
similarity index 100%
rename from lib/logstash/config/registry.rb
rename to logstash-core/lib/logstash/config/registry.rb
diff --git a/lib/logstash/environment.rb b/logstash-core/lib/logstash/environment.rb
similarity index 81%
rename from lib/logstash/environment.rb
rename to logstash-core/lib/logstash/environment.rb
index 8f710eed088..79e7f24d86c 100644
--- a/lib/logstash/environment.rb
+++ b/logstash-core/lib/logstash/environment.rb
@@ -1,18 +1,10 @@
 # encoding: utf-8
 require "logstash/errors"
-require "logstash/version"
 
 module LogStash
   module Environment
     extend self
 
-    # rehydrate the bootstrap environment if the startup was not done by executing bootstrap.rb
-    # and we are in the context of the logstash package
-    if !LogStash::Environment.const_defined?("LOGSTASH_HOME") &&  !ENV["LOGSTASH_HOME"].to_s.empty?
-      $LOAD_PATH << ::File.join(ENV["LOGSTASH_HOME"], "lib")
-      require "bootstrap/environment"
-    end
-
     LOGSTASH_CORE = ::File.expand_path(::File.join(::File.dirname(__FILE__), "..", ".."))
     LOGSTASH_ENV = (ENV["LS_ENV"] || 'production').to_s.freeze
 
@@ -81,14 +73,6 @@ def windows?
       ::Gem.win_platform?
     end
 
-    def vendor_path(path)
-      return ::File.join(LOGSTASH_HOME, "vendor", path)
-    end
-
-    def pattern_path(path)
-      return ::File.join(LOGSTASH_HOME, "patterns", path)
-    end
-
     def locales_path(path)
       return ::File.join(LOGSTASH_CORE, "locales", path)
     end
diff --git a/lib/logstash/errors.rb b/logstash-core/lib/logstash/errors.rb
similarity index 100%
rename from lib/logstash/errors.rb
rename to logstash-core/lib/logstash/errors.rb
diff --git a/lib/logstash/filters/base.rb b/logstash-core/lib/logstash/filters/base.rb
similarity index 93%
rename from lib/logstash/filters/base.rb
rename to logstash-core/lib/logstash/filters/base.rb
index 4ce752a0e33..d2f1c601d05 100644
--- a/lib/logstash/filters/base.rb
+++ b/logstash-core/lib/logstash/filters/base.rb
@@ -178,12 +178,16 @@ def filter_matched(event)
 
     LogStash::Util::Decorators.add_tags(@add_tag,event,"filters/#{self.class.name}")
 
+    # note below that the tags array field needs to be updated then reassigned to the event.
+    # this is important because a construct like event["tags"].delete(tag) will not work
+    # in the current Java event implementation. see https://github.com/elastic/logstash/issues/4140
     @remove_tag.each do |tag|
-      break if event["tags"].nil?
+      tags = event["tags"]
+      break if tags.nil? || tags.empty?
       tag = event.sprintf(tag)
-      @logger.debug? and @logger.debug("filters/#{self.class.name}: removing tag",
-                                       :tag => tag)
-      event["tags"].delete(tag)
+      @logger.debug? and @logger.debug("filters/#{self.class.name}: removing tag", :tag => tag)
+      tags.delete(tag)
+      event["tags"] = tags
     end
   end # def filter_matched
 
diff --git a/lib/logstash/inputs/base.rb b/logstash-core/lib/logstash/inputs/base.rb
similarity index 100%
rename from lib/logstash/inputs/base.rb
rename to logstash-core/lib/logstash/inputs/base.rb
diff --git a/lib/logstash/inputs/threadable.rb b/logstash-core/lib/logstash/inputs/threadable.rb
similarity index 100%
rename from lib/logstash/inputs/threadable.rb
rename to logstash-core/lib/logstash/inputs/threadable.rb
diff --git a/lib/logstash/java_integration.rb b/logstash-core/lib/logstash/java_integration.rb
similarity index 100%
rename from lib/logstash/java_integration.rb
rename to logstash-core/lib/logstash/java_integration.rb
diff --git a/lib/logstash/json.rb b/logstash-core/lib/logstash/json.rb
similarity index 100%
rename from lib/logstash/json.rb
rename to logstash-core/lib/logstash/json.rb
diff --git a/lib/logstash/logging.rb b/logstash-core/lib/logstash/logging.rb
similarity index 100%
rename from lib/logstash/logging.rb
rename to logstash-core/lib/logstash/logging.rb
diff --git a/lib/logstash/namespace.rb b/logstash-core/lib/logstash/namespace.rb
similarity index 100%
rename from lib/logstash/namespace.rb
rename to logstash-core/lib/logstash/namespace.rb
diff --git a/lib/logstash/outputs/base.rb b/logstash-core/lib/logstash/outputs/base.rb
similarity index 100%
rename from lib/logstash/outputs/base.rb
rename to logstash-core/lib/logstash/outputs/base.rb
diff --git a/lib/logstash/patches.rb b/logstash-core/lib/logstash/patches.rb
similarity index 100%
rename from lib/logstash/patches.rb
rename to logstash-core/lib/logstash/patches.rb
diff --git a/lib/logstash/patches/bugfix_jruby_2558.rb b/logstash-core/lib/logstash/patches/bugfix_jruby_2558.rb
similarity index 100%
rename from lib/logstash/patches/bugfix_jruby_2558.rb
rename to logstash-core/lib/logstash/patches/bugfix_jruby_2558.rb
diff --git a/lib/logstash/patches/cabin.rb b/logstash-core/lib/logstash/patches/cabin.rb
similarity index 100%
rename from lib/logstash/patches/cabin.rb
rename to logstash-core/lib/logstash/patches/cabin.rb
diff --git a/lib/logstash/patches/profile_require_calls.rb b/logstash-core/lib/logstash/patches/profile_require_calls.rb
similarity index 100%
rename from lib/logstash/patches/profile_require_calls.rb
rename to logstash-core/lib/logstash/patches/profile_require_calls.rb
diff --git a/lib/logstash/patches/rubygems.rb b/logstash-core/lib/logstash/patches/rubygems.rb
similarity index 100%
rename from lib/logstash/patches/rubygems.rb
rename to logstash-core/lib/logstash/patches/rubygems.rb
diff --git a/lib/logstash/patches/stronger_openssl_defaults.rb b/logstash-core/lib/logstash/patches/stronger_openssl_defaults.rb
similarity index 100%
rename from lib/logstash/patches/stronger_openssl_defaults.rb
rename to logstash-core/lib/logstash/patches/stronger_openssl_defaults.rb
diff --git a/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
similarity index 100%
rename from lib/logstash/pipeline.rb
rename to logstash-core/lib/logstash/pipeline.rb
diff --git a/lib/logstash/plugin.rb b/logstash-core/lib/logstash/plugin.rb
similarity index 100%
rename from lib/logstash/plugin.rb
rename to logstash-core/lib/logstash/plugin.rb
diff --git a/lib/logstash/program.rb b/logstash-core/lib/logstash/program.rb
similarity index 100%
rename from lib/logstash/program.rb
rename to logstash-core/lib/logstash/program.rb
diff --git a/lib/logstash/runner.rb b/logstash-core/lib/logstash/runner.rb
similarity index 100%
rename from lib/logstash/runner.rb
rename to logstash-core/lib/logstash/runner.rb
diff --git a/lib/logstash/sized_queue.rb b/logstash-core/lib/logstash/sized_queue.rb
similarity index 100%
rename from lib/logstash/sized_queue.rb
rename to logstash-core/lib/logstash/sized_queue.rb
diff --git a/lib/logstash/util.rb b/logstash-core/lib/logstash/util.rb
similarity index 100%
rename from lib/logstash/util.rb
rename to logstash-core/lib/logstash/util.rb
diff --git a/lib/logstash/util/buftok.rb b/logstash-core/lib/logstash/util/buftok.rb
similarity index 100%
rename from lib/logstash/util/buftok.rb
rename to logstash-core/lib/logstash/util/buftok.rb
diff --git a/lib/logstash/util/charset.rb b/logstash-core/lib/logstash/util/charset.rb
similarity index 100%
rename from lib/logstash/util/charset.rb
rename to logstash-core/lib/logstash/util/charset.rb
diff --git a/lib/logstash/util/decorators.rb b/logstash-core/lib/logstash/util/decorators.rb
similarity index 56%
rename from lib/logstash/util/decorators.rb
rename to logstash-core/lib/logstash/util/decorators.rb
index 0ea2c021aca..265656e5ce9 100644
--- a/lib/logstash/util/decorators.rb
+++ b/logstash-core/lib/logstash/util/decorators.rb
@@ -19,13 +19,16 @@ def add_fields(fields,event, pluginname)
         value.each do |v|
           v = event.sprintf(v)
           if event.include?(field)
-            event[field] = Array(event[field])
-            event[field] << v
+            # note below that the array field needs to be updated then reassigned to the event.
+            # this is important because a construct like event[field] << v will not work
+            # in the current Java event implementation. see https://github.com/elastic/logstash/issues/4140
+            a = Array(event[field])
+            a << v
+            event[field] = a
           else
             event[field] = v
           end
-          @logger.debug? and @logger.debug("#{pluginname}: adding value to field",
-                                         :field => field, :value => value)
+          @logger.debug? and @logger.debug("#{pluginname}: adding value to field", :field => field, :value => value)
         end
       end
     end
@@ -34,9 +37,13 @@ def add_fields(fields,event, pluginname)
     def add_tags(tags, event, pluginname)
       tags.each do |tag|
         tag = event.sprintf(tag)
-        @logger.debug? and @logger.debug("#{pluginname}: adding tag",
-                                       :tag => tag)
-        (event["tags"] ||= []) << tag
+        @logger.debug? and @logger.debug("#{pluginname}: adding tag", :tag => tag)
+        # note below that the tags array field needs to be updated then reassigned to the event.
+        # this is important because a construct like event["tags"] << tag will not work
+        # in the current Java event implementation. see https://github.com/elastic/logstash/issues/4140
+        tags = event["tags"] || []
+        tags << tag
+        event["tags"] = tags
       end
     end
 
diff --git a/lib/logstash/util/defaults_printer.rb b/logstash-core/lib/logstash/util/defaults_printer.rb
similarity index 100%
rename from lib/logstash/util/defaults_printer.rb
rename to logstash-core/lib/logstash/util/defaults_printer.rb
diff --git a/lib/logstash/util/filetools.rb b/logstash-core/lib/logstash/util/filetools.rb
similarity index 100%
rename from lib/logstash/util/filetools.rb
rename to logstash-core/lib/logstash/util/filetools.rb
diff --git a/lib/logstash/util/java_version.rb b/logstash-core/lib/logstash/util/java_version.rb
similarity index 100%
rename from lib/logstash/util/java_version.rb
rename to logstash-core/lib/logstash/util/java_version.rb
diff --git a/lib/logstash/util/password.rb b/logstash-core/lib/logstash/util/password.rb
similarity index 100%
rename from lib/logstash/util/password.rb
rename to logstash-core/lib/logstash/util/password.rb
diff --git a/lib/logstash/util/plugin_version.rb b/logstash-core/lib/logstash/util/plugin_version.rb
similarity index 100%
rename from lib/logstash/util/plugin_version.rb
rename to logstash-core/lib/logstash/util/plugin_version.rb
diff --git a/lib/logstash/util/prctl.rb b/logstash-core/lib/logstash/util/prctl.rb
similarity index 100%
rename from lib/logstash/util/prctl.rb
rename to logstash-core/lib/logstash/util/prctl.rb
diff --git a/lib/logstash/util/reporter.rb b/logstash-core/lib/logstash/util/reporter.rb
similarity index 100%
rename from lib/logstash/util/reporter.rb
rename to logstash-core/lib/logstash/util/reporter.rb
diff --git a/lib/logstash/util/retryable.rb b/logstash-core/lib/logstash/util/retryable.rb
similarity index 100%
rename from lib/logstash/util/retryable.rb
rename to logstash-core/lib/logstash/util/retryable.rb
diff --git a/lib/logstash/util/socket_peer.rb b/logstash-core/lib/logstash/util/socket_peer.rb
similarity index 100%
rename from lib/logstash/util/socket_peer.rb
rename to logstash-core/lib/logstash/util/socket_peer.rb
diff --git a/lib/logstash/util/unicode_trimmer.rb b/logstash-core/lib/logstash/util/unicode_trimmer.rb
similarity index 100%
rename from lib/logstash/util/unicode_trimmer.rb
rename to logstash-core/lib/logstash/util/unicode_trimmer.rb
diff --git a/lib/logstash/util/worker_threads_default_printer.rb b/logstash-core/lib/logstash/util/worker_threads_default_printer.rb
similarity index 100%
rename from lib/logstash/util/worker_threads_default_printer.rb
rename to logstash-core/lib/logstash/util/worker_threads_default_printer.rb
diff --git a/logstash-core/lib/logstash/version.rb b/logstash-core/lib/logstash/version.rb
new file mode 100644
index 00000000000..70715b097cb
--- /dev/null
+++ b/logstash-core/lib/logstash/version.rb
@@ -0,0 +1,14 @@
+# encoding: utf-8
+
+# The version of the logstash package (not the logstash-core gem version).
+#
+# Note to authors: this should not include dashes because 'gem' barfs if
+# you include a dash in the version string.
+
+# TODO: (colin) the logstash-core gem uses it's own version number in logstash-core/lib/logstash-core/version.rb
+#       there are some dependencies in logstash-core on the LOGSTASH_VERSION constant this is why
+#       the logstash version is currently defined here in logstash-core/lib/logstash/version.rb but
+#       eventually this file should be in the root logstash lib fir and dependencies in logstash-core should be
+#       fixed.
+
+LOGSTASH_VERSION = "3.0.0.dev"
diff --git a/locales/en.yml b/logstash-core/locales/en.yml
similarity index 100%
rename from locales/en.yml
rename to logstash-core/locales/en.yml
diff --git a/logstash-core.gemspec b/logstash-core/logstash-core.gemspec
similarity index 90%
rename from logstash-core.gemspec
rename to logstash-core/logstash-core.gemspec
index 35937a060a1..595c5f413c0 100644
--- a/logstash-core.gemspec
+++ b/logstash-core/logstash-core.gemspec
@@ -1,7 +1,7 @@
 # -*- encoding: utf-8 -*-
 lib = File.expand_path('../lib', __FILE__)
 $LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
-require 'logstash/version'
+require 'logstash-core/version'
 
 Gem::Specification.new do |gem|
   gem.authors       = ["Jordan Sissel", "Pete Fritchman", "Elasticsearch"]
@@ -11,11 +11,13 @@ Gem::Specification.new do |gem|
   gem.homepage      = "http://www.elastic.co/guide/en/logstash/current/index.html"
   gem.license       = "Apache License (2.0)"
 
-  gem.files         = Dir.glob(["logstash-core.gemspec", "lib/logstash-core.rb", "lib/logstash/**/*.rb", "spec/**/*.rb", "locales/*"])
+  gem.files         = Dir.glob(["logstash-core.gemspec", "lib/**/*.rb", "spec/**/*.rb", "locales/*"])
   gem.test_files    = gem.files.grep(%r{^(test|spec|features)/})
   gem.name          = "logstash-core"
   gem.require_paths = ["lib"]
-  gem.version       = LOGSTASH_VERSION
+  gem.version       = LOGSTASH_CORE_VERSION
+
+  gem.add_runtime_dependency "logstash-core-event", "~> 3.0.0.dev"
 
   gem.add_runtime_dependency "cabin", "~> 0.7.0" #(Apache 2.0 license)
   gem.add_runtime_dependency "pry", "~> 0.10.1"  #(Ruby license)
diff --git a/spec/core/conditionals_spec.rb b/logstash-core/spec/conditionals_spec.rb
similarity index 100%
rename from spec/core/conditionals_spec.rb
rename to logstash-core/spec/conditionals_spec.rb
diff --git a/spec/logstash/agent_spec.rb b/logstash-core/spec/logstash/agent_spec.rb
similarity index 100%
rename from spec/logstash/agent_spec.rb
rename to logstash-core/spec/logstash/agent_spec.rb
diff --git a/spec/core/config_spec.rb b/logstash-core/spec/logstash/config/config_ast_spec.rb
similarity index 100%
rename from spec/core/config_spec.rb
rename to logstash-core/spec/logstash/config/config_ast_spec.rb
diff --git a/spec/core/config_cpu_core_strategy_spec.rb b/logstash-core/spec/logstash/config/cpu_core_strategy_spec.rb
similarity index 100%
rename from spec/core/config_cpu_core_strategy_spec.rb
rename to logstash-core/spec/logstash/config/cpu_core_strategy_spec.rb
diff --git a/spec/core/config_defaults_spec.rb b/logstash-core/spec/logstash/config/defaults_spec.rb
similarity index 100%
rename from spec/core/config_defaults_spec.rb
rename to logstash-core/spec/logstash/config/defaults_spec.rb
diff --git a/spec/core/config_mixin_spec.rb b/logstash-core/spec/logstash/config/mixin_spec.rb
similarity index 100%
rename from spec/core/config_mixin_spec.rb
rename to logstash-core/spec/logstash/config/mixin_spec.rb
diff --git a/spec/core/environment_spec.rb b/logstash-core/spec/logstash/environment_spec.rb
similarity index 100%
rename from spec/core/environment_spec.rb
rename to logstash-core/spec/logstash/environment_spec.rb
diff --git a/spec/filters/base_spec.rb b/logstash-core/spec/logstash/filters/base_spec.rb
similarity index 100%
rename from spec/filters/base_spec.rb
rename to logstash-core/spec/logstash/filters/base_spec.rb
diff --git a/spec/inputs/base_spec.rb b/logstash-core/spec/logstash/inputs/base_spec.rb
similarity index 100%
rename from spec/inputs/base_spec.rb
rename to logstash-core/spec/logstash/inputs/base_spec.rb
diff --git a/spec/lib/logstash/java_integration_spec.rb b/logstash-core/spec/logstash/java_integration_spec.rb
similarity index 100%
rename from spec/lib/logstash/java_integration_spec.rb
rename to logstash-core/spec/logstash/java_integration_spec.rb
diff --git a/spec/util/json_spec.rb b/logstash-core/spec/logstash/json_spec.rb
similarity index 100%
rename from spec/util/json_spec.rb
rename to logstash-core/spec/logstash/json_spec.rb
diff --git a/spec/outputs/base_spec.rb b/logstash-core/spec/logstash/outputs/base_spec.rb
similarity index 100%
rename from spec/outputs/base_spec.rb
rename to logstash-core/spec/logstash/outputs/base_spec.rb
diff --git a/spec/logstash/patches_spec.rb b/logstash-core/spec/logstash/patches_spec.rb
similarity index 100%
rename from spec/logstash/patches_spec.rb
rename to logstash-core/spec/logstash/patches_spec.rb
diff --git a/spec/core/pipeline_spec.rb b/logstash-core/spec/logstash/pipeline_spec.rb
similarity index 100%
rename from spec/core/pipeline_spec.rb
rename to logstash-core/spec/logstash/pipeline_spec.rb
diff --git a/spec/core/plugin_spec.rb b/logstash-core/spec/logstash/plugin_spec.rb
similarity index 100%
rename from spec/core/plugin_spec.rb
rename to logstash-core/spec/logstash/plugin_spec.rb
diff --git a/spec/core/runner_spec.rb b/logstash-core/spec/logstash/runner_spec.rb
similarity index 100%
rename from spec/core/runner_spec.rb
rename to logstash-core/spec/logstash/runner_spec.rb
diff --git a/spec/util/buftok_spec.rb b/logstash-core/spec/logstash/util/buftok_spec.rb
similarity index 100%
rename from spec/util/buftok_spec.rb
rename to logstash-core/spec/logstash/util/buftok_spec.rb
diff --git a/spec/util/charset_spec.rb b/logstash-core/spec/logstash/util/charset_spec.rb
similarity index 100%
rename from spec/util/charset_spec.rb
rename to logstash-core/spec/logstash/util/charset_spec.rb
diff --git a/spec/util/defaults_printer_spec.rb b/logstash-core/spec/logstash/util/defaults_printer_spec.rb
similarity index 100%
rename from spec/util/defaults_printer_spec.rb
rename to logstash-core/spec/logstash/util/defaults_printer_spec.rb
diff --git a/spec/util/java_version_spec.rb b/logstash-core/spec/logstash/util/java_version_spec.rb
similarity index 100%
rename from spec/util/java_version_spec.rb
rename to logstash-core/spec/logstash/util/java_version_spec.rb
diff --git a/spec/util/plugin_version_spec.rb b/logstash-core/spec/logstash/util/plugin_version_spec.rb
similarity index 100%
rename from spec/util/plugin_version_spec.rb
rename to logstash-core/spec/logstash/util/plugin_version_spec.rb
diff --git a/spec/util/unicode_trimmer_spec.rb b/logstash-core/spec/logstash/util/unicode_trimmer_spec.rb
similarity index 100%
rename from spec/util/unicode_trimmer_spec.rb
rename to logstash-core/spec/logstash/util/unicode_trimmer_spec.rb
diff --git a/spec/util/worker_threads_default_printer_spec.rb b/logstash-core/spec/logstash/util/worker_threads_default_printer_spec.rb
similarity index 100%
rename from spec/util/worker_threads_default_printer_spec.rb
rename to logstash-core/spec/logstash/util/worker_threads_default_printer_spec.rb
diff --git a/spec/util_spec.rb b/logstash-core/spec/logstash/util_spec.rb
similarity index 100%
rename from spec/util_spec.rb
rename to logstash-core/spec/logstash/util_spec.rb
diff --git a/logstash-event.gemspec b/logstash-event.gemspec
deleted file mode 100644
index ea6cce87e1a..00000000000
--- a/logstash-event.gemspec
+++ /dev/null
@@ -1,41 +0,0 @@
-# -*- encoding: utf-8 -*-
-Gem::Specification.new do |gem|
-  gem.authors       = ["Jordan Sissel"]
-  gem.email         = ["jls@semicomplete.com"]
-  gem.description   = %q{Library that contains the classes required to create LogStash events}
-  gem.summary       = %q{Library that contains the classes required to create LogStash events}
-  gem.homepage      = "https://github.com/logstash/logstash"
-  gem.license       = "Apache License (2.0)"
-
-  gem.files = %w{
-    lib/logstash-event.rb
-    lib/logstash/environment.rb
-    lib/logstash/errors.rb
-    lib/logstash/event.rb
-    lib/logstash/java_integration.rb
-    lib/logstash/json.rb
-    lib/logstash/namespace.rb
-    lib/logstash/timestamp.rb
-    lib/logstash/version.rb
-    lib/logstash/util.rb
-    lib/logstash/util/accessors.rb
-    LICENSE
-  }
-
-  gem.test_files    = ["spec/core/event_spec.rb"]
-  gem.name          = "logstash-event"
-  gem.require_paths = ["lib"]
-  gem.version       = "1.3.0"
-
-  gem.add_runtime_dependency "cabin"
-  gem.add_development_dependency "rspec"
-  gem.add_development_dependency "guard"
-  gem.add_development_dependency "guard-rspec"
-
-  if RUBY_PLATFORM == 'java'
-    gem.platform = RUBY_PLATFORM
-    gem.add_runtime_dependency "jrjackson"
-  else
-    gem.add_runtime_dependency "oj"
-  end
-end
diff --git a/rakelib/artifacts.rake b/rakelib/artifacts.rake
index e2637f09995..fd66801588f 100644
--- a/rakelib/artifacts.rake
+++ b/rakelib/artifacts.rake
@@ -1,4 +1,4 @@
-require "logstash/version"
+require "logstash-core/lib/logstash/version"
 
 namespace "artifact" do
 
@@ -54,20 +54,46 @@ namespace "artifact" do
     File.open(".bundle/config", "w") { }
   end
 
-  # locate the "gem "logstash-core" ..." line in Gemfile, and if the :path => "." option if specified
+  # locate the "gem "logstash-core" ..." line in Gemfile, and if the :path => "..." option if specified
   # build and install the local logstash-core gem otherwise just do nothing, bundler will deal with it.
   task "install-logstash-core" do
+    # regex which matches a Gemfile gem definition for the logstash-core gem and captures the :path option
+    gem_line_regex = /^\s*gem\s+["']logstash-core["'](?:\s*,\s*["'][^"^']+["'])?(?:\s*,\s*:path\s*=>\s*["']([^"^']+)["'])?/i
+
     lines = File.readlines("Gemfile")
-    matches = lines.select{|line| line[/^gem\s+["']logstash-core["']/i]}
+    matches = lines.select{|line| line[gem_line_regex]}
     abort("ERROR: Gemfile format error, need a single logstash-core gem specification") if matches.size != 1
-    if matches.first =~ /:path\s*=>\s*["']\.["']/
-      Rake::Task["plugin:install-local-logstash-core-gem"].invoke
+
+    path = matches.first[gem_line_regex, 1]
+
+    if path
+      Rake::Task["plugin:install-local-core-gem"].invoke("logstash-core", path)
     else
       puts("[artifact:install-logstash-core] using logstash-core from Rubygems")
     end
   end
 
-  task "prepare" => ["bootstrap", "plugin:install-default", "install-logstash-core", "clean-bundle-config"]
+  # # locate the "gem "logstash-core-event*" ..." line in Gemfile, and if the :path => "." option if specified
+  # # build and install the local logstash-core-event* gem otherwise just do nothing, bundler will deal with it.
+  task "install-logstash-core-event" do
+    # regex which matches a Gemfile gem definition for the logstash-core-event* gem and captures the gem name and :path option
+    gem_line_regex = /^\s*gem\s+["'](logstash-core-event[^"^']*)["'](?:\s*,\s*["'][^"^']+["'])?(?:\s*,\s*:path\s*=>\s*["']([^"^']+)["'])?/i
+
+    lines = File.readlines("Gemfile")
+    matches = lines.select{|line| line[gem_line_regex]}
+    abort("ERROR: Gemfile format error, need a single logstash-core-event gem specification") if matches.size != 1
+
+    name = matches.first[gem_line_regex, 1]
+    path = matches.first[gem_line_regex, 2]
+
+    if path
+      Rake::Task["plugin:install-local-core-gem"].invoke(name, path)
+    else
+      puts("[artifact:install-logstash-core] using #{name} from Rubygems")
+    end
+  end
+
+  task "prepare" => ["bootstrap", "plugin:install-default", "install-logstash-core", "install-logstash-core-event", "clean-bundle-config"]
 
   desc "Build a tar.gz of logstash with all dependencies"
   task "tar" => ["prepare"] do
diff --git a/rakelib/compile.rake b/rakelib/compile.rake
index df572de21bc..be5693bead7 100644
--- a/rakelib/compile.rake
+++ b/rakelib/compile.rake
@@ -8,8 +8,15 @@ end
 
 namespace "compile" do
   desc "Compile the config grammar"
-  task "grammar" => "lib/logstash/config/grammar.rb"
+
+  task "grammar" => "logstash-core/lib/logstash/config/grammar.rb"
 
   desc "Build everything"
-  task "all" => "grammar"
+  # task "all" => ["grammar", "logstash-core-event-java"]
+  task "all" => ["grammar"]
+
+  task "logstash-core-event-java" do
+    puts("Building logstash-core-event-java using gradle")
+    system("logstash-core-event-java/gradlew", "jar", "-p", "./logstash-core-event-java")
+  end
 end
diff --git a/rakelib/plugin.rake b/rakelib/plugin.rake
index 9c2065c1f56..d08fbdf6f2a 100644
--- a/rakelib/plugin.rake
+++ b/rakelib/plugin.rake
@@ -57,26 +57,40 @@ namespace "plugin" do
     task.reenable # Allow this task to be run again
   end
 
-  task "clean-logstash-core-gem" do
-    Dir["logstash-core*.gem"].each do |gem|
+  task "clean-local-core-gem", [:name, :path] do |task, args|
+    name = args[:name]
+    path = args[:path]
+
+    Dir[File.join(path, "#{name}*.gem")].each do |gem|
+      puts("[plugin:clean-local-core-gem] Cleaning #{gem}")
       rm(gem)
     end
 
     task.reenable # Allow this task to be run again
   end
 
-  task "build-logstash-core-gem" => [ "clean-logstash-core-gem" ] do
-    puts("[plugin:build-logstash-core-gem] Building logstash-core.gemspec")
+  task "build-local-core-gem", [:name, :path]  do |task, args|
+    name = args[:name]
+    path = args[:path]
+
+    Rake::Task["plugin:clean-local-core-gem"].invoke(name, path)
 
-    system("gem build logstash-core.gemspec")
+    puts("[plugin:build-local-core-gem] Building #{File.join(path, name)}.gemspec")
+
+    system("cd #{path}; gem build #{name}.gemspec")
 
     task.reenable # Allow this task to be run again
   end
 
-  task "install-local-logstash-core-gem" => [ "build-logstash-core-gem" ] do
-    gems = Dir["logstash-core*.gem"]
-    abort("ERROR: logstash-core gem not found") if gems.size != 1
-    puts("[plugin:install-local-logstash-core-gem] Installing #{gems.first}")
+  task "install-local-core-gem", [:name, :path] do |task, args|
+    name = args[:name]
+    path = args[:path]
+
+    Rake::Task["plugin:build-local-core-gem"].invoke(name, path)
+
+    gems = Dir[File.join(path, "#{name}*.gem")]
+    abort("ERROR: #{name} gem not found in #{path}") if gems.size != 1
+    puts("[plugin:install-local-core-gem] Installing #{gems.first}")
     install_plugins("--no-verify", gems.first)
 
     task.reenable # Allow this task to be run again
diff --git a/rakelib/test.rake b/rakelib/test.rake
index 7ac22c304af..8c0d16ff4ef 100644
--- a/rakelib/test.rake
+++ b/rakelib/test.rake
@@ -19,18 +19,36 @@ namespace "test" do
     require 'ci/reporter/rake/rspec_loader'
   end
 
+  def core_specs
+    # note that regardless if which logstash-core-event-* gem is live, we will always run the
+    # logstash-core-event specs since currently this is the most complete Event and Timestamp specs
+    # which actually defines the Event contract and should pass regardless of the actuall underlying
+    # implementation.
+    specs = ["spec/**/*_spec.rb", "logstash-core/spec/**/*_spec.rb", "logstash-core-event/spec/**/*_spec.rb"]
+
+    # figure if the logstash-core-event-java gem is loaded and if so add its specific specs in the core specs to run
+    begin
+      require "logstash-core-event-java/version"
+      specs << "logstash-core-event-java/spec/**/*_spec.rb"
+    rescue LoadError
+      # logstash-core-event-java gem is not live, ignore and skip specs
+    end
+
+    Rake::FileList[*specs]
+  end
+
   desc "run core specs"
   task "core" => ["setup"] do
-    exit(RSpec::Core::Runner.run([Rake::FileList["spec/**/*_spec.rb"]]))
+    exit(RSpec::Core::Runner.run([core_specs]))
   end
 
   desc "run core specs in fail-fast mode"
   task "core-fail-fast" => ["setup"] do
-    exit(RSpec::Core::Runner.run(["--fail-fast", Rake::FileList["spec/**/*_spec.rb"]]))
+    exit(RSpec::Core::Runner.run(["--fail-fast", core_specs]))
   end
 
   desc "run core specs on a single file"
-  task "core-single-file", [:specfile] => ["setup"] do |t,args|
+  task "core-single-file", [:specfile] => ["setup"] do |t, args|
     exit(RSpec::Core::Runner.run([Rake::FileList[args.specfile]]))
   end
 
diff --git a/require-analyze.rb b/require-analyze.rb
deleted file mode 100644
index f69d858aa45..00000000000
--- a/require-analyze.rb
+++ /dev/null
@@ -1,22 +0,0 @@
-require "csv"
-
-#0.003,psych/nodes/mapping,/Users/jls/.rvm/rubies/jruby-1.7.8/lib/ruby/shared/psych/nodes.rb:6:in `(root)'
-
-durations = {}
-durations.default = 0
-
-CSV.foreach(ARGV[0]) do |duration, path, source|
-  source, line, where = source.split(":")
-  #{"0.002"=>"/Users/jls/projects/logstash/vendor/bundle/jruby/1.9/gems/clamp-0.6.3/lib/clamp.rb"}
-  if source.include?("jruby/1.9/gems")
-    # Get the gem name
-    source = source.gsub(/.*\/jruby\/1.9\/gems/, "")[/[^\/]+/]
-  elsif source.include?("/lib/logstash/")
-    source = source.gsub(/^.*(\/lib\/logstash\/)/, "/lib/logstash/")
-  end
-  durations[source] += duration.to_f
-end
-
-durations.sort_by { |k,v| v }.each do |k,v| 
-  puts "#{v} #{k}"
-end
diff --git a/spec/lib/logstash/bundler_spec.rb b/spec/bootstrap/bundler_spec.rb
similarity index 100%
rename from spec/lib/logstash/bundler_spec.rb
rename to spec/bootstrap/bundler_spec.rb
diff --git a/spec/util/gemfile_spec.rb b/spec/pluginmanager/gemfile_spec.rb
similarity index 100%
rename from spec/util/gemfile_spec.rb
rename to spec/pluginmanager/gemfile_spec.rb
