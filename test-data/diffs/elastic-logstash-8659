diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java
index b211d294c6f..0576a1714eb 100644
--- a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java
@@ -7,11 +7,11 @@
  */
 public class SecretStoreException extends RuntimeException {
 
-    public SecretStoreException(String message, Throwable cause) {
+    private SecretStoreException(String message, Throwable cause) {
         super(message, cause);
     }
 
-    public SecretStoreException(String message) {
+    private SecretStoreException(String message) {
         super(message);
     }
 
@@ -41,6 +41,15 @@ static public class CreateException extends SecretStoreException {
         public CreateException(String message, Throwable cause) {
             super(message, cause);
         }
+        public CreateException(String message) {
+            super(message);
+        }
+    }
+
+    static public class LoadException extends SecretStoreException {
+        public LoadException(String message, Throwable cause) {
+            super(message, cause);
+        }
     }
 
     static public class PersistException extends SecretStoreException {
@@ -55,9 +64,27 @@ public PurgeException(SecretIdentifier secretIdentifier, Throwable cause) {
         }
     }
 
+    static public class UnknownException extends SecretStoreException {
+        public UnknownException(String message, Throwable cause) {
+            super(message, cause);
+        }
+    }
+
+    static public class ImplementationNotFoundException extends SecretStoreException {
+        public ImplementationNotFoundException(String message, Throwable throwable) {
+            super(message, throwable);
+        }
+    }
+
     static public class AccessException extends SecretStoreException {
         public AccessException(String message, Throwable throwable) {
             super(message, throwable);
         }
+
+        public AccessException(String message) {
+            super(message);
+        }
     }
+
+
 }
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreFactory.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreFactory.java
new file mode 100644
index 00000000000..c1ffdbb0c55
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreFactory.java
@@ -0,0 +1,73 @@
+package org.logstash.secret.store;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.logstash.secret.SecretIdentifier;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+/**
+ * <p>A factory to load the implementation of a {@link SecretStore}. Where the implementation requires a constructor that accepts a {@link SecureConfig} as it's only parameter.
+ * </p>
+ */
+public class SecretStoreFactory {
+
+    public static final String KEYSTORE_ACCESS_KEY = "keystore.pass";
+    //secret stores should create a secret with this as the key and value to identify a logstash secret
+    public final static SecretIdentifier LOGSTASH_MARKER = new SecretIdentifier("logstash-secret-store");
+
+    public final static String ENVIRONMENT_PASS_KEY = "LOGSTASH_SECRET_STORE_PASS";
+
+    /**
+     * Private constructor
+     */
+    private SecretStoreFactory() {
+    }
+
+    private static final Logger LOGGER = LogManager.getLogger(SecretStoreFactory.class);
+
+    /**
+     * Creates a {@link SecretStore} based on the provided configuration
+     *
+     * @param secureConfig The configuration to pass to the implementation
+     * @return
+     */
+    @SuppressWarnings({"unchecked", "JavaReflectionMemberAccess"})
+    static public SecretStore loadSecretStore(SecureConfig secureConfig) {
+        //cheap SPI, if we ever support more then one implementation we should expose it as a setting and push the class name here via the secureConfig
+        String className = System.getProperty("org.logstash.secret.store.SecretStore", "org.logstash.secret.store.backend.JavaKeyStore");
+        try {
+            LOGGER.debug("Attempting to loadSecretStore secret store with implementation: {}", className);
+            Class<? extends SecretStore> implementation = (Class<? extends SecretStore>) Class.forName(className);
+            Constructor<? extends SecretStore> constructor = implementation.getConstructor(SecureConfig.class);
+            addSecretStoreAccess(secureConfig);
+            return constructor.newInstance(secureConfig);
+        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException e) {
+            throw new SecretStoreException.ImplementationNotFoundException(
+                    String.format("Could not loadSecretStore class %s, please ensure it is on the Java classpath, implements org.logstash.secret.store.SecretStore, and has a 1 " +
+                            "argument constructor that accepts a org.logstash.secret.store.SecureConfig", className), e);
+        } catch (InvocationTargetException ite) {
+            //this is thrown if an exception is thrown from the constructor
+            throw new SecretStoreException.LoadException("Unable to load Logstash secret store", ite);
+        }
+    }
+
+    /**
+     * <p>Adds the credential to the {@link SecureConfig} that is needed to access the {@link SecretStore}. Value read from environment variable "LOGSTASH_KEYSTORE_PASS"</p>
+     *
+     * @param secureConfig The configuration to add the secret store access
+     */
+    private static void addSecretStoreAccess(SecureConfig secureConfig) {
+        String environment = System.getenv(ENVIRONMENT_PASS_KEY);
+
+        char[] pass = null;
+        if (environment != null) {
+            secureConfig.add(KEYSTORE_ACCESS_KEY, environment.toCharArray());
+            environment = null;
+        }
+
+        //futile attempt to remove the original pass from memory
+        System.gc();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreUtil.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreUtil.java
index 9a8acc938b7..85639af0a4e 100644
--- a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreUtil.java
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreUtil.java
@@ -1,7 +1,9 @@
 package org.logstash.secret.store;
 
+import java.nio.ByteBuffer;
 import java.util.Arrays;
 import java.util.Base64;
+import java.util.Random;
 
 /**
  * Conversion utility between String, bytes, and chars. All methods attempt to keep sensitive data out of memory. Sensitive data should avoid using Java {@link String}'s.
@@ -14,6 +16,8 @@ final public class SecretStoreUtil {
     private SecretStoreUtil() {
     }
 
+    private static final Random RANDOM = new Random();
+
     /**
      * Converts bytes from ascii encoded text to a char[] and zero outs the original byte[]
      *
@@ -56,6 +60,16 @@ public static byte[] base64Encode(byte[] b) {
         return bytes;
     }
 
+    /**
+     * Base64 encode the given byte[], then zero out the original byte[]
+     *
+     * @param bytes the byte[] to base64 encode
+     * @return the char[] representation of the base64 encoding
+     */
+    public static char[] base64EncodeToChars(byte[] bytes) {
+        return asciiBytesToChar(base64Encode(bytes));
+    }
+
     /**
      * Base64 encode the given char[], then zero out the original char[]
      *
@@ -88,6 +102,15 @@ public static byte[] base64Decode(char[] chars) {
         return base64Decode(asciiCharToBytes(chars));
     }
 
+    /**
+     * Attempt to keep data out of the heap.
+     *
+     * @param chars the bytes to zero out
+     */
+    public static void clearChars(char[] chars) {
+        Arrays.fill(chars, '\0');
+    }
+
     /**
      * Attempt to keep data out of the heap.
      *
@@ -96,4 +119,45 @@ public static byte[] base64Decode(char[] chars) {
     public static void clearBytes(byte[] bytes) {
         Arrays.fill(bytes, (byte) '\0');
     }
+
+
+    /**
+     * De-obfuscates the obfuscated char[] generated by {@link SecretStoreUtil#obfuscate(char[])}
+     *
+     * @param chars The chars to de-obscure
+     * @return the de-obscured chars
+     */
+    public static char[] deObfuscate(char[] chars) {
+        byte[] bytes = asciiCharToBytes(chars);
+        byte[] random = Arrays.copyOfRange(bytes, bytes.length / 2, bytes.length);
+        byte[] deObfuscated = new byte[random.length];
+        for (int i = 0; i < random.length; i++) {
+            int xor = bytes[i] ^ random[i];
+            deObfuscated[i] = ((byte) (xor & 0xff));
+        }
+        return asciiBytesToChar(deObfuscated);
+    }
+
+    /**
+     * <p>Simple obfuscation that adds a bit of randomness and shuffles the bits of a char[].</p>
+     * <p>Note - this is NOT security and will only deter the lazy.</p>
+     *
+     * @param chars The chars to obscure
+     * @return the obscured bytes
+     */
+    public static char[] obfuscate(char[] chars) {
+        byte[] bytes = asciiCharToBytes(chars);
+        byte[] random = new byte[bytes.length];
+        RANDOM.nextBytes(random);
+
+        ByteBuffer obfuscated = ByteBuffer.allocate(bytes.length * 2);
+        for (int i = 0; i < bytes.length; i++) {
+            int xor = bytes[i] ^ random[i];
+            obfuscated.put((byte) (0xff & xor));
+        }
+        obfuscated.put(random);
+        char[] result = asciiBytesToChar(obfuscated.array());
+        clearBytes(obfuscated.array());
+        return result;
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecureConfig.java b/logstash-core/src/main/java/org/logstash/secret/store/SecureConfig.java
new file mode 100644
index 00000000000..df5984d7186
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecureConfig.java
@@ -0,0 +1,78 @@
+package org.logstash.secret.store;
+
+import java.nio.CharBuffer;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * A String -> char[] container that holds a referenced char[] obfuscated in memory and allows for easy clearing all values from memory.
+ */
+public class SecureConfig {
+
+    private Map<String, CharBuffer> config = new ConcurrentHashMap<>();
+
+    //package private for testing
+    volatile boolean cleared;
+
+    /**
+     * adds a value to the secure config
+     *
+     * @param key   the reference to the configuration value
+     * @param value the configuration value
+     * @throws IllegalStateException if this configuration has been cleared
+     */
+    public void add(String key, char[] value) {
+        if(cleared){
+            throw new IllegalStateException("This configuration has been cleared and can not be re-used.");
+        }
+        config.put(key, CharBuffer.wrap(SecretStoreUtil.obfuscate(value)));
+    }
+
+    /**
+     * Zero outs all internally held char[]
+     */
+    public void clearValues() {
+        config.forEach((k, v) -> SecretStoreUtil.clearChars(v.array()));
+        cleared = true;
+    }
+
+    /**
+     * Creates a full clone of this object.
+     *
+     * @return a copy of this {@link SecureConfig}
+     * @throws IllegalStateException if this configuration has been cleared
+     */
+    public SecureConfig clone() {
+        if(cleared){
+            throw new IllegalStateException("This configuration has been cleared and can not be re-used.");
+        }
+        SecureConfig clone = new SecureConfig();
+        config.forEach((k, v) -> clone.add(k, SecretStoreUtil.deObfuscate(v.array().clone())));
+        return clone;
+    }
+
+    /**
+     * Retrieve the un-obfuscated value
+     *
+     * @param key the reference to the configuration value
+     * @return the un-obfuscated configuration value.
+     */
+    public char[] getPlainText(String key) {
+        if(cleared){
+            throw new IllegalStateException("This configuration has been cleared and can not be re-used.");
+        }
+        return config.get(key) == null ? null : SecretStoreUtil.deObfuscate(config.get(key).array().clone());
+    }
+
+    /**
+     * Determine if a value for this key exists. No guarantees if the value has been zero'ed (cleared) or not.
+     *
+     * @param key the reference to the configuration value.
+     * @return true if this key has ever been added, false otherwise
+     */
+    public boolean has(String key) {
+        return config.get(key) != null;
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java b/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java
index 82e6a9daf58..a032b5efc47 100644
--- a/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java
+++ b/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java
@@ -3,21 +3,19 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.logstash.secret.SecretIdentifier;
-import org.logstash.secret.store.SecretStore;
-import org.logstash.secret.store.SecretStoreException;
-import org.logstash.secret.store.SecretStoreUtil;
+import org.logstash.secret.store.*;
 
 import javax.crypto.SecretKey;
 import javax.crypto.SecretKeyFactory;
 import javax.crypto.spec.PBEKeySpec;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
+import java.io.*;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.channels.FileLock;
+import java.nio.channels.SeekableByteChannel;
+import java.nio.charset.CharsetEncoder;
 import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
-import java.nio.file.NoSuchFileException;
-import java.nio.file.Path;
-import java.nio.file.StandardOpenOption;
+import java.nio.file.*;
 import java.nio.file.attribute.PosixFileAttributeView;
 import java.nio.file.attribute.PosixFilePermissions;
 import java.security.KeyStore;
@@ -32,40 +30,48 @@
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
+import static org.logstash.secret.store.SecretStoreFactory.LOGSTASH_MARKER;
+
 /**
  * <p>Java Key Store implementation for the {@link SecretStore}.</p>
  * <p>Note this implementation should not be used for high volume or large datasets.</p>
  * <p>This class is threadsafe.</p>
  */
 public final class JavaKeyStore implements SecretStore {
-    public static final String LOGSTASH_MARKER = "logstash-key-store";
     private static final Logger LOGGER = LogManager.getLogger(JavaKeyStore.class);
     private static final String KEYSTORE_TYPE = "pkcs12";
+    private static final CharsetEncoder asciiEncoder = StandardCharsets.US_ASCII.newEncoder();
 
-    private final char[] keyStorePass;
-    private final Path keyStorePath;
+    private char[] keyStorePass;
+    private Path keyStorePath;
     private final ProtectionParameter protectionParameter;
     private final Lock readLock;
     private final Lock writeLock;
     private KeyStore keyStore;
+    private final SecureConfig config;
 
     /**
-     * Constructor - will create the keystore if it does not exist
+     * Constructor - will create the keystore if it does not exist.
      *
-     * @param keyStorePath The full path to the java keystore
-     * @param keyStorePass The password to the keystore
+     * @param config The configuration for this keystore <p>Requires "keystore.pass" and "keystore.path" in the configuration</p><p>WARNING! this constructor clears all values
+     *               from this configuration, meaning this config is NOT reusable after passed in here.</p>
      * @throws SecretStoreException if errors occur while trying to create or access the keystore
      */
-    public JavaKeyStore(Path keyStorePath, char[] keyStorePass) {
+    public JavaKeyStore(SecureConfig config) {
+        this.config = config;
         try {
-            this.keyStorePath = keyStorePath;
+            char[] path = config.getPlainText("keystore.path");
+            if (path == null) {
+                throw new IllegalArgumentException("Logstash keystore path must be defined");
+            }
+            this.keyStorePath = Paths.get(new String(path));
+            this.keyStorePass = getKeyStorePassword(keyStorePath.toFile().exists());
             this.keyStore = KeyStore.getInstance(KEYSTORE_TYPE);
-            this.keyStorePass = SecretStoreUtil.base64Encode(keyStorePass);
+
             ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
             readLock = readWriteLock.readLock();
             writeLock = readWriteLock.writeLock();
             this.protectionParameter = new PasswordProtection(this.keyStorePass);
-            SecretIdentifier logstashMarker = new SecretIdentifier(LOGSTASH_MARKER);
 
             try (final InputStream is = Files.newInputStream(keyStorePath)) {
                 try {
@@ -80,7 +86,7 @@ public JavaKeyStore(Path keyStorePath, char[] keyStorePass) {
                                 keyStorePath.toAbsolutePath().toString()), ioe);
                     }
                 }
-                byte[] marker = retrieveSecret(logstashMarker);
+                byte[] marker = retrieveSecret(LOGSTASH_MARKER);
                 if (marker == null) {
                     throw new SecretStoreException.NotLogstashKeyStore(String.format("Found a keystore at %s, but it is not a Logstash keystore.",
                             keyStorePath.toAbsolutePath().toString()));
@@ -92,13 +98,13 @@ public JavaKeyStore(Path keyStorePath, char[] keyStorePass) {
                 String keyStorePermissions = System.getProperty("logstash.keystore.file.perms", "rw-rw----");
                 //create the keystore on disk with a default entry to identify this as a logstash keystore
                 Files.createFile(keyStorePath, PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(keyStorePermissions)));
-                try (final OutputStream os = Files.newOutputStream(keyStorePath, StandardOpenOption.WRITE)) {
+                try {
                     keyStore = KeyStore.Builder.newInstance(KEYSTORE_TYPE, null, protectionParameter).getKeyStore();
                     SecretKeyFactory factory = SecretKeyFactory.getInstance("PBE");
-                    byte[] base64 = SecretStoreUtil.base64Encode(LOGSTASH_MARKER.getBytes(StandardCharsets.UTF_8));
+                    byte[] base64 = SecretStoreUtil.base64Encode(LOGSTASH_MARKER.getKey().getBytes(StandardCharsets.UTF_8));
                     SecretKey secretKey = factory.generateSecret(new PBEKeySpec(SecretStoreUtil.asciiBytesToChar(base64)));
-                    keyStore.setEntry(logstashMarker.toExternalForm(), new KeyStore.SecretKeyEntry(secretKey), protectionParameter);
-                    keyStore.store(os, this.keyStorePass);
+                    keyStore.setEntry(LOGSTASH_MARKER.toExternalForm(), new KeyStore.SecretKeyEntry(secretKey), protectionParameter);
+                    saveKeyStore();
                     PosixFileAttributeView attrs = Files.getFileAttributeView(keyStorePath, PosixFileAttributeView.class);
                     if (attrs != null) {
                         //the directory umask applies when creating the file, so re-apply permissions here
@@ -112,8 +118,61 @@ public JavaKeyStore(Path keyStorePath, char[] keyStorePass) {
         } catch (SecretStoreException sse) {
             throw sse;
         } catch (Exception e) { //should never happen
-            throw new SecretStoreException("Error while trying to create or load the Logstash keystore", e);
+            throw new SecretStoreException.UnknownException("Error while trying to create or load the Logstash keystore", e);
+        } finally {
+            config.clearValues();
+        }
+    }
+
+    /**
+     * Obtains the keystore password depending on if the password is explicitly defined and/or if this is a new keystore.
+     *
+     * @param existing true if the keystore file already exists
+     * @return the char[] of the keystore password
+     * @throws IOException on io errors
+     */
+    private char[] getKeyStorePassword(boolean existing) throws IOException {
+        char[] plainText = config.getPlainText(SecretStoreFactory.KEYSTORE_ACCESS_KEY);
+
+        //ensure if a password is configured, that we don't allow empty passwords
+        if (config.has(SecretStoreFactory.KEYSTORE_ACCESS_KEY) && (plainText == null || plainText.length == 0)) {
+            String message = String.format("Empty keystore passwords are not allowed. Please ensure configured password is not empty for Logstash keystore %s.",
+                    keyStorePath.toAbsolutePath());
+            if (existing) {
+                throw new SecretStoreException.AccessException(message);
+            } else {
+                throw new SecretStoreException.CreateException(message);
+            }
+        }
+
+        if (plainText == null) {
+            if (existing) {
+                //read the pass
+                SeekableByteChannel byteChannel = Files.newByteChannel(keyStorePath, StandardOpenOption.READ);
+                if (byteChannel.size() > 1) {
+                    byteChannel.position(byteChannel.size() - 1);
+                    ByteBuffer byteBuffer = ByteBuffer.allocate(1);
+                    byteChannel.read(byteBuffer);
+                    int size = byteBuffer.array()[0] & 0xff;
+                    if (size > 0 && byteChannel.size() >= size + 1) {
+                        byteBuffer = ByteBuffer.allocate(size);
+                        byteChannel.position(byteChannel.size() - size - 1);
+                        byteChannel.read(byteBuffer);
+                        return SecretStoreUtil.deObfuscate(SecretStoreUtil.asciiBytesToChar(byteBuffer.array()));
+                    }
+                }
+            } else {
+                //create the pass
+                byte[] randomBytes = new byte[32];
+                new Random().nextBytes(randomBytes);
+                return SecretStoreUtil.base64EncodeToChars(randomBytes);
+            }
+        } else {
+            //keystore passwords require ascii encoding, only base64 encode if necessary
+            return asciiEncoder.canEncode(CharBuffer.wrap(plainText)) ? plainText : SecretStoreUtil.base64Encode(plainText);
         }
+        throw new SecretStoreException.AccessException(
+                String.format("Could not determine keystore password. Please ensure the file at %s is a valid Logstash keystore", keyStorePath.toAbsolutePath()));
     }
 
     @Override
@@ -121,7 +180,7 @@ public Collection<SecretIdentifier> list() {
         Set<SecretIdentifier> identifiers = new HashSet<>();
         try {
             readLock.lock();
-            reloadKeyStore();
+            loadKeyStore();
             Enumeration<String> aliases = keyStore.aliases();
             while (aliases.hasMoreElements()) {
                 String alias = aliases.nextElement();
@@ -139,15 +198,15 @@ public Collection<SecretIdentifier> list() {
     public void persistSecret(SecretIdentifier identifier, byte[] secret) {
         try {
             writeLock.lock();
-            reloadKeyStore();
+            loadKeyStore();
             SecretKeyFactory factory = SecretKeyFactory.getInstance("PBE");
             //PBEKey requires an ascii password, so base64 encode it
             byte[] base64 = SecretStoreUtil.base64Encode(secret);
             PBEKeySpec passwordBasedKeySpec = new PBEKeySpec(SecretStoreUtil.asciiBytesToChar(base64));
             SecretKey secretKey = factory.generateSecret(passwordBasedKeySpec);
             keyStore.setEntry(identifier.toExternalForm(), new KeyStore.SecretKeyEntry(secretKey), protectionParameter);
-            try (final OutputStream os = Files.newOutputStream(keyStorePath)) {
-                keyStore.store(os, keyStorePass);
+            try {
+                saveKeyStore();
             } finally {
                 passwordBasedKeySpec.clearPassword();
                 SecretStoreUtil.clearBytes(secret);
@@ -164,11 +223,9 @@ public void persistSecret(SecretIdentifier identifier, byte[] secret) {
     public void purgeSecret(SecretIdentifier identifier) {
         try {
             writeLock.lock();
-            reloadKeyStore();
+            loadKeyStore();
             keyStore.deleteEntry(identifier.toExternalForm());
-            try (final OutputStream os = Files.newOutputStream(keyStorePath)) {
-                keyStore.store(os, keyStorePass);
-            }
+            saveKeyStore();
             LOGGER.debug("purged secret {}", identifier.toExternalForm());
         } catch (Exception e) {
             throw new SecretStoreException.PurgeException(identifier, e);
@@ -182,7 +239,7 @@ public byte[] retrieveSecret(SecretIdentifier identifier) {
         if (identifier != null && identifier.getKey() != null && !identifier.getKey().isEmpty()) {
             try {
                 readLock.lock();
-                reloadKeyStore();
+                loadKeyStore();
                 SecretKeyFactory factory = SecretKeyFactory.getInstance("PBE");
                 KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore.getEntry(identifier.toExternalForm(), protectionParameter);
                 //not found
@@ -209,10 +266,41 @@ public byte[] retrieveSecret(SecretIdentifier identifier) {
     /**
      * Need to reload the keystore before any operations in case an external (or different JVM)  has modified the keystore on disk.
      */
-    private void reloadKeyStore() throws CertificateException, NoSuchAlgorithmException, IOException {
+    private void loadKeyStore() throws CertificateException, NoSuchAlgorithmException, IOException {
         try (final InputStream is = Files.newInputStream(keyStorePath)) {
             keyStore.load(is, keyStorePass);
         }
     }
+
+    /**
+     * Saves the keystore with some extra meta data if needed. Note - need two output streams here to allow checking the with the append flag, and the other without an append.
+     */
+    private void saveKeyStore() throws IOException, CertificateException, NoSuchAlgorithmException, KeyStoreException {
+        FileLock fileLock = null;
+        try (final FileOutputStream appendOs = new FileOutputStream(keyStorePath.toFile(), true)) {
+            fileLock = appendOs.getChannel().tryLock();
+            if (fileLock == null) {
+                throw new IllegalStateException("Can not save Logstash keystore. Some other process has a lock on the file: " + keyStorePath.toAbsolutePath());
+            }
+            try (final OutputStream os = Files.newOutputStream(keyStorePath, StandardOpenOption.WRITE)) {
+                keyStore.store(os, keyStorePass);
+                if (!config.has(SecretStoreFactory.KEYSTORE_ACCESS_KEY)) {
+                    byte[] obfuscatedPass = SecretStoreUtil.asciiCharToBytes(SecretStoreUtil.obfuscate(keyStorePass.clone()));
+                    DataOutputStream dataOutputStream = new DataOutputStream(os);
+                    os.write(obfuscatedPass);
+                    dataOutputStream.write(obfuscatedPass.length); // 1 byte integer
+                }
+            } finally {
+                if (fileLock != null) {
+                    fileLock.release();
+                }
+            }
+        }
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        SecretStoreUtil.clearChars(keyStorePass);
+    }
 }
 
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreFactoryTest.java b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreFactoryTest.java
new file mode 100644
index 00000000000..249cc6163b2
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreFactoryTest.java
@@ -0,0 +1,194 @@
+package org.logstash.secret.store;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TemporaryFolder;
+import org.logstash.secret.SecretIdentifier;
+import org.logstash.secret.store.backend.JavaKeyStore;
+
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.*;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.logstash.secret.store.SecretStoreFactory.*;
+
+/**
+ * Unit tests for {@link SecretStoreFactory}
+ */
+public class SecretStoreFactoryTest {
+
+    @Rule
+    public TemporaryFolder folder = new TemporaryFolder();
+
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+
+    //exact copy from https://stackoverflow.com/questions/318239/how-do-i-set-environment-variables-from-java
+    //thanks @pushy and @Edward Campbell !
+    @SuppressWarnings("unchecked")
+    private static void setEnv(Map<String, String> newenv) throws Exception {
+        try {
+            Class<?> processEnvironmentClass = Class.forName("java.lang.ProcessEnvironment");
+            Field theEnvironmentField = processEnvironmentClass.getDeclaredField("theEnvironment");
+            theEnvironmentField.setAccessible(true);
+            Map<String, String> env = (Map<String, String>) theEnvironmentField.get(null);
+            env.putAll(newenv);
+            Field theCaseInsensitiveEnvironmentField = processEnvironmentClass.getDeclaredField("theCaseInsensitiveEnvironment");
+            theCaseInsensitiveEnvironmentField.setAccessible(true);
+            Map<String, String> cienv = (Map<String, String>) theCaseInsensitiveEnvironmentField.get(null);
+            cienv.putAll(newenv);
+        } catch (NoSuchFieldException e) {
+            Class[] classes = Collections.class.getDeclaredClasses();
+            Map<String, String> env = System.getenv();
+            for (Class cl : classes) {
+                if ("java.util.Collections$UnmodifiableMap".equals(cl.getName())) {
+                    Field field = cl.getDeclaredField("m");
+                    field.setAccessible(true);
+                    Object obj = field.get(env);
+                    Map<String, String> map = (Map<String, String>) obj;
+                    map.clear();
+                    map.putAll(newenv);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testAlternativeImplementation(){
+        String beforeSystem = System.getProperty(SecretStore.class.getCanonicalName());
+        try {
+            System.setProperty(SecretStore.class.getCanonicalName(), "org.logstash.secret.store.SecretStoreFactoryTest$MemoryStore");
+            SecretStore secretStore = SecretStoreFactory.loadSecretStore(new SecureConfig());
+            assertThat(secretStore).isInstanceOf(MemoryStore.class);
+            validateMarker(secretStore);
+        } finally {
+            if (beforeSystem == null) {
+                System.clearProperty(SecretStore.class.getCanonicalName());
+            } else {
+                System.setProperty(SecretStore.class.getCanonicalName(), beforeSystem);
+            }
+        }
+    }
+
+    @Test
+    public void testAlternativeImplementationInvalid(){
+        thrown.expect(SecretStoreException.ImplementationNotFoundException.class);
+        String beforeSystem = System.getProperty(SecretStore.class.getCanonicalName());
+        try {
+            System.setProperty(SecretStore.class.getCanonicalName(), "junk");
+            SecretStoreFactory.loadSecretStore(new SecureConfig());
+        } finally {
+            if (beforeSystem == null) {
+                System.clearProperty(SecretStore.class.getCanonicalName());
+            } else {
+                System.setProperty(SecretStore.class.getCanonicalName(), beforeSystem);
+            }
+        }
+    }
+
+    @Test
+    public void testDefaultLoad() throws IOException {
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.path", folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray());
+        SecretStore secretStore = SecretStoreFactory.loadSecretStore(secureConfig);
+
+        byte[] marker = secretStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+    }
+
+    @Test
+    public void testDefaultLoadWithEnvPass() throws Exception {
+        Map<String, String> beforeEnvironment = System.getenv();
+        try {
+
+            String pass = UUID.randomUUID().toString();
+            setEnv(new HashMap<String, String>() {{
+                put(ENVIRONMENT_PASS_KEY, pass);
+            }});
+
+            //Each usage of the secure config requires it's own instance since implementations can/should clear all the values once used.
+            SecureConfig secureConfig1 = new SecureConfig();
+            secureConfig1.add("keystore.path", folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray());
+            SecureConfig secureConfig2 = secureConfig1.clone();
+            SecureConfig secureConfig3 = secureConfig1.clone();
+            SecureConfig secureConfig4 = secureConfig1.clone();
+
+            //ensure that with only the environment we can retrieve the marker from the store
+            SecretStore secretStore = SecretStoreFactory.loadSecretStore(secureConfig1);
+            validateMarker(secretStore);
+
+            //ensure that aren't simply using the defaults
+            boolean expectedException = false;
+            try {
+                new JavaKeyStore(secureConfig2);
+            } catch (SecretStoreException e) {
+                expectedException = true;
+            }
+            assertThat(expectedException).isTrue();
+
+            //ensure that direct key access using the system key wil work
+            secureConfig3.add(KEYSTORE_ACCESS_KEY, pass.toCharArray());
+            secretStore = new JavaKeyStore(secureConfig3);
+            validateMarker(secretStore);
+
+            //ensure that pass will work again
+            secretStore = SecretStoreFactory.loadSecretStore(secureConfig4);
+            validateMarker(secretStore);
+
+        } finally {
+            setEnv(new HashMap<>(beforeEnvironment));
+        }
+    }
+
+    /**
+     * Ensures that load failure is the correct type.
+     */
+    @Test
+    public void testErrorLoading() {
+        thrown.expect(SecretStoreException.LoadException.class);
+        //default implementation requires a path
+        SecretStoreFactory.loadSecretStore(new SecureConfig());
+    }
+
+    private void validateMarker(SecretStore secretStore) {
+        byte[] marker = secretStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+    }
+
+    /**
+     * Valid alternate implementation
+     */
+    static class MemoryStore implements SecretStore {
+
+        Map<SecretIdentifier, ByteBuffer> secrets = new HashMap(1);
+
+        public MemoryStore(SecureConfig secureConfig){
+            persistSecret(LOGSTASH_MARKER, LOGSTASH_MARKER.getKey().getBytes(StandardCharsets.UTF_8));
+        }
+
+        @Override
+        public Collection<SecretIdentifier> list() {
+            return secrets.keySet();
+        }
+
+        @Override
+        public void persistSecret(SecretIdentifier id, byte[] secret) {
+            secrets.put(id, ByteBuffer.wrap(secret));
+        }
+
+        @Override
+        public void purgeSecret(SecretIdentifier id) {
+            secrets.remove(id);
+        }
+
+        @Override
+        public byte[] retrieveSecret(SecretIdentifier id) {
+            return secrets.get(id).array();
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreUtilTest.java b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreUtilTest.java
index 964f249e803..48a472f7c85 100644
--- a/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreUtilTest.java
+++ b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreUtilTest.java
@@ -14,8 +14,9 @@
 public class SecretStoreUtilTest {
 
     private String asciiString;
+
     @Before
-    public void setup(){
+    public void _setup() {
         asciiString = UUID.randomUUID().toString();
     }
 
@@ -28,7 +29,7 @@ public void testAsciiBytesToChar() {
     }
 
     @Test
-    public void testAsciiCharToBytes(){
+    public void testAsciiCharToBytes() {
         char[] asciiChars = asciiString.toCharArray();
         byte[] asciiBytes = SecretStoreUtil.asciiCharToBytes(asciiChars);
         assertThat(asciiBytes).isEqualTo(asciiString.getBytes(StandardCharsets.US_ASCII));
@@ -36,7 +37,7 @@ public void testAsciiCharToBytes(){
     }
 
     @Test
-    public void testBase64EncodeBytes(){
+    public void testBase64EncodeBytes() {
         byte[] asciiBytes = asciiString.getBytes(StandardCharsets.US_ASCII);
         byte[] base64Bytes = SecretStoreUtil.base64Encode(asciiBytes);
         assertThat(asciiBytes).containsOnly('\0');
@@ -46,7 +47,17 @@ public void testBase64EncodeBytes(){
     }
 
     @Test
-    public void testBase64EncodeChars(){
+    public void testBase64EncodeBytesToChars() {
+        byte[] asciiBytes = asciiString.getBytes(StandardCharsets.US_ASCII);
+        char[] base64Chars = SecretStoreUtil.base64EncodeToChars(asciiBytes);
+        assertThat(asciiBytes).containsOnly('\0');
+        asciiBytes = SecretStoreUtil.base64Decode(base64Chars);
+        assertThat(base64Chars).containsOnly('\0');
+        assertThat(asciiBytes).isEqualTo(asciiString.getBytes(StandardCharsets.US_ASCII));
+    }
+
+    @Test
+    public void testBase64EncodeChars() {
         char[] asciiChars = asciiString.toCharArray();
         char[] base64Chars = SecretStoreUtil.base64Encode(asciiChars);
         assertThat(asciiChars).containsOnly('\0');
@@ -54,4 +65,19 @@ public void testBase64EncodeChars(){
         assertThat(base64Chars).containsOnly('\0');
         assertThat(asciiBytes).isEqualTo(asciiString.getBytes(StandardCharsets.US_ASCII));
     }
+
+    @Test
+    public void testClear() {
+        byte[] asciiBytes = asciiString.getBytes(StandardCharsets.US_ASCII);
+        char[] base64Chars = SecretStoreUtil.base64EncodeToChars(asciiBytes);
+        SecretStoreUtil.clearChars(base64Chars);
+        assertThat(base64Chars).containsOnly('\0');
+    }
+
+    @Test
+    public void testObfuscate() {
+        String original = UUID.randomUUID().toString();
+        assertThat(SecretStoreUtil.deObfuscate(SecretStoreUtil.obfuscate(original.toCharArray()))).isEqualTo(original.toCharArray());
+    }
+
 }
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/SecureConfigTest.java b/logstash-core/src/test/java/org/logstash/secret/store/SecureConfigTest.java
new file mode 100644
index 00000000000..72c4758bd60
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/store/SecureConfigTest.java
@@ -0,0 +1,60 @@
+package org.logstash.secret.store;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.IntStream;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Unit tests for {@link SecureConfig}
+ */
+public class SecureConfigTest {
+
+    private SecureConfig secureConfig;
+
+    @Before
+    public void _setup() {
+        secureConfig = new SecureConfig();
+    }
+
+    @Test
+    public void test() throws Exception {
+        Set<String> expected = new HashSet(100);
+        IntStream.range(0, 100).forEach(i -> expected.add(UUID.randomUUID().toString()));
+        expected.forEach(s -> secureConfig.add(s, s.toCharArray()));
+        expected.forEach(s -> assertThat(secureConfig.getPlainText(s)).isEqualTo(s.toCharArray()));
+        expected.forEach(s -> assertThat(secureConfig.has(s)));
+        SecureConfig clone = secureConfig.clone();
+        expected.forEach(s -> assertThat(clone.getPlainText(s)).isEqualTo(s.toCharArray()));
+        expected.forEach(s -> assertThat(clone.has(s)));
+        secureConfig.clearValues();
+        //manually reset cleared flag to allow the assertions
+        secureConfig.cleared = false;
+        expected.forEach(s -> assertThat(secureConfig.getPlainText(s)).containsOnly('\0'));
+        //clone is not zero'ed
+        expected.forEach(s -> assertThat(clone.getPlainText(s)).isEqualTo(s.toCharArray()));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testClearedAdd() {
+        secureConfig.clearValues();
+        secureConfig.add("foo", "bar".toCharArray());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testClearedClone() {
+        secureConfig.clearValues();
+        secureConfig.clone();
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testClearedGet() {
+        secureConfig.clearValues();
+        secureConfig.getPlainText("foo");
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java b/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java
index 315e02cf89e..339bfe7d6b7 100644
--- a/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java
+++ b/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java
@@ -8,36 +8,133 @@
 import org.junit.rules.TemporaryFolder;
 import org.logstash.secret.SecretIdentifier;
 import org.logstash.secret.store.SecretStoreException;
+import org.logstash.secret.store.SecretStoreFactory;
+import org.logstash.secret.store.SecureConfig;
 
+import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.channels.FileLock;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
+import java.nio.file.NoSuchFileException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.attribute.PosixFileAttributeView;
 import java.nio.file.attribute.PosixFilePermission;
 import java.util.*;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
 import static java.nio.file.attribute.PosixFilePermission.*;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Fail.fail;
-import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.isA;
+import static org.logstash.secret.store.SecretStoreFactory.LOGSTASH_MARKER;
 
 /**
  * Unit tests for the {@link JavaKeyStore}
  */
 public class JavaKeyStoreTest {
 
+    private final static String EXTERNAL_TEST_FILE_LOCK = "test_file_lock";
+    private final static String EXTERNAL_TEST_WRITE = "test_external_write";
     @Rule
     public TemporaryFolder folder = new TemporaryFolder();
-
     @Rule
     public ExpectedException thrown = ExpectedException.none();
     private JavaKeyStore keyStore;
-    private char[] keyStorePass;
-    private Path keyStorePath;
+    private char[] keyStorePath;
+    private SecureConfig withDefaultPassConfig;
+    private SecureConfig withDefinedPassConfig;
+
+    /**
+     * Launch a second JVM with the expected args
+     * <ul>
+     * <li>arg[0] - the descriptor to identify which test this is for</li>
+     * <li>arg[1] - path to file to write as marker that the second JVM is ready to be tested</li>
+     * <li>arg[2..n] - any additional information needed for the test</li>
+     * </ul>
+     *
+     * @param args the args as described
+     * @throws IOException when i/o exceptions happen
+     */
+    public static void main(String... args) throws IOException, InterruptedException {
+
+        Path magicFile = Paths.get(args[1]);
+
+        //Use a second JVM to lock the keystore for 2 seconds
+        if (EXTERNAL_TEST_FILE_LOCK.equals(args[0])) {
+            Path keystoreFile = Paths.get(args[2]);
+            FileLock fileLock = null;
+            try (final FileOutputStream keystore = new FileOutputStream(keystoreFile.toFile(), true)) {
+                fileLock = keystore.getChannel().tryLock();
+                assertThat(fileLock).isNotNull();
+                //write the magic file to let the other process know the test is ready
+                try (final OutputStream os = Files.newOutputStream(magicFile)) {
+                    os.write(args[0].getBytes(StandardCharsets.UTF_8));
+                    Thread.sleep(2000);
+                } finally {
+                    Files.delete(magicFile);
+                }
+            } finally {
+                if (fileLock != null) {
+                    fileLock.release();
+                }
+            }
+        } else if (EXTERNAL_TEST_WRITE.equals(args[0])) {
+            Path keyStoreFile = Paths.get(args[2]);
+            SecureConfig config = new SecureConfig();
+            config.add("keystore.path", keyStoreFile.toAbsolutePath().toString().toCharArray());
+            JavaKeyStore keyStore = new JavaKeyStore(config);
+            writeAtoZ(keyStore);
+            validateAtoZ(keyStore);
+            //write the magic file to let the other process know the test is ready
+            try (final OutputStream os = Files.newOutputStream(magicFile)) {
+                os.write(args[0].getBytes(StandardCharsets.UTF_8));
+            } finally {
+                Files.delete(magicFile);
+            }
+        }
+    }
+
+    private static void validateAtoZ(JavaKeyStore keyStore) {
+        //contents of the existing is a-z for both the key and value
+        for (int i = 65; i <= 90; i++) {
+            byte[] expected = new byte[]{(byte) i};
+            SecretIdentifier id = new SecretIdentifier(new String(expected, StandardCharsets.UTF_8));
+            assertThat(keyStore.retrieveSecret(id)).isEqualTo(expected);
+        }
+    }
+
+    private static void writeAtoZ(JavaKeyStore keyStore) {
+        //a-z key and value
+        for (int i = 65; i <= 90; i++) {
+            byte[] expected = new byte[]{(byte) i};
+            SecretIdentifier id = new SecretIdentifier(new String(expected, StandardCharsets.UTF_8));
+            keyStore.persistSecret(id, expected);
+        }
+    }
+
+    @Before
+    public void _setup() throws Exception {
+        keyStorePath = folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray();
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.path", keyStorePath.clone());
+        keyStore = new JavaKeyStore(secureConfig);
+
+        withDefinedPassConfig = new SecureConfig();
+        withDefinedPassConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "mypassword".toCharArray());
+        withDefinedPassConfig.add("keystore.path",
+                Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore.with.defined.pass").toURI()).toString().toCharArray());
+
+        withDefaultPassConfig = new SecureConfig();
+        withDefaultPassConfig.add("keystore.path",
+                Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore.with.default.pass").toURI()).toString().toCharArray());
+    }
 
     /**
      * Simple example usage.
@@ -65,24 +162,44 @@ public void basicTest() {
     @Test
     public void isLogstashKeystore() throws Exception {
         //newly created
-        byte[] marker = keyStore.retrieveSecret(new SecretIdentifier(JavaKeyStore.LOGSTASH_MARKER));
-        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(JavaKeyStore.LOGSTASH_MARKER);
+        byte[] marker = keyStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
 
         //exiting
-        JavaKeyStore existingKeyStore = new JavaKeyStore(Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore").toURI()), "mypassword".toCharArray());
-        marker = existingKeyStore.retrieveSecret(new SecretIdentifier(JavaKeyStore.LOGSTASH_MARKER));
-        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(JavaKeyStore.LOGSTASH_MARKER);
+        JavaKeyStore existingKeyStore = new JavaKeyStore(withDefinedPassConfig);
+        marker = existingKeyStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
     }
 
     /**
-     * Tests that when the magic marker that identifies this a logstash keystore is not present the correct exception is thrown.
+     * Tests that trying to read a random file throws the right error.
      *
      * @throws Exception when ever it wants to.
      */
     @Test
     public void notLogstashKeystore() throws Exception {
         thrown.expect(SecretStoreException.NotLogstashKeyStore.class);
-        new JavaKeyStore(Paths.get(this.getClass().getClassLoader().getResource("not.a.logstash.keystore").toURI()), "mypassword".toCharArray());
+        SecureConfig altConfig = new SecureConfig();
+        Path altPath = folder.newFolder().toPath().resolve("alt.not.a.logstash.keystore");
+        try (OutputStream out = Files.newOutputStream(altPath)) {
+            byte[] randomBytes = new byte[300];
+            new Random().nextBytes(randomBytes);
+            out.write(randomBytes);
+        }
+        altConfig.add("keystore.path", altPath.toString().toCharArray());
+        new JavaKeyStore(altConfig);
+    }
+
+    /**
+     * Tests that when the magic marker that identifies this a logstash keystore is not present the correct exception is thrown.
+     *
+     * @throws Exception when ever it wants to.
+     */
+    @Test
+    public void notLogstashKeystoreNoMarker() throws Exception {
+        thrown.expect(SecretStoreException.NotLogstashKeyStore.class);
+        withDefinedPassConfig.add("keystore.path", Paths.get(this.getClass().getClassLoader().getResource("not.a.logstash.keystore").toURI()).toString().toCharArray().clone());
+        new JavaKeyStore(withDefinedPassConfig);
     }
 
     /**
@@ -119,46 +236,31 @@ public void purgeMissingSecret() {
      */
     @Test
     public void readExisting() throws Exception {
-        JavaKeyStore existingKeyStore = new JavaKeyStore(Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore").toURI()), "mypassword".toCharArray());
-        //contents of the existing is a-z for both the key and value
-        for (int i = 65; i <= 90; i++) {
-            byte[] expected = new byte[]{(byte) i};
-            SecretIdentifier id = new SecretIdentifier(new String(expected, StandardCharsets.UTF_8));
-            assertThat(existingKeyStore.retrieveSecret(id)).isEqualTo(expected);
-        }
+        //uses an explicit password
+        validateAtoZ(new JavaKeyStore(this.withDefinedPassConfig));
+
+        //uses an implicit password
+        validateAtoZ(new JavaKeyStore(this.withDefaultPassConfig));
     }
 
     /**
      * Comprehensive tests that uses a freshly created keystore to write 26 entries, list them, read them, and delete them.
      */
     @Test
-    public void readWriteListDelete() {
-        Set<String> values = new HashSet<>(27);
-        Set<SecretIdentifier> keys = new HashSet<>(27);
-        SecretIdentifier markerId = new SecretIdentifier(JavaKeyStore.LOGSTASH_MARKER);
-        //add the marker
-        keys.add(markerId);
-        values.add(JavaKeyStore.LOGSTASH_MARKER);
-        //a-z key and value
-        for (int i = 65; i <= 90; i++) {
-            byte[] expected = new byte[]{(byte) i};
-            values.add(new String(expected, StandardCharsets.UTF_8));
-            SecretIdentifier id = new SecretIdentifier(new String(expected, StandardCharsets.UTF_8));
-            keyStore.persistSecret(id, expected);
-            keys.add(id);
-        }
+    public void readWriteListDelete() throws InterruptedException {
+
+
+        writeAtoZ(keyStore);
         Collection<SecretIdentifier> foundIds = keyStore.list();
         assertThat(keyStore.list().size()).isEqualTo(26 + 1);
-        assertThat(values.size()).isEqualTo(26 + 1);
-        assertThat(keys.size()).isEqualTo(26 + 1);
 
-        foundIds.stream().forEach(id -> assertThat(keys).contains(id));
-        foundIds.stream().forEach(id -> assertThat(values).contains(new String(keyStore.retrieveSecret(id), StandardCharsets.UTF_8)));
+        validateAtoZ(keyStore);
 
-        foundIds.stream().filter(id -> !id.equals(markerId)).forEach(id -> keyStore.purgeSecret(id));
+
+        foundIds.stream().filter(id -> !id.equals(LOGSTASH_MARKER)).forEach(id -> keyStore.purgeSecret(id));
 
         assertThat(keyStore.list().size()).isEqualTo(1);
-        assertThat(keyStore.list().stream().findFirst().get()).isEqualTo(markerId);
+        assertThat(keyStore.list().stream().findFirst().get()).isEqualTo(LOGSTASH_MARKER);
     }
 
     /**
@@ -177,13 +279,6 @@ public void retrieveWithInvalidInput() {
         assertThat(keyStore.retrieveSecret(null)).isNull();
     }
 
-    @Before
-    public void setup() throws Exception {
-        keyStorePath = folder.newFolder().toPath().resolve("logstash.keystore");
-        keyStorePass = UUID.randomUUID().toString().toCharArray();
-        keyStore = new JavaKeyStore(keyStorePath, keyStorePass);
-    }
-
     /**
      * Test to ensure that keystore is tamper proof.  This really ends up testing the Java's KeyStore implementation, not the code here....but an important attribute to ensure
      * for any type of secret store.
@@ -192,15 +287,217 @@ public void setup() throws Exception {
      */
     @Test
     public void tamperedKeystore() throws Exception {
-
-        thrown.expect(SecretStoreException.NotLogstashKeyStore.class);
-        byte[] keyStoreAsBytes = Files.readAllBytes(keyStorePath);
+        thrown.expect(SecretStoreException.class);
+        byte[] keyStoreAsBytes = Files.readAllBytes(Paths.get(new String(keyStorePath)));
         //bump the middle byte by 1
         int tamperLocation = keyStoreAsBytes.length / 2;
         keyStoreAsBytes[tamperLocation] = (byte) (keyStoreAsBytes[tamperLocation] + 1);
         Path tamperedPath = folder.newFolder().toPath().resolve("tampered.logstash.keystore");
         Files.write(tamperedPath, keyStoreAsBytes);
-        new JavaKeyStore(tamperedPath, keyStorePass);
+        SecureConfig sc = new SecureConfig();
+        sc.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "mypassword".toCharArray());
+        sc.add("keystore.path", tamperedPath.toUri().toString().toCharArray());
+        new JavaKeyStore(sc);
+    }
+
+    /**
+     * The default permissions should be restrictive for Posix filesystems.
+     *
+     * @throws Exception when it goes boom.
+     */
+    @Test
+    public void testDefaultPermissions() throws Exception {
+        PosixFileAttributeView attrs = Files.getFileAttributeView(Paths.get(new String(keyStorePath)), PosixFileAttributeView.class);
+
+        boolean isWindows = System.getProperty("os.name").startsWith("Windows");
+        //not all Windows FS are Posix
+        if (!isWindows && attrs == null) {
+            fail("Can not determine POSIX file permissions for " + keyStore + " this is likely an error in the test");
+        }
+        // if we got attributes, lets assert them.
+        if (attrs != null) {
+            Set<PosixFilePermission> permissions = attrs.readAttributes().permissions();
+            EnumSet<PosixFilePermission> expected = EnumSet.of(OWNER_READ, OWNER_WRITE, GROUP_READ, GROUP_WRITE);
+            assertThat(permissions.toArray()).containsExactlyInAnyOrder(expected.toArray());
+        }
+    }
+
+    /**
+     * Empty passwords are not allowed
+     *
+     * @throws IOException when ever it wants to
+     */
+    @Test
+    public void testEmptyNotAllowedOnCreate() throws IOException {
+        thrown.expect(SecretStoreException.CreateException.class);
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig altConfig = new SecureConfig();
+        altConfig.add("keystore.path", altPath.toString().toCharArray());
+        altConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "".toCharArray());
+        new JavaKeyStore(altConfig);
+    }
+
+    /**
+     * Empty passwords should always throw an Access Exception
+     *
+     * @throws Exception when ever it wants to
+     */
+    @Test
+    public void testEmptyNotAllowedOnExisting() throws Exception {
+        thrown.expect(SecretStoreException.AccessException.class);
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig altConfig = new SecureConfig();
+        altConfig.add("keystore.path", altPath.toString().toCharArray());
+        SecureConfig altConfig2 = altConfig.clone();
+        altConfig2.add("keystore.path", altPath.toString().toCharArray());
+        altConfig2.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "".toCharArray());
+        new JavaKeyStore(altConfig);
+        new JavaKeyStore(altConfig2);
+    }
+
+    /**
+     * Simulates different JVMs modifying the keystore and ensure a consistent list view
+     *
+     * @throws IOException when it goes boom.
+     */
+    @Test
+    public void testExternalUpdateList() throws IOException {
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.path", altPath.toString().toCharArray());
+        JavaKeyStore keyStore1 = new JavaKeyStore(secureConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore(secureConfig);
+        String value = UUID.randomUUID().toString();
+        SecretIdentifier id = new SecretIdentifier(value);
+        //jvm1 persist, jvm2 list
+        keyStore1.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        assertThat(keyStore2.list().stream().map(k -> keyStore2.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8)).collect(Collectors.toSet())).contains(value);
+        //purge from jvm1
+        assertThat(new String(keyStore2.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
+        keyStore1.purgeSecret(id);
+        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value))).isNull();
+    }
+
+    /**
+     * Simulates different JVMs modifying the keystore and ensure a consistent view
+     *
+     * @throws IOException when it goes boom.
+     */
+    @Test
+    public void testExternalUpdatePersist() throws IOException {
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.path", altPath.toString().toCharArray());
+        JavaKeyStore keyStore1 = new JavaKeyStore(secureConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore(secureConfig);
+        String value1 = UUID.randomUUID().toString();
+        String value2 = UUID.randomUUID().toString();
+        SecretIdentifier id1 = new SecretIdentifier(value1);
+        SecretIdentifier id2 = new SecretIdentifier(value2);
+        //jvm1 persist id1, jvm2 persist id2
+        keyStore1.persistSecret(id1, value1.getBytes(StandardCharsets.UTF_8));
+        keyStore2.persistSecret(id2, value2.getBytes(StandardCharsets.UTF_8));
+        //both keystores should contain both values
+        assertThat(keyStore1.list().stream().map(k -> keyStore1.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8))
+                .collect(Collectors.toSet())).contains(value1, value2);
+        assertThat(keyStore2.list().stream().map(k -> keyStore2.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8))
+                .collect(Collectors.toSet())).contains(value1, value2);
+        //purge from jvm1
+        keyStore1.purgeSecret(id1);
+        keyStore1.purgeSecret(id2);
+        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value1))).isNull();
+        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value2))).isNull();
+        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value1))).isNull();
+        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value2))).isNull();
+    }
+
+    /**
+     * Simulates different JVMs modifying the keystore and ensure a consistent read view
+     *
+     * @throws IOException when it goes boom.
+     */
+    @Test
+    public void testExternalUpdateRead() throws IOException {
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.path", altPath.toString().toCharArray());
+        secureConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "mypass".toCharArray());
+        JavaKeyStore keyStore1 = new JavaKeyStore(secureConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore(secureConfig);
+        String value = UUID.randomUUID().toString();
+        SecretIdentifier id = new SecretIdentifier(value);
+        //jvm1 persist, jvm2 read
+        keyStore1.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        assertThat(new String(keyStore2.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
+        //purge from jvm2
+        assertThat(new String(keyStore1.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
+        keyStore2.purgeSecret(id);
+        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value))).isNull();
+    }
+
+    /**
+     * Spins up a second VM, locks the underlying keystore, asserts correct exception, once lock is released and now can write
+     *
+     * @throws Exception when exceptions happen
+     */
+    @Test
+    public void testFileLock() throws Exception {
+        Path magicFile = folder.newFolder().toPath().resolve(EXTERNAL_TEST_FILE_LOCK);
+
+        String java = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
+        ProcessBuilder builder = new ProcessBuilder(java, "-cp", System.getProperty("java.class.path"), getClass().getCanonicalName(),
+                EXTERNAL_TEST_FILE_LOCK, magicFile.toAbsolutePath().toString(), new String(keyStorePath));
+        Future<Integer> future = Executors.newScheduledThreadPool(1).submit(() -> builder.start().waitFor());
+
+        boolean passed = false;
+        while (!future.isDone()) {
+            try {
+                Files.readAllBytes(magicFile);
+            } catch (NoSuchFileException sfe) {
+                Thread.sleep(100);
+                continue;
+            }
+            try {
+                keyStore.persistSecret(new SecretIdentifier("foo"), "bar".getBytes(StandardCharsets.UTF_8));
+            } catch (SecretStoreException.PersistException e) {
+                assertThat(e.getCause()).isInstanceOf(IllegalStateException.class);
+                assertThat(e.getCause().getMessage()).contains("has a lock on the file");
+                passed = true;
+            }
+            break;
+        }
+        assertThat(passed).isTrue();
+
+        //can still read
+        byte[] marker = keyStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+
+        //block until other JVM finishes
+        future.get();
+        //can write/read now
+        SecretIdentifier id = new SecretIdentifier("foo2");
+        keyStore.persistSecret(id, "bar".getBytes(StandardCharsets.UTF_8));
+        assertThat(new String(keyStore.retrieveSecret(id), StandardCharsets.UTF_8)).isEqualTo("bar");
+    }
+
+    /**
+     * Simulates different JVMs can read using a default (non-provided) password
+     *
+     * @throws IOException when it goes boom.
+     */
+    @Test
+    public void testGeneratedSecret() throws IOException {
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig altConfig = new SecureConfig();
+        altConfig.add("keystore.path", altPath.toString().toCharArray());
+        //note - no password given here.
+        JavaKeyStore keyStore1 = new JavaKeyStore(altConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore(altConfig);
+        String value = UUID.randomUUID().toString();
+        SecretIdentifier id = new SecretIdentifier(value);
+        //jvm1 persist, jvm2 read
+        keyStore1.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        assertThat(new String(keyStore2.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
     }
 
     /**
@@ -227,6 +524,13 @@ public void testLargeKeysAndValues() {
         keyStore.purgeSecret(id);
     }
 
+    @Test
+    public void testNoPathDefined() {
+        thrown.expect(SecretStoreException.class);
+        thrown.expectCause(isA(IllegalArgumentException.class));
+        new JavaKeyStore(new SecureConfig());
+    }
+
     /**
      * Ensure that non-ascii keys and values are properly handled.
      *
@@ -236,30 +540,15 @@ public void testLargeKeysAndValues() {
     public void testNonAscii() throws Exception {
         int[] codepoints = {0xD83E, 0xDD21, 0xD83E, 0xDD84};
         String nonAscii = new String(codepoints, 0, codepoints.length);
-        SecretIdentifier id = new SecretIdentifier(nonAscii);
-        keyStore.persistSecret(id, nonAscii.getBytes(StandardCharsets.UTF_8));
-        assertThat(new String(keyStore.retrieveSecret(id), StandardCharsets.UTF_8)).isEqualTo(nonAscii);
-    }
 
-    /**
-     * The default permissions should be restrictive for Posix filesystems.
-     *
-     * @throws Exception when it goes boom.
-     */
-    @Test
-    public void testDefaultPermissions() throws Exception {
-        PosixFileAttributeView attrs = Files.getFileAttributeView(keyStorePath, PosixFileAttributeView.class);
-        boolean isWindows = System.getProperty("os.name").startsWith("Windows");
-        //not all Windows FS are Posix
-        if (!isWindows && attrs == null) {
-            fail("Can not determine POSIX file permissions for " + keyStore + " this is likely an error in the test");
-        }
-        // if we got attributes, lets assert them.
-        if (attrs != null) {
-            Set<PosixFilePermission> permissions = attrs.readAttributes().permissions();
-            EnumSet<PosixFilePermission> expected = EnumSet.of(OWNER_READ, OWNER_WRITE, GROUP_READ, GROUP_WRITE);
-            assertThat(permissions.toArray()).containsExactlyInAnyOrder(expected.toArray());
-        }
+        SecureConfig sc = new SecureConfig();
+        sc.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, nonAscii.toCharArray());
+        sc.add("keystore.path", (new String(keyStorePath) + ".nonAscii").toCharArray());
+        JavaKeyStore nonAsciiKeyStore = new JavaKeyStore(sc);
+
+        SecretIdentifier id = new SecretIdentifier(nonAscii);
+        nonAsciiKeyStore.persistSecret(id, nonAscii.getBytes(StandardCharsets.UTF_8));
+        assertThat(new String(nonAsciiKeyStore.retrieveSecret(id), StandardCharsets.UTF_8)).isEqualTo(nonAscii);
     }
 
     /**
@@ -273,7 +562,10 @@ public void testRestrictivePermissions() throws Exception {
         try {
             System.setProperty("logstash.keystore.file.perms", "rw-------");
             Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
-            keyStore = new JavaKeyStore(altPath, keyStorePass);
+            SecureConfig secureConfig = new SecureConfig();
+            secureConfig.add("keystore.path", altPath.toString().toCharArray());
+
+            keyStore = new JavaKeyStore(secureConfig);
             assertThat(altPath.toFile().exists()).isTrue();
             PosixFileAttributeView attrs = Files.getFileAttributeView(altPath, PosixFileAttributeView.class);
 
@@ -298,70 +590,32 @@ public void testRestrictivePermissions() throws Exception {
     }
 
     /**
-     * Simulates a different JVM modifying the keystore and ensure a consistent read view
+     * Spins up a second JVM, writes all the data, then read it from this JVM
+     *
+     * @throws Exception when exceptions happen
      */
     @Test
-    public void testExternalUpdateRead() throws IOException {
+    public void testWithRealSecondJvm() throws Exception {
+        Path magicFile = folder.newFolder().toPath().resolve(EXTERNAL_TEST_FILE_LOCK);
         Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
-        JavaKeyStore keyStore1 = new JavaKeyStore(altPath, "mypass".toCharArray());
-        JavaKeyStore keyStore2 = new JavaKeyStore(altPath, "mypass".toCharArray());
-        String value = UUID.randomUUID().toString();
-        SecretIdentifier id = new SecretIdentifier(value);
-        //jvm1 persist, jvm2 read
-        keyStore1.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
-        assertThat(new String(keyStore2.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
-        //purge from jvm2
-        assertThat(new String(keyStore1.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
-        keyStore2.purgeSecret(id);
-        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value))).isNull();
-    }
 
-    /**
-     * Simulates a different JVM modifying the keystore and ensure a consistent list view
-     */
-    @Test
-    public void testExternalUpdateList() throws IOException {
-        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
-        JavaKeyStore keyStore1 = new JavaKeyStore(altPath, "mypass".toCharArray());
-        JavaKeyStore keyStore2 = new JavaKeyStore(altPath, "mypass".toCharArray());
-        String value = UUID.randomUUID().toString();
-        SecretIdentifier id = new SecretIdentifier(value);
-        //jvm1 persist, jvm2 list
-        keyStore1.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
-        assertThat(keyStore2.list().stream().map(k -> keyStore2.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8)).collect(Collectors.toSet())).contains(value);
-        //purge from jvm1
-        assertThat(new String(keyStore2.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
-        keyStore1.purgeSecret(id);
-        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value))).isNull();
-    }
-
-    /**
-     * Simulates a different JVMs modifying the keystore and ensure a consistent view
-     */
-    @Test
-    public void testExternalUpdatePersist() throws IOException {
-        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
-        JavaKeyStore keyStore1 = new JavaKeyStore(altPath, "mypass".toCharArray());
-        JavaKeyStore keyStore2 = new JavaKeyStore(altPath, "mypass".toCharArray());
-        String value1 = UUID.randomUUID().toString();
-        String value2 = UUID.randomUUID().toString();
-        SecretIdentifier id1 = new SecretIdentifier(value1);
-        SecretIdentifier id2 = new SecretIdentifier(value2);
-        //jvm1 persist id1, jvm2 persist id2
-        keyStore1.persistSecret(id1, value1.getBytes(StandardCharsets.UTF_8));
-        keyStore2.persistSecret(id2, value2.getBytes(StandardCharsets.UTF_8));
-        //both keystores should contain both values
-        assertThat(keyStore1.list().stream().map(k -> keyStore1.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8))
-                .collect(Collectors.toSet())).contains(value1,  value2);
-        assertThat(keyStore2.list().stream().map(k -> keyStore2.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8))
-                .collect(Collectors.toSet())).contains(value1,  value2);
-        //purge from jvm1
-        keyStore1.purgeSecret(id1);
-        keyStore1.purgeSecret(id2);
-        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value1))).isNull();
-        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value2))).isNull();
-        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value1))).isNull();
-        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value2))).isNull();
+        String java = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
+        ProcessBuilder builder = new ProcessBuilder(java, "-cp", System.getProperty("java.class.path"), getClass().getCanonicalName(),
+                EXTERNAL_TEST_WRITE, magicFile.toAbsolutePath().toString(), altPath.toAbsolutePath().toString());
+        Future<Integer> future = Executors.newScheduledThreadPool(1).submit(() -> builder.start().waitFor());
+
+        while (!future.isDone()) {
+            try {
+                Files.readAllBytes(magicFile);
+            } catch (NoSuchFileException sfe) {
+                Thread.sleep(100);
+                continue;
+            }
+        }
+        SecureConfig config = new SecureConfig();
+        config.add("keystore.path", altPath.toAbsolutePath().toString().toCharArray());
+        JavaKeyStore keyStore = new JavaKeyStore(config);
+        validateAtoZ(keyStore);
     }
 
     /**
@@ -372,6 +626,9 @@ public void testExternalUpdatePersist() throws IOException {
     @Test
     public void wrongPassword() throws Exception {
         thrown.expect(SecretStoreException.AccessException.class);
-        new JavaKeyStore(Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore").toURI()), "wrongpassword".toCharArray());
+        withDefinedPassConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "wrongpassword".toCharArray());
+        new JavaKeyStore(withDefinedPassConfig);
     }
+
+
 }
\ No newline at end of file
diff --git a/logstash-core/src/test/resources/logstash.keystore b/logstash-core/src/test/resources/logstash.keystore
deleted file mode 100644
index ecf06032af1..00000000000
Binary files a/logstash-core/src/test/resources/logstash.keystore and /dev/null differ
diff --git a/logstash-core/src/test/resources/logstash.keystore.with.default.pass b/logstash-core/src/test/resources/logstash.keystore.with.default.pass
new file mode 100644
index 00000000000..b1064058956
Binary files /dev/null and b/logstash-core/src/test/resources/logstash.keystore.with.default.pass differ
diff --git a/logstash-core/src/test/resources/logstash.keystore.with.defined.pass b/logstash-core/src/test/resources/logstash.keystore.with.defined.pass
new file mode 100644
index 00000000000..a4b418be80f
Binary files /dev/null and b/logstash-core/src/test/resources/logstash.keystore.with.defined.pass differ
diff --git a/logstash-core/src/test/resources/not.a.logstash.keystore b/logstash-core/src/test/resources/not.a.logstash.keystore
index 195e18d7948..70ebb48bcf4 100644
Binary files a/logstash-core/src/test/resources/not.a.logstash.keystore and b/logstash-core/src/test/resources/not.a.logstash.keystore differ
