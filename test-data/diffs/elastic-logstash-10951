diff --git a/logstash-core/build.gradle b/logstash-core/build.gradle
index 13ddb05ff4a..125b623b07f 100644
--- a/logstash-core/build.gradle
+++ b/logstash-core/build.gradle
@@ -127,6 +127,9 @@ dependencies {
     compile 'org.apache.logging.log4j:log4j-api:2.11.1'
     compile 'org.apache.logging.log4j:log4j-core:2.11.1'
     runtime 'org.apache.logging.log4j:log4j-slf4j-impl:2.11.1'
+    compile('org.reflections:reflections:0.9.11') {
+        exclude group: 'com.google.guava', module: 'guava'
+    }
     compile 'commons-codec:commons-codec:1.11'
     // Jackson version moved to versions.yml in the project root (the JrJackson version is there too)
     compile "com.fasterxml.jackson.core:jackson-core:${jacksonVersion}"
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/AbstractScanner.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/AbstractScanner.java
deleted file mode 100644
index 088e8670016..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/AbstractScanner.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
-import com.google.common.collect.Multimap;
-
-/**
- *
- */
-@SuppressWarnings({"RawUseOfParameterizedType", "unchecked"})
-public abstract class AbstractScanner implements Scanner {
-
-    private Configuration configuration;
-    private Multimap<String, String> store;
-    private Predicate<String> resultFilter = Predicates.alwaysTrue(); //accept all by default
-
-    public boolean acceptsInput(String file) {
-        return getMetadataAdapter().acceptsInput(file);
-    }
-
-    public Object scan(Vfs.File file, Object classObject) {
-        if (classObject == null) {
-            try {
-                classObject = configuration.getMetadataAdapter().getOfCreateClassObject(file);
-            } catch (Exception e) {
-                throw new ReflectionsException("could not create class object from file " + file.getRelativePath(), e);
-            }
-        }
-        scan(classObject);
-        return classObject;
-    }
-
-    public abstract void scan(Object cls);
-
-    //
-    public Configuration getConfiguration() {
-        return configuration;
-    }
-
-    public void setConfiguration(final Configuration configuration) {
-        this.configuration = configuration;
-    }
-
-    public Multimap<String, String> getStore() {
-        return store;
-    }
-
-    public void setStore(final Multimap<String, String> store) {
-        this.store = store;
-    }
-
-    public Predicate<String> getResultFilter() {
-        return resultFilter;
-    }
-
-    public void setResultFilter(Predicate<String> resultFilter) {
-        this.resultFilter = resultFilter;
-    }
-
-    @Override
-    public Scanner filterResultsBy(Predicate<String> filter) {
-        this.setResultFilter(filter);
-        return this;
-    }
-
-    public boolean acceptResult(final String fqn) {
-        return fqn != null && resultFilter.apply(fqn);
-    }
-
-    @SuppressWarnings("rawtypes")
-    protected MetadataAdapter getMetadataAdapter() {
-        return configuration.getMetadataAdapter();
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        return this == o || o != null && getClass() == o.getClass();
-    }
-
-    @Override
-    public int hashCode() {
-        return getClass().hashCode();
-    }
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/ClasspathHelper.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/ClasspathHelper.java
deleted file mode 100644
index 8d73d5e4365..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/ClasspathHelper.java
+++ /dev/null
@@ -1,200 +0,0 @@
-package org.logstash.plugins.discovery;
-
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Enumeration;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-import java.io.IOException;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.net.URLClassLoader;
-
-/**
- * Helper methods for working with the classpath.
- */
-public abstract class ClasspathHelper {
-
-    /**
-     * Gets the current thread context class loader.
-     * {@code Thread.currentThread().getContextClassLoader()}.
-     *
-     * @return the context class loader, may be null
-     */
-    public static ClassLoader contextClassLoader() {
-        return Thread.currentThread().getContextClassLoader();
-    }
-
-    /**
-     * Gets the class loader of this library.
-     * {@code Reflections.class.getClassLoader()}.
-     *
-     * @return the static library class loader, may be null
-     */
-    public static ClassLoader staticClassLoader() {
-        return Reflections.class.getClassLoader();
-    }
-
-    /**
-     * Returns an array of class Loaders initialized from the specified array.
-     * <p>
-     * If the input is null or empty, it defaults to both {@link #contextClassLoader()} and {@link #staticClassLoader()}
-     *
-     * @param classLoaders provided ClassLoaders
-     * @return the array of class loaders, not null
-     */
-    public static ClassLoader[] classLoaders(ClassLoader... classLoaders) {
-        if (classLoaders != null && classLoaders.length != 0) {
-            return classLoaders;
-        } else {
-            ClassLoader contextClassLoader = contextClassLoader(), staticClassLoader = staticClassLoader();
-            return contextClassLoader != null ?
-                staticClassLoader != null && contextClassLoader != staticClassLoader ?
-                    new ClassLoader[]{contextClassLoader, staticClassLoader} :
-                    new ClassLoader[]{contextClassLoader} :
-                new ClassLoader[] {};
-
-        }
-    }
-
-    public static Collection<URL> forPackage(String name, ClassLoader... classLoaders) {
-        return forResource(resourceName(name), classLoaders);
-    }
-
-    /**
-     * Returns a distinct collection of URLs based on a resource.
-     * <p>
-     * This searches for the resource name, using {@link ClassLoader#getResources(String)}.
-     * For example, {@code forResource(test.properties)} effectively returns URLs from the
-     * classpath containing files of that name.
-     * <p>
-     * If the optional {@link ClassLoader}s are not specified, then both {@link #contextClassLoader()}
-     * and {@link #staticClassLoader()} are used for {@link ClassLoader#getResources(String)}.
-     * <p>
-     * The returned URLs retains the order of the given {@code classLoaders}.
-     *
-     * @param resourceName resource name on which to search
-     * @param classLoaders optional ClassLoaders to search
-     * @return the collection of URLs, not null
-     */
-    public static Collection<URL> forResource(String resourceName, ClassLoader... classLoaders) {
-        final List<URL> result = new ArrayList<>();
-        final ClassLoader[] loaders = classLoaders(classLoaders);
-        for (ClassLoader classLoader : loaders) {
-            try {
-                final Enumeration<URL> urls = classLoader.getResources(resourceName);
-                while (urls.hasMoreElements()) {
-                    final URL url = urls.nextElement();
-                    int index = url.toExternalForm().lastIndexOf(resourceName);
-                    if (index != -1) {
-                        // Add old url as contextUrl to support exotic url handlers
-                        result.add(new URL(url, url.toExternalForm().substring(0, index)));
-                    } else {
-                        result.add(url);
-                    }
-                }
-            } catch (IOException e) {
-            }
-        }
-        return distinctUrls(result);
-    }
-
-    /**
-     * Returns the URL that contains a {@code Class}.
-     * <p>
-     * This searches for the class using {@link ClassLoader#getResource(String)}.
-     * <p>
-     * If the optional {@link ClassLoader}s are not specified, then both {@link #contextClassLoader()}
-     * and {@link #staticClassLoader()} are used for {@link ClassLoader#getResources(String)}.
-     *
-     * @param aClass class for which to search
-     * @param classLoaders optional ClassLoaders to search
-     * @return the URL containing the class, null if not found
-     */
-    public static URL forClass(Class<?> aClass, ClassLoader... classLoaders) {
-        final ClassLoader[] loaders = classLoaders(classLoaders);
-        final String resourceName = aClass.getName().replace(".", "/") + ".class";
-        for (ClassLoader classLoader : loaders) {
-            try {
-                final URL url = classLoader.getResource(resourceName);
-                if (url != null) {
-                    final String normalizedUrl = url.toExternalForm().substring(0, url.toExternalForm().lastIndexOf(aClass.getPackage().getName().replace(".", "/")));
-                    return new URL(normalizedUrl);
-                }
-            } catch (MalformedURLException e) {
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Returns a distinct collection of URLs based on URLs derived from class loaders.
-     * <p>
-     * This finds the URLs using {@link URLClassLoader#getURLs()} using both
-     * {@link #contextClassLoader()} and {@link #staticClassLoader()}.
-     * <p>
-     * The returned URLs retains the order of the given {@code classLoaders}.
-     *
-     * @return the collection of URLs, not null
-     */
-    public static Collection<URL> forClassLoader() {
-        return forClassLoader(classLoaders());
-    }
-
-    /**
-     * Returns a distinct collection of URLs based on URLs derived from class loaders.
-     * <p>
-     * This finds the URLs using {@link URLClassLoader#getURLs()} using the specified
-     * class loader, searching up the parent hierarchy.
-     * <p>
-     * If the optional {@link ClassLoader}s are not specified, then both {@link #contextClassLoader()}
-     * and {@link #staticClassLoader()} are used for {@link ClassLoader#getResources(String)}.
-     * <p>
-     * The returned URLs retains the order of the given {@code classLoaders}.
-     *
-     * @param classLoaders optional ClassLoaders to search
-     * @return the collection of URLs, not null
-     */
-    public static Collection<URL> forClassLoader(ClassLoader... classLoaders) {
-        final Collection<URL> result = new ArrayList<>();
-        final ClassLoader[] loaders = classLoaders(classLoaders);
-        for (ClassLoader classLoader : loaders) {
-            while (classLoader != null) {
-                if (classLoader instanceof URLClassLoader) {
-                    URL[] urls = ((URLClassLoader) classLoader).getURLs();
-                    if (urls != null) {
-                        result.addAll(Arrays.asList(urls));
-                    }
-                }
-                classLoader = classLoader.getParent();
-            }
-        }
-        return distinctUrls(result);
-    }
-
-    private static String resourceName(String name) {
-        if (name != null) {
-            String resourceName = name.replace(".", "/");
-            resourceName = resourceName.replace("\\", "/");
-            if (resourceName.startsWith("/")) {
-                resourceName = resourceName.substring(1);
-            }
-            return resourceName;
-        }
-        return null;
-    }
-
-    //http://michaelscharf.blogspot.co.il/2006/11/javaneturlequals-and-hashcode-make.html
-    private static Collection<URL> distinctUrls(Collection<URL> urls) {
-        Map<String, URL> distinct = new LinkedHashMap<>(urls.size());
-        for (URL url : urls) {
-            distinct.put(url.toExternalForm(), url);
-        }
-        return distinct.values();
-    }
-}
-
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/Configuration.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/Configuration.java
deleted file mode 100644
index 225e1027257..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/Configuration.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import com.google.common.base.Predicate;
-import java.net.URL;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-
-public interface Configuration {
-    /**
-     * @return the scanner instances used for scanning different metadata
-     */
-    Set<Scanner> getScanners();
-
-    /**
-     * @return the urls to be scanned
-     */
-    Set<URL> getUrls();
-
-    /**
-     * @return the metadata adapter used to fetch metadata from classes
-     */
-    @SuppressWarnings("rawtypes")
-    MetadataAdapter getMetadataAdapter();
-
-    /**
-     * @return the fully qualified name filter used to filter types to be scanned
-     */
-    Predicate<String> getInputsFilter();
-
-    /**
-     * @return executor service used to scan files. if null, scanning is done in a simple for loop
-     */
-    ExecutorService getExecutorService();
-
-    /**
-     * @return class loaders, might be used for resolving methods/fields
-     */
-    ClassLoader[] getClassLoaders();
-
-    boolean shouldExpandSuperTypes();
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/ConfigurationBuilder.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/ConfigurationBuilder.java
deleted file mode 100644
index a23aa7eb43d..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/ConfigurationBuilder.java
+++ /dev/null
@@ -1,245 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import com.google.common.base.Predicate;
-import com.google.common.collect.Lists;
-import com.google.common.collect.ObjectArrays;
-import com.google.common.collect.Sets;
-import java.net.URL;
-import java.util.Collection;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-
-public final class ConfigurationBuilder implements Configuration {
-
-    private final Set<Scanner> scanners;
-
-    private Set<URL> urls;
-    @SuppressWarnings("rawtypes") protected MetadataAdapter metadataAdapter;
-
-    private Predicate<String> inputsFilter;
-
-    private ExecutorService executorService;
-
-    private ClassLoader[] classLoaders;
-    private boolean expandSuperTypes = true;
-
-    public ConfigurationBuilder() {
-        scanners = Sets.newHashSet(new TypeAnnotationsScanner(), new SubTypesScanner());
-        urls = Sets.newHashSet();
-    }
-
-    @SuppressWarnings({"unchecked","rawtypes"})
-    public static ConfigurationBuilder build(final Object... params) {
-        ConfigurationBuilder builder = new ConfigurationBuilder();
-
-        //flatten
-        List<Object> parameters = Lists.newArrayList();
-        if (params != null) {
-            for (Object param : params) {
-                if (param != null) {
-                    if (param.getClass().isArray()) {
-                        for (Object p : (Object[]) param)
-                            if (p != null) {
-                                parameters.add(p);
-                            }
-                    } else if (param instanceof Iterable) {
-                        for (Object p : (Iterable) param)
-                            if (p != null) {
-                                parameters.add(p);
-                            }
-                    } else {
-                        parameters.add(param);
-                    }
-                }
-            }
-        }
-
-        List<ClassLoader> loaders = Lists.newArrayList();
-        for (Object param : parameters)
-            if (param instanceof ClassLoader) {
-                loaders.add((ClassLoader) param);
-            }
-
-        ClassLoader[] classLoaders = loaders.isEmpty() ? null : loaders.toArray(new ClassLoader[loaders.size()]);
-        FilterBuilder filter = new FilterBuilder();
-        List<Scanner> scanners = Lists.newArrayList();
-
-        for (Object param : parameters) {
-            if (param instanceof String) {
-                builder.addUrls(ClasspathHelper.forPackage((String) param, classLoaders));
-                filter.includePackage((String) param);
-            } else if (param instanceof Class) {
-                if (Scanner.class.isAssignableFrom((Class) param)) {
-                    try {
-                        builder.addScanners((Scanner) ((Class) param).getConstructor().newInstance());
-                    } catch (Exception e) { /*fallback*/ }
-                }
-                builder.addUrls(ClasspathHelper.forClass((Class) param, classLoaders));
-                filter.includePackage((Class) param);
-            } else if (param instanceof Scanner) {
-                scanners.add((Scanner) param);
-            } else if (param instanceof URL) {
-                builder.addUrls((URL) param);
-            } else if (param instanceof ClassLoader) { /* already taken care */ } else if (param instanceof Predicate) {
-                filter.add((Predicate<String>) param);
-            } else if (param instanceof ExecutorService) {
-                builder.setExecutorService((ExecutorService) param);
-            }
-        }
-
-        if (builder.getUrls().isEmpty()) {
-            if (classLoaders != null) {
-                builder.addUrls(ClasspathHelper.forClassLoader(classLoaders)); //default urls getResources("")
-            } else {
-                builder.addUrls(ClasspathHelper.forClassLoader()); //default urls getResources("")
-            }
-        }
-
-        builder.filterInputsBy(filter);
-        if (!scanners.isEmpty()) {
-            builder.setScanners(scanners.toArray(new Scanner[scanners.size()]));
-        }
-        if (!loaders.isEmpty()) {
-            builder.addClassLoaders(loaders);
-        }
-
-        return builder;
-    }
-
-    @Override
-
-    public Set<Scanner> getScanners() {
-        return scanners;
-    }
-
-    /**
-     * set the scanners instances for scanning different metadata
-     * @param scanners provided scanners
-     * @return updated {@link ConfigurationBuilder} instance
-     */
-    public ConfigurationBuilder setScanners(final Scanner... scanners) {
-        this.scanners.clear();
-        return addScanners(scanners);
-    }
-
-    /**
-     * set the scanners instances for scanning different metadata
-     * @param scanners provided scanners
-     * @return updated {@link ConfigurationBuilder} instance
-     */
-    public ConfigurationBuilder addScanners(final Scanner... scanners) {
-        this.scanners.addAll(Sets.newHashSet(scanners));
-        return this;
-    }
-
-    @Override
-
-    public Set<URL> getUrls() {
-        return urls;
-    }
-
-    /**
-     * add urls to be scanned
-     * <p>use {@link ClasspathHelper} convenient methods to get the relevant urls
-     * @param urls provided URLs
-     * @return updated {@link ConfigurationBuilder} instance
-     */
-    public ConfigurationBuilder addUrls(final Collection<URL> urls) {
-        this.urls.addAll(urls);
-        return this;
-    }
-
-    /**
-     * add urls to be scanned
-     * <p>use {@link ClasspathHelper} convenient methods to get the relevant urls
-     * @param urls provided URLs
-     * @return updated {@link ConfigurationBuilder} instance
-     */
-    public ConfigurationBuilder addUrls(final URL... urls) {
-        this.urls.addAll(Sets.newHashSet(urls));
-        return this;
-    }
-
-    /**
-     * @return the metadata adapter.
-     * if javassist library exists in the classpath, this method returns {@link JavassistAdapter} otherwise defaults to {@link JavaReflectionAdapter}.
-     * <p>the {@link JavassistAdapter} is preferred in terms of performance and class loading.
-     */
-    @SuppressWarnings("rawtypes")
-    @Override
-    public MetadataAdapter getMetadataAdapter() {
-        if (metadataAdapter != null) {
-            return metadataAdapter;
-        } else {
-            try {
-                return metadataAdapter = new JavassistAdapter();
-            } catch (Throwable e) {
-                return metadataAdapter = new JavaReflectionAdapter();
-            }
-        }
-    }
-
-    @Override
-    public Predicate<String> getInputsFilter() {
-        return inputsFilter;
-    }
-
-    /**
-     * sets the input filter for all resources to be scanned.
-     * <p> supply a {@link Predicate} or use the {@link FilterBuilder}
-     * @param inputsFilter provided inputs filter
-     * @return updated {@link ConfigurationBuilder} instance
-     */
-    public ConfigurationBuilder filterInputsBy(Predicate<String> inputsFilter) {
-        this.inputsFilter = inputsFilter;
-        return this;
-    }
-
-    @Override
-    public ExecutorService getExecutorService() {
-        return executorService;
-    }
-
-    /**
-     * sets the executor service used for scanning.
-     * @param executorService provided executor service
-     * @return updated {@link ConfigurationBuilder} instance
-     */
-    public ConfigurationBuilder setExecutorService(ExecutorService executorService) {
-        this.executorService = executorService;
-        return this;
-    }
-
-    /**
-     * @return class loader, might be used for scanning or resolving methods/fields
-     */
-    @Override
-    public ClassLoader[] getClassLoaders() {
-        return classLoaders;
-    }
-
-    @Override
-    public boolean shouldExpandSuperTypes() {
-        return expandSuperTypes;
-    }
-
-    /**
-     * add class loader, might be used for resolving methods/fields
-     * @param classLoaders provided class loaders
-     * @return updated {@link ConfigurationBuilder} instance
-     */
-    public ConfigurationBuilder addClassLoaders(ClassLoader... classLoaders) {
-        this.classLoaders = this.classLoaders == null ? classLoaders : ObjectArrays.concat(this.classLoaders, classLoaders, ClassLoader.class);
-        return this;
-    }
-
-    /**
-     * add class loader, might be used for resolving methods/fields
-     * @param classLoaders provided class loaders
-     * @return updated {@link ConfigurationBuilder} instance
-     */
-    public ConfigurationBuilder addClassLoaders(Collection<ClassLoader> classLoaders) {
-        return addClassLoaders(classLoaders.toArray(new ClassLoader[classLoaders.size()]));
-    }
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/FilterBuilder.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/FilterBuilder.java
deleted file mode 100644
index 1f981fae62d..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/FilterBuilder.java
+++ /dev/null
@@ -1,137 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import com.google.common.base.Joiner;
-import com.google.common.base.Predicate;
-import com.google.common.collect.Lists;
-import java.util.List;
-import java.util.regex.Pattern;
-
-public class FilterBuilder implements Predicate<String> {
-    private final List<Predicate<String>> chain;
-
-    public FilterBuilder() {
-        chain = Lists.newArrayList();
-    }
-
-    /**
-     * exclude a regular expression
-     * @param regex regex to exclude
-     * @return updated {@link FilterBuilder} instance
-     */
-    public FilterBuilder exclude(final String regex) {
-        add(new FilterBuilder.Exclude(regex));
-        return this;
-    }
-
-    /**
-     * add a Predicate to the chain of predicates
-     * @param filter predicate to add
-     * @return updated {@link FilterBuilder} instance
-     */
-    public FilterBuilder add(Predicate<String> filter) {
-        chain.add(filter);
-        return this;
-    }
-
-    /**
-     * include a package of a given class
-     * @param aClass provided class
-     * @return updated {@link FilterBuilder} instance
-     */
-    public FilterBuilder includePackage(final Class<?> aClass) {
-        return add(new FilterBuilder.Include(packageNameRegex(aClass)));
-    }
-
-    /**
-     * include packages of given prefixes
-     * @param prefixes package prefixes
-     * @return updated {@link FilterBuilder} instance
-     */
-    public FilterBuilder includePackage(final String... prefixes) {
-        for (String prefix : prefixes) {
-            add(new FilterBuilder.Include(prefix(prefix)));
-        }
-        return this;
-    }
-
-    private static String packageNameRegex(Class<?> aClass) {
-        return prefix(aClass.getPackage().getName() + ".");
-    }
-
-    public static String prefix(String qualifiedName) {
-        return qualifiedName.replace(".", "\\.") + ".*";
-    }
-
-    @Override
-    public String toString() {
-        return Joiner.on(", ").join(chain);
-    }
-
-    public boolean apply(String regex) {
-        boolean accept = chain == null || chain.isEmpty() || chain.get(0) instanceof FilterBuilder.Exclude;
-
-        if (chain != null) {
-            for (Predicate<String> filter : chain) {
-                if (accept && filter instanceof FilterBuilder.Include) {
-                    continue;
-                } //skip if this filter won't change
-                if (!accept && filter instanceof FilterBuilder.Exclude) {
-                    continue;
-                }
-                accept = filter.apply(regex);
-                if (!accept && filter instanceof FilterBuilder.Exclude) {
-                    break;
-                } //break on first exclusion
-            }
-        }
-        return accept;
-    }
-
-    public abstract static class Matcher implements Predicate<String> {
-        final Pattern pattern;
-
-        public Matcher(final String regex) {
-            pattern = Pattern.compile(regex);
-        }
-
-        public abstract boolean apply(String regex);
-
-        @Override
-        public String toString() {
-            return pattern.pattern();
-        }
-    }
-
-    public static class Include extends FilterBuilder.Matcher {
-        public Include(final String patternString) {
-            super(patternString);
-        }
-
-        @Override
-        public boolean apply(final String regex) {
-            return pattern.matcher(regex).matches();
-        }
-
-        @Override
-        public String toString() {
-            return "+" + super.toString();
-        }
-    }
-
-    public static class Exclude extends FilterBuilder.Matcher {
-        public Exclude(final String patternString) {
-            super(patternString);
-        }
-
-        @Override
-        public boolean apply(final String regex) {
-            return !pattern.matcher(regex).matches();
-        }
-
-        @Override
-        public String toString() {
-            return "-" + super.toString();
-        }
-    }
-
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/JavaReflectionAdapter.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/JavaReflectionAdapter.java
deleted file mode 100644
index 8edc965b919..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/JavaReflectionAdapter.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import java.lang.annotation.Annotation;
-import java.util.ArrayList;
-import java.util.List;
-
-@SuppressWarnings("rawtypes")
-public final class JavaReflectionAdapter implements MetadataAdapter<Class> {
-
-    public List<String> getClassAnnotationNames(Class aClass) {
-        return getAnnotationNames(aClass.getDeclaredAnnotations());
-    }
-
-    public Class getOfCreateClassObject(Vfs.File file) { return getOfCreateClassObject(file, new ClassLoader[]{}); }
-
-    public Class getOfCreateClassObject(Vfs.File file, ClassLoader... loaders) {
-        String name = file.getRelativePath().replace("/", ".").replace(".class", "");
-        return ReflectionUtils.forName(name, loaders);
-    }
-
-    public String getClassName(Class cls) {
-        return cls.getName();
-    }
-
-    public String getSuperclassName(Class cls) {
-        Class superclass = cls.getSuperclass();
-        return superclass != null ? superclass.getName() : "";
-    }
-
-    public List<String> getInterfacesNames(Class cls) {
-        Class[] classes = cls.getInterfaces();
-        List<String> names = new ArrayList<>(classes != null ? classes.length : 0);
-        if (classes != null) {
-            for (Class cls1 : classes) names.add(cls1.getName());
-        }
-        return names;
-    }
-
-    public boolean acceptsInput(String file) {
-        return file.endsWith(".class");
-    }
-
-    private List<String> getAnnotationNames(Annotation[] annotations) {
-        List<String> names = new ArrayList<>(annotations.length);
-        for (Annotation annotation : annotations) {
-            names.add(annotation.annotationType().getName());
-        }
-        return names;
-    }
-
-    public static String getName(Class type) {
-        if (type.isArray()) {
-            try {
-                Class cl = type;
-                int dim = 0;
-                while (cl.isArray()) {
-                    dim++;
-                    cl = cl.getComponentType();
-                }
-                return cl.getName() + Utils.repeat("[]", dim);
-            } catch (Throwable e) {
-                // do nothing
-            }
-        }
-        return type.getName();
-    }
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/JavassistAdapter.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/JavassistAdapter.java
deleted file mode 100644
index 5704736992f..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/JavassistAdapter.java
+++ /dev/null
@@ -1,76 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import com.google.common.collect.Lists;
-import java.io.BufferedInputStream;
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Arrays;
-import java.util.List;
-import javassist.bytecode.AnnotationsAttribute;
-import javassist.bytecode.ClassFile;
-import javassist.bytecode.annotation.Annotation;
-
-/**
- *
- */
-public class JavassistAdapter implements MetadataAdapter<ClassFile> {
-
-    /**
-     * setting this to false will result in returning only visible annotations from the relevant methods here (only {@link java.lang.annotation.RetentionPolicy#RUNTIME})
-     */
-    public static boolean includeInvisibleTag = true;
-
-    public List<String> getClassAnnotationNames(final ClassFile aClass) {
-        return getAnnotationNames((AnnotationsAttribute) aClass.getAttribute(AnnotationsAttribute.visibleTag),
-            includeInvisibleTag ? (AnnotationsAttribute) aClass.getAttribute(AnnotationsAttribute.invisibleTag) : null);
-    }
-
-    public ClassFile getOfCreateClassObject(final Vfs.File file) {
-        InputStream inputStream = null;
-        try {
-            inputStream = file.openInputStream();
-            DataInputStream dis = new DataInputStream(new BufferedInputStream(inputStream));
-            return new ClassFile(dis);
-        } catch (IOException e) {
-            throw new ReflectionsException("could not create class file from " + file.getName(), e);
-        } finally {
-            Utils.close(inputStream);
-        }
-    }
-
-    //
-    public String getClassName(final ClassFile cls) {
-        return cls.getName();
-    }
-
-    public String getSuperclassName(final ClassFile cls) {
-        return cls.getSuperclass();
-    }
-
-    public List<String> getInterfacesNames(final ClassFile cls) {
-        return Arrays.asList(cls.getInterfaces());
-    }
-
-    public boolean acceptsInput(String file) {
-        return file.endsWith(".class");
-    }
-
-    //
-    private List<String> getAnnotationNames(final AnnotationsAttribute... annotationsAttributes) {
-        List<String> result = Lists.newArrayList();
-
-        if (annotationsAttributes != null) {
-            for (AnnotationsAttribute annotationsAttribute : annotationsAttributes) {
-                if (annotationsAttribute != null) {
-                    for (Annotation annotation : annotationsAttribute.getAnnotations()) {
-                        result.add(annotation.getTypeName());
-                    }
-                }
-            }
-        }
-
-        return result;
-    }
-
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/MetadataAdapter.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/MetadataAdapter.java
deleted file mode 100644
index 23b7e018c6e..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/MetadataAdapter.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import java.util.List;
-
-/**
- *
- */
-public interface MetadataAdapter<C> {
-
-    //
-    String getClassName(final C cls);
-
-    String getSuperclassName(final C cls);
-
-    List<String> getInterfacesNames(final C cls);
-
-    List<String> getClassAnnotationNames(final C aClass);
-
-    C getOfCreateClassObject(Vfs.File file) throws Exception;
-
-    boolean acceptsInput(String file);
-
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/PluginRegistry.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/PluginRegistry.java
index 8a1f232d7ac..f779a317f55 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/PluginRegistry.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/discovery/PluginRegistry.java
@@ -8,6 +8,7 @@
 import co.elastic.logstash.api.Input;
 import co.elastic.logstash.api.LogstashPlugin;
 import co.elastic.logstash.api.Output;
+import org.reflections.Reflections;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
@@ -33,7 +34,7 @@ private PluginRegistry() {} // utility class
 
     @SuppressWarnings("unchecked")
     private static void discoverPlugins() {
-        Reflections reflections = new Reflections("");
+        Reflections reflections = new Reflections("org.logstash.plugins");
         Set<Class<?>> annotated = reflections.getTypesAnnotatedWith(LogstashPlugin.class);
         for (final Class<?> cls : annotated) {
             for (final Annotation annotation : cls.getAnnotations()) {
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/ReflectionUtils.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/ReflectionUtils.java
deleted file mode 100644
index 8bc2a6c535c..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/ReflectionUtils.java
+++ /dev/null
@@ -1,120 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import com.google.common.collect.Lists;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-
-@SuppressWarnings("unchecked")
-public abstract class ReflectionUtils {
-
-
-    public static boolean includeObject;
-
-    /**
-     * @param type type to query
-     * @return immediate supertype and interfaces of the given {@code type}
-     */
-    public static Set<Class<?>> getSuperTypes(Class<?> type) {
-        Set<Class<?>> result = new LinkedHashSet<>();
-        Class<?> superclass = type.getSuperclass();
-        Class<?>[] interfaces = type.getInterfaces();
-        if (superclass != null && (includeObject || !superclass.equals(Object.class))) {
-            result.add(superclass);
-        }
-        if (interfaces != null && interfaces.length > 0) {
-            result.addAll(Arrays.asList(interfaces));
-        }
-        return result;
-    }
-
-    //predicates
-
-    public static Class<?> forName(String typeName, ClassLoader... classLoaders) {
-        if (getPrimitiveNames().contains(typeName)) {
-            return getPrimitiveTypes().get(getPrimitiveNames().indexOf(typeName));
-        } else {
-            String type;
-            if (typeName.contains("[")) {
-                int i = typeName.indexOf("[");
-                type = typeName.substring(0, i);
-                String array = typeName.substring(i).replace("]", "");
-
-                if (getPrimitiveNames().contains(type)) {
-                    type = getPrimitiveDescriptors().get(getPrimitiveNames().indexOf(type));
-                } else {
-                    type = "L" + type + ";";
-                }
-
-                type = array + type;
-            } else {
-                type = typeName;
-            }
-
-            List<ReflectionsException> reflectionsExceptions = Lists.newArrayList();
-            for (ClassLoader classLoader : ClasspathHelper.classLoaders(classLoaders)) {
-                if (type.contains("[")) {
-                    try {
-                        return Class.forName(type, false, classLoader);
-                    } catch (Throwable e) {
-                        reflectionsExceptions.add(new ReflectionsException("could not get type for name " + typeName, e));
-                    }
-                }
-                try {
-                    return classLoader.loadClass(type);
-                } catch (Throwable e) {
-                    reflectionsExceptions.add(new ReflectionsException("could not get type for name " + typeName, e));
-                }
-            }
-            return null;
-        }
-    }
-
-    /**
-     * @param <T> Search will include subclasses of this type
-     * @param classes list of names of Java types
-     * @param classLoaders class loaders to search
-     * @return list of Java types given string representations of their names
-     */
-    public static <T> List<Class<? extends T>> forNames(final Iterable<String> classes, ClassLoader... classLoaders) {
-        List<Class<? extends T>> result = new ArrayList<>();
-        for (String className : classes) {
-            Class<?> type = forName(className, classLoaders);
-            if (type != null) {
-                result.add((Class<? extends T>) type);
-            }
-        }
-        return result;
-    }
-
-    private static List<String> primitiveNames;
-    @SuppressWarnings("rawtypes") private static List<Class> primitiveTypes;
-    private static List<String> primitiveDescriptors;
-
-    private static void initPrimitives() {
-        if (primitiveNames == null) {
-            primitiveNames = Lists.newArrayList("boolean", "char", "byte", "short", "int", "long", "float", "double", "void");
-            primitiveTypes = Lists.newArrayList(boolean.class, char.class, byte.class, short.class, int.class, long.class, float.class, double.class, void.class);
-            primitiveDescriptors = Lists.newArrayList("Z", "C", "B", "S", "I", "J", "F", "D", "V");
-        }
-    }
-
-    private static List<String> getPrimitiveNames() {
-        initPrimitives();
-        return primitiveNames;
-    }
-
-    @SuppressWarnings("rawtypes")
-    private static List<Class> getPrimitiveTypes() {
-        initPrimitives();
-        return primitiveTypes;
-    }
-
-    private static List<String> getPrimitiveDescriptors() {
-        initPrimitives();
-        return primitiveDescriptors;
-    }
-
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/Reflections.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/Reflections.java
deleted file mode 100644
index 61e20356f2d..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/Reflections.java
+++ /dev/null
@@ -1,155 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import com.google.common.base.Predicate;
-import com.google.common.collect.HashMultimap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Multimap;
-import com.google.common.collect.Sets;
-import java.lang.annotation.Annotation;
-import java.lang.annotation.Inherited;
-import java.net.URL;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Future;
-
-public class Reflections {
-
-    protected final Configuration configuration;
-    protected Store store;
-
-    public Reflections(final Configuration configuration) {
-        this.configuration = configuration;
-        store = new Store(configuration);
-
-        if (configuration.getScanners() != null && !configuration.getScanners().isEmpty()) {
-            //inject to scanners
-            for (Scanner scanner : configuration.getScanners()) {
-                scanner.setConfiguration(configuration);
-                scanner.setStore(store.getOrCreate(scanner.getClass().getSimpleName()));
-            }
-
-            scan();
-
-            if (configuration.shouldExpandSuperTypes()) {
-                expandSuperTypes();
-            }
-        }
-    }
-
-    public Reflections(final String prefix, final Scanner... scanners) {
-        this((Object) prefix, scanners);
-    }
-
-    public Reflections(final Object... params) {
-        this(ConfigurationBuilder.build(params));
-    }
-
-    @SuppressWarnings("rawtypes")
-    protected void scan() {
-        if (configuration.getUrls() == null || configuration.getUrls().isEmpty()) {
-            return;
-        }
-        ExecutorService executorService = configuration.getExecutorService();
-        List<Future<?>> futures = Lists.newArrayList();
-
-        for (final URL url : configuration.getUrls()) {
-            try {
-                if (executorService != null) {
-                    futures.add(executorService.submit(() -> scan(url)));
-                } else {
-                    scan(url);
-                }
-            } catch (ReflectionsException e) {
-            }
-        }
-
-        if (executorService != null) {
-            for (Future future : futures) {
-                try {
-                    future.get();
-                } catch (Exception e) {
-                    throw new RuntimeException(e);
-                }
-            }
-        }
-
-        if (executorService != null) {
-            executorService.shutdown();
-        }
-    }
-
-    protected void scan(URL url) {
-        Vfs.Dir dir = Vfs.fromURL(url);
-
-        try {
-            for (final Vfs.File file : dir.getFiles()) {
-                // scan if inputs filter accepts file relative path or fqn
-                Predicate<String> inputsFilter = configuration.getInputsFilter();
-                String path = file.getRelativePath();
-                String fqn = path.replace('/', '.');
-                if (inputsFilter == null || inputsFilter.apply(path) || inputsFilter.apply(fqn)) {
-                    Object classObject = null;
-                    for (Scanner scanner : configuration.getScanners()) {
-                        try {
-                            if (scanner.acceptsInput(path) || scanner.acceptResult(fqn)) {
-                                classObject = scanner.scan(file, classObject);
-                            }
-                        } catch (Exception e) {
-                        }
-                    }
-                }
-            }
-        } finally {
-            dir.close();
-        }
-    }
-
-    public void expandSuperTypes() {
-        if (store.keySet().contains(index(SubTypesScanner.class))) {
-            Multimap<String, String> mmap = store.get(index(SubTypesScanner.class));
-            Sets.SetView<String> keys = Sets.difference(mmap.keySet(), Sets.newHashSet(mmap.values()));
-            Multimap<String, String> expand = HashMultimap.create();
-            for (String key : keys) {
-                final Class<?> type = ReflectionUtils.forName(key);
-                if (type != null) {
-                    expandSupertypes(expand, key, type);
-                }
-            }
-            mmap.putAll(expand);
-        }
-    }
-
-    private void expandSupertypes(Multimap<String, String> mmap, String key, Class<?> type) {
-        for (Class<?> supertype : ReflectionUtils.getSuperTypes(type)) {
-            if (mmap.put(supertype.getName(), key)) {
-                expandSupertypes(mmap, supertype.getName(), supertype);
-            }
-        }
-    }
-
-    public Set<Class<?>> getTypesAnnotatedWith(final Class<? extends Annotation> annotation) {
-        return getTypesAnnotatedWith(annotation, false);
-    }
-
-    public Set<Class<?>> getTypesAnnotatedWith(final Class<? extends Annotation> annotation, boolean honorInherited) {
-        Iterable<String> annotated = store.get(index(TypeAnnotationsScanner.class), annotation.getName());
-        Iterable<String> classes = getAllAnnotated(annotated, annotation.isAnnotationPresent(Inherited.class), honorInherited);
-        return Sets.newHashSet(Iterables.concat(ReflectionUtils.forNames(annotated, loaders()), ReflectionUtils.forNames(classes, loaders())));
-    }
-
-    protected Iterable<String> getAllAnnotated(Iterable<String> annotated, boolean inherited, boolean honorInherited) {
-        Iterable<String> subTypes = Iterables.concat(annotated, store.getAll(index(TypeAnnotationsScanner.class), annotated));
-        return Iterables.concat(subTypes, store.getAll(index(SubTypesScanner.class), subTypes));
-    }
-
-    private static String index(Class<? extends Scanner> scannerClass) {
-        return scannerClass.getSimpleName();
-    }
-
-    private ClassLoader[] loaders() {
-        return configuration.getClassLoaders();
-    }
-
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/ReflectionsException.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/ReflectionsException.java
deleted file mode 100644
index dcde5c576fa..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/ReflectionsException.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package org.logstash.plugins.discovery;
-
-public class ReflectionsException extends RuntimeException {
-
-    private static final long serialVersionUID = 1L;
-
-    public ReflectionsException(String message) {
-        super(message);
-    }
-
-    public ReflectionsException(String message, Throwable cause) {
-        super(message, cause);
-    }
-
-}
-
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/Scanner.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/Scanner.java
deleted file mode 100644
index ef7fd62b248..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/Scanner.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import com.google.common.base.Predicate;
-import com.google.common.collect.Multimap;
-
-/**
- *
- */
-public interface Scanner {
-
-    void setConfiguration(Configuration configuration);
-
-    Multimap<String, String> getStore();
-
-    void setStore(Multimap<String, String> store);
-
-    Scanner filterResultsBy(Predicate<String> filter);
-
-    boolean acceptsInput(String file);
-
-    Object scan(Vfs.File file, Object classObject);
-
-    boolean acceptResult(String fqn);
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/Store.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/Store.java
deleted file mode 100644
index 609f3151e89..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/Store.java
+++ /dev/null
@@ -1,126 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Multimap;
-import com.google.common.collect.Multimaps;
-import com.google.common.collect.SetMultimap;
-import com.google.common.collect.Sets;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-
-public final class Store {
-
-    private transient boolean concurrent;
-    private final Map<String, Multimap<String, String>> storeMap;
-
-    //used via reflection
-    @SuppressWarnings("UnusedDeclaration")
-    protected Store() {
-        storeMap = new HashMap<>();
-        concurrent = false;
-    }
-
-    public Store(Configuration configuration) {
-        storeMap = new HashMap<>();
-        concurrent = configuration.getExecutorService() != null;
-    }
-
-    /**
-     * @return all indices
-     */
-    public Set<String> keySet() {
-        return storeMap.keySet();
-    }
-
-    /**
-     * @param index specified index
-     * @return existing or newly-created multimap object for the given {@code index}
-     */
-    public Multimap<String, String> getOrCreate(String index) {
-        Multimap<String, String> mmap = storeMap.get(index);
-        if (mmap == null) {
-            SetMultimap<String, String> multimap =
-                Multimaps.newSetMultimap(new HashMap<>(),
-                    () -> Collections.newSetFromMap(new ConcurrentHashMap<>()));
-            mmap = concurrent ? Multimaps.synchronizedSetMultimap(multimap) : multimap;
-            storeMap.put(index, mmap);
-        }
-        return mmap;
-    }
-
-    public Multimap<String, String> get(String index) {
-        Multimap<String, String> mmap = storeMap.get(index);
-        if (mmap == null) {
-            throw new ReflectionsException("Scanner " + index + " was not configured");
-        }
-        return mmap;
-    }
-
-    /**
-     * @param index specified index
-     * @param keys specified keys
-     * @return values stored for the given {@code index} and {@code keys}
-     */
-    public Iterable<String> get(String index, String... keys) {
-        return get(index, Arrays.asList(keys));
-    }
-
-    /**
-     * @param index specified index
-     * @param keys specified keys
-     * @return values stored for the given {@code index} and {@code keys}
-     */
-    public Iterable<String> get(String index, Iterable<String> keys) {
-        Multimap<String, String> mmap = get(index);
-        IterableChain<String> result = new IterableChain<>();
-        for (String key : keys) {
-            result.addAll(mmap.get(key));
-        }
-        return result;
-    }
-
-    /**
-     * @param index specified index
-     * @param keys specified keys
-     * @param result accumulates intermediate results
-     * @return values stored for the given {@code index} and {@code keys}, including keys
-     */
-    private Iterable<String> getAllIncluding(String index, Iterable<String> keys, IterableChain<String> result) {
-        result.addAll(keys);
-        for (String key : keys) {
-            Iterable<String> values = get(index, key);
-            if (values.iterator().hasNext()) {
-                getAllIncluding(index, values, result);
-            }
-        }
-        return result;
-    }
-
-    /**
-     * @param index specified index
-     * @param keys specified keys
-     * @return values stored for the given {@code index} and {@code keys}, not including keys
-     */
-    public Iterable<String> getAll(String index, Iterable<String> keys) {
-        return getAllIncluding(index, get(index, keys), new IterableChain<>());
-    }
-
-    private static class IterableChain<T> implements Iterable<T> {
-        private final List<Iterable<T>> chain = Lists.newArrayList();
-
-        private void addAll(Iterable<T> iterable) {
-            chain.add(iterable);
-        }
-
-        public Iterator<T> iterator() {
-            return Iterables.concat(chain).iterator();
-        }
-    }
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/SubTypesScanner.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/SubTypesScanner.java
deleted file mode 100644
index 820565998ad..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/SubTypesScanner.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import java.util.List;
-
-/** scans for superclass and interfaces of a class, allowing a reverse lookup for subtypes */
-public class SubTypesScanner extends AbstractScanner {
-
-    /** created new SubTypesScanner. will exclude direct Object subtypes */
-    public SubTypesScanner() {
-        this(true); //exclude direct Object subtypes by default
-    }
-
-    /** created new SubTypesScanner.
-     * @param excludeObjectClass if false, include direct {@link Object} subtypes in results.  */
-    public SubTypesScanner(boolean excludeObjectClass) {
-        if (excludeObjectClass) {
-            filterResultsBy(new FilterBuilder().exclude(Object.class.getName())); //exclude direct Object subtypes
-        }
-    }
-
-    @SuppressWarnings({"unchecked"})
-    public void scan(final Object cls) {
-        String className = getMetadataAdapter().getClassName(cls);
-        String superclass = getMetadataAdapter().getSuperclassName(cls);
-
-        if (acceptResult(superclass)) {
-            getStore().put(superclass, className);
-        }
-
-        for (String anInterface : (List<String>) getMetadataAdapter().getInterfacesNames(cls)) {
-            if (acceptResult(anInterface)) {
-                getStore().put(anInterface, className);
-            }
-        }
-    }
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/TypeAnnotationsScanner.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/TypeAnnotationsScanner.java
deleted file mode 100644
index 3b31cc6ad14..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/TypeAnnotationsScanner.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import java.lang.annotation.Inherited;
-import java.util.List;
-
-/**
- * scans for class's annotations, where @Retention(RetentionPolicy.RUNTIME)
- */
-@SuppressWarnings("unchecked")
-public class TypeAnnotationsScanner extends AbstractScanner {
-
-    @Override
-    public void scan(final Object cls) {
-        final String className = getMetadataAdapter().getClassName(cls);
-
-        for (String annotationType : (List<String>) getMetadataAdapter().getClassAnnotationNames(cls)) {
-
-            if (acceptResult(annotationType) ||
-                annotationType.equals(Inherited.class.getName())) { //as an exception, accept Inherited as well
-                getStore().put(annotationType, className);
-            }
-        }
-    }
-
-}
-
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/Utils.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/Utils.java
deleted file mode 100644
index bdb3046a750..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/Utils.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import com.google.common.base.Joiner;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convenient methods for plugin discovery.
- */
-public abstract class Utils {
-
-    public static String repeat(String string, int times) {
-        StringBuilder sb = new StringBuilder();
-
-        for (int i = 0; i < times; i++) {
-            sb.append(string);
-        }
-
-        return sb.toString();
-    }
-
-    /**
-     * @param s string to test
-     * @return Java5-compatible isEmpty result
-     */
-    public static boolean isEmpty(String s) {
-        return s == null || s.length() == 0;
-    }
-
-    public static boolean isEmpty(Object[] objects) {
-        return objects == null || objects.length == 0;
-    }
-
-    public static void close(InputStream closeable) {
-        try {
-            if (closeable != null) {
-                closeable.close();
-            }
-        } catch (IOException e) {
-        }
-    }
-
-    public static String name(@SuppressWarnings("rawtypes") Class type) {
-        if (!type.isArray()) {
-            return type.getName();
-        } else {
-            int dim = 0;
-            while (type.isArray()) {
-                dim++;
-                type = type.getComponentType();
-            }
-            return type.getName() + repeat("[]", dim);
-        }
-    }
-
-    public static List<String> names(Iterable<Class<?>> types) {
-        List<String> result = new ArrayList<>();
-        for (Class<?> type : types) result.add(name(type));
-        return result;
-    }
-
-    public static List<String> names(Class<?>... types) {
-        return names(Arrays.asList(types));
-    }
-
-    public static String name(@SuppressWarnings("rawtypes") Constructor constructor) {
-        return constructor.getName() + "." + "<init>" + "(" + Joiner.on(", ").join(names(constructor.getParameterTypes())) + ")";
-    }
-
-    public static String name(Method method) {
-        return method.getDeclaringClass().getName() + "." + method.getName() + "(" + Joiner.on(", ").join(names(method.getParameterTypes())) + ")";
-    }
-
-    public static String name(Field field) {
-        return field.getDeclaringClass().getName() + "." + field.getName();
-    }
-}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/discovery/Vfs.java b/logstash-core/src/main/java/org/logstash/plugins/discovery/Vfs.java
deleted file mode 100644
index 5de32413f84..00000000000
--- a/logstash-core/src/main/java/org/logstash/plugins/discovery/Vfs.java
+++ /dev/null
@@ -1,634 +0,0 @@
-package org.logstash.plugins.discovery;
-
-import com.google.common.base.Predicate;
-import com.google.common.collect.AbstractIterator;
-import com.google.common.collect.Lists;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
-import java.net.JarURLConnection;
-import java.net.MalformedURLException;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.URLDecoder;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.List;
-import java.util.Stack;
-import java.util.jar.JarFile;
-import java.util.jar.JarInputStream;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import java.util.zip.ZipEntry;
-
-public abstract class Vfs {
-    private static List<Vfs.UrlType> defaultUrlTypes = Lists.newArrayList(Vfs.DefaultUrlTypes.values());
-
-    /**
-     * an abstract vfs dir
-     */
-    public interface Dir {
-        String getPath();
-
-        Iterable<Vfs.File> getFiles();
-
-        void close();
-    }
-
-    /**
-     * an abstract vfs file
-     */
-    public interface File {
-        String getName();
-
-        String getRelativePath();
-
-        InputStream openInputStream() throws IOException;
-    }
-
-    /**
-     * a matcher and factory for a url
-     */
-    public interface UrlType {
-        boolean matches(URL url) throws Exception;
-
-        Vfs.Dir createDir(URL url) throws Exception;
-    }
-
-    /**
-     * @param url URL from which to create a Dir
-     * @return Dir created from the given url, using the defaultUrlTypes
-     */
-    public static Vfs.Dir fromURL(final URL url) {
-        return fromURL(url, defaultUrlTypes);
-    }
-
-    /**
-     * @param url URL from which to create a Dir
-     * @param urlTypes given URL types
-     * @return Dir created from the given url, using the given urlTypes
-     */
-    public static Vfs.Dir fromURL(final URL url, final List<Vfs.UrlType> urlTypes) {
-        for (final Vfs.UrlType type : urlTypes) {
-            try {
-                if (type.matches(url)) {
-                    final Vfs.Dir dir = type.createDir(url);
-                    if (dir != null) {
-                        return dir;
-                    }
-                }
-            } catch (final Throwable e) {
-            }
-        }
-
-        throw new ReflectionsException("could not create Vfs.Dir from url, no matching UrlType was found [" + url.toExternalForm() + "]\n" +
-            "either use fromURL(final URL url, final List<UrlType> urlTypes) or " +
-            "use the static setDefaultURLTypes(final List<UrlType> urlTypes) or addDefaultURLTypes(UrlType urlType) " +
-            "with your specialized UrlType.");
-    }
-
-    /**
-     * @param url provided URL
-     * @return {@link Vfs.File} from provided URL
-     */
-    public static java.io.File getFile(final URL url) {
-        java.io.File file;
-        String path;
-
-        try {
-            path = url.toURI().getSchemeSpecificPart();
-            if ((file = new java.io.File(path)).exists()) {
-                return file;
-            }
-        } catch (final URISyntaxException e) {
-        }
-
-        try {
-            path = URLDecoder.decode(url.getPath(), "UTF-8");
-            if (path.contains(".jar!")) {
-                path = path.substring(0, path.lastIndexOf(".jar!") + ".jar".length());
-            }
-            if ((file = new java.io.File(path)).exists()) {
-                return file;
-            }
-
-        } catch (final UnsupportedEncodingException e) {
-        }
-
-        try {
-            path = url.toExternalForm();
-            if (path.startsWith("jar:")) {
-                path = path.substring("jar:".length());
-            }
-            if (path.startsWith("wsjar:")) {
-                path = path.substring("wsjar:".length());
-            }
-            if (path.startsWith("file:")) {
-                path = path.substring("file:".length());
-            }
-            if (path.contains(".jar!")) {
-                path = path.substring(0, path.indexOf(".jar!") + ".jar".length());
-            }
-            if ((file = new java.io.File(path)).exists()) {
-                return file;
-            }
-
-            path = path.replace("%20", " ");
-            if ((file = new java.io.File(path)).exists()) {
-                return file;
-            }
-
-        } catch (final Exception e) {
-        }
-
-        return null;
-    }
-
-    private static boolean hasJarFileInPath(final URL url) {
-        return url.toExternalForm().matches(".*\\.jar(\\!.*|$)");
-    }
-
-    public enum DefaultUrlTypes implements Vfs.UrlType {
-        jarFile {
-            @Override
-            public boolean matches(final URL url) {
-                return url.getProtocol().equals("file") && hasJarFileInPath(url);
-            }
-
-            @Override
-            public Vfs.Dir createDir(final URL url) throws Exception {
-                return new Vfs.ZipDir(new JarFile(getFile(url)));
-            }
-        },
-
-        jarUrl {
-            @Override
-            public boolean matches(final URL url) {
-                return "jar".equals(url.getProtocol()) || "zip".equals(url.getProtocol()) || "wsjar".equals(url.getProtocol());
-            }
-
-            @Override
-            public Vfs.Dir createDir(final URL url) throws Exception {
-                try {
-                    final URLConnection urlConnection = url.openConnection();
-                    if (urlConnection instanceof JarURLConnection) {
-                        return new Vfs.ZipDir(((JarURLConnection) urlConnection).getJarFile());
-                    }
-                } catch (final Throwable e) { /*fallback*/ }
-                final java.io.File file = getFile(url);
-                if (file != null) {
-                    return new Vfs.ZipDir(new JarFile(file));
-                }
-                return null;
-            }
-        },
-
-        directory {
-            @Override
-            public boolean matches(final URL url) {
-                if (url.getProtocol().equals("file") && !hasJarFileInPath(url)) {
-                    final java.io.File file = getFile(url);
-                    return file != null && file.isDirectory();
-                } else {
-                    return false;
-                }
-            }
-
-            @Override
-            public Vfs.Dir createDir(final URL url) {
-                return new Vfs.SystemDir(getFile(url));
-            }
-        },
-
-        jboss_vfs {
-            @Override
-            public boolean matches(final URL url) {
-                return url.getProtocol().equals("vfs");
-            }
-
-            @Override
-            public Vfs.Dir createDir(final URL url) throws Exception {
-                final Object content = url.openConnection().getContent();
-                final Class<?> virtualFile = ClasspathHelper.contextClassLoader().loadClass("org.jboss.vfs.VirtualFile");
-                final java.io.File physicalFile = (java.io.File) virtualFile.getMethod("getPhysicalFile").invoke(content);
-                final String name = (String) virtualFile.getMethod("getName").invoke(content);
-                java.io.File file = new java.io.File(physicalFile.getParentFile(), name);
-                if (!file.exists() || !file.canRead()) {
-                    file = physicalFile;
-                }
-                return file.isDirectory() ? new Vfs.SystemDir(file) : new Vfs.ZipDir(new JarFile(file));
-            }
-        },
-
-        jboss_vfsfile {
-            @Override
-            public boolean matches(final URL url) {
-                return "vfszip".equals(url.getProtocol()) || "vfsfile".equals(url.getProtocol());
-            }
-
-            @Override
-            public Vfs.Dir createDir(final URL url) {
-                return new Vfs.UrlTypeVFS().createDir(url);
-            }
-        },
-
-        bundle {
-            @Override
-            public boolean matches(final URL url) {
-                return url.getProtocol().startsWith("bundle");
-            }
-
-            @Override
-            public Vfs.Dir createDir(final URL url) throws Exception {
-                return fromURL((URL) ClasspathHelper.contextClassLoader().
-                    loadClass("org.eclipse.core.runtime.FileLocator").getMethod("resolve", URL.class).invoke(null, url));
-            }
-        },
-
-        jarInputStream {
-            @Override
-            public boolean matches(final URL url) {
-                return url.toExternalForm().contains(".jar");
-            }
-
-            @Override
-            public Vfs.Dir createDir(final URL url) {
-                return new Vfs.JarInputDir(url);
-            }
-        }
-    }
-
-    private static final class JarInputDir implements Vfs.Dir {
-        private final URL url;
-        JarInputStream jarInputStream;
-        long cursor;
-        long nextCursor;
-
-        public JarInputDir(final URL url) {
-            this.url = url;
-        }
-
-        @Override
-        public String getPath() {
-            return url.getPath();
-        }
-
-        @Override
-        public Iterable<Vfs.File> getFiles() {
-            return () -> new AbstractIterator<Vfs.File>() {
-
-                {
-                    try {
-                        jarInputStream = new JarInputStream(url.openConnection().getInputStream());
-                    } catch (final Exception e) {
-                        throw new ReflectionsException("Could not open url connection", e);
-                    }
-                }
-
-                @Override
-                protected Vfs.File computeNext() {
-                    while (true) {
-                        try {
-                            final ZipEntry entry = jarInputStream.getNextJarEntry();
-                            if (entry == null) {
-                                return endOfData();
-                            }
-
-                            long size = entry.getSize();
-                            if (size < 0) {
-                                size = 0xffffffffl + size; //JDK-6916399
-                            }
-                            nextCursor += size;
-                            if (!entry.isDirectory()) {
-                                return new Vfs.JarInputFile(entry, Vfs.JarInputDir.this, cursor, nextCursor);
-                            }
-                        } catch (final IOException e) {
-                            throw new ReflectionsException("could not get next zip entry", e);
-                        }
-                    }
-                }
-            };
-        }
-
-        @Override
-        public void close() {
-            Utils.close(jarInputStream);
-        }
-    }
-
-    public static class JarInputFile implements Vfs.File {
-        private final ZipEntry entry;
-        private final Vfs.JarInputDir jarInputDir;
-        private final long fromIndex;
-        private final long endIndex;
-
-        public JarInputFile(final ZipEntry entry, final Vfs.JarInputDir jarInputDir, final long cursor, final long nextCursor) {
-            this.entry = entry;
-            this.jarInputDir = jarInputDir;
-            fromIndex = cursor;
-            endIndex = nextCursor;
-        }
-
-        @Override
-        public String getName() {
-            final String name = entry.getName();
-            return name.substring(name.lastIndexOf("/") + 1);
-        }
-
-        @Override
-        public String getRelativePath() {
-            return entry.getName();
-        }
-
-        @Override
-        public InputStream openInputStream() {
-            return new InputStream() {
-                @Override
-                public int read() throws IOException {
-                    if (jarInputDir.cursor >= fromIndex && jarInputDir.cursor <= endIndex) {
-                        final int read = jarInputDir.jarInputStream.read();
-                        jarInputDir.cursor++;
-                        return read;
-                    } else {
-                        return -1;
-                    }
-                }
-            };
-        }
-    }
-
-    public static final class ZipDir implements Vfs.Dir {
-        final java.util.zip.ZipFile jarFile;
-
-        public ZipDir(final JarFile jarFile) {
-            this.jarFile = jarFile;
-        }
-
-        @Override
-        public String getPath() {
-            return jarFile.getName();
-        }
-
-        @Override
-        public Iterable<Vfs.File> getFiles() {
-            return () -> new AbstractIterator<Vfs.File>() {
-                final Enumeration<? extends ZipEntry> entries = jarFile.entries();
-
-                @Override
-                protected Vfs.File computeNext() {
-                    while (entries.hasMoreElements()) {
-                        final ZipEntry entry = entries.nextElement();
-                        if (!entry.isDirectory()) {
-                            return new Vfs.ZipFile(Vfs.ZipDir.this, entry);
-                        }
-                    }
-
-                    return endOfData();
-                }
-            };
-        }
-
-        @Override
-        public void close() {
-            try {
-                jarFile.close();
-            } catch (final IOException e) {
-            }
-        }
-
-        @Override
-        public String toString() {
-            return jarFile.getName();
-        }
-    }
-
-    public static final class ZipFile implements Vfs.File {
-        private final Vfs.ZipDir root;
-        private final ZipEntry entry;
-
-        public ZipFile(final Vfs.ZipDir root, final ZipEntry entry) {
-            this.root = root;
-            this.entry = entry;
-        }
-
-        @Override
-        public String getName() {
-            final String name = entry.getName();
-            return name.substring(name.lastIndexOf("/") + 1);
-        }
-
-        @Override
-        public String getRelativePath() {
-            return entry.getName();
-        }
-
-        @Override
-        public InputStream openInputStream() throws IOException {
-            return root.jarFile.getInputStream(entry);
-        }
-
-        @Override
-        public String toString() {
-            return root.getPath() + "!" + java.io.File.separatorChar + entry.toString();
-        }
-    }
-
-    public static final class SystemDir implements Vfs.Dir {
-        private final java.io.File file;
-
-        public SystemDir(final java.io.File file) {
-            if (file != null && (!file.isDirectory() || !file.canRead())) {
-                throw new RuntimeException("cannot use dir " + file);
-            }
-
-            this.file = file;
-        }
-
-        @Override
-        public String getPath() {
-            if (file == null) {
-                return "/NO-SUCH-DIRECTORY/";
-            }
-            return file.getPath().replace("\\", "/");
-        }
-
-        @Override
-        public Iterable<Vfs.File> getFiles() {
-            if (file == null || !file.exists()) {
-                return Collections.emptyList();
-            }
-            return () -> new AbstractIterator<Vfs.File>() {
-                final Stack<java.io.File> stack = new Stack<>();
-
-                {
-                    stack.addAll(listFiles(file));
-                }
-
-                @Override
-                protected Vfs.File computeNext() {
-                    while (!stack.isEmpty()) {
-                        final java.io.File file = stack.pop();
-                        if (file.isDirectory()) {
-                            stack.addAll(listFiles(file));
-                        } else {
-                            return new Vfs.SystemFile(Vfs.SystemDir.this, file);
-                        }
-                    }
-
-                    return endOfData();
-                }
-            };
-        }
-
-        private static List<java.io.File> listFiles(final java.io.File file) {
-            final java.io.File[] files = file.listFiles();
-
-            if (files != null) {
-                return Lists.newArrayList(files);
-            } else {
-                return Lists.newArrayList();
-            }
-        }
-
-        @Override
-        public void close() {
-        }
-
-        @Override
-        public String toString() {
-            return getPath();
-        }
-    }
-
-    private static final class UrlTypeVFS implements Vfs.UrlType {
-        public static final String[] REPLACE_EXTENSION = {".ear/", ".jar/", ".war/", ".sar/", ".har/", ".par/"};
-
-        final String VFSZIP = "vfszip";
-        final String VFSFILE = "vfsfile";
-
-        @Override
-        public boolean matches(final URL url) {
-            return VFSZIP.equals(url.getProtocol()) || VFSFILE.equals(url.getProtocol());
-        }
-
-        @Override
-        public Vfs.Dir createDir(final URL url) {
-            try {
-                final URL adaptedUrl = adaptURL(url);
-                return new Vfs.ZipDir(new JarFile(adaptedUrl.getFile()));
-            } catch (final Exception e) {
-                try {
-                    return new Vfs.ZipDir(new JarFile(url.getFile()));
-                } catch (final IOException e1) {
-                }
-            }
-            return null;
-        }
-
-        public URL adaptURL(final URL url) throws MalformedURLException {
-            if (VFSZIP.equals(url.getProtocol())) {
-                return replaceZipSeparators(url.getPath(), realFile);
-            } else if (VFSFILE.equals(url.getProtocol())) {
-                return new URL(url.toString().replace(VFSFILE, "file"));
-            } else {
-                return url;
-            }
-        }
-
-        URL replaceZipSeparators(final String path, final Predicate<java.io.File> acceptFile)
-            throws MalformedURLException {
-            int pos = 0;
-            while (pos != -1) {
-                pos = findFirstMatchOfDeployableExtention(path, pos);
-
-                if (pos > 0) {
-                    final java.io.File file = new java.io.File(path.substring(0, pos - 1));
-                    if (acceptFile.apply(file)) {
-                        return replaceZipSeparatorStartingFrom(path, pos);
-                    }
-                }
-            }
-
-            throw new ReflectionsException("Unable to identify the real zip file in path '" + path + "'.");
-        }
-
-        int findFirstMatchOfDeployableExtention(final String path, final int pos) {
-            final Pattern p = Pattern.compile("\\.[ejprw]ar/");
-            final Matcher m = p.matcher(path);
-            if (m.find(pos)) {
-                return m.end();
-            } else {
-                return -1;
-            }
-        }
-
-        Predicate<java.io.File> realFile = file -> file.exists() && file.isFile();
-
-        URL replaceZipSeparatorStartingFrom(final String path, final int pos)
-            throws MalformedURLException {
-            final String zipFile = path.substring(0, pos - 1);
-            String zipPath = path.substring(pos);
-
-            int numSubs = 1;
-            for (final String ext : REPLACE_EXTENSION) {
-                while (zipPath.contains(ext)) {
-                    zipPath = zipPath.replace(ext, ext.substring(0, 4) + "!");
-                    numSubs++;
-                }
-            }
-
-            String prefix = "";
-            for (int i = 0; i < numSubs; i++) {
-                prefix += "zip:";
-            }
-
-            if (zipPath.trim().length() == 0) {
-                return new URL(prefix + "/" + zipFile);
-            } else {
-                return new URL(prefix + "/" + zipFile + "!" + zipPath);
-            }
-        }
-    }
-
-    private static final class SystemFile implements Vfs.File {
-        private final Vfs.SystemDir root;
-        private final java.io.File file;
-
-        public SystemFile(final Vfs.SystemDir root, final java.io.File file) {
-            this.root = root;
-            this.file = file;
-        }
-
-        @Override
-        public String getName() {
-            return file.getName();
-        }
-
-        @Override
-        public String getRelativePath() {
-            final String filepath = file.getPath().replace("\\", "/");
-            if (filepath.startsWith(root.getPath())) {
-                return filepath.substring(root.getPath().length() + 1);
-            }
-
-            return null; //should not get here
-        }
-
-        @Override
-        public InputStream openInputStream() {
-            try {
-                return new FileInputStream(file);
-            } catch (final FileNotFoundException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        @Override
-        public String toString() {
-            return file.toString();
-        }
-    }
-}
diff --git a/qa/integration/specs/monitoring_api_spec.rb b/qa/integration/specs/monitoring_api_spec.rb
index a82af052044..c40e5302b18 100644
--- a/qa/integration/specs/monitoring_api_spec.rb
+++ b/qa/integration/specs/monitoring_api_spec.rb
@@ -129,7 +129,7 @@
       result = logstash_service.monitoring_api.logging_get
       result["loggers"].each do | k, v |
         #since we explicitly set the logstash.agent logger above, the logger.logstash parent logger will not take precedence
-        if k.eql?("logstash.agent") || k.start_with?("org.logstash")
+        if k.eql?("logstash.agent") || k.start_with?("org.logstash") || k.eql?("org.reflections.Reflections")
           expect(v).to eq("INFO")
         else
           expect(v).to eq("ERROR")
