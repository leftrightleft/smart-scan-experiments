diff --git a/logstash-core/lib/logstash/api/lib/helpers/app_helpers.rb b/logstash-core/lib/logstash/api/app_helpers.rb
similarity index 100%
rename from logstash-core/lib/logstash/api/lib/helpers/app_helpers.rb
rename to logstash-core/lib/logstash/api/app_helpers.rb
diff --git a/logstash-core/lib/logstash/api/command_factory.rb b/logstash-core/lib/logstash/api/command_factory.rb
new file mode 100644
index 00000000000..df26ccad546
--- /dev/null
+++ b/logstash-core/lib/logstash/api/command_factory.rb
@@ -0,0 +1,34 @@
+# encoding: utf-8
+require "logstash/api/service"
+require "logstash/api/commands/system/basicinfo_command"
+require "logstash/api/commands/system/plugins_command"
+require "logstash/api/commands/stats"
+
+
+module LogStash
+  module Api
+    class CommandFactory
+      attr_reader :factory, :service
+
+      def initialize(service)
+        @service = service
+        @factory = {
+          :system_basic_info => ::LogStash::Api::Commands::System::BasicInfo,
+          :plugins_command => ::LogStash::Api::Commands::System::Plugins,
+          :stats => ::LogStash::Api::Commands::Stats
+        }
+      end
+
+      def build(*klass_path)
+        # Get a nested path with args like (:parent, :child)
+        klass = klass_path.reduce(factory) {|acc,v| acc[v]}
+
+        if klass
+          klass.new(service)
+        else
+          raise ArgumentError, "Class path '#{klass_path}' does not map to command!"
+        end
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/commands/base.rb b/logstash-core/lib/logstash/api/commands/base.rb
new file mode 100644
index 00000000000..1ca1d879832
--- /dev/null
+++ b/logstash-core/lib/logstash/api/commands/base.rb
@@ -0,0 +1,25 @@
+module LogStash
+  module Api
+    module Commands
+      class Base
+        attr_reader :service
+        
+        def initialize(service = LogStash::Api::Service.instance)
+          @service = service
+        end
+
+        def hostname
+          service.agent.node_name
+        end
+
+        def uptime
+          service.agent.uptime
+        end
+
+        def started_at
+          (LogStash::Agent::STARTED_AT.to_f * 1000.0).to_i
+        end
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/commands/stats.rb b/logstash-core/lib/logstash/api/commands/stats.rb
new file mode 100644
index 00000000000..6d4ef2430fc
--- /dev/null
+++ b/logstash-core/lib/logstash/api/commands/stats.rb
@@ -0,0 +1,105 @@
+require "logstash/api/commands/base"
+require 'logstash/util/thread_dump'
+
+module LogStash
+  module Api
+    module Commands
+      class Stats < Commands::Base
+
+        def jvm
+          {:threads => service.get_shallow(:jvm, :threads)}
+        end
+
+        def process
+          service.get_shallow(:jvm, :process)
+        end
+
+        def events
+          service.get_shallow(:stats, :events)
+        end
+
+        def memory
+          memory = LogStash::Json.load(service.get(:jvm_memory_stats))
+          {
+            :heap_used_in_bytes => memory["heap"]["used_in_bytes"],
+            :heap_used_percent => memory["heap"]["used_percent"],
+            :heap_committed_in_bytes => memory["heap"]["committed_in_bytes"],
+            :heap_max_in_bytes => memory["heap"]["max_in_bytes"],
+            :heap_used_in_bytes => memory["heap"]["used_in_bytes"],
+            :non_heap_used_in_bytes => memory["non_heap"]["used_in_bytes"],
+            :non_heap_committed_in_bytes => memory["non_heap"]["committed_in_bytes"],
+            :pools => memory["pools"].inject({}) do |acc, (type, hash)|
+              hash.delete("committed_in_bytes")
+              acc[type] = hash
+              acc
+            end
+          }
+        end
+
+        def hot_threads(options={})
+          HotThreadsReport.new(self, options)
+        end
+
+        class HotThreadsReport
+          HOT_THREADS_STACK_TRACES_SIZE_DEFAULT = 10.freeze
+          
+          def initialize(cmd, options)
+            @cmd = cmd
+            filter = { :stacktrace_size => options.fetch(:stacktrace_size, HOT_THREADS_STACK_TRACES_SIZE_DEFAULT) }
+            jr_dump = JRMonitor.threads.generate(filter)
+            @thread_dump = ::LogStash::Util::ThreadDump.new(options.merge(:dump => jr_dump))
+          end
+          
+          def to_s
+            hash = to_hash
+            report =  "#{I18n.t("logstash.web_api.hot_threads.title", :hostname => hash[:hostname], :time => hash[:time], :top_count => @thread_dump.top_count )} \n"
+            report << '=' * 80
+            report << "\n"
+            hash[:threads].each do |thread|
+              thread_report = ""
+              thread_report = "#{I18n.t("logstash.web_api.
+                                hot_threads.thread_title", :percent_of_cpu_time => thread[:percent_of_cpu_time], :thread_state => thread[:state], :thread_name => thread[:name])} \n"
+              thread_report = "#{thread[:percent_of_cpu_time]} % of of cpu usage by #{thread[:state]} thread named '#{thread[:name]}'\n"
+              thread_report << "#{thread[:path]}\n" if thread[:path]
+              thread[:traces].each do |trace|
+                thread_report << "\t#{trace}\n"
+              end
+              report << thread_report
+              report << '-' * 80
+              report << "\n"
+            end
+            report
+          end
+
+          def to_hash
+            hash = { :hostname => @cmd.hostname, :time => Time.now.iso8601, :busiest_threads => @thread_dump.top_count, :threads => [] }
+            @thread_dump.each do |thread_name, _hash|
+              thread_name, thread_path = _hash["thread.name"].split(": ")
+              thread = { :name => thread_name,
+                         :percent_of_cpu_time => cpu_time_as_percent(_hash),
+                         :state => _hash["thread.state"]
+                       }
+              thread[:path] = thread_path if thread_path
+              traces = []
+              _hash["thread.stacktrace"].each do |trace|
+                traces << trace
+              end
+              thread[:traces] = traces unless traces.empty?
+              hash[:threads] << thread
+            end
+            hash
+          end
+
+          def cpu_time_as_percent(hash)
+            (((cpu_time(hash) / @cmd.uptime * 1.0)*10000).to_i)/100.0
+          end
+
+          def cpu_time(hash)
+            hash["cpu.time"] / 1000000.0
+          end
+
+        end       
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/commands/system/basicinfo_command.rb b/logstash-core/lib/logstash/api/commands/system/basicinfo_command.rb
new file mode 100644
index 00000000000..7a32073990e
--- /dev/null
+++ b/logstash-core/lib/logstash/api/commands/system/basicinfo_command.rb
@@ -0,0 +1,23 @@
+# encoding: utf-8
+require 'logstash/api/commands/base'
+require "logstash/util/duration_formatter"
+
+module LogStash
+  module Api
+    module Commands
+      module System
+        class BasicInfo < Commands::Base
+
+          def run
+            {
+              "hostname" => hostname,
+              "version" => {
+                "number" => LOGSTASH_VERSION
+              }
+            }
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/commands/system/plugins_command.rb b/logstash-core/lib/logstash/api/commands/system/plugins_command.rb
new file mode 100644
index 00000000000..f787f9aff9b
--- /dev/null
+++ b/logstash-core/lib/logstash/api/commands/system/plugins_command.rb
@@ -0,0 +1,35 @@
+# encoding: utf-8
+require "logstash/api/commands/base"
+
+module LogStash
+  module Api
+    module Commands
+      module System
+        class Plugins < Commands::Base
+          def run
+            { :total => plugins.count, :plugins => plugins }
+          end
+
+          private
+
+          def plugins
+            @plugins ||= find_plugins_gem_specs.map do |spec|
+              { :name => spec.name, :version => spec.version.to_s }
+            end.sort_by do |spec|
+              spec[:name]
+            end
+          end
+
+          def find_plugins_gem_specs
+            @specs ||= Gem::Specification.find_all.select{|spec| logstash_plugin_gem_spec?(spec)}
+          end
+
+          def logstash_plugin_gem_spec?(spec)
+            spec.metadata && spec.metadata["logstash_plugin"] == "true"
+          end
+
+        end
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/init.ru b/logstash-core/lib/logstash/api/init.ru
deleted file mode 100644
index 720541e82ee..00000000000
--- a/logstash-core/lib/logstash/api/init.ru
+++ /dev/null
@@ -1,31 +0,0 @@
-api_root = File.expand_path(File.dirname(__FILE__))
-$LOAD_PATH.unshift File.join(api_root, 'lib')
-Dir.glob('lib/**').each{ |d| $LOAD_PATH.unshift(File.join(api_root, d)) }
-
-require 'sinatra'
-require 'app/root'
-require 'app/modules/stats'
-require 'app/modules/node'
-require 'app/modules/node_stats'
-require 'app/modules/plugins'
-
-env = ENV["RACK_ENV"].to_sym
-set :environment, env
-
-set :service, LogStash::Api::Service.instance
-
-configure do
-  enable :logging
-end
-run LogStash::Api::Root
-
-namespaces = { "/_node" => LogStash::Api::Node,
-               "/_node/stats" => LogStash::Api::NodeStats,
-               "/_stats" => LogStash::Api::Stats,
-               "/_plugins" => LogStash::Api::Plugins }
-
-namespaces.each_pair do |namespace, app|
-  map(namespace) do
-    run app
-  end
-end
diff --git a/logstash-core/lib/logstash/api/lib/app.rb b/logstash-core/lib/logstash/api/lib/app.rb
deleted file mode 100644
index 72946ec6707..00000000000
--- a/logstash-core/lib/logstash/api/lib/app.rb
+++ /dev/null
@@ -1,40 +0,0 @@
-# encoding: utf-8
-require "cabin"
-require "logstash/json"
-require "helpers/app_helpers"
-require "app/service"
-require "app/command_factory"
-require "logstash/util/loggable"
-
-module LogStash::Api
-  class BaseApp < ::Sinatra::Application
-
-    attr_reader :factory
-
-    if settings.environment != :production
-      set :raise_errors, true
-      set :show_exceptions, :after_handler
-    end
-
-    include LogStash::Util::Loggable
-
-    helpers AppHelpers
-
-    def initialize(app=nil)
-      super(app)
-      @factory = CommandFactory.new(settings.service)
-    end
-
-    not_found do
-      status 404
-      as   = params.has_key?("human") ? :string : :json
-      text = as == :string ? "" : {}
-      respond_with(text, :as => as)
-    end
-
-    error do
-      logger.error(env['sinatra.error'].message, :url => request.url, :ip => request.ip, :params => request.params)
-    end
-
-  end
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/command.rb b/logstash-core/lib/logstash/api/lib/app/command.rb
deleted file mode 100644
index 75d8f958c6b..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/command.rb
+++ /dev/null
@@ -1,29 +0,0 @@
-# encoding: utf-8
-require "app/service"
-
-module LogStash::Api
-  class Command
-
-    attr_reader :service
-
-    def initialize(service = LogStash::Api::Service.instance)
-      @service = service
-    end
-
-    def run
-      raise "Not implemented"
-    end
-
-    def hostname
-      service.agent.node_name
-    end
-
-    def uptime
-      service.agent.uptime
-    end
-
-    def started_at
-      (LogStash::Agent::STARTED_AT.to_f * 1000.0).to_i
-    end
-  end
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/command_factory.rb b/logstash-core/lib/logstash/api/lib/app/command_factory.rb
deleted file mode 100644
index 29e71e6c4f7..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/command_factory.rb
+++ /dev/null
@@ -1,29 +0,0 @@
-# encoding: utf-8
-require "app/service"
-require "app/commands/system/basicinfo_command"
-require "app/commands/stats/events_command"
-require "app/commands/stats/hotthreads_command"
-require "app/commands/stats/memory_command"
-require "app/commands/system/plugins_command"
-
-module LogStash::Api
-  class CommandFactory
-
-    attr_reader :factory, :service
-
-    def initialize(service)
-      @service = service
-      @factory = {}.merge(
-        :system_basic_info => SystemBasicInfoCommand,
-        :events_command => StatsEventsCommand,
-        :hot_threads_command => HotThreadsCommand,
-        :memory_command => JvmMemoryCommand,
-        :plugins_command => PluginsCommand
-      )
-    end
-
-    def build(klass)
-      factory[klass].new(service)
-    end
-  end
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/commands/stats/events_command.rb b/logstash-core/lib/logstash/api/lib/app/commands/stats/events_command.rb
deleted file mode 100644
index 78337364548..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/commands/stats/events_command.rb
+++ /dev/null
@@ -1,13 +0,0 @@
-# encoding: utf-8
-require "app/command"
-
-class LogStash::Api::StatsEventsCommand < LogStash::Api::Command
-
-  def run
-    #return whatever is comming out of the snapshot event, this obvoiusly
-    #need to be tailored to the right metrics for this command.
-    stats =  LogStash::Json.load(service.get(:events_stats))
-    stats["stats"]["events"]
-  end
-
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/commands/stats/hotthreads_command.rb b/logstash-core/lib/logstash/api/lib/app/commands/stats/hotthreads_command.rb
deleted file mode 100644
index 0c3f4ee2ef7..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/commands/stats/hotthreads_command.rb
+++ /dev/null
@@ -1,120 +0,0 @@
-# encoding: utf-8
-require "app/command"
-require 'monitoring'
-require "socket"
-
-class LogStash::Api::HotThreadsCommand < LogStash::Api::Command
-
-  STACK_TRACES_SIZE_DEFAULT = 10.freeze
-
-  def run(options={})
-    filter = { :stacktrace_size => options.fetch(:stacktrace_size, STACK_TRACES_SIZE_DEFAULT) }
-    hash   = JRMonitor.threads.generate(filter)
-    ThreadDump.new(hash, self, options)
-  end
-
-  private
-
-  class ThreadDump
-
-    SKIPPED_THREADS             = [ "Finalizer", "Reference Handler", "Signal Dispatcher" ].freeze
-    THREADS_COUNT_DEFAULT       = 3.freeze
-    IGNORE_IDLE_THREADS_DEFAULT = true.freeze
-
-    attr_reader :top_count, :ignore, :dump
-
-    def initialize(dump, cmd, options={})
-      @dump      = dump
-      @options   = options
-      @top_count = options.fetch(:threads, THREADS_COUNT_DEFAULT)
-      @ignore    = options.fetch(:ignore_idle_threads, IGNORE_IDLE_THREADS_DEFAULT)
-      @cmd       = cmd
-    end
-
-    def to_s
-      hash = to_hash
-      report =  "#{I18n.t("logstash.web_api.hot_threads.title", :hostname => hash[:hostname], :time => hash[:time], :top_count => top_count )} \n"
-      hash[:threads].each do |thread|
-        thread_report = ""
-        thread_report = "\t #{I18n.t("logstash.web_api.hot_threads.thread_title", :percent_of_cpu_time => thread[:percent_of_cpu_time], :thread_state => thread[:state], :thread_name => thread[:name])} \n"
-        thread_report = "\t #{thread[:percent_of_cpu_time]} % of of cpu usage by #{thread[:state]} thread named '#{thread[:name]}'\n"
-        thread_report << "\t\t #{thread[:path]}\n" if thread[:path]
-        thread[:traces].split("\n").each do |trace|
-          thread_report << "#{trace}\n"
-        end
-        report << thread_report
-      end
-      report
-    end
-
-    def to_hash
-      hash = { :hostname => hostname, :time => Time.now.iso8601, :busiest_threads => top_count, :threads => [] }
-      each do |thread_name, _hash|
-        thread_name, thread_path = _hash["thread.name"].split(": ")
-        thread = { :name => thread_name,
-                   :percent_of_cpu_time => cpu_time_as_percent(_hash),
-                   :state => _hash["thread.state"]
-        }
-        thread[:path] = thread_path if thread_path
-        traces = ""
-        _hash["thread.stacktrace"].each do |trace|
-          traces << "\t\t#{trace}\n"
-        end
-        thread[:traces] = traces unless traces.empty?
-        hash[:threads] << thread
-      end
-      hash
-    end
-
-    private
-
-    def each(&block)
-      i=0
-      dump.each_pair do |thread_name, _hash|
-        break if i >= top_count
-        if ignore
-          next if idle_thread?(thread_name, _hash)
-        end
-        block.call(thread_name, _hash)
-        i += 1
-      end
-    end
-
-    def idle_thread?(thread_name, data)
-      idle = false
-      if SKIPPED_THREADS.include?(thread_name)
-        # these are likely JVM dependent
-        idle = true
-      elsif thread_name.match(/Ruby-\d+-JIT-\d+/)
-        # This are internal JRuby JIT threads, 
-        # see java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor for details.
-        idle = true
-      elsif thread_name.match(/pool-\d+-thread-\d+/)
-        # This are threads used by the internal JRuby implementation to dispatch
-        # calls and tasks, see prg.jruby.internal.runtime.methods.DynamicMethod.call
-        idle = true
-      else
-        data["thread.stacktrace"].each do |trace|
-          if trace.start_with?("java.util.concurrent.ThreadPoolExecutor.getTask")
-            idle = true
-            break
-          end
-        end
-      end
-      idle
-    end
-
-    def hostname
-      @cmd.hostname
-    end
-
-    def cpu_time_as_percent(hash)
-      (((cpu_time(hash) / @cmd.uptime * 1.0)*10000).to_i)/100.0
-    end
-
-    def cpu_time(hash)
-      hash["cpu.time"] / 1000000.0
-    end
-  end
-
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/commands/stats/memory_command.rb b/logstash-core/lib/logstash/api/lib/app/commands/stats/memory_command.rb
deleted file mode 100644
index b6aa34f5d42..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/commands/stats/memory_command.rb
+++ /dev/null
@@ -1,25 +0,0 @@
-# encoding: utf-8
-require "app/command"
-require 'monitoring'
-
-class LogStash::Api::JvmMemoryCommand < LogStash::Api::Command
-
-  def run
-    memory = LogStash::Json.load(service.get(:jvm_memory_stats))
-    {
-      :heap_used_in_bytes => memory["heap"]["used_in_bytes"],
-      :heap_used_percent => memory["heap"]["used_percent"],
-      :heap_committed_in_bytes => memory["heap"]["committed_in_bytes"],
-      :heap_max_in_bytes => memory["heap"]["max_in_bytes"],
-      :heap_used_in_bytes => memory["heap"]["used_in_bytes"],
-      :non_heap_used_in_bytes => memory["non_heap"]["used_in_bytes"],
-      :non_heap_committed_in_bytes => memory["non_heap"]["committed_in_bytes"],
-      :pools => memory["pools"].inject({}) do |acc, (type, hash)|
-          hash.delete("committed_in_bytes")
-          acc[type] = hash
-          acc
-    end
-    }
-  end
-
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/commands/system/basicinfo_command.rb b/logstash-core/lib/logstash/api/lib/app/commands/system/basicinfo_command.rb
deleted file mode 100644
index 0822f54fb6a..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/commands/system/basicinfo_command.rb
+++ /dev/null
@@ -1,15 +0,0 @@
-# encoding: utf-8
-require "app/command"
-require "logstash/util/duration_formatter"
-
-class LogStash::Api::SystemBasicInfoCommand < LogStash::Api::Command
-
-  def run
-    {
-      "hostname" => hostname,
-      "version" => {
-        "number" => LOGSTASH_VERSION
-      }
-    }
-  end
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/commands/system/plugins_command.rb b/logstash-core/lib/logstash/api/lib/app/commands/system/plugins_command.rb
deleted file mode 100644
index 07623283ecc..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/commands/system/plugins_command.rb
+++ /dev/null
@@ -1,28 +0,0 @@
-# encoding: utf-8
-require "app/command"
-
-class LogStash::Api::PluginsCommand < LogStash::Api::Command
-
-  def run
-    { :total => plugins.count, :plugins => plugins }
-  end
-
-  private
-
-  def plugins
-    @plugins ||= find_plugins_gem_specs.map do |spec|
-      { :name => spec.name, :version => spec.version.to_s }
-    end.sort_by do |spec|
-      spec[:name]
-    end
-  end
-
-  def find_plugins_gem_specs
-    @specs ||= Gem::Specification.find_all.select{|spec| logstash_plugin_gem_spec?(spec)}
-  end
-
-  def logstash_plugin_gem_spec?(spec)
-    spec.metadata && spec.metadata["logstash_plugin"] == "true"
-  end
-
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/modules/node.rb b/logstash-core/lib/logstash/api/lib/app/modules/node.rb
deleted file mode 100644
index 3edfb0de5a1..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/modules/node.rb
+++ /dev/null
@@ -1,25 +0,0 @@
-# encoding: utf-8
-require "app"
-
-module LogStash::Api
-  class Node < BaseApp
-
-    helpers AppHelpers
-
-    # return hot threads information
-    get "/hot_threads" do
-      ignore_idle_threads = params["ignore_idle_threads"] || true
-
-      options = {
-        :ignore_idle_threads => as_boolean(ignore_idle_threads),
-        :human => params.has_key?("human")
-      }
-      options[:threads] = params["threads"].to_i if params.has_key?("threads")
-
-      command = factory.build(:hot_threads_command)
-      as    = options[:human] ? :string : :json
-      respond_with(command.run(options), {:as => as})
-    end
-
-  end
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/modules/node_stats.rb b/logstash-core/lib/logstash/api/lib/app/modules/node_stats.rb
deleted file mode 100644
index 8317cad3369..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/modules/node_stats.rb
+++ /dev/null
@@ -1,51 +0,0 @@
-# encoding: utf-8
-require "app"
-
-module LogStash::Api
-  class NodeStats < BaseApp
-
-    helpers AppHelpers
-
-
-    # Global _stats resource where all information is 
-    # retrieved and show
-    get "/" do
-      events_command = factory.build(:events_command)
-      payload = {
-        :events => events_command.run,
-        :jvm => jvm_payload
-      }
-
-      respond_with payload
-    end
-
-    # Show all events stats information
-    # (for ingested, emitted, dropped)
-    # - #events since startup
-    # - #data (bytes) since startup
-    # - events/s
-    # - bytes/s
-    # - dropped events/s
-    # - events in the pipeline
-    get "/events" do
-      command = factory.build(:events_command)
-      respond_with({ :events => command.run })
-    end
-
-    # return hot threads information
-    get "/jvm" do
-      respond_with jvm_payload
-    end
-
-    private
-
-    def jvm_payload
-      command = factory.build(:memory_command)
-      {
-        :timestamp => command.started_at,
-        :uptime_in_millis => command.uptime,
-        :mem => command.run
-      }
-    end
-  end
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/modules/plugins.rb b/logstash-core/lib/logstash/api/lib/app/modules/plugins.rb
deleted file mode 100644
index 93a94bf76c3..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/modules/plugins.rb
+++ /dev/null
@@ -1,15 +0,0 @@
-# encoding: utf-8
-require "app"
-
-module LogStash::Api
-  class Plugins < BaseApp
-
-    helpers AppHelpers
-
-    get "/" do
-      command = factory.build(:plugins_command)
-      respond_with(command.run())
-    end
-
-  end
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/modules/stats.rb b/logstash-core/lib/logstash/api/lib/app/modules/stats.rb
deleted file mode 100644
index ed3aa54f789..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/modules/stats.rb
+++ /dev/null
@@ -1,21 +0,0 @@
-# encoding: utf-8
-require "app"
-
-module LogStash::Api
-  class Stats < BaseApp
-
-    helpers AppHelpers
-
-    # return hot threads information
-    get "/jvm" do
-      command = factory.build(:memory_command)
-      jvm_payload = {
-        :timestamp => command.started_at,
-        :uptime_in_millis => command.uptime,
-        :mem => command.run
-      }
-      respond_with({:jvm => jvm_payload})
-    end
-
-  end
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/root.rb b/logstash-core/lib/logstash/api/lib/app/root.rb
deleted file mode 100644
index 75a0ba6be67..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/root.rb
+++ /dev/null
@@ -1,13 +0,0 @@
-# encoding: utf-8
-require "app"
-
-module LogStash::Api
-  class Root < BaseApp
-
-    get "/" do
-      command = factory.build(:system_basic_info)
-      respond_with command.run
-    end
-
-  end
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/service.rb b/logstash-core/lib/logstash/api/lib/app/service.rb
deleted file mode 100644
index 87ab8a5d16f..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/service.rb
+++ /dev/null
@@ -1,61 +0,0 @@
-# encoding: utf-8
-require "logstash/instrument/collector"
-require "logstash/util/loggable"
-
-class LogStash::Api::Service
-
-  include Singleton
-  include LogStash::Util::Loggable
-
-  def initialize
-    @snapshot_rotation_mutex = Mutex.new
-    @snapshot = nil
-    logger.debug("[api-service] start") if logger.debug?
-    LogStash::Instrument::Collector.instance.add_observer(self)
-  end
-
-  def stop
-    logger.debug("[api-service] stop") if logger.debug?
-    LogStash::Instrument::Collector.instance.delete_observer(self)
-  end
-
-  def agent
-    LogStash::Instrument::Collector.instance.agent
-  end
-
-  def started?
-    !@snapshot.nil? && has_counters?
-  end
-
-  def update(snapshot)
-    logger.debug("[api-service] snapshot received", :snapshot_time => snapshot.created_at) if logger.debug?
-    if @snapshot_rotation_mutex.try_lock
-      @snapshot = snapshot
-      @snapshot_rotation_mutex.unlock
-    end
-  end
-
-  def get(key)
-    metric_store = @snapshot.metric_store
-    if key == :jvm_memory_stats
-      data = metric_store.get_with_path("jvm/memory")[:jvm][:memory]
-    else
-      data = metric_store.get_with_path("stats/events")
-    end
-    LogStash::Json.dump(data)
-  end
-
-  private
-
-  def has_counters?
-    (["LogStash::Instrument::MetricType::Counter", "LogStash::Instrument::MetricType::Gauge"] - metric_types).empty?
-  end
-
-  def metric_types
-    types = []
-    @snapshot_rotation_mutex.synchronize do
-      types = @snapshot.metric_store.all.map { |t| t.class.to_s }
-    end
-    return types
-  end
-end
diff --git a/logstash-core/lib/logstash/api/lib/app/stats.rb b/logstash-core/lib/logstash/api/lib/app/stats.rb
deleted file mode 100644
index 2d3f9a4f08b..00000000000
--- a/logstash-core/lib/logstash/api/lib/app/stats.rb
+++ /dev/null
@@ -1,56 +0,0 @@
-# encoding: utf-8
-require "app"
-require "app/stats/events_command"
-require "app/stats/hotthreads_command"
-
-module LogStash::Api
-  class Stats < BaseApp
-
-    helpers AppHelpers
-
-
-    # Global _stats resource where all information is 
-    # retrieved and show
-    get "/" do
-      events_command = factory.build(:events_command)
-      memory_command = factory.build(:memory_command)
-      payload = {
-        :events => events_command.run,
-        :jvm => { :memory => memory_command.run }
-      }
-      respond_with payload
-    end
-
-    # Show all events stats information
-    # (for ingested, emitted, dropped)
-    # - #events since startup
-    # - #data (bytes) since startup
-    # - events/s
-    # - bytes/s
-    # - dropped events/s
-    # - events in the pipeline
-    get "/events" do
-      command = factory.build(:events_command)
-      respond_with({ :events => command.run })
-    end
-
-    # return hot threads information
-    get "/jvm/hot_threads" do
-      top_threads_count = params["threads"] || 3
-      ignore_idle_threads = params["ignore_idle_threads"] || true
-      options = {
-        :threads => top_threads_count.to_i,
-        :ignore_idle_threads => as_boolean(ignore_idle_threads)
-      }
-      command = factory.build(:hot_threads_command)
-      respond_with(command.run(options), :string)
-    end
-
-    # return hot threads information
-    get "/jvm/memory" do
-      command = factory.build(:memory_command)
-      respond_with({ :memory => command.run })
-    end
-
-  end
-end
diff --git a/logstash-core/lib/logstash/api/modules/base.rb b/logstash-core/lib/logstash/api/modules/base.rb
new file mode 100644
index 00000000000..022e697ded9
--- /dev/null
+++ b/logstash-core/lib/logstash/api/modules/base.rb
@@ -0,0 +1,41 @@
+require "logstash/api/app_helpers"
+require "logstash/api/command_factory"
+
+module LogStash
+  module Api
+    module Modules
+      class Base < ::Sinatra::Base
+        helpers AppHelpers
+
+        attr_reader :factory
+
+        if settings.environment != :production
+          set :raise_errors, true
+          set :show_exceptions, :after_handler
+        end
+
+        include LogStash::Util::Loggable
+
+        helpers AppHelpers
+
+        def initialize(app=nil)
+          super(app)
+          @factory = ::LogStash::Api::CommandFactory.new(LogStash::Api::Service.instance)
+        end
+
+        not_found do
+          status 404
+          as   = params.has_key?("human") ? :string : :json
+          text = as == :string ? "" : {}
+          respond_with(text, :as => as)
+        end
+
+        error do
+          e = env['sinatra.error']
+          logger.error(e.message, :url => request.url, :ip => request.ip, :params => request.params, :class => e.class.name, :backtrace => e.backtrace)
+        end
+
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/modules/node.rb b/logstash-core/lib/logstash/api/modules/node.rb
new file mode 100644
index 00000000000..931b2152c38
--- /dev/null
+++ b/logstash-core/lib/logstash/api/modules/node.rb
@@ -0,0 +1,24 @@
+# encoding: utf-8
+module LogStash
+  module Api
+    module Modules
+      class Node < ::LogStash::Api::Modules::Base
+        # return hot threads information
+        get "/hot_threads" do
+          ignore_idle_threads = params["ignore_idle_threads"] || true
+
+          options = {
+            :ignore_idle_threads => as_boolean(ignore_idle_threads),
+            :human => params.has_key?("human")
+          }
+          options[:threads] = params["threads"].to_i if params.has_key?("threads")
+
+          stats = factory.build(:stats)
+          as    = options[:human] ? :string : :json
+          respond_with(stats.hot_threads(options), {:as => as})
+        end
+
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/modules/node_stats.rb b/logstash-core/lib/logstash/api/modules/node_stats.rb
new file mode 100644
index 00000000000..a744eb8ee33
--- /dev/null
+++ b/logstash-core/lib/logstash/api/modules/node_stats.rb
@@ -0,0 +1,59 @@
+# encoding: utf-8
+module LogStash
+  module Api
+    module Modules
+      class NodeStats < ::LogStash::Api::Modules::Base
+        
+        before do
+          @stats = factory.build(:stats)
+        end
+
+        # Global _stats resource where all information is
+        # retrieved and show
+        get "/" do          
+          payload = {
+            :events => events_payload,
+            :jvm => jvm_payload,
+            :process => process_payload
+          }
+
+          respond_with payload
+        end
+
+        # Show all events stats information
+        # (for ingested, emitted, dropped)
+        # - #events since startup
+        # - #data (bytes) since startup
+        # - events/s
+        # - bytes/s
+        # - dropped events/s
+        # - events in the pipeline
+        get "/events" do
+          respond_with({ :events => events_payload })
+        end
+
+        get "/jvm" do
+          respond_with :jvm => jvm_payload
+        end
+
+        get "/process" do
+          respond_with :process => process_payload
+        end
+
+        private
+
+        def events_payload
+          @stats.events
+        end
+
+        def jvm_payload
+          @stats.jvm
+        end
+
+        def process_payload
+          @stats.process
+        end
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/modules/plugins.rb b/logstash-core/lib/logstash/api/modules/plugins.rb
new file mode 100644
index 00000000000..7edd3da154a
--- /dev/null
+++ b/logstash-core/lib/logstash/api/modules/plugins.rb
@@ -0,0 +1,15 @@
+# encoding: utf-8
+module LogStash
+  module Api
+    module Modules
+      class Plugins < ::LogStash::Api::Modules::Base
+
+        get "/" do
+          command = factory.build(:plugins_command)
+          respond_with(command.run())
+        end
+
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/modules/root.rb b/logstash-core/lib/logstash/api/modules/root.rb
new file mode 100644
index 00000000000..66dc4d8730b
--- /dev/null
+++ b/logstash-core/lib/logstash/api/modules/root.rb
@@ -0,0 +1,15 @@
+# encoding: utf-8
+module LogStash
+  module Api
+    module Modules
+      class Root < ::LogStash::Api::Modules::Base
+        
+        get "/" do
+          command = factory.build(:system_basic_info)
+          respond_with command.run
+        end
+        
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/modules/stats.rb b/logstash-core/lib/logstash/api/modules/stats.rb
new file mode 100644
index 00000000000..fde364f2432
--- /dev/null
+++ b/logstash-core/lib/logstash/api/modules/stats.rb
@@ -0,0 +1,63 @@
+# encoding: utf-8
+module LogStash
+  module Api
+    module Modules
+      class Stats < ::LogStash::Api::Modules::Base
+
+        def stats_command
+          factory.build(:stats)
+        end
+
+        # Global _stats resource where all information is 
+        # retrieved and show
+        get "/" do
+          payload = {
+            :events => stats_command.events,
+            :jvm => { :memory => stats_command.memory }
+          }
+          respond_with payload
+        end
+
+
+        # return hot threads information
+        get "/jvm" do
+          jvm_payload = {
+            :timestamp => stats_command.started_at,
+            :uptime_in_millis => stats_command.uptime,
+            :mem => stats_command.memory
+          }
+          respond_with({:jvm => jvm_payload})
+        end
+
+        # Show all events stats information
+        # (for ingested, emitted, dropped)
+        # - #events since startup
+        # - #data (bytes) since startup
+        # - events/s
+        # - bytes/s
+        # - dropped events/s
+        # - events in the pipeline
+        get "/events" do
+          respond_with({ :events => stats_command.events })
+        end
+
+        # return hot threads information
+        get "/jvm/hot_threads" do
+          top_threads_count = params["threads"] || 3
+          ignore_idle_threads = params["ignore_idle_threads"] || true
+          options = {
+            :threads => top_threads_count.to_i,
+            :ignore_idle_threads => as_boolean(ignore_idle_threads)
+          }
+
+          respond_with(stats_command.hot_threads(options))
+        end
+
+        # return hot threads information
+        get "/jvm/memory" do
+          respond_with({ :memory => stats_command.memory })
+        end
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/rack_app.rb b/logstash-core/lib/logstash/api/rack_app.rb
new file mode 100644
index 00000000000..5624d1c3516
--- /dev/null
+++ b/logstash-core/lib/logstash/api/rack_app.rb
@@ -0,0 +1,33 @@
+require "logstash/api/modules/base"
+require "logstash/api/modules/node"
+require "logstash/api/modules/node_stats"
+require "logstash/api/modules/plugins"
+require "logstash/api/modules/root"
+require "logstash/api/modules/stats"
+
+module LogStash
+  module Api
+    module RackApp
+      def self.app
+        namespaces = rack_namespaces 
+        Rack::Builder.new do
+          run LogStash::Api::Modules::Root
+          namespaces.each_pair do |namespace, app|
+            map(namespace) do
+              run app
+            end
+          end
+        end
+      end
+
+      def self.rack_namespaces
+        {
+          "/_node" => LogStash::Api::Modules::Node,
+          "/_stats" => LogStash::Api::Modules::Stats,
+          "/_node/stats" => LogStash::Api::Modules::NodeStats,
+          "/_plugins" => LogStash::Api::Modules::Plugins
+        }
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/api/service.rb b/logstash-core/lib/logstash/api/service.rb
new file mode 100644
index 00000000000..799e802b6f9
--- /dev/null
+++ b/logstash-core/lib/logstash/api/service.rb
@@ -0,0 +1,73 @@
+# encoding: utf-8
+require "logstash/instrument/collector"
+require "logstash/util/loggable"
+
+module LogStash
+  module Api
+    class Service
+
+      include Singleton
+      include LogStash::Util::Loggable
+
+      def initialize
+        @snapshot_rotation_mutex = Mutex.new
+        @snapshot = nil
+        logger.debug("[api-service] start") if logger.debug?
+        LogStash::Instrument::Collector.instance.add_observer(self)
+      end
+
+      def stop
+        logger.debug("[api-service] stop") if logger.debug?
+        LogStash::Instrument::Collector.instance.delete_observer(self)
+      end
+
+      def agent
+        LogStash::Instrument::Collector.instance.agent
+      end
+
+      def started?
+        !@snapshot.nil? && has_counters?
+      end
+
+      def update(snapshot)
+        logger.debug("[api-service] snapshot received", :snapshot_time => snapshot.created_at) if logger.debug?
+
+        @snapshot_rotation_mutex.synchronize do
+          @snapshot = snapshot
+        end
+      end
+
+      def snapshot
+        @snapshot_rotation_mutex.synchronize { @snapshot }
+      end
+
+      def get_shallow(*path)
+        snapshot.metric_store.get_shallow(*path)
+      end
+
+      def get(key)
+        metric_store = @snapshot_rotation_mutex.synchronize { @snapshot.metric_store }
+        if key == :jvm_memory_stats
+          data = metric_store.get_shallow(:jvm, :memory)
+        else
+          data = metric_store.get_with_path("stats/events")
+        end
+        LogStash::Json.dump(data)
+      end
+
+      private
+
+      def has_counters?
+        (["LogStash::Instrument::MetricType::Counter", "LogStash::Instrument::MetricType::Gauge"] - metric_types).empty?
+      end
+
+      def metric_types
+        types = []
+        @snapshot_rotation_mutex.synchronize do
+          types = @snapshot.metric_store.all.map { |t| t.class.to_s }
+        end
+        return types
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/instrument/metric_store.rb b/logstash-core/lib/logstash/instrument/metric_store.rb
index 664624296c7..653f6774440 100644
--- a/logstash-core/lib/logstash/instrument/metric_store.rb
+++ b/logstash-core/lib/logstash/instrument/metric_store.rb
@@ -86,7 +86,7 @@ def get_with_path(path)
 
     # Similar to `get_with_path` but use symbols instead of string
     #
-    # @param [Array<Symbol>
+    # @param [Array<Symbol>]
     # @return [Hash]
     def get(*key_paths)
       # Normalize the symbols access
@@ -100,6 +100,16 @@ def get(*key_paths)
       new_hash
     end
 
+    # Retrieve values like `get`, but don't return them fully nested.
+    # This means that if you call `get_shallow(:foo, :bar)` the result will not
+    # be nested inside of `{:foo {:bar => values}`.
+    #
+    # @param [Array<Symbol>]
+    # @return [Hash]
+    def get_shallow(*key_paths)
+      key_paths.reduce(get(*key_paths)) {|acc, p| acc[p]}
+    end
+
     # Return all the individuals Metric,
     # This call mimic a Enum's each if a block is provided
     #
diff --git a/logstash-core/lib/logstash/instrument/periodic_poller/base.rb b/logstash-core/lib/logstash/instrument/periodic_poller/base.rb
index 1834c3342f5..313f52b2504 100644
--- a/logstash-core/lib/logstash/instrument/periodic_poller/base.rb
+++ b/logstash-core/lib/logstash/instrument/periodic_poller/base.rb
@@ -37,6 +37,8 @@ def start
       logger.debug("PeriodicPoller: Starting",
                    :polling_interval => @options[:polling_interval],
                    :polling_timeout => @options[:polling_timeout]) if logger.debug?
+      
+      collect # Collect data right away if possible
       @task.execute
     end
 
diff --git a/logstash-core/lib/logstash/instrument/periodic_poller/jvm.rb b/logstash-core/lib/logstash/instrument/periodic_poller/jvm.rb
index 3b85d92efa6..6cd6495d49f 100644
--- a/logstash-core/lib/logstash/instrument/periodic_poller/jvm.rb
+++ b/logstash-core/lib/logstash/instrument/periodic_poller/jvm.rb
@@ -1,6 +1,15 @@
+
 # encoding: utf-8
 require "logstash/instrument/periodic_poller/base"
-require 'monitoring'
+require 'jrmonitor'
+
+java_import 'java.lang.management.ManagementFactory'
+java_import 'java.lang.management.OperatingSystemMXBean'
+java_import 'com.sun.management.UnixOperatingSystemMXBean'
+java_import 'javax.management.MBeanServer'
+java_import 'javax.management.ObjectName'
+java_import 'javax.management.AttributeList'
+java_import 'javax.naming.directory.Attribute'
 
 module LogStash module Instrument module PeriodicPoller
   class JVM < Base
@@ -13,14 +22,50 @@ def initialize(metric, options = {})
     end
 
     def collect
-      raw = JRMonitor.memory.generate
+      raw = JRMonitor.memory.generate      
       collect_heap_metrics(raw)
       collect_non_heap_metrics(raw)
       collect_pools_metrics(raw)
+      collect_threads_metrics
+      collect_process_metrics
     end
 
     private
 
+    def collect_threads_metrics      
+      threads = JRMonitor.threads.generate
+      
+      current = threads.count
+      if @peak_threads.nil? || @peak_threads < current
+        @peak_threads = current
+      end      
+      
+      metric.gauge([:jvm, :threads], :count, threads.count)     
+      metric.gauge([:jvm, :threads], :peak_count, @peak_threads)
+    end
+
+    def collect_process_metrics
+      process_metrics = JRMonitor.process.generate
+      
+      path = [:jvm, :process]
+
+
+      open_fds = process_metrics["open_file_descriptors"]
+      if @peak_open_fds.nil? || open_fds > @peak_open_fds
+        @peak_open_fds = open_fds
+      end
+      metric.gauge(path, :open_file_descriptors, open_fds)
+      metric.gauge(path, :peak_open_file_descriptors, @peak_open_fds)
+      metric.gauge(path, :max_file_descriptors, process_metrics["max_file_descriptors"])
+
+      cpu_path = path + [:cpu]
+      cpu_metrics = process_metrics["cpu"]
+      metric.gauge(cpu_path, :percent, cpu_metrics["process_percent"])
+      metric.gauge(cpu_path, :total_in_millis, cpu_metrics["total_in_millis"])
+
+      metric.gauge(path + [:mem], :total_virtual_in_bytes, process_metrics["mem"]["total_virtual_in_bytes"])
+    end
+
     def collect_heap_metrics(data)
       heap = aggregate_information_for(data["heap"].values)
       heap[:used_percent] = (heap[:used_in_bytes] / heap[:max_in_bytes].to_f)*100.0
diff --git a/logstash-core/lib/logstash/util/thread_dump.rb b/logstash-core/lib/logstash/util/thread_dump.rb
new file mode 100644
index 00000000000..11d1a8da066
--- /dev/null
+++ b/logstash-core/lib/logstash/util/thread_dump.rb
@@ -0,0 +1,55 @@
+# encoding: utf-8
+module LogStash
+  module Util
+    class ThreadDump
+      SKIPPED_THREADS             = [ "Finalizer", "Reference Handler", "Signal Dispatcher" ].freeze
+      THREADS_COUNT_DEFAULT       = 3.freeze
+      IGNORE_IDLE_THREADS_DEFAULT = true.freeze
+
+      attr_reader :top_count, :ignore, :dump
+
+      def initialize(options={})
+        @options   = options
+        @dump = options.fetch(:dump, JRMonitor.threads.generate({}))
+        @top_count = options.fetch(:threads, THREADS_COUNT_DEFAULT)
+        @ignore    = options.fetch(:ignore_idle_threads, IGNORE_IDLE_THREADS_DEFAULT)
+      end
+
+      def each(&block)
+        i=0
+        dump.each_pair do |thread_name, _hash|
+          break if i >= top_count
+          if ignore
+            next if idle_thread?(thread_name, _hash)
+          end
+          block.call(thread_name, _hash)
+          i += 1
+        end
+      end
+
+      def idle_thread?(thread_name, data)
+        idle = false
+        if SKIPPED_THREADS.include?(thread_name)
+          # these are likely JVM dependent
+          idle = true
+        elsif thread_name.match(/Ruby-\d+-JIT-\d+/)
+          # This are internal JRuby JIT threads, 
+          # see java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor for details.
+          idle = true
+        elsif thread_name.match(/pool-\d+-thread-\d+/)
+          # This are threads used by the internal JRuby implementation to dispatch
+          # calls and tasks, see prg.jruby.internal.runtime.methods.DynamicMethod.call
+          idle = true
+        else
+          data["thread.stacktrace"].each do |trace|
+            if trace.start_with?("java.util.concurrent.ThreadPoolExecutor.getTask")
+              idle = true
+              break
+            end
+          end
+        end
+        idle
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/webserver.rb b/logstash-core/lib/logstash/webserver.rb
index 23bcaf0b576..9fbd9718b32 100644
--- a/logstash-core/lib/logstash/webserver.rb
+++ b/logstash-core/lib/logstash/webserver.rb
@@ -1,16 +1,15 @@
 # encoding: utf-8
 require "puma"
-require "puma/single"
-require "puma/binder"
-require "puma/configuration"
-require "puma/commonlogger"
+require "puma/server"
+require "sinatra"
+require "rack"
+require "logstash/api/rack_app"
 
 module LogStash 
   class WebServer
-
     extend Forwardable
 
-    attr_reader :logger, :status, :config, :options, :cli_options, :runner, :binder, :events
+    attr_reader :logger, :status, :config, :options, :cli_options, :runner, :binder, :events, :http_host, :http_port
 
     def_delegator :@runner, :stats
 
@@ -19,8 +18,8 @@ class WebServer
 
     def initialize(logger, options={})
       @logger      = logger
-      http_host    = options[:http_host] || DEFAULT_HOST
-      http_port    = options[:http_port] || DEFAULT_PORT
+      @http_host    = options[:http_host] || DEFAULT_HOST
+      @http_port    = options[:http_port] || DEFAULT_PORT
       @options     = {}
       @cli_options = options.merge({ :rackup => ::File.join(::File.dirname(__FILE__), "api", "init.ru"),
                                      :binds => ["tcp://#{http_host}:#{http_port}"],
@@ -31,24 +30,17 @@ def initialize(logger, options={})
                                      :queue_requests => false
       })
       @status      = nil
-
-      parse_options
-
-      @runner  = nil
-      @events  = ::Puma::Events.strings
-      @binder  = ::Puma::Binder.new(@events)
-      @binder.import_from_env
-
-      set_environment
     end
 
     def run
       log "=== puma start: #{Time.now} ==="
 
-      @runner = Puma::Single.new(self)
-      @status = :run
-      @runner.run
-      stop(:graceful => true)
+      stop # Just in case
+
+      @server = ::Puma::Server.new(LogStash::Api::RackApp.app)
+      @server.add_tcp_listener(http_host, http_port)
+
+      @server.run.join
     end
 
     def log(str)
@@ -58,7 +50,7 @@ def log(str)
     def error(str)
       logger.error(str)
     end
-
+    
     # Empty method, this method is required because of the puma usage we make through
     # the Single interface, https://github.com/puma/puma/blob/master/lib/puma/single.rb#L82
     # for more details. This can always be implemented when we want to keep track of this
@@ -66,33 +58,7 @@ def error(str)
     def write_state; end
 
     def stop(options={})
-      graceful = options.fetch(:graceful, true)
-
-      if graceful
-        @runner.stop_blocked
-      else
-        @runner.stop
-      end rescue nil
-
-      @status = :stop
-      log "=== puma shutdown: #{Time.now} ==="
-    end
-
-    private
-
-    def env
-      @options[:debug] ? "development" : "production"
-    end
-
-    def set_environment
-      @options[:environment] = env
-      ENV['RACK_ENV']        = env
-    end
-
-    def parse_options
-      @config  = ::Puma::Configuration.new(cli_options)
-      @config.load
-      @options = @config.options
+      @server.stop(true) if @server
     end
   end
 end
diff --git a/logstash-core/locales/en.yml b/logstash-core/locales/en.yml
index c963a064d4c..ed38a34f968 100644
--- a/logstash-core/locales/en.yml
+++ b/logstash-core/locales/en.yml
@@ -1,6 +1,6 @@
 # YAML notes
 #   |- means 'scalar block' useful for formatted text
-#   > means 'scalar block' but it chomps all newlines. Useful 
+#   > means 'scalar block' but it chomps all newlines. Useful
 #     for unformatted text.
 en:
   oops: |-
@@ -76,7 +76,7 @@ en:
       hot_threads:
         title: |-
           ::: {%{hostname}}
-            Hot threads at %{time}, busiestThreads=%{top_count}:
+          Hot threads at %{time}, busiestThreads=%{top_count}:
         thread_title: |-
             %{percent_of_cpu_time} % of cpu usage by %{thread_state} thread named '%{thread_name}'
     runner:
@@ -141,18 +141,18 @@ en:
           after %{after}
         invalid_plugin_register: >-
           Cannot register %{plugin} %{type} plugin.
-          The error reported is: 
+          The error reported is:
             %{error}
         plugin_path_missing: >-
           You specified a plugin path that does not exist: %{path}
         no_plugins_found: |-
           Could not find any plugins in "%{path}"
-          I tried to find files matching the following, but found none: 
+          I tried to find files matching the following, but found none:
             %{plugin_glob}
         log_file_failed: |-
           Failed to open %{path} for writing: %{error}
 
-          This is often a permissions issue, or the wrong 
+          This is often a permissions issue, or the wrong
           path was specified?
       flag:
         # Note: Wrap these at 55 chars so they display nicely when clamp emits
diff --git a/logstash-core/logstash-core.gemspec b/logstash-core/logstash-core.gemspec
index b88fac568a0..fc621bc702a 100644
--- a/logstash-core/logstash-core.gemspec
+++ b/logstash-core/logstash-core.gemspec
@@ -27,10 +27,10 @@ Gem::Specification.new do |gem|
   gem.add_runtime_dependency "gems", "~> 0.8.3"  #(MIT license)
   gem.add_runtime_dependency "concurrent-ruby", "1.0.0"
   gem.add_runtime_dependency "sinatra", '~> 1.4', '>= 1.4.6'
-  gem.add_runtime_dependency 'puma', '~> 2.16', '>= 2.16.0'
+  gem.add_runtime_dependency 'puma', '~> 3.4.0'
   gem.add_runtime_dependency "jruby-openssl", "0.9.16" # >= 0.9.13 Required to support TLSv1.2
   gem.add_runtime_dependency "chronic_duration", "0.10.6"
-  gem.add_runtime_dependency "jruby-monitoring", '~> 0.3.1'
+  gem.add_runtime_dependency "jrmonitor", '~> 0.4.2'
 
   # TODO(sissel): Treetop 1.5.x doesn't seem to work well, but I haven't
   # investigated what the cause might be. -Jordan
diff --git a/logstash-core/spec/api/lib/api/node_spec.rb b/logstash-core/spec/api/lib/api/node_spec.rb
index 119fca23ed2..3fc6ad97752 100644
--- a/logstash-core/spec/api/lib/api/node_spec.rb
+++ b/logstash-core/spec/api/lib/api/node_spec.rb
@@ -1,10 +1,10 @@
 # encoding: utf-8
 require_relative "../../spec_helper"
 require "sinatra"
-require "app/modules/node"
+require "logstash/api/modules/node"
 require "logstash/json"
 
-describe LogStash::Api::Node do
+describe LogStash::Api::Modules::Node do
 
   include Rack::Test::Methods
 
diff --git a/logstash-core/spec/api/lib/api/node_stats_spec.rb b/logstash-core/spec/api/lib/api/node_stats_spec.rb
index c90d167e3a7..03bf7fd6152 100644
--- a/logstash-core/spec/api/lib/api/node_stats_spec.rb
+++ b/logstash-core/spec/api/lib/api/node_stats_spec.rb
@@ -1,68 +1,43 @@
 # encoding: utf-8
 require_relative "../../spec_helper"
 require "sinatra"
-require "app/modules/node_stats"
+require "logstash/api/modules/node_stats"
 require "logstash/json"
 
-describe LogStash::Api::NodeStats do
-
+describe LogStash::Api::Modules::NodeStats do
   include Rack::Test::Methods
+  extend ResourceDSLMethods
 
-  def app()
+  def app() # Used by Rack::Test::Methods
     described_class
   end
 
-  let(:payload) { LogStash::Json.load(last_response.body) }
-
-  context "#root" do
-
-    before(:all) do
-      do_request { get "/" }
-    end
-
-    it "respond OK" do
-      expect(last_response).to be_ok
-    end
-
-    ["events", "jvm"].each do |key|
-      it "contains #{key} information" do
-        expect(payload).to include(key)
-      end
-    end
-  end
-
-  context "#events" do
-
-    let(:payload) { LogStash::Json.load(last_response.body) }
-
-    before(:all) do
-      do_request { get "/events" }
-    end
-
-    it "respond OK" do
-      expect(last_response).to be_ok
-    end
-
-    it "contains events information" do
-      expect(payload).to include("events")
-    end
-  end
-
-  context "#jvm" do
-
-    let(:payload) { LogStash::Json.load(last_response.body) }
-
-    before(:all) do
-      do_request { get "/jvm" }
-    end
-
-    it "respond OK" do
-      expect(last_response).to be_ok
-    end
-
-    it "contains memory information" do
-      expect(payload).to include("mem")
-    end
-  end
-
+  # DSL describing response structure
+  root_structure = {
+    "events"=>{
+      "in"=>Numeric,
+      "filtered"=>Numeric,
+      "out"=>Numeric
+    },
+    "jvm"=>{
+      "threads"=>{
+        "count"=>Numeric,
+        "peak_count"=>Numeric
+      }
+    },
+    "process"=>{
+      "peak_open_file_descriptors"=>Numeric,
+      "max_file_descriptors"=>Numeric,
+      "open_file_descriptors"=>Numeric,
+      "mem"=>{
+        "total_virtual_in_bytes"=>Numeric
+      },
+      "cpu"=>{
+        "total_in_millis"=>Numeric,
+        "percent"=>Numeric
+      }
+    }
+  }
+
+  test_api_and_resources(root_structure)
 end
diff --git a/logstash-core/spec/api/lib/api/plugins_spec.rb b/logstash-core/spec/api/lib/api/plugins_spec.rb
index 4e0aa66b48b..6e646827244 100644
--- a/logstash-core/spec/api/lib/api/plugins_spec.rb
+++ b/logstash-core/spec/api/lib/api/plugins_spec.rb
@@ -1,10 +1,10 @@
 # encoding: utf-8
 require_relative "../../spec_helper"
 require "sinatra"
-require "app/modules/plugins"
+require "logstash/api/modules/plugins"
 require "logstash/json"
 
-describe LogStash::Api::Plugins do
+describe LogStash::Api::Modules::Plugins do
 
   include Rack::Test::Methods
 
diff --git a/logstash-core/spec/api/lib/api/root_spec.rb b/logstash-core/spec/api/lib/api/root_spec.rb
index 6bc8a4937b6..2395c9edc5d 100644
--- a/logstash-core/spec/api/lib/api/root_spec.rb
+++ b/logstash-core/spec/api/lib/api/root_spec.rb
@@ -1,10 +1,10 @@
 # encoding: utf-8
 require_relative "../../spec_helper"
 require "sinatra"
-require "app/root"
+require "logstash/api/modules/root"
 require "logstash/json"
 
-describe LogStash::Api::Root do
+describe LogStash::Api::Modules::Root do
 
   include Rack::Test::Methods
 
diff --git a/logstash-core/spec/api/lib/api/stats_spec.rb b/logstash-core/spec/api/lib/api/stats_spec.rb
deleted file mode 100644
index 8dfd2617b42..00000000000
--- a/logstash-core/spec/api/lib/api/stats_spec.rb
+++ /dev/null
@@ -1,19 +0,0 @@
-# encoding: utf-8
-require_relative "../../spec_helper"
-require "sinatra"
-require "app/modules/stats"
-
-describe LogStash::Api::Stats do
-
-  include Rack::Test::Methods
-
-  def app()
-    described_class
-  end
-
-  it "respond to the jvm resource" do
-    do_request { get "/jvm" }
-    expect(last_response).to be_ok
-  end
-
-end
diff --git a/logstash-core/spec/api/lib/api/support/resource_dsl_methods.rb b/logstash-core/spec/api/lib/api/support/resource_dsl_methods.rb
new file mode 100644
index 00000000000..786a37f984a
--- /dev/null
+++ b/logstash-core/spec/api/lib/api/support/resource_dsl_methods.rb
@@ -0,0 +1,47 @@
+module ResourceDSLMethods
+  # Convert a nested hash to a mapping of key paths to expected classes
+  def hash_to_mapping(h, path=[], mapping={})
+    h.each do |k,v|
+      if v.is_a?(Hash)
+        hash_to_mapping(v, path + [k], mapping)
+      else
+        full_path = path + [k]
+        mapping[full_path] = v
+      end
+    end
+    mapping
+  end
+
+  def test_api(expected, path)
+    context "GET #{path}" do
+      let(:payload) { LogStash::Json.load(last_response.body) }
+      
+      before(:all) do
+        do_request { get path }
+      end      
+      
+      it "should respond OK" do
+        expect(last_response).to be_ok
+      end
+      
+      hash_to_mapping(expected).each do |path,klass|
+        dotted = path.join(".")
+        
+        it "should set '#{dotted}' to be a '#{klass}'" do
+          path_value = path.reduce(payload) {|acc,v| acc[v]}
+          expect(path_value).to be_a(klass), "could not find '#{dotted}' in #{payload}"
+        end
+      end
+    end
+
+    yield if block_given? # Add custom expectations
+  end
+
+  def test_api_and_resources(expected)
+    test_api(expected, "/")
+
+    expected.keys.each do |key|
+      test_api({key => expected[key]}, "/#{key}")
+    end
+  end
+end
diff --git a/logstash-core/spec/api/lib/commands/events_spec.rb b/logstash-core/spec/api/lib/commands/events_spec.rb
deleted file mode 100644
index 9bbcc3e7aa8..00000000000
--- a/logstash-core/spec/api/lib/commands/events_spec.rb
+++ /dev/null
@@ -1,17 +0,0 @@
-# encoding: utf-8
-require_relative "../../spec_helper"
-require "app/commands/stats/events_command"
-
-describe LogStash::Api::StatsEventsCommand do
-
-  context "#schema" do
-
-    let(:report) do
-      do_request { subject.run }
-    end
-
-    it "return events information" do
-      expect(report).to include("in", "filtered", "out")
-    end
-  end
-end
diff --git a/logstash-core/spec/api/lib/commands/jvm_spec.rb b/logstash-core/spec/api/lib/commands/jvm_spec.rb
deleted file mode 100644
index e3f01d00aaf..00000000000
--- a/logstash-core/spec/api/lib/commands/jvm_spec.rb
+++ /dev/null
@@ -1,45 +0,0 @@
-# encoding: utf-8
-require_relative "../../spec_helper"
-require "app/commands/stats/hotthreads_command"
-require "app/commands/stats/memory_command"
-
-describe "JVM stats" do
-
-  describe LogStash::Api::HotThreadsCommand do
-
-    let(:report) do
-      do_request { subject.run }
-    end
-
-    context "#schema" do
-      it "return hot threads information" do
-        report = do_request { subject.run }
-        expect(report.to_s).not_to be_empty
-      end
-
-    end
-  end
-
-  describe LogStash::Api::JvmMemoryCommand do
-
-    context "#schema" do
-
-      let(:report) do
-        do_request { subject.run }
-      end
-
-      it "return hot threads information" do
-        expect(report).not_to be_empty
-      end
-
-      it "return heap information" do
-        expect(report.keys).to include(:heap_used_in_bytes)
-      end
-
-      it "return non heap information" do
-        expect(report.keys).to include(:non_heap_used_in_bytes)
-      end
-
-    end
-  end
-end
diff --git a/logstash-core/spec/api/lib/commands/stats.rb b/logstash-core/spec/api/lib/commands/stats.rb
new file mode 100644
index 00000000000..3059e1460f3
--- /dev/null
+++ b/logstash-core/spec/api/lib/commands/stats.rb
@@ -0,0 +1,47 @@
+# encoding: utf-8
+require_relative "../../spec_helper"
+
+describe LogStash::Api::Commands::Stats do
+
+  let(:report_method) { :run }
+  subject(:report) { do_request { report_class.new.send(report_method) } }
+
+  let(:report_class) { described_class }
+
+  describe "#events" do
+    let(:report_method) { :events }
+
+    it "return events information" do
+      expect(report.keys).to include(:in, :filtered, :out)
+    end
+  end
+  
+  describe "#hot_threads" do
+    let(:report_method) { :hot_threads }
+    
+    it "should return hot threads information as a string" do
+      expect(report.to_s).to be_a(String)
+    end
+
+    it "should return hot threads info as a hash" do
+      expect(report.to_hash).to be_a(Hash)
+    end
+  end
+
+  describe "memory stats" do
+    let(:report_method) { :memory }
+      
+    it "return hot threads information" do
+      expect(report).not_to be_empty
+    end
+
+    it "return heap information" do
+      expect(report.keys).to include(:heap_used_in_bytes)
+    end
+
+    it "return non heap information" do
+      expect(report.keys).to include(:non_heap_used_in_bytes)
+    end
+
+  end
+end
diff --git a/logstash-core/spec/api/spec_helper.rb b/logstash-core/spec/api/spec_helper.rb
index 190eca38d93..4149bd3956c 100644
--- a/logstash-core/spec/api/spec_helper.rb
+++ b/logstash-core/spec/api/spec_helper.rb
@@ -2,16 +2,13 @@
 API_ROOT = File.expand_path(File.join(File.dirname(__FILE__), "..", "..", "lib", "logstash", "api"))
 
 require "logstash/devutils/rspec/spec_helper"
+require "api/lib/api/support/resource_dsl_methods"
 
 require "logstash/settings"
 require 'rack/test'
 require 'rspec'
 require "json"
 
-ENV['RACK_ENV'] = 'test'
-
-Rack::Builder.parse_file(File.join(API_ROOT, 'init.ru'))
-
 def read_fixture(name)
   path = File.join(File.dirname(__FILE__), "fixtures", name)
   File.read(path)
@@ -80,7 +77,7 @@ def wait_until_snapshot_received
 
 ##
 # Method used to wrap up a request in between of a running
-# pipeline, this makes the hole execution model easier and
+# pipeline, this makes the whole execution model easier and
 # more contained as some threads might go wild.
 ##
 def do_request(&block)
diff --git a/logstash-core/spec/logstash/instrument/periodic_poller/jvm_spec.rb b/logstash-core/spec/logstash/instrument/periodic_poller/jvm_spec.rb
new file mode 100644
index 00000000000..649e711d119
--- /dev/null
+++ b/logstash-core/spec/logstash/instrument/periodic_poller/jvm_spec.rb
@@ -0,0 +1,45 @@
+require 'spec_helper'
+require 'logstash/instrument/periodic_poller/jvm'
+
+describe LogStash::Instrument::PeriodicPoller::JVM do
+  let(:metric) { LogStash::Instrument::Metric.new }
+  let(:options) { {} }
+  subject(:jvm) { described_class.new(metric, options) }
+  
+  it "should initialize cleanly" do
+    expect { jvm }.not_to raise_error
+  end
+
+  describe "collections" do
+    subject(:collection) { jvm.collect }
+    
+    it "should run cleanly" do
+      expect { collection }.not_to raise_error
+    end
+
+    describe "metrics" do
+      let(:snapshot_store) { metric.collector.snapshot_metric.metric_store }
+      subject(:jvm_metrics) { snapshot_store.get_shallow(:jvm, :process) }
+
+      # Make looking up metric paths easy when given varargs of keys
+      # e.g. mval(:parent, :child)
+      def mval(*metric_path)
+        metric_path.reduce(jvm_metrics) {|acc,k| acc[k]}.value
+      end          
+
+      [
+        :max_file_descriptors,
+        :open_file_descriptors,
+        :peak_open_file_descriptors,
+        [:mem, :total_virtual_in_bytes],
+        [:cpu, :total_in_millis],
+        [:cpu, :percent]
+      ].each do |path|
+        path = Array(path)
+        it "should have a value for #{path} that is Numeric" do
+          expect(mval(*path)).to be_a(Numeric)
+        end
+      end
+    end
+  end
+end
