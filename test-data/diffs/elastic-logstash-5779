diff --git a/logstash-core/lib/logstash/config/coercers/array.rb b/logstash-core/lib/logstash/config/coercers/array.rb
new file mode 100644
index 00000000000..4fc25fc7061
--- /dev/null
+++ b/logstash-core/lib/logstash/config/coercers/array.rb
@@ -0,0 +1,15 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+module LogStash::Config
+  module TypeCoercers
+    module Array
+
+      def self.coerce(value)
+        return value if value.is_a?(::Array)
+        Array(value)
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/coercers/boolean.rb b/logstash-core/lib/logstash/config/coercers/boolean.rb
new file mode 100644
index 00000000000..942b53a9e9e
--- /dev/null
+++ b/logstash-core/lib/logstash/config/coercers/boolean.rb
@@ -0,0 +1,18 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+module LogStash::Config
+  module TypeCoercers
+    module Boolean
+
+      def self.coerce(value)
+        return value if [TrueClass, FalseClass].include?(value.class)
+
+        return true if value =~ (/^(true|t|yes|y|1)$/i)
+        return false if value.empty? || value =~ (/^(false|f|no|n|0)$/i)
+        return value
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/coercers/bytes.rb b/logstash-core/lib/logstash/config/coercers/bytes.rb
new file mode 100644
index 00000000000..4c47fcf6b94
--- /dev/null
+++ b/logstash-core/lib/logstash/config/coercers/bytes.rb
@@ -0,0 +1,15 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+module LogStash::Config
+  module TypeCoercers
+    module Bytes
+
+      def self.coerce(value)
+        bytes = Integer(value) rescue nil
+        bytes || Filesize.from(value).to_i
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/coercers/codec.rb b/logstash-core/lib/logstash/config/coercers/codec.rb
new file mode 100644
index 00000000000..518cab9de61
--- /dev/null
+++ b/logstash-core/lib/logstash/config/coercers/codec.rb
@@ -0,0 +1,18 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+module LogStash::Config
+  module TypeCoercers
+    module Codec
+
+      def self.coerce(value)
+        if value.is_a?(String)
+          return LogStash::Plugin.lookup("codec", value).new
+        else
+          return value
+        end
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/coercers/hash.rb b/logstash-core/lib/logstash/config/coercers/hash.rb
new file mode 100644
index 00000000000..19cf85fabc5
--- /dev/null
+++ b/logstash-core/lib/logstash/config/coercers/hash.rb
@@ -0,0 +1,28 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+module LogStash::Config
+  module TypeCoercers
+    module Hash
+
+      def self.coerce(value)
+        return value if !value.is_a?(::Enumerable) || value.is_a?(::Hash)
+        result = {}
+        value.each_slice(2) do |key, _value|
+          entry = result[key]
+          if entry.nil?
+            result[key] = _value
+          else
+            if entry.is_a?(::Array)
+              entry << _value
+            else
+              result[key] = [entry, _value]
+            end
+          end
+        end
+        result
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/coercers/null.rb b/logstash-core/lib/logstash/config/coercers/null.rb
new file mode 100644
index 00000000000..fb365cbcbd7
--- /dev/null
+++ b/logstash-core/lib/logstash/config/coercers/null.rb
@@ -0,0 +1,14 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+module LogStash::Config
+  module TypeCoercers
+    module NullCoercer
+
+      def self.coerce(value)
+        value
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/coercers/number.rb b/logstash-core/lib/logstash/config/coercers/number.rb
new file mode 100644
index 00000000000..17f70b25dc7
--- /dev/null
+++ b/logstash-core/lib/logstash/config/coercers/number.rb
@@ -0,0 +1,20 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+module LogStash::Config
+  module TypeCoercers
+    module Number
+
+      def self.coerce(value)
+        return value if value.is_a?(::Numeric)
+
+        if v.include?(".")
+          return value.to_f
+        else
+          return value.to_i
+        end
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/coercers/password.rb b/logstash-core/lib/logstash/config/coercers/password.rb
new file mode 100644
index 00000000000..d6901c0d3ca
--- /dev/null
+++ b/logstash-core/lib/logstash/config/coercers/password.rb
@@ -0,0 +1,15 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+module LogStash::Config
+  module TypeCoercers
+    module Password
+
+      def self.coerce(value)
+        return value if value.is_a?(::LogStash::Util::Password)
+        ::LogStash::Util::Password.new(value)
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/coercers/uri.rb b/logstash-core/lib/logstash/config/coercers/uri.rb
new file mode 100644
index 00000000000..7a2c3a59501
--- /dev/null
+++ b/logstash-core/lib/logstash/config/coercers/uri.rb
@@ -0,0 +1,15 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+module LogStash::Config
+  module TypeCoercers
+    module Uri
+
+      def self.coerce(value)
+        return value if value.is_a?(::LogStash::Util::SafeURI)
+        ::LogStash::Util::SafeURI.new(value)
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/config_registry.rb b/logstash-core/lib/logstash/config/config_registry.rb
new file mode 100644
index 00000000000..c7e82980e0c
--- /dev/null
+++ b/logstash-core/lib/logstash/config/config_registry.rb
@@ -0,0 +1,186 @@
+# encoding: utf-8
+require "logstash/namespace"
+require "logstash/config/coercers/boolean"
+require "logstash/config/coercers/bytes"
+require "logstash/config/coercers/codec"
+require "logstash/config/coercers/hash"
+require "logstash/config/coercers/number"
+require "logstash/config/coercers/password"
+require "logstash/config/coercers/uri"
+
+
+module LogStash::Config
+
+  class EnvironmentVariables
+
+    ENV_PLACEHOLDER_REGEX = /\$\{(?<name>\w+)(\:(?<default>[^}]*))?\}/
+
+    # Replace all environment variable references in 'value' param by environment variable value and return updated value
+    # Process following patterns : $VAR, ${VAR}, ${VAR:defaultValue}
+    def self.replace_env_placeholders(value)
+      return value unless value.is_a?(String)
+
+      value.gsub(ENV_PLACEHOLDER_REGEX) do |placeholder|
+        # Note: Ruby docs claim[1] Regexp.last_match is thread-local and scoped to
+        # the call, so this should be thread-safe.
+        #
+        # [1] http://ruby-doc.org/core-2.1.1/Regexp.html#method-c-last_match
+        name = Regexp.last_match(:name)
+        default = Regexp.last_match(:default)
+
+        replacement = ENV.fetch(name, default)
+        if replacement.nil?
+          raise LogStash::ConfigurationError, "Cannot evaluate `#{placeholder}`. Environment variable `#{name}` is not set and there is no default value given."
+        end
+        replacement
+      end
+    end # def replace_env_placeholders
+  end
+
+  class InternalRegistry
+
+    attr_reader :parent, :klass, :config, :params, :logger, :validator
+    attr_writer :params
+
+    def initialize(parent, params, logger)
+      @params = params
+      @logger = logger
+      @klass  = parent.class
+      @parent = parent
+      plugin_type = klass.ancestors.find { |a| a.name =~ /::Base$/ }.config_name
+      @validator = LogStash::Config::Validation.new(config, plugin_type, config_name, logger)
+    end
+
+    def setup(&block)
+      warn_deprecated_and_obsolete
+
+      # fetch defaults and environment variables
+      initialize_defaults
+      resolv_environment_variables 
+
+      # validate and coerce values
+      block.call(validator, params)
+
+      # We remove any config options marked as obsolete,
+      # no code should be associated to them and their values should not bleed
+      # to the plugin context.
+      #
+      # This need to be done after fetching the options from the parents classed
+      remove_obsolete
+
+      # set instance variables like '@foo'  for each config value given.
+      set_instance_vars
+    end
+
+    def warn_deprecated_and_obsolete
+      params.each do |name, value|
+        opts = config[name]
+        if opts && opts[:deprecated]
+          extra = opts[:deprecated].is_a?(String) ? opts[:deprecated] : ""
+          extra.gsub!("%PLUGIN%", config_name)
+          @logger.warn("You are using a deprecated config setting " +
+                       "#{name.inspect} set in #{config_name}. " +
+                       "Deprecated settings will continue to work, " +
+                       "but are scheduled for removal from logstash " +
+                       "in the future. #{extra} If you have any questions " +
+                       "about this, please visit the #logstash channel " +
+                       "on freenode irc.", :name => name, :plugin => parent)
+        end
+        if opts && opts[:obsolete]
+          extra = opts[:obsolete].is_a?(String) ? opts[:obsolete] : ""
+          extra.gsub!("%PLUGIN%", config_name)
+          raise LogStash::ConfigurationError,
+            I18n.t("logstash.runner.configuration.obsolete", :name => name, :plugin => config_name, :extra => extra)
+        end
+      end
+    end
+
+    # We remove any config options marked as obsolete,
+    # no code should be associated to them and their values should not bleed
+    # to the plugin context.
+    #
+    # This need to be done after fetching the options from the parents classed
+    def remove_obsolete
+      params.reject! do |name, value|
+        opts = config[name]
+        opts.include?(:obsolete)
+      end
+    end
+
+    def set_instance_vars
+      params.each do |key, value|
+        next if key[0,  1] == "@"
+        # Set this key as an instance variable only if it doesn't start with an '@'
+        @logger.debug("config #{self.class.name}/@#{key} = #{value.inspect}")
+        parent.instance_variable_set("@#{key}", value)
+      end
+    end
+
+    # now that we know the parameters are valid, we can obfuscate the original copy
+    # of the parameters before storing them as an instance variable
+    def secure_params!(params)
+      params.each do |key, value|
+        klass = nil
+        case config[key][:validate]
+        when :uri
+          klass = LogStash::Config::TypeCoercers::Uri
+        when :password
+          klass = LogStash::Config::TypeCoercers::Password
+        end
+
+        next unless klass
+
+        if config[key][:list]
+          params[key] = params[key].map { |_value| klass.coerce(_value) }
+        else
+          params[key] = klass.coerce(value)
+        end
+      end
+    end
+
+    def initialize_defaults
+      config.each do |name, opts|
+        next if params.include?(name.to_s)
+        if opts.include?(:default) && (name.is_a?(Symbol) || name.is_a?(String))
+          case opts[:default]
+          when FalseClass, TrueClass, NilClass, Numeric
+            params[name.to_s] = opts[:default]
+          else
+            params[name.to_s] = opts[:default].clone
+          end
+        end
+        # Allow plugins to override default values of config settings
+        if klass.default?(name)
+          params[name.to_s] = klass.get_default(name)
+        end
+      end
+    end
+
+    def resolv_environment_variables
+      params.each do |name, value|
+        if (value.is_a?(Hash))
+          value.each do |valueHashKey, valueHashValue|
+            value[valueHashKey.to_s] = EnvironmentVariables.replace_env_placeholders(valueHashValue)
+          end
+        else
+          if (value.is_a?(Array))
+            value.each_index do |valueArrayIndex|
+              value[valueArrayIndex] = EnvironmentVariables.replace_env_placeholders(value[valueArrayIndex])
+            end
+          else
+            params[name.to_s] = EnvironmentVariables.replace_env_placeholders(value)
+          end
+        end
+      end
+    end
+
+    def config
+      @config ||= klass.get_config
+    end
+
+    def config_name
+      @config_name ||= klass.config_name
+    end
+
+  end
+end
diff --git a/logstash-core/lib/logstash/config/config_validator.rb b/logstash-core/lib/logstash/config/config_validator.rb
new file mode 100644
index 00000000000..c94e378ca7e
--- /dev/null
+++ b/logstash-core/lib/logstash/config/config_validator.rb
@@ -0,0 +1,175 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+require_relative "validators/parameter_validator"
+require_relative "validators/type/array"
+require_relative "validators/type/boolean"
+require_relative "validators/type/bytes"
+require_relative "validators/type/codec"
+require_relative "validators/type/hash"
+require_relative "validators/type/ipaddr"
+require_relative "validators/type/number"
+require_relative "validators/type/path"
+require_relative "validators/type/string"
+require_relative "validators/type/uri"
+require_relative "validators/type/password"
+
+require_relative "coercers/null"
+require_relative "coercers/array"
+require_relative "coercers/boolean"
+require_relative "coercers/bytes"
+require_relative "coercers/codec"
+require_relative "coercers/hash"
+require_relative "coercers/number"
+require_relative "coercers/password"
+require_relative "coercers/uri"
+
+
+module LogStash::Config
+
+  class ValidatorFactory
+
+    def self.fetch_validator(type)
+      fetch_object(TypeValidators, type)
+    end
+
+    def self.fetch_coercer(type)
+      coercer = fetch_object(TypeCoercers, type) rescue nil
+      coercer.nil? ? TypeCoercers::NullCoercer : coercer
+    end
+
+    private
+
+    def self.fetch_object(type_class, type)
+      begin
+        klass = constantize(type)
+        if type_class.const_defined?(klass)
+           type_class.const_get(klass)
+        end
+      rescue
+        raise NameError.new("#{type_class} of type #{type} is not defined")
+      end
+    end
+
+    def self.constantize(type)
+      type.to_s.capitalize
+    end
+  end
+
+  class Validation
+
+    attr_reader :config, :plugin_type, :plugin_name, :logger
+
+    def initialize(config, plugin_type, plugin_name, logger=nil)
+      @config = config
+      @plugin_type = plugin_type
+      @plugin_name = plugin_name
+      @errors      = []
+      @logger      = logger || Cabin::Channel.get(LogStash)
+    end
+
+    def valid_params?(params={})
+      params_valid, params_errors  = true, []
+
+      [ :validate_attribute_names, :validate_required_params ].each do |validator|
+
+        valid, errors  = self.send(validator, params)
+        params_valid  &= valid
+        params_errors += errors
+      end
+      return params_valid, params_errors
+    end
+
+    def valid_values?(params={})
+      errors = []
+      params.each do |key, value|
+        validate_with = config[key][:validate]
+        next unless validate_with
+        validator     = fetch_validator(validate_with, params)
+        if config[key][:list]
+          list = Array(value)
+          list.each do |v|
+            errors << validator.errors if !validator.valid?(v)
+          end
+        else
+          errors << validator.errors if !validator.valid?(value)
+        end
+      end
+      [errors.empty?, errors.flatten]
+    end
+
+    def coerce_values!(params={})
+      errors = []
+      params.each do |key, value|
+        type    = config[key][:validate]
+        begin
+          coercer     = ValidatorFactory.fetch_coercer(type)
+          if config[key][:list]
+            list        = Array(params[key])
+            if  list.empty? && !config[key][:required]
+              params[key] = nil
+            else
+              params[key] = list.map { |_value| coercer.coerce(_value) }
+            end
+          else
+            params[key] = coercer.coerce(value)
+          end
+        rescue => e
+          errors << "#{e} during the coercion of #{key} with value #{value}"
+        end
+      end
+      [errors.empty?, errors]
+    end
+
+    def fetch_validator(validate_with, params)
+      if validate_with.is_a?(Symbol) 
+        return ValidatorFactory.fetch_validator(validate_with).new(params)
+      elsif validate_with.respond_to?(:call)
+        return TypeValidators::BlockValidator.new(validate_with, params)
+      elsif validate_with.is_a?(::Array) && validate_with.length > 0
+        logger.warn "Using an array as validator deprecated, Procs are now available and are more powerful than Arrays."
+        validate_proc =  Proc.new { |value| validate_with.include?(value) }
+        return TypeValidators::BlockValidator.new(validate_proc, params)
+      else
+        build_custom_validator(validate_with, params)
+      end
+    end
+
+    private
+
+    def build_custom_validator(klass, params)
+      validator = TypeValidators.const_get(klass).new(params)
+      if !validator.is_a?(TypeValidators::Abstract)
+        raise NameError.new("#{validator.class} should be of type TypeValidators::Abstract");
+      end
+      return validator
+    end
+
+    def validate_attribute_names(params)
+      errors = []
+      parameter_name_validator = build_task(LogStash::Config::Validators::NameValidator)
+      params.each do |attr, value|
+        valid, error_msg = parameter_name_validator.valid?(attr, value)
+        errors << error_msg unless valid
+      end
+      return errors.empty?, errors
+    end
+
+    def validate_required_params(params)
+      errors = []
+      required_value_validator = build_task(LogStash::Config::Validators::ExistValueValidator)
+      required_values_config   = config.select { |k,v| v[:required] }
+
+      required_values_config.each do |attr, config_attributes|
+        valid, error_msg = required_value_validator.valid?(attr, params[attr])
+        errors << error_msg unless valid
+      end
+
+      return errors.empty?, errors
+    end
+
+    def build_task(klass)
+       klass.new(config, plugin_type, plugin_name)
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/mixin.rb b/logstash-core/lib/logstash/config/mixin.rb
index 5ffd320cc1d..c77abfbcbe6 100644
--- a/logstash-core/lib/logstash/config/mixin.rb
+++ b/logstash-core/lib/logstash/config/mixin.rb
@@ -10,6 +10,9 @@
 require "logstash/util/plugin_version"
 require "filesize"
 
+require "logstash/config/config_registry"
+require "logstash/config/config_validator"
+
 LogStash::Environment.load_locale!
 
 # This module is meant as a mixin to classes wishing to be configurable from
@@ -37,9 +40,6 @@ module LogStash::Config::Mixin
   attr_accessor :config
   attr_accessor :original_params
 
-  PLUGIN_VERSION_1_0_0 = LogStash::Util::PluginVersion.new(1, 0, 0)
-  PLUGIN_VERSION_0_9_0 = LogStash::Util::PluginVersion.new(0, 9, 0)
-
   ENV_PLACEHOLDER_REGEX = /\$\{(?<name>\w+)(\:(?<default>[^}]*))?\}/
 
   # This method is called when someone does 'include LogStash::Config'
@@ -49,131 +49,30 @@ def self.included(base)
   end
 
   def config_init(params)
-    # Validation will modify the values inside params if necessary.
-    # For example: converting a string to a number, etc.
-    
-    # Keep a copy of the original config params so that we can later
-    # differentiate between explicit configuration and implicit (default)
-    # configuration.
     original_params = params.clone
-    
-    # store the plugin type, turns LogStash::Inputs::Base into 'input'
-    @plugin_type = self.class.ancestors.find { |a| a.name =~ /::Base$/ }.config_name
 
-    # warn about deprecated variable use
-    params.each do |name, value|
-      opts = self.class.get_config[name]
-      if opts && opts[:deprecated]
-        extra = opts[:deprecated].is_a?(String) ? opts[:deprecated] : ""
-        extra.gsub!("%PLUGIN%", self.class.config_name)
-        @logger.warn("You are using a deprecated config setting " +
-                     "#{name.inspect} set in #{self.class.config_name}. " +
-                     "Deprecated settings will continue to work, " +
-                     "but are scheduled for removal from logstash " +
-                     "in the future. #{extra} If you have any questions " +
-                     "about this, please visit the #logstash channel " +
-                     "on freenode irc.", :name => name, :plugin => self)
-      end
-      if opts && opts[:obsolete]
-        extra = opts[:obsolete].is_a?(String) ? opts[:obsolete] : ""
-        extra.gsub!("%PLUGIN%", self.class.config_name)
-        raise LogStash::ConfigurationError,
-          I18n.t("logstash.runner.configuration.obsolete", :name => name,
-                 :plugin => self.class.config_name, :extra => extra)
-      end
-    end
+    @registry  = LogStash::Config::InternalRegistry.new(self, params, @logger)
 
-    # Set defaults from 'config :foo, :default => somevalue'
-    self.class.get_config.each do |name, opts|
-      next if params.include?(name.to_s)
-      if opts.include?(:default) and (name.is_a?(Symbol) or name.is_a?(String))
-        # default values should be cloned if possible
-        # cloning prevents 
-        case opts[:default]
-          when FalseClass, TrueClass, NilClass, Numeric
-            params[name.to_s] = opts[:default]
-          else
-            params[name.to_s] = opts[:default].clone
-        end
+    @registry.setup do |validator, _params|
+      valid, _ = validator.valid_params?(_params)
+      if !valid
+        raise LogStash::ConfigurationError, I18n.t("logstash.runner.configuration.invalid_plugin_settings")
       end
-
-      # Allow plugins to override default values of config settings
-      if self.class.default?(name)
-        params[name.to_s] = self.class.get_default(name)
+      valid, errors = validator.valid_values?(_params)
+      if !valid
+        raise LogStash::ConfigurationError, errors.join('\n')
       end
-    end
-
-    # Resolve environment variables references
-    params.each do |name, value|
-      if (value.is_a?(Hash))
-        value.each do |valueHashKey, valueHashValue|
-          value[valueHashKey.to_s] = replace_env_placeholders(valueHashValue)
-        end
-      else
-        if (value.is_a?(Array))
-          value.each_index do |valueArrayIndex|
-            value[valueArrayIndex] = replace_env_placeholders(value[valueArrayIndex])
-          end
-        else
-          params[name.to_s] = replace_env_placeholders(value)
-        end
-      end
-    end
-
-
-    if !self.class.validate(params)
-      raise LogStash::ConfigurationError,
-        I18n.t("logstash.runner.configuration.invalid_plugin_settings")
-    end
-
-    # We remove any config options marked as obsolete,
-    # no code should be associated to them and their values should not bleed
-    # to the plugin context.
-    #
-    # This need to be done after fetching the options from the parents classed
-    params.reject! do |name, value|
-      opts = self.class.get_config[name]
-      opts.include?(:obsolete)
-    end
-
-    # set instance variables like '@foo'  for each config value given.
-    params.each do |key, value|
-      next if key[0, 1] == "@"
-
-      # Set this key as an instance variable only if it doesn't start with an '@'
-      @logger.debug("config #{self.class.name}/@#{key} = #{value.inspect}")
-      instance_variable_set("@#{key}", value)
+      validator.coerce_values!(_params)
     end
 
     # now that we know the parameters are valid, we can obfuscate the original copy
     # of the parameters before storing them as an instance variable
-    self.class.secure_params!(original_params)
+    @registry.secure_params!(original_params)
+    
     @original_params = original_params
-
     @config = params
   end # def config_init
 
-  # Replace all environment variable references in 'value' param by environment variable value and return updated value
-  # Process following patterns : $VAR, ${VAR}, ${VAR:defaultValue}
-  def replace_env_placeholders(value)
-    return value unless value.is_a?(String)
-
-    value.gsub(ENV_PLACEHOLDER_REGEX) do |placeholder|
-      # Note: Ruby docs claim[1] Regexp.last_match is thread-local and scoped to
-      # the call, so this should be thread-safe.
-      #
-      # [1] http://ruby-doc.org/core-2.1.1/Regexp.html#method-c-last_match
-      name = Regexp.last_match(:name)
-      default = Regexp.last_match(:default)
-
-      replacement = ENV.fetch(name, default)
-      if replacement.nil?
-        raise LogStash::ConfigurationError, "Cannot evaluate `#{placeholder}`. Environment variable `#{name}` is not set and there is no default value given."
-      end
-      replacement
-    end
-  end # def replace_env_placeholders
-
   module DSL
     attr_accessor :flags
 
@@ -189,19 +88,6 @@ def config_name(name = nil)
     end
     alias_method :config_plugin, :config_name
 
-    # Deprecated: Declare the version of the plugin
-    # inside the gemspec.
-    def plugin_status(status = nil)
-      milestone(status)
-    end
-
-    # Deprecated: Declare the version of the plugin
-    # inside the gemspec.
-    def milestone(m = nil)
-      @logger = Cabin::Channel.get(LogStash)
-      @logger.debug(I18n.t('logstash.plugin.deprecated_milestone', :plugin => config_name))
-    end
-
     # Define a new configuration setting
     def config(name, opts={})
       @config ||= Hash.new
@@ -221,6 +107,10 @@ def default(name, value)
       @defaults[name.to_s] = value
     end
 
+    def milestone(*args)
+
+    end
+
     def get_config
       return @config
     end # def get_config
@@ -256,347 +146,7 @@ def inherited(subclass)
         end
       end
       subclass.instance_variable_set("@config", subconfig)
-      @@version_notice_given = false
     end # def inherited
 
-    def validate(params)
-      @plugin_name = config_name
-      @plugin_type = ancestors.find { |a| a.name =~ /::Base$/ }.config_name
-      @logger = Cabin::Channel.get(LogStash)
-      is_valid = true
-
-      print_version_notice
-
-      is_valid &&= validate_check_invalid_parameter_names(params)
-      is_valid &&= validate_check_required_parameter_names(params)
-      is_valid &&= validate_check_parameter_values(params)
-
-      return is_valid
-    end # def validate
-
-    def print_version_notice
-      return if @@version_notice_given
-
-      begin
-        plugin_version = LogStash::Util::PluginVersion.find_plugin_version!(@plugin_type, @config_name)
-
-        if plugin_version < PLUGIN_VERSION_1_0_0
-          if plugin_version < PLUGIN_VERSION_0_9_0
-            @logger.info(I18n.t("logstash.plugin.version.0-1-x", 
-                                :type => @plugin_type,
-                                :name => @config_name,
-                                :LOGSTASH_VERSION => LOGSTASH_VERSION))
-          else
-            @logger.info(I18n.t("logstash.plugin.version.0-9-x", 
-                                :type => @plugin_type,
-                                :name => @config_name,
-                                :LOGSTASH_VERSION => LOGSTASH_VERSION))
-          end
-        end
-      rescue LogStash::PluginNoVersionError
-        # If we cannot find a version in the currently installed gems we
-        # will display this message. This could happen in the test, if you 
-        # create an anonymous class to test a plugin.
-        @logger.warn(I18n.t("logstash.plugin.no_version",
-                                :type => @plugin_type,
-                                :name => @config_name,
-                                :LOGSTASH_VERSION => LOGSTASH_VERSION))
-      ensure 
-        @@version_notice_given = true
-      end
-    end
-
-    def validate_check_invalid_parameter_names(params)
-      invalid_params = params.keys
-      # Filter out parameters that match regexp keys.
-      # These are defined in plugins like this:
-      #   config /foo.*/ => ...
-      @config.each_key do |config_key|
-        if config_key.is_a?(Regexp)
-          invalid_params.reject! { |k| k =~ config_key }
-        elsif config_key.is_a?(String)
-          invalid_params.reject! { |k| k == config_key }
-        end
-      end
-
-      if invalid_params.size > 0
-        invalid_params.each do |name|
-          @logger.error("Unknown setting '#{name}' for #{@plugin_name}")
-        end
-        return false
-      end # if invalid_params.size > 0
-      return true
-    end # def validate_check_invalid_parameter_names
-
-    def validate_check_required_parameter(config_key, config_opts, k, v)
-      if config_key.is_a?(Regexp)
-        (k =~ config_key && v)
-      elsif config_key.is_a?(String)
-        k && v
-      end
-    end
-
-    def validate_check_required_parameter_names(params)
-      is_valid = true
-
-      @config.each do |config_key, config|
-        next unless config[:required]
-
-        if config_key.is_a?(Regexp) && !params.keys.any? { |k| k =~ config_key }
-          is_valid = false
-        end
-
-        value = params[config_key]
-        if value.nil? || (config[:list] && Array(value).empty?)
-          @logger.error(I18n.t("logstash.runner.configuration.setting_missing",
-                               :setting => config_key, :plugin => @plugin_name,
-                               :type => @plugin_type))
-          is_valid = false
-        end        
-      end
-
-      return is_valid
-    end
-
-    def process_parameter_value(value, config_settings)
-      config_val = config_settings[:validate]
-      
-      if config_settings[:list]
-        value = Array(value) # coerce scalars to lists
-        # Empty lists are converted to nils
-        return true, nil if value.empty?
-          
-        validated_items = value.map {|v| validate_value(v, config_val)}
-        is_valid = validated_items.all? {|sr| sr[0] }
-        processed_value = validated_items.map {|sr| sr[1]}
-      else
-        is_valid, processed_value = validate_value(value, config_val)
-      end
-      
-      return [is_valid, processed_value]
-    end
-
-    def validate_check_parameter_values(params)
-      # Filter out parametrs that match regexp keys.
-      # These are defined in plugins like this:
-      #   config /foo.*/ => ... 
-      all_params_valid = true
-
-      params.each do |key, value|
-        @config.keys.each do |config_key|
-          next unless (config_key.is_a?(Regexp) && key =~ config_key) \
-                      || (config_key.is_a?(String) && key == config_key)
-
-          config_settings = @config[config_key]          
-
-          is_valid, processed_value = process_parameter_value(value, config_settings)
-          
-          if is_valid
-            # Accept coerced value if valid
-            # Used for converting values in the config to proper objects.
-            params[key] = processed_value
-          else
-            @logger.error(I18n.t("logstash.runner.configuration.setting_invalid",
-                                 :plugin => @plugin_name, :type => @plugin_type,
-                                 :setting => key, :value => value.inspect,
-                                 :value_type => config_settings[:validate],
-                                 :note => processed_value))
-          end
-          
-          all_params_valid &&= is_valid
-
-          break # done with this param key
-        end # config.each
-      end # params.each
-
-      return all_params_valid
-    end # def validate_check_parameter_values
-
-    def validator_find(key)
-      @config.each do |config_key, config_val|
-        if (config_key.is_a?(Regexp) && key =~ config_key) \
-           || (config_key.is_a?(String) && key == config_key)
-          return config_val
-        end
-      end # @config.each
-      return nil
-    end
-
-    def validate_value(value, validator)
-      # Validator comes from the 'config' pieces of plugins.
-      # They look like this
-      #   config :mykey => lambda do |value| ... end
-      # (see LogStash::Inputs::File for example)
-      result = nil
-
-      if validator.nil?
-        return true, value
-      elsif validator.is_a?(Array)
-        value = [*value]
-        if value.size > 1
-          return false, "Expected one of #{validator.inspect}, got #{value.inspect}"
-        end
-
-        if !validator.include?(value.first)
-          return false, "Expected one of #{validator.inspect}, got #{value.inspect}"
-        end
-        result = value.first
-      elsif validator.is_a?(Symbol)
-        # TODO(sissel): Factor this out into a coersion method?
-        # TODO(sissel): Document this stuff.
-        value = hash_or_array(value)
-
-        case validator
-          when :codec
-            if value.first.is_a?(String)
-              value = LogStash::Plugin.lookup("codec", value.first).new
-              return true, value
-            else
-              value = value.first
-              return true, value
-            end
-          when :hash
-            if value.is_a?(Hash)
-              return true, value
-            end
-
-            if value.size % 2 == 1
-              return false, "This field must contain an even number of items, got #{value.size}"
-            end
-
-            # Convert the array the config parser produces into a hash.
-            result = {}
-            value.each_slice(2) do |key, value|
-              entry = result[key]
-              if entry.nil?
-                result[key] = value
-              else
-                if entry.is_a?(Array)
-                  entry << value
-                else
-                  result[key] = [entry, value]
-                end
-              end
-            end
-          when :array
-            result = value
-          when :string
-            if value.size > 1 # only one value wanted
-              return false, "Expected string, got #{value.inspect}"
-            end
-            result = value.first
-          when :number
-            if value.size > 1 # only one value wanted
-              return false, "Expected number, got #{value.inspect} (type #{value.class})"
-            end
-
-            v = value.first
-            case v
-              when Numeric
-                result = v
-              when String
-                if v.to_s.to_f.to_s != v.to_s \
-                   && v.to_s.to_i.to_s != v.to_s
-                  return false, "Expected number, got #{v.inspect} (type #{v})"
-                end
-                if v.include?(".")
-                  # decimal value, use float.
-                  result = v.to_f
-                else
-                  result = v.to_i
-                end
-            end # case v
-          when :boolean
-            if value.size > 1 # only one value wanted
-              return false, "Expected boolean, got #{value.inspect}"
-            end
-
-            bool_value = value.first
-            if !!bool_value == bool_value
-              # is_a does not work for booleans
-              # we have Boolean and not a string
-              result = bool_value
-            else
-              if bool_value !~ /^(true|false)$/
-                return false, "Expected boolean 'true' or 'false', got #{bool_value.inspect}"
-              end
-
-              result = (bool_value == "true")
-            end
-          when :ipaddr
-            if value.size > 1 # only one value wanted
-              return false, "Expected IPaddr, got #{value.inspect}"
-            end
-
-            octets = value.split(".")
-            if octets.length != 4
-              return false, "Expected IPaddr, got #{value.inspect}"
-            end
-            octets.each do |o|
-              if o.to_i < 0 or o.to_i > 255
-                return false, "Expected IPaddr, got #{value.inspect}"
-              end
-            end
-            result = value.first
-          when :password
-            if value.size > 1
-              return false, "Expected password (one value), got #{value.size} values?"
-            end
-
-            result = value.first.is_a?(::LogStash::Util::Password) ? value.first : ::LogStash::Util::Password.new(value.first)
-          when :uri
-            if value.size > 1
-              return false, "Expected uri (one value), got #{value.size} values?"
-            end
-            
-            result = value.first.is_a?(::LogStash::Util::SafeURI) ? value.first : ::LogStash::Util::SafeURI.new(value.first)
-          when :path
-            if value.size > 1 # Only 1 value wanted
-              return false, "Expected path (one value), got #{value.size} values?"
-            end
-
-            # Paths must be absolute
-            #if !Pathname.new(value.first).absolute?
-              #return false, "Require absolute path, got relative path #{value.first}?"
-            #end
-
-            if !File.exists?(value.first) # Check if the file exists
-              return false, "File does not exist or cannot be opened #{value.first}"
-            end
-
-            result = value.first
-          when :bytes
-            begin
-              bytes = Integer(value.first) rescue nil
-              result = bytes || Filesize.from(value.first).to_i
-            rescue ArgumentError
-              return false, "Unparseable filesize: #{value.first}. possible units (KiB, MiB, ...) e.g. '10 KiB'. doc reference: http://www.elastic.co/guide/en/logstash/current/configuration.html#bytes"
-            end
-          else
-            return false, "Unknown validator symbol #{validator}"
-        end # case validator
-      else
-        return false, "Unknown validator #{validator.class}"
-      end
-
-      # Return the validator for later use, like with type coercion.
-      return true, result
-    end # def validate_value
-
-    def secure_params!(params)
-      params.each do |key, value|
-        if [:uri, :password].include? @config[key][:validate]
-          is_valid, processed_value = process_parameter_value(value, @config[key])
-          params[key] = processed_value
-        end
-      end
-    end
-
-    def hash_or_array(value)
-      if !value.is_a?(Hash)
-        value = [*value] # coerce scalar to array if necessary
-      end
-      return value
-    end
   end # module LogStash::Config::DSL
 end # module LogStash::Config
diff --git a/logstash-core/lib/logstash/config/validators/abstract_validator.rb b/logstash-core/lib/logstash/config/validators/abstract_validator.rb
new file mode 100644
index 00000000000..348aa505988
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/abstract_validator.rb
@@ -0,0 +1,31 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+module LogStash::Config
+
+  module Validators
+
+    class AbstractValidator
+
+      attr_reader :config, :plugin_name, :plugin_type
+
+      def initialize(config, plugin_type, plugin_name)
+        @plugin_name = plugin_name
+        @plugin_type = plugin_type
+        @config      = config
+        @logger      = Cabin::Channel.get(LogStash)
+      end
+
+      def add_error(message)
+        @errors ||= []
+        @errors << message
+      end
+
+      def errors
+        @errors
+      end
+
+    end
+
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/parameter_validator.rb b/logstash-core/lib/logstash/config/validators/parameter_validator.rb
new file mode 100644
index 00000000000..bc6c0112531
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/parameter_validator.rb
@@ -0,0 +1,101 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract_validator"
+
+module LogStash::Config
+
+  module Validators
+
+  ##
+  # Make sure required values have a value.
+  ##
+
+  class ExistValueValidator < AbstractValidator
+
+    attr_reader :config_required_fields, :config_required_keys
+
+    def initialize(config, plugin_type, plugin_name)
+      super
+      @config_required_fields = config.select { |k,v| v[:required] }
+      @config_required_keys   = config_required_fields.map { |k,v| k }
+    end
+
+    def valid?(key, value)
+      if !verify_required_key(key, value)
+        error_msg = I18n.t("logstash.runner.configuration.setting_missing", :setting => key, :plugin => plugin_name, :type => plugin_type)
+        @logger.error(error_msg) if @logger.error?
+        return false, error_msg
+      end
+      return true, ""
+    end
+
+    private
+
+    def verify_required_key(key, value)
+      return true if !config_required_keys.include?(key) # if the key is not required one return true
+      if key.is_a?(Regexp)
+        return true
+      end
+      !is_empty?(config_required_fields[key], value)
+    end
+
+    def is_empty?(config, value)
+      value.nil? || (config[:list] && Array(value).empty?)
+    end
+  end
+
+  ##
+  # Verify that the config values defined are valid ones, this means the configuration
+  # names are inside the set defined while creating the plugin.
+  ##
+  class NameValidator < AbstractValidator
+
+    attr_reader :valid_config_names
+
+    def initialize(config, plugin_type, plugin_name)
+      super
+      @valid_config_names = config.keys
+    end
+    # Return true if the parameter name is valid, false otherwise
+    def valid?(key, value)
+      if !verify_invalid_name(key)
+        error_msg = "Unknown setting '#{key}' for #{plugin_name}"
+        @logger.error(error_msg) if @logger.error?
+        return false, error_msg
+      end
+      return true, ""
+    end
+
+    private
+
+    def verify_invalid_name(name)
+      if name.is_a?(String)
+        valid_config_names.include?(name)
+      elsif name.is_a?(Regexp)
+        !valid_config_names.select { |s| s.match(name) }.empty?
+      else
+        false
+      end
+    end
+
+    def verify_required_name(key, value)
+      return true if config[key][:required]  #we've to be sure keys are always going to be present.
+      ## if the key is a Regexp and there is no key that match the regexp return false.
+      if key.is_a?(Regexp)
+        return true # should be extended properly
+      elsif is_empty?(config[key], value)
+        return false
+      else
+        true
+      end
+      ## if required, but no value in the parameters is setup
+    end
+
+    def is_empty?(config, value)
+      value.nil? || (config[:list] && Array(value).empty?)
+    end
+
+  end
+
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/abstract.rb b/logstash-core/lib/logstash/config/validators/type/abstract.rb
new file mode 100644
index 00000000000..74a8eb2e2b1
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/abstract.rb
@@ -0,0 +1,48 @@
+# encoding: utf-8
+require "logstash/namespace"
+
+module LogStash::Config
+  module TypeValidators
+    class Abstract
+
+      attr_reader :params
+
+      def initialize(params={})
+        @params = params
+      end
+
+      def add_errors(message)
+        @errors ||= []
+        @errors << message
+      end
+
+      def errors
+        @errors
+      end
+
+      private
+
+      def valid_type?(value, klass)
+        return true if value.is_a?(klass)
+        return true if value.is_a?(::Array) && value.size == 1 && value[0].is_a?(klass)
+        false
+      end
+    end
+
+    class BlockValidator < Abstract
+
+      def initialize(block, params)
+        @block  = block
+        @params = params
+      end
+
+      def valid?(value)
+        if !@block.call(value, params)
+          add_errors "Validation of #{value} with #{self} failed"
+          return false
+        end
+        return true
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/array.rb b/logstash-core/lib/logstash/config/validators/type/array.rb
new file mode 100644
index 00000000000..d8f38633656
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/array.rb
@@ -0,0 +1,19 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract"
+
+module LogStash::Config
+  module TypeValidators
+    class Array < Abstract
+
+      def valid?(value)
+        if value.is_a?(Enumerable) && value.is_a?(Array)
+          add_errors "Expected array, got #{value.inspect}"
+          return false
+        end
+        return true
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/boolean.rb b/logstash-core/lib/logstash/config/validators/type/boolean.rb
new file mode 100644
index 00000000000..9dbddcfa29c
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/boolean.rb
@@ -0,0 +1,28 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract"
+
+module LogStash::Config
+  module TypeValidators
+    class Boolean < Abstract
+
+      def valid?(value)
+        bool_value = value
+        return true  if !!bool_value == bool_value
+        if !valid_type?(value)
+          add_errors "Expected boolean 'true' or 'false', got #{bool_value.inspect}"
+          return false
+        end
+        true
+      end
+
+      private 
+
+      def valid_type?(value)
+        ( ( value =~ (/^(true|t|yes|y|1)$/i) ) ||
+          ( value.empty? || value =~ (/^(false|f|no|n|0)$/i) ) )
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/bytes.rb b/logstash-core/lib/logstash/config/validators/type/bytes.rb
new file mode 100644
index 00000000000..20ad84d9f28
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/bytes.rb
@@ -0,0 +1,21 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract"
+
+module LogStash::Config
+  module TypeValidators
+    class Bytes < Abstract
+
+      def valid?(value)
+        begin
+          bytes = Integer(value) rescue nil
+          (bytes || Filesize.from(value).to_i) > 0
+        rescue ArgumentError
+          add_errors "Unparseable filesize: #{value}. possible units (KiB, MiB, ...) e.g. '10 KiB'. doc reference: http://www.elastic.co/guide/en/logstash/current/configuration.html#bytes"
+          return false
+        end
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/codec.rb b/logstash-core/lib/logstash/config/validators/type/codec.rb
new file mode 100644
index 00000000000..7c8008d8913
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/codec.rb
@@ -0,0 +1,15 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract"
+
+module LogStash::Config
+  module TypeValidators
+    class Codec < Abstract
+
+      def valid?(value)
+        true
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/hash.rb b/logstash-core/lib/logstash/config/validators/type/hash.rb
new file mode 100644
index 00000000000..1d74c23d386
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/hash.rb
@@ -0,0 +1,26 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract"
+
+module LogStash::Config
+  module TypeValidators
+    class Hash < Abstract
+
+      def valid?(value)
+        if !value.is_a?(::Hash)
+          if value.is_a?(::Array)
+            if value.size % 2 == 1
+              add_errors "This field must contain an even number of items, got #{value.size}"
+              return false
+            end
+            return true
+          end
+          add_errors "Expected hash or array but got #{value.inspect}"
+          return false
+        end
+        return true
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/ipaddr.rb b/logstash-core/lib/logstash/config/validators/type/ipaddr.rb
new file mode 100644
index 00000000000..51339ff0db4
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/ipaddr.rb
@@ -0,0 +1,25 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract"
+
+module LogStash::Config
+  module TypeValidators
+    class Ipaddr < Abstract
+
+      def valid?(value)
+        octets = value.split(".")
+        if octets.length != 4
+          add_errors "Expected IPaddr, got #{value.inspect}"
+          return false
+        end
+        octets.each do |o|
+          if (o.to_i < 0 || o.to_i > 255)
+            add_errors "Expected IPaddr, got #{value.inspect}"
+            return false
+          end
+        end
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/number.rb b/logstash-core/lib/logstash/config/validators/type/number.rb
new file mode 100644
index 00000000000..c02ced69149
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/number.rb
@@ -0,0 +1,30 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract"
+
+module LogStash::Config
+  module TypeValidators
+    class Number < Abstract
+
+      def valid?(value)
+        valid = value.is_a?(::Numeric) || (value.is_a?(::String) && string_number?(value))
+        add_errors "Expected number, got #{value.inspect} (type #{value.class})" if !valid
+        valid
+      end
+
+      private
+
+      def string_number?(v)
+        float_number?(v) || integer_number?(v)
+      end
+
+      def float_number?(v)
+        v.to_s.to_f.to_s == v.to_s
+      end
+
+      def integer_number?(v)
+        v.to_s.to_i.to_s == v.to_s
+      end
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/password.rb b/logstash-core/lib/logstash/config/validators/type/password.rb
new file mode 100644
index 00000000000..1c3495f4109
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/password.rb
@@ -0,0 +1,15 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract"
+
+module LogStash::Config
+  module TypeValidators
+    class Password < Abstract
+
+      def valid?(value)
+        true
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/path.rb b/logstash-core/lib/logstash/config/validators/type/path.rb
new file mode 100644
index 00000000000..4c1f460226a
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/path.rb
@@ -0,0 +1,19 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract"
+
+module LogStash::Config
+  module TypeValidators
+    class Path < Abstract
+
+      def valid?(value)
+        if !::File.exists?(value)
+          add_errors "File does not exist or cannot be opened #{value}"
+          return false
+        end
+        true
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/string.rb b/logstash-core/lib/logstash/config/validators/type/string.rb
new file mode 100644
index 00000000000..78211569d7d
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/string.rb
@@ -0,0 +1,19 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract"
+
+module LogStash::Config
+  module TypeValidators
+    class String < Abstract
+
+      def valid?(value)
+        valid = valid_type?(value, ::String)
+        if !valid
+          add_errors "Expected string, got #{value.inspect}"
+        end
+        valid
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/config/validators/type/uri.rb b/logstash-core/lib/logstash/config/validators/type/uri.rb
new file mode 100644
index 00000000000..f42911ee4e8
--- /dev/null
+++ b/logstash-core/lib/logstash/config/validators/type/uri.rb
@@ -0,0 +1,15 @@
+# encoding: utf-8
+require "logstash/namespace"
+require_relative "abstract"
+
+module LogStash::Config
+  module TypeValidators
+    class Uri < Abstract
+
+      def valid?(value)
+        true
+      end
+
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/config/mixin_spec.rb b/logstash-core/spec/logstash/config/config_spec.rb
similarity index 74%
rename from logstash-core/spec/logstash/config/mixin_spec.rb
rename to logstash-core/spec/logstash/config/config_spec.rb
index a5b74cf5726..d38dee606d2 100644
--- a/logstash-core/spec/logstash/config/mixin_spec.rb
+++ b/logstash-core/spec/logstash/config/config_spec.rb
@@ -9,7 +9,6 @@
       Class.new(LogStash::Filters::Base) do
         include LogStash::Config::Mixin
         config_name "test"
-        milestone 1
         config :size_bytes, :validate => :bytes
         config :size_default, :validate => :bytes, :default => "#{local_num_bytes}"
         config :size_upcase, :validate => :bytes
@@ -50,7 +49,6 @@
         Class.new(LogStash::Filters::Base) do
           include LogStash::Config::Mixin
           config_name "test"
-          milestone 1
           config :size_file, :validate => :bytes
         end.new({"size_file" => "10 yolobytes"})
       }.to raise_error(LogStash::ConfigurationError)
@@ -61,7 +59,6 @@
         Class.new(LogStash::Filters::Base) do
           include LogStash::Config::Mixin
           config_name "test"
-          milestone 1
           config :size_file, :validate => :bytes
         end.new({"size_file" => "10  kib"})
       }.to raise_error(LogStash::ConfigurationError)
@@ -180,7 +177,7 @@
 
     shared_examples("safe URI") do |options|
       options ||= {}
-      
+
       subject { klass.new("uri" => uri_str) }
 
       it "should be a SafeURI object" do
@@ -418,4 +415,138 @@ def initialize(params)
       end
     end
   end
+
+  context "when using Proc as validator" do
+
+    it "should validate without an error" do
+      plugin = Class.new(LogStash::Inputs::Base) do
+        include LogStash::Config::Mixin
+        config_name "testing"
+        config :size,     :validate =>  Proc.new { |value| true }, :required => true
+        config :charset,  :validate => :string, :default => "UTF-8"
+      end
+      expect {  plugin.new("size" => "100") }.not_to raise_error
+    end
+
+    it "should raise an error if the validation fails" do
+      plugin = Class.new(LogStash::Inputs::Base) do
+        include LogStash::Config::Mixin
+        config_name "testing"
+        config :size,     :validate =>  Proc.new { |value| false }, :required => true
+        config :charset,  :validate => :string, :default => "UTF-8"
+      end
+      expect {  plugin.new("size" => "100") }.to raise_error(LogStash::ConfigurationError)
+    end
+
+    context "when doing cross validation" do
+
+      it "should validate without an error" do
+        plugin = Class.new(LogStash::Inputs::Base) do
+          include LogStash::Config::Mixin
+          config_name "testing"
+          config :size,     :validate =>  Proc.new { |value, params| params["charset"] == "UTF-8" }, :required => true
+          config :charset,  :validate => :string, :default => "UTF-8"
+        end
+        expect {  plugin.new("size" => "100") }.not_to raise_error
+      end
+
+      it "should raise an error" do
+        plugin = Class.new(LogStash::Inputs::Base) do
+          include LogStash::Config::Mixin
+          config_name "testing"
+          config :size,     :validate =>  Proc.new { |value, params| params["charset"] == "UTF-8" }, :required => true
+          config :charset,  :validate => :string, :default => "UTF-8"
+        end
+        expect {  plugin.new("size" => "100", "charset" => "foo") }.to raise_error(LogStash::ConfigurationError)
+      end
+
+    end
+  end
+
+  context "when using custom validators" do
+
+    it "should use the class as validator" do
+      module LogStash::Config
+        module TypeValidators
+          class NumberTrueValidator < Abstract
+            def valid?(value)
+              return true
+            end
+          end
+        end
+      end
+
+      plugin = Class.new(LogStash::Inputs::Base) do
+        include LogStash::Config::Mixin
+        config_name "testing"
+        config :size,     :validate => "NumberTrueValidator", :required => true
+        config :charset,  :validate => :string, :default => "UTF-8"
+      end
+
+      expect {  plugin.new("size" => "100") }.not_to raise_error
+    end
+
+    it "should raise an error if the validator used is not properly scoped" do
+      module LogStash::Config
+        module TypeValidator
+          class NumberWrongScopeValidator
+            def valid?(value)
+              return true
+            end
+          end
+        end
+      end
+
+      plugin = Class.new(LogStash::Inputs::Base) do
+        include LogStash::Config::Mixin
+        config_name "testing"
+        config :size,     :validate => "NumberWrongScopeValidator", :required => true
+        config :charset,  :validate => :string, :default => "UTF-8"
+      end
+
+      expect {  plugin.new("size" => "100") }.to raise_error
+    end
+
+    context "when doing cross validaton of properties" do
+
+      let(:plugin) do
+        Class.new(LogStash::Inputs::Base) do
+          include LogStash::Config::Mixin
+          config_name "testing"
+          config :size,     :validate => "NumberValidator", :required => true
+          config :charset,  :validate => :string, :default => "UTF-8"
+        end
+      end
+
+      it "should not raise an error if cross criteria is meet" do
+        module LogStash::Config
+          module TypeValidators
+            class NumberValidator < Abstract
+              def valid?(value)
+                return params["charset"] == "UTF-16" && value == "100"
+              end
+            end
+          end
+        end
+
+        expect {  plugin.new("size" => "100", "charset" => "UTF-16") }.not_to raise_error
+      end
+
+      it "should raise an error if cross criteria is not meet" do
+        module LogStash::Config
+          module TypeValidators
+            class NumberValidator < Abstract
+              def valid?(value)
+                return params["charset"] == "UTF-16" && value == "100"
+              end
+            end
+          end
+        end
+
+        expect {  plugin.new("size" => "100") }.to raise_error(LogStash::ConfigurationError)
+      end
+    end
+
+  end
+
 end
diff --git a/logstash-core/spec/logstash/config/validation_spec.rb b/logstash-core/spec/logstash/config/validation_spec.rb
new file mode 100644
index 00000000000..0c47506f851
--- /dev/null
+++ b/logstash-core/spec/logstash/config/validation_spec.rb
@@ -0,0 +1,80 @@
+# encoding: utf-8
+require "spec_helper"
+require "logstash/config/validators/parameter_validator"
+require "logstash/config/config_validator"
+
+describe LogStash::Config::Validation do
+
+  let(:config) do
+
+    {"enable_metric"  => { :validate=>:boolean, :default=>true },
+     "id"             => { :validate=>:string },
+     "codec"          => { :validate=>:codec, :default=>"plain" },
+     "size"           => { :validate=>:bytes, :required=>true },
+     "files"          => { :validate=>:array, :required=>true }}
+  end
+
+  subject(:validator) { described_class.new(config, "plugin_type", "plugin_name") }
+
+
+  describe "Validation of params" do
+
+    it "should return false if there is an attribute not defined in the config" do
+      params       = {"sized"=>100, "enable_metric"=>true, "codec"=>"plain"}
+      valid_params, errors = validator.valid_params?(params)
+      expect(valid_params).to eq(false)
+      expect(errors).not_to be_empty
+    end
+
+    it "should return false if a required attribute is missing" do
+      params = {"size"=>100, "enable_metric"=>true, "codec"=>"plain" }
+      valid_params, errors = validator.valid_params?(params)
+      expect(valid_params).to eq(false)
+      expect(errors).not_to be_empty
+    end
+
+    it "should return true if all required parameters are defined" do
+      params = {"size"=>100, "files" => ["foo"], "enable_metric"=>true, "codec"=>"plain"}
+      expect(validator.valid_params?(params)).to eq([true, []])
+    end
+  end
+
+  describe "Validation of values" do
+
+    describe "String validation" do
+      let(:config) do
+        {"enable_metric"  => { :validate=>:boolean, :default=>true },
+         "files"          => { :validate=>:string, :required=>true }}
+      end
+
+      it "should validate a single string as OK" do
+        params = { "files" => "/foo/bar.txt" }
+        expect(validator.valid_values?(params)).to eq([true, []])
+      end
+
+      it "should validate a single array as if a single String as OK" do
+        params = { "files" => ["/foo/bar.txt"] }
+        expect(validator.valid_values?(params)).to eq([true, []])
+      end
+
+      it "should fail with a non String" do
+        params = { "files" => 123  }
+        expect(validator.valid_values?(params)).to eq([false, ["Expected string, got 123"]])
+      end
+
+      it "should fail with a non String Array" do
+        params = { "files" => [123] }
+        expect(validator.valid_values?(params)).to eq([false, ["Expected string, got [123]"]])
+      end
+
+      it "should fail with a multi type array" do
+        params = { "files" => ["Foo", 123] }
+        expect(validator.valid_values?(params)).to eq([false, ["Expected string, got [\"Foo\", 123]"]])
+      end
+      it "should fail with a size > 1 array" do
+        params = { "files" => ["Foo", "Bar"] }
+        expect(validator.valid_values?(params)).to eq([false, ["Expected string, got [\"Foo\", \"Bar\"]"]])
+      end
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/config/validators_spec.rb b/logstash-core/spec/logstash/config/validators_spec.rb
new file mode 100644
index 00000000000..fecce1edb18
--- /dev/null
+++ b/logstash-core/spec/logstash/config/validators_spec.rb
@@ -0,0 +1,103 @@
+# encoding: utf-8
+require "spec_helper"
+require "logstash/config/validators/parameter_validator"
+require "logstash/config/config_validator"
+
+describe "validators" do
+
+  describe LogStash::Config::TypeValidators::String do
+
+    it "should return true for a valid String" do
+      expect(subject.valid?("foo")).to eq(true)
+    end
+
+    it "should return true for a valid string array" do
+      expect(subject.valid?(["foo"])).to eq(true)
+    end
+
+    it "shuold return false for a non string value" do
+      expect(subject.valid?(1234)).to   eq(false)
+      expect(subject.valid?([1234])).to eq(false)
+    end
+
+end
+
+
+  describe LogStash::Config::TypeValidators::Boolean do
+
+    it "should return true for a valid Boolean" do
+      ["true", "false", true, false].each do |type|
+        expect(subject.valid?(type)).to eq(true)
+      end
+    end
+
+    it "should return false for a non valid Boolean" do
+      expect(subject.valid?("truethy")).to eq(false)
+    end
+  end
+
+  describe LogStash::Config::TypeValidators::Bytes do
+   
+    it "should return true for a valid Bytes" do
+      expect(subject.valid?("1 kb")).to eq(true)
+    end
+
+    it "should return false for a invalid Bytes" do
+      expect(subject.valid?("-1 kb")).to eq(false)
+    end
+
+  end
+
+  describe LogStash::Config::Validators::NameValidator do
+
+    let(:config) do
+
+      {"enable_metric"  => { :validate=>:boolean, :default=>true },
+       "id"             => { :validate=>:string },
+       "codec"          => { :validate=>:codec, :default=>"plain" },
+       "size"           => { :validate=>:bytes, :required=>true },
+       "files"          => { :validate=>:array, :required=>true }
+      }
+    end
+
+    let(:params) {
+      {"sized"=>100, "enable_metric"=>true, "debug"=>false, "codec"=>"plain", "add_field"=>{}}
+    }
+
+    subject(:validator) { described_class.new(config, "plugin_type", "plugin_name") }
+
+    it "should return false if the key is not present" do
+      expect(validator.valid?("not-preset-key", 100)).to eq( [false, "Unknown setting 'not-preset-key' for plugin_name"])
+    end
+
+  end
+
+  describe LogStash::Config::Validators::ExistValueValidator do
+
+    let(:config) do
+      {"enable_metric"  => { :validate=>:boolean, :default=>true },
+       "id"             => { :validate=>:string },
+       "codec"          => { :validate=>:codec, :default=>"plain" },
+       "size"           => { :validate=>:bytes, :required=>true },
+       "files"          => { :validate=>:array, :required=>true }}
+    end
+
+    let(:params) {
+      {"sized"=>100, "enable_metric"=>true, "debug"=>false, "codec"=>"plain", "add_field"=>{}}
+    }
+
+    subject(:validator) { described_class.new(config, "plugin_type", "plugin_name") }
+
+    it "should return false if the required value is missing" do
+      expect(validator.valid?("size", nil)).to eq([false, "Missing a required setting for the plugin_name plugin_type plugin:\n\n  plugin_type {\n    plugin_name {\n      size => # SETTING MISSING\n      ...\n    }\n  }"])
+    end
+
+    it "should return true if the required value is present" do
+      expect(validator.valid?("size", 100)).to eq([true, ""])
+    end
+
+    it "should return true if the value is not required" do
+      expect(validator.valid?("codec", "json")).to eq([true, ""])
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/plugin_spec.rb b/logstash-core/spec/logstash/plugin_spec.rb
index 5f0bde381f9..8ae7077093a 100644
--- a/logstash-core/spec/logstash/plugin_spec.rb
+++ b/logstash-core/spec/logstash/plugin_spec.rb
@@ -63,81 +63,6 @@ class LogStash::Filters::MyTestFilter < LogStash::Filters::Base
     end
   end
 
-  context "when validating the plugin version" do
-    let(:plugin_name) { 'logstash-filter-stromae' }
-    subject do
-      Class.new(LogStash::Filters::Base) do
-        config_name 'stromae'
-      end
-    end
-
-    it "doesn't warn the user if the version is superior or equal to 1.0.0" do
-      allow(Gem::Specification).to receive(:find_by_name)
-        .with(plugin_name)
-        .and_return(double(:version => Gem::Version.new('1.0.0')))
-
-      expect_any_instance_of(Cabin::Channel).not_to receive(:info)
-      subject.validate({})
-    end
-
-    it 'warns the user if the plugin version is between 0.9.x and 1.0.0' do
-      allow(Gem::Specification).to receive(:find_by_name)
-        .with(plugin_name)
-        .and_return(double(:version => Gem::Version.new('0.9.1')))
-
-      expect_any_instance_of(Cabin::Channel).to receive(:info)
-        .with(/Using version 0.9.x/)
-
-      subject.validate({})
-    end
-
-    it 'warns the user if the plugin version is inferior to 0.9.x' do
-      allow(Gem::Specification).to receive(:find_by_name)
-        .with(plugin_name)
-        .and_return(double(:version => Gem::Version.new('0.1.1')))
-
-      expect_any_instance_of(Cabin::Channel).to receive(:info)
-        .with(/Using version 0.1.x/)
-      subject.validate({})
-    end
-
-    it "doesnt show the version notice more than once" do
-      one_notice = Class.new(LogStash::Filters::Base) do
-        config_name "stromae"
-      end
-
-      allow(Gem::Specification).to receive(:find_by_name)
-        .with(plugin_name)
-        .and_return(double(:version => Gem::Version.new('0.1.1')))
-
-      expect_any_instance_of(Cabin::Channel).to receive(:info)
-        .once
-        .with(/Using version 0.1.x/)
-
-      one_notice.validate({})
-      one_notice.validate({})
-    end
-
-    it "warns the user if we can't find a defined version" do
-      expect_any_instance_of(Cabin::Channel).to receive(:warn)
-        .once
-        .with(/plugin doesn't have a version/)
-
-      subject.validate({})
-    end
-
-
-    it 'logs a warning if the plugin use the milestone option' do
-      expect_any_instance_of(Cabin::Channel).to receive(:debug)
-        .with(/stromae plugin is using the 'milestone' method/)
-
-      class LogStash::Filters::Stromae < LogStash::Filters::Base
-        config_name "stromae"
-        milestone 2
-      end
-    end
-  end
-
   describe "subclass initialize" do
     let(:args) { Hash.new }
 
