diff --git a/logstash-core/build.gradle b/logstash-core/build.gradle
index 4131604fe76..dcde87a5eca 100644
--- a/logstash-core/build.gradle
+++ b/logstash-core/build.gradle
@@ -122,3 +122,4 @@ dependencies {
     testCompile 'org.assertj:assertj-core:3.8.0'
     provided "org.jruby:jruby-core:$jrubyVersion"
 }
+
diff --git a/logstash-core/lib/logstash/instrument/metric_type/base.rb b/logstash-core/lib/logstash/instrument/metric_type/base.rb
deleted file mode 100644
index b473871b56e..00000000000
--- a/logstash-core/lib/logstash/instrument/metric_type/base.rb
+++ /dev/null
@@ -1,31 +0,0 @@
-# encoding: utf-8
-require "logstash/util"
-
-module LogStash module Instrument module MetricType
-  class Base
-    attr_reader :namespaces, :key
-
-    def initialize(namespaces, key)
-      @namespaces = namespaces
-      @key = key
-    end
-
-    def inspect
-      "#{self.class.name} - namespaces: #{namespaces} key: #{key} value: #{value}"
-    end
-
-    def to_hash
-      {
-        key => value
-      }
-    end
-
-    def to_json_data
-      value
-    end
-
-    def type
-      @type ||= LogStash::Util.class_name(self).downcase
-    end
-  end
-end; end; end
diff --git a/logstash-core/lib/logstash/instrument/metric_type/counter.rb b/logstash-core/lib/logstash/instrument/metric_type/counter.rb
index e99bca57939..ae69effeb21 100644
--- a/logstash-core/lib/logstash/instrument/metric_type/counter.rb
+++ b/logstash-core/lib/logstash/instrument/metric_type/counter.rb
@@ -1,29 +1,17 @@
-# encoding: utf-8
-require "logstash/instrument/metric_type/base"
-require "concurrent"
+#encoding: utf-8
+java_import org.logstash.instrument.metrics.counter.LongCounter
 
 module LogStash module Instrument module MetricType
-  class Counter < Base
-    def initialize(namespaces, key, value = 0)
-      super(namespaces, key)
+  class Counter < LongCounter
 
-      @counter = Concurrent::AtomicFixnum.new(value)
-    end
-
-    def increment(value = 1)
-      @counter.increment(value)
-    end
+    def initialize(namespaces, key)
+      super(namespaces, key.to_s)
 
-    def decrement(value = 1)
-      @counter.decrement(value)
     end
 
     def execute(action, value = 1)
-      @counter.send(action, value)
+      send(action, value)
     end
 
-    def value
-      @counter.value
-    end
   end
 end; end; end
diff --git a/logstash-core/lib/logstash/instrument/metric_type/gauge.rb b/logstash-core/lib/logstash/instrument/metric_type/gauge.rb
index 7981bc877a5..f7808053748 100644
--- a/logstash-core/lib/logstash/instrument/metric_type/gauge.rb
+++ b/logstash-core/lib/logstash/instrument/metric_type/gauge.rb
@@ -1,22 +1,16 @@
 # encoding: utf-8
-require "logstash/instrument/metric_type/base"
-require "concurrent/atomic_reference/mutex_atomic"
-require "logstash/json"
-
+java_import org.logstash.instrument.metrics.gauge.LazyDelegatingGauge
 module LogStash module Instrument module MetricType
-  class Gauge < Base
-    def initialize(namespaces, key)
-      super(namespaces, key)
+  class Gauge < LazyDelegatingGauge
 
-      @gauge = Concurrent::MutexAtomicReference.new()
+    def initialize(namespaces, key)
+      super(namespaces, key.to_s)
     end
 
     def execute(action, value = nil)
-      @gauge.set(value)
+      send(action, value)
     end
 
-    def value
-      @gauge.get
-    end
   end
 end; end; end
+
diff --git a/logstash-core/spec/logstash/instrument/metric_store_spec.rb b/logstash-core/spec/logstash/instrument/metric_store_spec.rb
index 3b655bc3e9d..dac026643cb 100644
--- a/logstash-core/spec/logstash/instrument/metric_store_spec.rb
+++ b/logstash-core/spec/logstash/instrument/metric_store_spec.rb
@@ -1,6 +1,5 @@
 # encoding: utf-8
 require "logstash/instrument/metric_store"
-require "logstash/instrument/metric_type/base"
 
 describe LogStash::Instrument::MetricStore do
   let(:namespaces) { [ :root, :pipelines, :pipeline_01 ] }
@@ -81,7 +80,7 @@
 
         it "allow to retrieve a specific metrics" do
           metrics = subject.get(:node, :sashimi, :pipelines, :pipeline01, :plugins, :"logstash-output-elasticsearch", :event_in)
-          expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => a_hash_including(:plugins => a_hash_including(:"logstash-output-elasticsearch" => a_hash_including(:event_in => be_kind_of(LogStash::Instrument::MetricType::Base)))))))))
+          expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => a_hash_including(:plugins => a_hash_including(:"logstash-output-elasticsearch" => a_hash_including(:event_in => be_kind_of(LogStash::Instrument::MetricType::Counter)))))))))
         end
 
         context "with filtered keys" do
@@ -127,7 +126,7 @@
 
           it "allow to retrieve a specific metrics" do
             metrics = subject.get_with_path("node/sashimi/pipelines/pipeline01/plugins/logstash-output-elasticsearch/event_in")
-            expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => a_hash_including(:plugins => a_hash_including(:"logstash-output-elasticsearch" => a_hash_including(:event_in => be_kind_of(LogStash::Instrument::MetricType::Base)))))))))
+            expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => a_hash_including(:plugins => a_hash_including(:"logstash-output-elasticsearch" => a_hash_including(:event_in => be_kind_of(LogStash::Instrument::MetricType::Counter)))))))))
           end
 
           context "with filtered keys" do
diff --git a/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb b/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb
index 05d9054069d..82b7c581acc 100644
--- a/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb
+++ b/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb
@@ -14,22 +14,10 @@
     end
   end
 
-  describe "#decrement" do
-    it "decrement the counter" do
-      expect{ subject.decrement }.to change { subject.value }.by(-1)
-    end
-  end
-
   context "When serializing to JSON" do
     it "serializes the value" do
       expect(LogStash::Json.dump(subject)).to eq("0")
     end
   end
 
-  context "When creating a hash " do
-    it "creates the hash from all the values" do
-      metric_hash = { key => 0 }
-      expect(subject.to_hash).to match(metric_hash)
-    end
-  end
 end
diff --git a/logstash-core/spec/logstash/instrument/metric_type/gauge_spec.rb b/logstash-core/spec/logstash/instrument/metric_type/gauge_spec.rb
index e285a8eb5cf..69ee278a0e7 100644
--- a/logstash-core/spec/logstash/instrument/metric_type/gauge_spec.rb
+++ b/logstash-core/spec/logstash/instrument/metric_type/gauge_spec.rb
@@ -26,12 +26,5 @@
     end
   end
 
-  context "When creating a hash " do
-    it "creates the hash from all the values" do
-      metric_hash = {
-        key => value
-      }
-      expect(subject.to_hash).to match(metric_hash)
-    end
-  end
+
 end
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/AbstractMetric.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/AbstractMetric.java
new file mode 100644
index 00000000000..85cdbfc4f98
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/AbstractMetric.java
@@ -0,0 +1,41 @@
+package org.logstash.instrument.metrics;
+
+
+import com.fasterxml.jackson.annotation.JsonValue;
+
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Abstract implementation of a {@link Metric}. All metrics should subclass this.
+ *
+ * @param <T> The underlying type for this metric. For example {@link Long} for Counter, or {@link String} for Gauge.
+ */
+public abstract class AbstractMetric<T> implements Metric<T> {
+    final protected String key;
+    final protected List<String> nameSpace;
+
+    /**
+     * Constructor
+     *
+     * @param nameSpace The namespace for this metric
+     * @param key       The key <i>(with in the namespace)</i> for this metric
+     */
+    protected AbstractMetric(final List<String> nameSpace, final String key) {
+        this.nameSpace = nameSpace;
+        this.key = key;
+    }
+
+    @Override
+    public abstract MetricType getType();
+
+    @JsonValue
+    public abstract T getValue();
+
+    @Override
+    public String toString() {
+        return String.format("%s - namespace: %s key: %s value:%s", this.getClass().getName(), Arrays.toString(nameSpace.toArray()), this.key, getValue() == null ? "null" :
+                getValue().toString());
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/Metric.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/Metric.java
new file mode 100644
index 00000000000..3aa7fc99778
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/Metric.java
@@ -0,0 +1,55 @@
+package org.logstash.instrument.metrics;
+
+/**
+ * Top level contract for metrics within Logstash.
+ *
+ * @param <T> The underlying type for this metric. For example {@link Long} for Counter, or {@link String} for Gauge.
+ * @since 6.0
+ */
+public interface Metric<T> {
+
+    /**
+     * This should be equal to #getValue, exists for passivity with legacy Ruby code. Java consumers should use #getValue().
+     *
+     * @return This metric value
+     * @deprecated
+     */
+    default T get() {
+        return getValue();
+    }
+
+    /**
+     * The enumerated Metric Type. This is a semantic type <i>(not Java type)</i> that can be useful to help identify the type of Metric. For example "counter/long".
+     *
+     * @return The {@link MetricType} that this metric represents.
+     */
+    MetricType getType();
+
+    /**
+     * Retrieves the value associated with this metric
+     *
+     * @return This metric value
+     */
+    T getValue();
+
+    /**
+     * This may be equal to the #toString method, exists for passivity with legacy Ruby code. Java consumers should use #toString
+     *
+     * @return A description of this Metric that can be used for logging.
+     * @deprecated
+     */
+    default String inspect() {
+        return toString();
+    }
+
+    /**
+     * This should be equal to {@link MetricType#asString()}, exists for passivity with legacy Ruby code. Java consumers should use #getType().
+     *
+     * @return The {@link String} version of the {@link MetricType}
+     * @deprecated
+     */
+    default String type() {
+        return getType().asString();
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/MetricType.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/MetricType.java
new file mode 100644
index 00000000000..cc412a6bc82
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/MetricType.java
@@ -0,0 +1,61 @@
+package org.logstash.instrument.metrics;
+
+
+import java.util.EnumSet;
+
+/**
+ * A semantic means of defining the type of metric. Also serves as the list of supported metrics.
+ */
+public enum MetricType {
+
+    /**
+     * A counter backed by a {@link Long} type
+     */
+    COUNTER_LONG("counter/long"),
+    /**
+     * A gauge backed by a {@link String} type
+     */
+    GAUGE_TEXT("gauge/text"),
+    /**
+     * A gauge backed by a {@link Boolean} type
+     */
+    GAUGE_BOOLEAN("gauge/boolean"),
+    /**
+     * A gauge backed by a {@link Number} type
+     */
+    GAUGE_NUMERIC("gauge/numeric"),
+    /**
+     * A gauge backed by a {@link Object} type.
+     */
+    GAUGE_UNKNOWN("gauge/unknown"),
+    /**
+     * A gauge backed by a {@link org.jruby.RubyHash} type. Note - Java consumers should not use this, exist for legacy Ruby code.
+     */
+    GAUGE_RUBYHASH("gauge/rubyhash");
+
+    private final String type;
+
+    MetricType(final String type) {
+        this.type = type;
+    }
+
+    /**
+     * Finds the {@link MetricType} enumeration that matches the provided {@link String}
+     *
+     * @param s The input string
+     * @return The {@link MetricType} that matches the input, else null.
+     */
+    public static MetricType fromString(String s) {
+        return EnumSet.allOf(MetricType.class).stream().filter(e -> e.asString().equalsIgnoreCase(s)).findFirst().orElse(null);
+    }
+
+    /**
+     * Retrieve the {@link String} representation of this MetricType.
+     *
+     * @return the {@link String} representation
+     */
+    public String asString() {
+        return type;
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/counter/CounterMetric.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/counter/CounterMetric.java
new file mode 100644
index 00000000000..8f2dda58ed0
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/counter/CounterMetric.java
@@ -0,0 +1,22 @@
+package org.logstash.instrument.metrics.counter;
+
+import org.logstash.instrument.metrics.Metric;
+
+/**
+ * A {@link Metric} to count things. A counter can only increment, and there are no guarantees of durability of current value between JVM restarts.
+ * @param <T> The underlying {@link Number} type that can be incremented. Care should be taken to which {@link Number} is used to back the counter, since some {@link Number}
+ *           types may not be appropriate for a monotonic increasing series.
+ */
+public interface CounterMetric<T extends Number> extends Metric<T> {
+
+    /**
+     * Helper method that increments by 1
+     */
+    void increment();
+
+    /**
+     * Increments the counter by the value specified. <i>The caller should be careful to avoid incrementing by values so large as to overflow the underlying type.</i>
+     * @param by The value which to increment by.
+     */
+    void increment(T by) ;
+}
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/counter/LongCounter.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/counter/LongCounter.java
new file mode 100644
index 00000000000..04a65ad954a
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/counter/LongCounter.java
@@ -0,0 +1,66 @@
+package org.logstash.instrument.metrics.counter;
+
+
+import org.logstash.instrument.metrics.AbstractMetric;
+import org.logstash.instrument.metrics.MetricType;
+
+import java.util.List;
+import java.util.concurrent.atomic.LongAdder;
+
+/**
+ * A {@link CounterMetric} that is backed by a {@link Long} type.
+ */
+public class LongCounter extends AbstractMetric<Long> implements CounterMetric<Long> {
+
+    private final LongAdder longAdder;
+
+    /**
+     * Constructor
+     *
+     * @param nameSpace    The namespace for this metric
+     * @param key          The key <i>(with in the namespace)</i> for this metric
+     */
+    public LongCounter(List<String> nameSpace, String key) {
+        super(nameSpace, key);
+        longAdder = new LongAdder();
+     }
+
+    @Override
+    public MetricType getType() {
+        return MetricType.COUNTER_LONG;
+    }
+
+    @Override
+    public Long getValue() {
+        return longAdder.longValue();
+    }
+
+    @Override
+    public void increment() {
+        increment(1l);
+    }
+
+    /**
+     * {@inheritDoc}
+     * throws {@link UnsupportedOperationException} if attempt is made to increment by a negative value
+     */
+    @Override
+    public void increment(Long by) {
+        if (by < 0) {
+            throw new UnsupportedOperationException("Counters can not be incremented by negative values");
+        }
+        longAdder.add(by);
+    }
+
+    /**
+     * Optimized version of {@link #increment(Long)} to avoid auto-boxing.
+     * throws {@link UnsupportedOperationException} if attempt is made to increment by a negative value
+     */
+    public void increment(long by) {
+        if (by < 0) {
+            throw new UnsupportedOperationException("Counters can not be incremented by negative values");
+        }
+        longAdder.add(by);
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/BooleanGauge.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/BooleanGauge.java
new file mode 100644
index 00000000000..6864c9870d7
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/BooleanGauge.java
@@ -0,0 +1,53 @@
+package org.logstash.instrument.metrics.gauge;
+
+import org.logstash.instrument.metrics.AbstractMetric;
+import org.logstash.instrument.metrics.MetricType;
+import org.logstash.instrument.metrics.counter.CounterMetric;
+
+import java.util.List;
+
+/**
+ * A {@link GaugeMetric} that is backed by a {@link Boolean}
+ */
+public class BooleanGauge extends AbstractMetric<Boolean> implements GaugeMetric<Boolean> {
+
+    private volatile Boolean value;
+
+    /**
+     * Constructor - null initial value
+     *
+     * @param nameSpace    The namespace for this metric
+     * @param key          The key <i>(with in the namespace)</i> for this metric
+     */
+    public BooleanGauge(List<String> nameSpace, String key) {
+        this(nameSpace, key, null);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param nameSpace    The namespace for this metric
+     * @param key          The key <i>(with in the namespace)</i> for this metric
+     * @param initialValue The initial value for this {@link GaugeMetric}, may be null
+     */
+    public BooleanGauge(List<String> nameSpace, String key, Boolean initialValue) {
+        super(nameSpace, key);
+        this.value = initialValue;
+    }
+
+    @Override
+    public MetricType getType() {
+        return MetricType.GAUGE_BOOLEAN;
+    }
+
+    @Override
+    public Boolean getValue() {
+        return value;
+    }
+
+    @Override
+    public void set(Boolean value) {
+        this.value = value;
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/GaugeMetric.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/GaugeMetric.java
new file mode 100644
index 00000000000..4037a8ad24e
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/GaugeMetric.java
@@ -0,0 +1,18 @@
+package org.logstash.instrument.metrics.gauge;
+
+
+import org.logstash.instrument.metrics.Metric;
+
+/**
+ * A {@link Metric} to set/get a value. A Gauge is useful for measuring a single value that may change over time, but does not carry any additional semantics beyond simply setting
+ * and getting the value.
+ * @param <T> The backing Java type for the gauge. For example, a text gauge is backed by a {@link String}
+ */
+public interface GaugeMetric<T> extends Metric<T> {
+
+    /**
+     * Sets the value
+     * @param value The value to set
+     */
+    void set(T value);
+}
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/LazyDelegatingGauge.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/LazyDelegatingGauge.java
new file mode 100644
index 00000000000..8b487c8ec75
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/LazyDelegatingGauge.java
@@ -0,0 +1,100 @@
+package org.logstash.instrument.metrics.gauge;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.jruby.RubyHash;
+import org.logstash.instrument.metrics.AbstractMetric;
+import org.logstash.instrument.metrics.MetricType;
+import org.logstash.instrument.metrics.counter.CounterMetric;
+
+import java.util.List;
+
+/**
+ * A lazy proxy to a more specific typed {@link GaugeMetric}. The metric will only be initialized if the initial value is set, or once the {@code set} operation is called.
+ * <p><strong>Intended only for use with Ruby's duck typing, Java consumers should use the specific typed {@link GaugeMetric}</strong></p>
+ */
+public class LazyDelegatingGauge extends AbstractMetric<Object> implements GaugeMetric<Object> {
+
+    private final static Logger LOGGER = LogManager.getLogger(LazyDelegatingGauge.class);
+
+    protected final String key;
+    protected final List<String> nameSpaces;
+
+    private GaugeMetric lazyMetric;
+
+    /**
+     * Constructor - protected so that Ruby may sub class proxy and discourage usage from Java, null initial value
+     *
+     * @param nameSpace The namespace for this metric
+     * @param key       The key <i>(with in the namespace)</i> for this metric
+     */
+    public LazyDelegatingGauge(final List<String> nameSpace, final String key) {
+        this(nameSpace, key, null);
+    }
+
+    /**
+     * Constructor - protected so that Ruby may sub class proxy and discourage usage from Java
+     *
+     * @param nameSpace    The namespace for this metric
+     * @param key          The key <i>(with in the namespace)</i> for this metric
+     * @param initialValue The initial value for this {@link GaugeMetric}, may be null
+     */
+    protected LazyDelegatingGauge(List<String> nameSpace, String key, Object initialValue) {
+        super(nameSpace, key);
+        this.nameSpaces = nameSpace;
+        this.key = key;
+        if (initialValue != null) {
+            wakeMetric(initialValue);
+        }
+    }
+
+    @Override
+    @SuppressWarnings( "deprecation" )
+    public Object get() {
+        return lazyMetric == null ? null : lazyMetric.get();
+    }
+
+    @Override
+    public MetricType getType() {
+        return lazyMetric == null ? null : lazyMetric.getType();
+    }
+
+    @Override
+    public Object getValue() {
+        return lazyMetric == null ? null : lazyMetric.getValue();
+    }
+
+    @Override
+    public void set(Object value) {
+        if (lazyMetric == null) {
+            wakeMetric(value);
+        } else {
+            lazyMetric.set(value);
+        }
+    }
+
+    /**
+     * Instantiates the metric based on the type used to set this Gauge
+     *
+     * @param value The object used to set this value
+     */
+    private synchronized void wakeMetric(Object value) {
+        if (lazyMetric == null && value != null) {
+            //"quack quack"
+            if (value instanceof Number) {
+                lazyMetric = new NumericGauge(nameSpaces, key, (Number) value);
+            } else if (value instanceof String) {
+                lazyMetric = new TextGauge(nameSpaces, key, (String) value);
+            } else if (value instanceof Boolean) {
+                lazyMetric = new BooleanGauge(nameSpaces, key, (Boolean) value);
+            } else if (value instanceof RubyHash) {
+                lazyMetric = new RubyHashGauge(nameSpaces, key, (RubyHash) value);
+            } else {
+                LOGGER.warn("A gauge metric of an unknown type ({}) has been create for key: {}, namespace:{}. This may result in invalid serialization.  It is recommended to " +
+                        "log an issue to the responsible developer/development team.", value.getClass().getCanonicalName(), key, nameSpaces);
+                lazyMetric = new UnknownGauge(nameSpaces, key, value);
+            }
+        }
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/NumericGauge.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/NumericGauge.java
new file mode 100644
index 00000000000..b5ee49eade4
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/NumericGauge.java
@@ -0,0 +1,52 @@
+package org.logstash.instrument.metrics.gauge;
+
+import org.logstash.instrument.metrics.AbstractMetric;
+import org.logstash.instrument.metrics.MetricType;
+
+import java.util.List;
+
+/**
+ * A {@link GaugeMetric} that is backed by a {@link Number}
+ */
+public class NumericGauge extends AbstractMetric<Number> implements GaugeMetric<Number> {
+
+    private volatile Number value;
+
+    /**
+     * Constructor
+     *
+     * @param nameSpace The namespace for this metric
+     * @param key       The key <i>(with in the namespace)</i> for this metric
+     */
+    public NumericGauge(List<String> nameSpace, String key) {
+        this(nameSpace, key, null);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param nameSpace    The namespace for this metric
+     * @param key          The key <i>(with in the namespace)</i> for this metric
+     * @param initialValue The initial value for this {@link GaugeMetric}, may be null
+     */
+    public NumericGauge(List<String> nameSpace, String key, Number initialValue) {
+        super(nameSpace, key);
+        this.value = initialValue;
+    }
+
+    @Override
+    public MetricType getType() {
+        return MetricType.GAUGE_NUMERIC;
+    }
+
+    @Override
+    public Number getValue() {
+        return value;
+    }
+
+    @Override
+    public void set(Number value) {
+        this.value = value;
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/RubyHashGauge.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/RubyHashGauge.java
new file mode 100644
index 00000000000..c48479a30a6
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/RubyHashGauge.java
@@ -0,0 +1,54 @@
+package org.logstash.instrument.metrics.gauge;
+
+import org.jruby.RubyHash;
+import org.logstash.instrument.metrics.AbstractMetric;
+import org.logstash.instrument.metrics.MetricType;
+
+import java.util.List;
+
+/**
+ * A {@link GaugeMetric} that is backed by a {@link RubyHash}.  Note - This should not be used directly from Java code and exists for passivity with legacy Ruby code. Depending
+ * on the types in in the {@link RubyHash} there are no guarantees serializing properly.
+ */
+public class RubyHashGauge extends AbstractMetric<RubyHash> implements GaugeMetric<RubyHash> {
+
+    private volatile RubyHash value;
+
+    /**
+     * Constructor - protected so that Ruby may sub class proxy and discourage usage from Java, null initial value
+     *
+     * @param nameSpace    The namespace for this metric
+     * @param key          The key <i>(with in the namespace)</i> for this metric
+     */
+    protected RubyHashGauge(List<String> nameSpace, String key) {
+        this(nameSpace, key, null);
+    }
+
+    /**
+     * Constructor - protected so that Ruby may sub class proxy and discourage usage from Java
+     *
+     * @param nameSpace    The namespace for this metric
+     * @param key          The key <i>(with in the namespace)</i> for this metric
+     * @param initialValue The initial value for this {@link GaugeMetric}, may be null
+     */
+    protected RubyHashGauge(List<String> nameSpace, String key, RubyHash initialValue) {
+        super(nameSpace, key);
+        this.value = initialValue;
+    }
+
+    @Override
+    public MetricType getType() {
+        return MetricType.GAUGE_RUBYHASH;
+    }
+
+    @Override
+    public RubyHash getValue() {
+        return value;
+    }
+
+    @Override
+    public void set(RubyHash value) {
+        this.value = value;
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/TextGauge.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/TextGauge.java
new file mode 100644
index 00000000000..2c029c38718
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/TextGauge.java
@@ -0,0 +1,54 @@
+package org.logstash.instrument.metrics.gauge;
+
+
+import org.logstash.instrument.metrics.AbstractMetric;
+import org.logstash.instrument.metrics.MetricType;
+
+import java.util.List;
+
+/**
+ * A {@link GaugeMetric} that is backed by a {@link String}
+ */
+public class TextGauge extends AbstractMetric<String> implements GaugeMetric<String> {
+
+    private volatile String value;
+
+    /**
+     * Constructor - null initial value
+     *
+     * @param nameSpace The namespace for this metric
+     * @param key       The key <i>(with in the namespace)</i> for this metric
+     */
+    public TextGauge(List<String> nameSpace, String key) {
+        this(nameSpace, key, null);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param nameSpace    The namespace for this metric
+     * @param key          The key <i>(with in the namespace)</i> for this metric
+     * @param initialValue The initial value for this {@link GaugeMetric}, may be null
+     */
+    public TextGauge(List<String> nameSpace, String key, String initialValue) {
+        super(nameSpace, key);
+        this.value = initialValue;
+    }
+
+    @Override
+    public MetricType getType() {
+        return MetricType.GAUGE_TEXT;
+    }
+
+    @Override
+    public String getValue() {
+        return value;
+    }
+
+    @Override
+    public void set(String value) {
+        this.value = value;
+    }
+
+
+}
\ No newline at end of file
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/UnknownGauge.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/UnknownGauge.java
new file mode 100644
index 00000000000..418c0bc6b41
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/gauge/UnknownGauge.java
@@ -0,0 +1,52 @@
+package org.logstash.instrument.metrics.gauge;
+
+import org.logstash.instrument.metrics.AbstractMetric;
+import org.logstash.instrument.metrics.MetricType;
+
+import java.util.List;
+
+/**
+ * A {@link GaugeMetric} that is backed by a {@link Object}.  Note - A stronger typed {@link GaugeMetric} should be used since this makes no guarantees of serializing properly.
+ */
+public class UnknownGauge extends AbstractMetric<Object> implements GaugeMetric<Object> {
+
+    private volatile Object value;
+
+    /**
+     * Constructor - null initial value
+     *
+     * @param nameSpace    The namespace for this metric
+     * @param key          The key <i>(with in the namespace)</i> for this metric
+     */
+    public UnknownGauge(List<String> nameSpace, String key) {
+        this(nameSpace, key, null);
+    }
+
+    /**
+     * Constructor
+     *
+     * @param nameSpace    The namespace for this metric
+     * @param key          The key <i>(with in the namespace)</i> for this metric
+     * @param initialValue The initial value for this {@link GaugeMetric}, may be null
+     */
+    public UnknownGauge(List<String> nameSpace, String key, Object initialValue) {
+        super(nameSpace, key);
+        this.value = initialValue;
+    }
+
+    @Override
+    public MetricType getType() {
+        return MetricType.GAUGE_UNKNOWN;
+    }
+
+    @Override
+    public Object getValue() {
+        return value;
+    }
+
+    @Override
+    public void set(Object value) {
+        this.value = value;
+    }
+
+}
diff --git a/logstash-core/src/test/java/org/logstash/instrument/metrics/MetricTypeTest.java b/logstash-core/src/test/java/org/logstash/instrument/metrics/MetricTypeTest.java
new file mode 100644
index 00000000000..15dfa003c30
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/instrument/metrics/MetricTypeTest.java
@@ -0,0 +1,38 @@
+package org.logstash.instrument.metrics;
+
+import org.junit.Test;
+
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+
+/**
+ * Unit tests for {@link MetricType}
+ */
+public class MetricTypeTest {
+
+    /**
+     * The {@link String} version of the {@link MetricType} should be considered as a public contract, and thus non-passive to change. Admittedly this test is a bit silly since it
+     * just duplicates the code, but should cause a developer to think twice if they are changing the public contract.
+     */
+    @Test
+    public void ensurePassivity(){
+        Map<MetricType, String>  nameMap = new HashMap(EnumSet.allOf(MetricType.class).size());
+        nameMap.put(MetricType.COUNTER_LONG, "counter/long");
+        nameMap.put(MetricType.GAUGE_TEXT, "gauge/text");
+        nameMap.put(MetricType.GAUGE_BOOLEAN, "gauge/boolean");
+        nameMap.put(MetricType.GAUGE_NUMERIC, "gauge/numeric");
+        nameMap.put(MetricType.GAUGE_UNKNOWN, "gauge/unknown");
+        nameMap.put(MetricType.GAUGE_RUBYHASH, "gauge/rubyhash");
+
+        //ensure we are testing all of the enumerations
+        assertThat(EnumSet.allOf(MetricType.class).size()).isEqualTo(nameMap.size());
+
+        nameMap.forEach((k,v) -> assertThat(k.asString()).isEqualTo(v));
+        nameMap.forEach((k,v) -> assertThat(MetricType.fromString(v)).isEqualTo(k));
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/instrument/metrics/counter/LongCounterTest.java b/logstash-core/src/test/java/org/logstash/instrument/metrics/counter/LongCounterTest.java
new file mode 100644
index 00000000000..2aa46f31246
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/instrument/metrics/counter/LongCounterTest.java
@@ -0,0 +1,60 @@
+package org.logstash.instrument.metrics.counter;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.logstash.instrument.metrics.MetricType;
+
+import java.util.Collections;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+
+/**
+ * Unit tests for {@link LongCounter}
+ */
+public class LongCounterTest {
+
+    private final long INITIAL_VALUE = 0l;
+    private LongCounter longCounter;
+
+    @Before
+    public void _setup() {
+        longCounter = new LongCounter(Collections.singletonList("foo"), "bar");
+    }
+
+    @Test
+    public void getValue() {
+        assertThat(longCounter.getValue()).isEqualTo(INITIAL_VALUE);
+    }
+
+    @Test
+    public void increment() {
+
+        longCounter.increment();
+        assertThat(longCounter.getValue()).isEqualTo(INITIAL_VALUE + 1);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void incrementByNegativeValue() {
+        longCounter.increment(-100l);
+    }
+
+    @Test
+    public void incrementByValue() {
+        longCounter.increment(100l);
+        assertThat(longCounter.getValue()).isEqualTo(INITIAL_VALUE + 100);
+    }
+
+    @Test
+    public void noInitialValue() {
+        LongCounter counter = new LongCounter(Collections.singletonList("foo"), "bar");
+        counter.increment();
+        assertThat(counter.getValue()).isEqualTo(1l);
+    }
+
+    @Test
+    @SuppressWarnings( "deprecation" )
+    public void type() {
+        assertThat(longCounter.type()).isEqualTo(MetricType.COUNTER_LONG.asString());
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/BooleanGaugeTest.java b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/BooleanGaugeTest.java
new file mode 100644
index 00000000000..200e5f4f886
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/BooleanGaugeTest.java
@@ -0,0 +1,35 @@
+package org.logstash.instrument.metrics.gauge;
+
+import org.junit.Test;
+import org.logstash.instrument.metrics.MetricType;
+
+import java.util.Collections;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Unit tests for {@link BooleanGauge}
+ */
+public class BooleanGaugeTest {
+    @Test
+    public void getValue() {
+        BooleanGauge gauge = new BooleanGauge(Collections.singletonList("foo"), "bar", true);
+        assertThat(gauge.getValue()).isTrue();
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_BOOLEAN);
+
+        //Null initialize
+        gauge = new BooleanGauge(Collections.singletonList("foo"), "bar");
+        assertThat(gauge.getValue()).isNull();
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_BOOLEAN);
+    }
+
+    @Test
+    public void set() {
+        BooleanGauge gauge = new BooleanGauge(Collections.singletonList("foo"), "bar");
+        gauge.set(true);
+        assertThat(gauge.getValue()).isTrue();
+        gauge.set(false);
+        assertThat(gauge.getValue()).isFalse();
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_BOOLEAN);
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/LazyDelegatingGaugeTest.java b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/LazyDelegatingGaugeTest.java
new file mode 100644
index 00000000000..5750f3d4da4
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/LazyDelegatingGaugeTest.java
@@ -0,0 +1,124 @@
+package org.logstash.instrument.metrics.gauge;
+
+import org.jruby.RubyHash;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.logstash.instrument.metrics.MetricType;
+import org.mockito.Mock;
+import org.mockito.runners.MockitoJUnitRunner;
+
+import java.net.URI;
+import java.util.Collections;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.when;
+
+/**
+ * Unit tests for {@link LazyDelegatingGauge}
+ */
+@RunWith(MockitoJUnitRunner.class)
+public class LazyDelegatingGaugeTest {
+
+    @Mock
+    RubyHash rubyHash;
+
+    private static final String RUBY_HASH_AS_STRING = "{}";
+
+    @Before
+    public void _setup() {
+        //hacky workaround using the toString method to avoid mocking the Ruby runtime
+        when(rubyHash.toString()).thenReturn(RUBY_HASH_AS_STRING);
+    }
+
+    @Test
+    public void getValue() {
+        //Numeric
+        LazyDelegatingGauge gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar", 99l);
+        assertThat(gauge.getValue()).isEqualTo(99l);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_NUMERIC);
+
+        //Boolean
+        gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar", true);
+        assertThat(gauge.getValue()).isEqualTo(true);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_BOOLEAN);
+
+        //Text
+        gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar", "something");
+        assertThat(gauge.getValue()).isEqualTo("something");
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_TEXT);
+
+        //Ruby Hash
+        gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar", rubyHash);
+        assertThat(gauge.getValue().toString()).isEqualTo(RUBY_HASH_AS_STRING);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_RUBYHASH);
+
+        //Unknown
+        gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar", Collections.singleton("value"));
+        assertThat(gauge.getValue()).isEqualTo(Collections.singleton("value"));
+        assertThat(gauge.getValue()).isEqualTo(gauge.get());
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_UNKNOWN);
+
+        //Null
+        gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar");
+        assertThat(gauge.getValue()).isNull();
+        assertThat(gauge.get()).isNull();
+        assertThat(gauge.getType()).isNull();
+    }
+
+    @Test
+    public void set() {
+        //Numeric
+        LazyDelegatingGauge gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar");
+        gauge.set(99l);
+        assertThat(gauge.getValue()).isEqualTo(99l);
+        gauge.set(199l);
+        assertThat(gauge.getValue()).isEqualTo(199l);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_NUMERIC);
+
+        //Boolean
+        gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar");
+        gauge.set(true);
+        assertThat(gauge.getValue()).isEqualTo(true);
+        gauge.set(false);
+        assertThat(gauge.getValue()).isEqualTo(false);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_BOOLEAN);
+
+        //Text
+        gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar");
+        gauge.set("something");
+        assertThat(gauge.getValue()).isEqualTo("something");
+        gauge.set("something else");
+        assertThat(gauge.getValue()).isEqualTo("something else");
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_TEXT);
+
+        //Ruby Hash
+        gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar");
+        gauge.set(rubyHash);
+        assertThat(gauge.getValue().toString()).isEqualTo(RUBY_HASH_AS_STRING);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_RUBYHASH);
+
+        //Unknown
+        gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar");
+        gauge.set(Collections.singleton("value"));
+        assertThat(gauge.getValue()).isEqualTo(Collections.singleton("value"));
+        gauge.set(URI.create("foo")); //please don't change the type of gauge after already set
+        assertThat(gauge.getValue()).isEqualTo(URI.create("foo"));
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_UNKNOWN);
+
+        //Null
+        gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar");
+        gauge.set(null);
+        assertThat(gauge.getValue()).isNull();
+        assertThat(gauge.getType()).isNull();
+
+        //Valid, then Null
+        gauge = new LazyDelegatingGauge(Collections.singletonList("foo"), "bar");
+        gauge.set("something");
+        assertThat(gauge.getValue()).isEqualTo("something");
+        gauge.set(null);
+        assertThat(gauge.getValue()).isNull();
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_TEXT);
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/NumericGaugeTest.java b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/NumericGaugeTest.java
new file mode 100644
index 00000000000..ed8260fff9e
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/NumericGaugeTest.java
@@ -0,0 +1,58 @@
+package org.logstash.instrument.metrics.gauge;
+
+import org.junit.Test;
+import org.logstash.instrument.metrics.MetricType;
+
+import java.math.BigInteger;
+import java.util.Collections;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+
+/**
+ * Unit tests for {@link NumericGauge}
+ */
+public class NumericGaugeTest {
+
+
+    @Test
+    public void getValue() {
+
+        //Long
+        NumericGauge gauge = new NumericGauge(Collections.singletonList("foo"), "bar", 99l);
+        assertThat(gauge.getValue()).isEqualTo(99l);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_NUMERIC);
+
+        //Float
+        gauge = new NumericGauge(Collections.singletonList("foo"), "bar", 123.0f);
+        assertThat(gauge.getValue()).isEqualTo(123.0f);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_NUMERIC);
+
+        //Null
+        gauge = new NumericGauge(Collections.singletonList("foo"), "bar");
+        assertThat(gauge.getValue()).isNull();
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_NUMERIC);
+    }
+
+
+    @Test
+    public void set() {
+        //Long
+        NumericGauge gauge = new NumericGauge(Collections.singletonList("foo"), "bar");
+        gauge.set(99l);
+        assertThat(gauge.getValue()).isEqualTo(99l);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_NUMERIC);
+
+        //Float
+        gauge = new NumericGauge(Collections.singletonList("foo"), "bar");
+        gauge.set(123.0f);
+        assertThat(gauge.getValue()).isEqualTo(123.0f);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_NUMERIC);
+
+        //Null
+        gauge = new NumericGauge(Collections.singletonList("foo"), "bar");
+        gauge.set(BigInteger.TEN);
+        assertThat(gauge.getValue()).isEqualTo(BigInteger.TEN);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_NUMERIC);
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/RubyHashGaugeTest.java b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/RubyHashGaugeTest.java
new file mode 100644
index 00000000000..440aefdd8a4
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/RubyHashGaugeTest.java
@@ -0,0 +1,57 @@
+package org.logstash.instrument.metrics.gauge;
+
+import org.jruby.RubyHash;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.logstash.instrument.metrics.MetricType;
+import org.mockito.Mock;
+import org.mockito.runners.MockitoJUnitRunner;
+
+import java.util.Collections;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.ThrowableAssert.catchThrowable;
+import static org.mockito.Mockito.when;
+
+/**
+ * Unit tests for {@link RubyHashGauge}
+ */
+@RunWith(MockitoJUnitRunner.class)
+public class RubyHashGaugeTest {
+
+    @Mock
+    RubyHash rubyHash;
+
+    private static final String RUBY_HASH_AS_STRING = "{}";
+
+    @Before
+    public void _setup() {
+        //hacky workaround using the toString method to avoid mocking the Ruby runtime
+        when(rubyHash.toString()).thenReturn(RUBY_HASH_AS_STRING);
+    }
+
+    @Test
+    public void getValue() {
+        RubyHashGauge gauge = new RubyHashGauge(Collections.singletonList("foo"), "bar", rubyHash);
+        assertThat(gauge.getValue().toString()).isEqualTo(RUBY_HASH_AS_STRING);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_RUBYHASH);
+
+        //Null initialize
+        final RubyHashGauge gauge2 = new RubyHashGauge(Collections.singletonList("foo"), "bar");
+        Throwable thrown = catchThrowable(() -> {
+            gauge2.getValue().toString();
+        });
+        assertThat(thrown).isInstanceOf(NullPointerException.class);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_RUBYHASH);
+    }
+
+    @Test
+    public void set() {
+        RubyHashGauge gauge = new RubyHashGauge(Collections.singletonList("foo"), "bar");
+        gauge.set(rubyHash);
+        assertThat(gauge.getValue().toString()).isEqualTo(RUBY_HASH_AS_STRING);
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_RUBYHASH);
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/TextGaugeTest.java b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/TextGaugeTest.java
new file mode 100644
index 00000000000..9fa46d02b6b
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/TextGaugeTest.java
@@ -0,0 +1,33 @@
+package org.logstash.instrument.metrics.gauge;
+
+import org.junit.Test;
+import org.logstash.instrument.metrics.MetricType;
+
+import java.util.Collections;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Unit tests for {@link TextGauge}
+ */
+public class TextGaugeTest {
+    @Test
+    public void getValue() {
+        TextGauge gauge = new TextGauge(Collections.singletonList("foo"), "bar", "baz");
+        assertThat(gauge.getValue()).isEqualTo("baz");
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_TEXT);
+
+        //Null initialize
+        gauge = new TextGauge(Collections.singletonList("foo"), "bar");
+        assertThat(gauge.getValue()).isNull();
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_TEXT);
+    }
+
+    @Test
+    public void set() {
+        TextGauge gauge = new TextGauge(Collections.singletonList("foo"), "bar");
+        gauge.set("baz");
+        assertThat(gauge.getValue()).isEqualTo("baz");
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_TEXT);
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/UnknownGaugeTest.java b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/UnknownGaugeTest.java
new file mode 100644
index 00000000000..c0a2fa5676c
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/instrument/metrics/gauge/UnknownGaugeTest.java
@@ -0,0 +1,37 @@
+package org.logstash.instrument.metrics.gauge;
+
+import org.junit.Test;
+import org.logstash.instrument.metrics.MetricType;
+
+import java.net.URI;
+import java.util.Collections;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Unit tests for {@link UnknownGauge}
+ */
+public class UnknownGaugeTest {
+
+    @Test
+    public void getValue() {
+        UnknownGauge gauge = new UnknownGauge(Collections.singletonList("foo"), "bar", URI.create("baz"));
+        assertThat(gauge.getValue()).isEqualTo(URI.create("baz"));
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_UNKNOWN);
+
+        //Null initialize
+        gauge = new UnknownGauge(Collections.singletonList("foo"), "bar");
+        assertThat(gauge.getValue()).isNull();
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_UNKNOWN);
+    }
+
+    @Test
+    public void set() {
+        UnknownGauge gauge = new UnknownGauge(Collections.singletonList("foo"), "bar");
+        gauge.set(URI.create("baz"));
+        assertThat(gauge.getValue()).isEqualTo(URI.create("baz"));
+        gauge.set(URI.create("fizzbuzz"));
+        assertThat(gauge.getValue()).isEqualTo(URI.create("fizzbuzz"));
+        assertThat(gauge.getType()).isEqualTo(MetricType.GAUGE_UNKNOWN);
+    }
+}
