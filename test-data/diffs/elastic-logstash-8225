diff --git a/logstash-core/build.gradle b/logstash-core/build.gradle
index e50a226be2d..8e3777c18b0 100644
--- a/logstash-core/build.gradle
+++ b/logstash-core/build.gradle
@@ -112,6 +112,6 @@ dependencies {
     testCompile 'net.javacrumbs.json-unit:json-unit:1.9.0'
     testCompile 'org.elasticsearch:securemock:1.2'
     testCompile 'org.assertj:assertj-core:3.8.0'
-    provided "org.jruby:jruby-core:$jrubyVersion"
+    provided "org.jruby:jruby-complete:$jrubyVersion"
 }
 
diff --git a/logstash-core/src/main/java/org/logstash/plugin/ConstructingObjectParser.java b/logstash-core/src/main/java/org/logstash/plugin/ConstructingObjectParser.java
new file mode 100644
index 00000000000..7232c9a1880
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugin/ConstructingObjectParser.java
@@ -0,0 +1,185 @@
+package org.logstash.plugin;
+
+import java.util.*;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+/**
+ * A functional class which constructs an object from a given configuration map.
+ *
+ * History: This is idea is taken largely from Elasticsearch's ConstructingObjectParser
+ *
+ * @param <Value> The object type to construct when `parse` is called.
+ */
+public class ConstructingObjectParser<Value> implements Function<Map<String, Object>, Value> {
+    private final Function<Object[], Value> builder;
+    private final Map<String, BiConsumer<Value, Object>> parsers = new LinkedHashMap<>();
+    private final Map<String, BiConsumer<ArrayList<Object>, Object>> constructorArgs = new TreeMap<>();
+
+    public ConstructingObjectParser(Function<Object[], Value> builder) {
+        this.builder = builder;
+    }
+
+    public static Integer integerTransform(Object object) {
+        if (object instanceof Integer) {
+            return (Integer) object;
+        } else if (object instanceof String) {
+            return Integer.parseInt((String) object);
+        } else {
+            throw new IllegalArgumentException("Value must be a number, but is a " + object.getClass());
+        }
+    }
+
+    public static String stringTransform(Object object) {
+        if (object instanceof String) {
+            return (String) object;
+        } else if (object instanceof Number) {
+            return object.toString();
+        } else {
+            throw new IllegalArgumentException("Value must be a string, but is a " + object.getClass());
+        }
+    }
+
+    public static <T> T objectTransform(Object object, ConstructingObjectParser<T> parser) {
+        if (object instanceof Map) {
+            // XXX: Fix this unchecked cast.
+            return parser.apply((Map<String, Object>) object);
+        } else {
+            throw new IllegalArgumentException("Object value must be a Map, but is a " + object.getClass());
+        }
+    }
+
+    /**
+     * Add an field with an integer value.
+     *
+     * @param name the name of this field
+     * @param consumer the function to call once the value is available
+     */
+    public void integer(String name, BiConsumer<Value, Integer> consumer) {
+        declareField(name, consumer, ConstructingObjectParser::integerTransform);
+    }
+
+    /**
+     * Declare an integer constructor argument.
+     *
+     * @param name the name of the field.
+     */
+    public void integer(String name) {
+        declareConstructorArg(name, ConstructingObjectParser::integerTransform);
+    }
+
+    /**
+     * Add a field with a string value.
+     *
+     * @param name the name of this field
+     * @param consumer the function to call once the value is available
+     */
+    public void string(String name, BiConsumer<Value, String> consumer) {
+        declareField(name, consumer, ConstructingObjectParser::stringTransform);
+    }
+
+    /**
+     * Declare a constructor argument that is a string.
+     *
+     * @param name the name of this field.
+     */
+    public void string(String name) {
+        declareConstructorArg(name, ConstructingObjectParser::stringTransform);
+    }
+
+    /**
+     * Add a field with an object value
+     *
+     * @param name the name of this field
+     * @param consumer the function to call once the value is available
+     * @param parser The ConstructingObjectParser that will build the object
+     * @param <T> The type of object to store as the value.
+     */
+    public <T> void object(String name, BiConsumer<Value, T> consumer, ConstructingObjectParser<T> parser) {
+        declareField(name, consumer, (t) -> objectTransform(t, parser));
+    }
+
+    /**
+     * Declare a constructor argument that is an object.
+     *
+     * @param name   the name of the field which represents this constructor argument
+     * @param parser the ConstructingObjectParser that builds the object
+     * @param <T>    The type of object created by the parser.
+     */
+    public <T> void object(String name, ConstructingObjectParser<T> parser) {
+        declareConstructorArg(name, (t) -> objectTransform(t, parser));
+    }
+
+    public <T> void declareField(String name, BiConsumer<Value, T> consumer, Function<Object, T> transform) {
+        BiConsumer<Value, Object> objConsumer = (value, object) -> consumer.accept(value, transform.apply(object));
+        parsers.put(name, objConsumer);
+    }
+
+    public <T> void declareConstructorArg(String name, Function<Object, T> transform) {
+        int position = constructorArgs.size();
+        BiConsumer<ArrayList<Object>, Object> objConsumer = (array, object) -> array.add(position, transform.apply(object));
+        constructorArgs.put(name, objConsumer);
+    }
+
+    /**
+     * Construct an object using the given config.
+     *
+     * The intent is that a config map, such as one from a Logstash pipeline config:
+     *
+     *     input {
+     *         example {
+     *             some => "setting"
+     *             goes => "here"
+     *         }
+     *     }
+     *
+     *  ... will know how to build an object for the above "example" input plugin.
+     */
+    public Value apply(Map<String, Object> config) {
+        rejectUnknownFields(config.keySet());
+        Value value = construct(config);
+
+        // Now call all the object setters/etc
+        for (Map.Entry<String, Object> entry : config.entrySet()) {
+            String name = entry.getKey();
+            if (constructorArgs.containsKey(name)) {
+                // Skip constructor arguments
+                continue;
+            }
+
+            BiConsumer<Value, Object> parser = parsers.get(name);
+            assert parser != null;
+
+            parser.accept(value, entry.getValue());
+        }
+
+        return value;
+    }
+
+    private void rejectUnknownFields(Set<String> configNames) {
+        // Check for any unknown parameters.
+        List<String> unknown = configNames.stream().filter(name -> !(parsers.containsKey(name) || constructorArgs.containsKey(name))).collect(Collectors.toList());
+
+        if (!unknown.isEmpty()) {
+            throw new IllegalArgumentException("Unknown settings " + unknown);
+        }
+    }
+
+    private Value construct(Map<String, Object> config) {
+        ArrayList<Object> args = new ArrayList<>(constructorArgs.size());
+
+        // Constructor arguments. Any constructor argument is a *required* setting.
+        for (Map.Entry<String, BiConsumer<ArrayList<Object>, Object>> argInfo : constructorArgs.entrySet()) {
+            String name = argInfo.getKey();
+            BiConsumer<ArrayList<Object>, Object> argsBuilder = argInfo.getValue();
+            if (config.containsKey(name)) {
+                argsBuilder.accept(args, config.get(name));
+            } else {
+                throw new IllegalArgumentException("Missing required argument '" + name + "' for " + getClass());
+            }
+        }
+
+        return builder.apply(args.toArray());
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugin/Input.java b/logstash-core/src/main/java/org/logstash/plugin/Input.java
new file mode 100644
index 00000000000..3bcd0892938
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugin/Input.java
@@ -0,0 +1,44 @@
+package org.logstash.plugin;
+
+import org.logstash.Event;
+
+import java.util.Collection;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executors;
+import java.util.function.Consumer;
+
+/**
+ * A Logstash input plugin.
+ * <p>
+ * Input plugins produce events intended given to Processors.
+ * <p>
+ * Inputs will generally run forever until there is some terminating condition such as a pipeline shutdown.
+ */
+public interface Input {
+    /**
+     * The method contract is as follows:
+     * <p>
+     * 1) When `Thread.interrupted()` is true, you MUST close all open resources and return.
+     * 2) When this method returns, it is assumed all work for this input is completed.
+     * 3) consumer.accept(...) may block
+     * <p>
+     * Acknowledging Data:
+     * <p>
+     * When `consumer.accept(...)` returns, the given Events have been successfully written into the consumer, and it is now
+     * safe to acknowledge these events to the upstream data source. The consumer is generally the Logstash internal queue,
+     * such as the persistent queue.
+     *
+     * @param consumer Send batches of events with consumer.accept(batch).
+     */
+    void run(Consumer<Collection<Event>> consumer);
+
+    /**
+     * Return this Input as a Callable for use with an ExecutorService.
+     *
+     * @param consumer the
+     * @return A Callable which wraps the `run` method.
+     */
+    default Callable<Void> toCallable(Consumer<Collection<Event>> consumer) {
+        return Executors.callable(() -> run(consumer), null);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugin/Output.java b/logstash-core/src/main/java/org/logstash/plugin/Output.java
new file mode 100644
index 00000000000..fb0fa54a56f
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugin/Output.java
@@ -0,0 +1,15 @@
+package org.logstash.plugin;
+
+import org.logstash.Event;
+
+import java.util.Collection;
+
+public interface Output {
+    /**
+     * Process a batch with the intent of sending the event externally.
+     *
+     *
+     * @param events the events to output.
+     */
+    void process(Collection<Event> events);
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugin/Plugin.java b/logstash-core/src/main/java/org/logstash/plugin/Plugin.java
new file mode 100644
index 00000000000..8accc0ddced
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugin/Plugin.java
@@ -0,0 +1,20 @@
+package org.logstash.plugin;
+
+import java.util.Map;
+
+public interface Plugin {
+    // register hooks
+    // additional settings
+
+    default Map<String, ConstructingObjectParser<? extends Input>> getInputs() {
+        return null;
+    }
+
+    default Map<String, ConstructingObjectParser<? extends Processor>> getProcessors() {
+        return null;
+    }
+
+    default Map<String, ConstructingObjectParser<? extends Output>> getOutputs() {
+        return null;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugin/Processor.java b/logstash-core/src/main/java/org/logstash/plugin/Processor.java
new file mode 100644
index 00000000000..b0172fe08a4
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugin/Processor.java
@@ -0,0 +1,15 @@
+package org.logstash.plugin;
+
+import org.logstash.Event;
+
+import java.util.Collection;
+
+public interface Processor {
+    /**
+     * Process events. In the past, this was called a `filter` in Logstash.
+     *
+     * @param events The events to be processed
+     * @return Any new events created by this processor.
+     */
+    Collection<Event> process(Collection<Event> events);
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugin/RubyOutput.java b/logstash-core/src/main/java/org/logstash/plugin/RubyOutput.java
new file mode 100644
index 00000000000..55a0750b397
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugin/RubyOutput.java
@@ -0,0 +1,29 @@
+package org.logstash.plugin;
+
+import org.jruby.RubyArray;
+import org.jruby.RubyObject;
+import org.logstash.Event;
+import org.logstash.ext.JrubyEventExtLibrary;
+
+import java.util.Collection;
+
+public class RubyOutput implements Output {
+    private static final String MULTI_RECEIVE_METHOD = "multi_receive";
+    private RubyObject plugin;
+    private RubyArray events;
+    private Output handler;
+
+    public RubyOutput(RubyObject plugin) {
+        // XXX: assert that `plugin` is a subclass of LogStash::Filter::Base
+        this.plugin = plugin;
+        events = RubyArray.newArray(plugin.getRuntime());
+
+
+    }
+    @Override
+    public void process(Collection<Event> events) {
+        final RubyArray rubyEvents = RubyArray.newArray(plugin.getRuntime());
+        events.forEach(event -> rubyEvents.add(JrubyEventExtLibrary.RubyEvent.newRubyEvent(plugin.getRuntime(), event)));
+        plugin.callMethod(plugin.getRuntime().getCurrentContext(), MULTI_RECEIVE_METHOD, rubyEvents);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugin/RubyProcessor.java b/logstash-core/src/main/java/org/logstash/plugin/RubyProcessor.java
new file mode 100644
index 00000000000..690dc36f6d4
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugin/RubyProcessor.java
@@ -0,0 +1,45 @@
+package org.logstash.plugin;
+
+import org.jruby.RubyArray;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.logstash.Event;
+import org.logstash.ext.JrubyEventExtLibrary.RubyEvent;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+
+public class RubyProcessor implements Processor {
+    private static final Collection<Event> EMPTY_RESULT = Collections.emptyList();
+
+    private static final String MULTI_FILTER_METHOD = "multi_filter";
+    private IRubyObject plugin;
+    private Processor handler;
+
+    public RubyProcessor(IRubyObject plugin) {
+        this.plugin = plugin;
+    }
+
+    @Override
+    public Collection<Event> process(Collection<Event> events) {
+        final RubyArray rubyEvents = RubyArray.newArray(plugin.getRuntime());
+        events.forEach(event -> rubyEvents.add(RubyEvent.newRubyEvent(plugin.getRuntime(), event)));
+
+        // filters/base.rb provides a basic multi_filter even if the actual plugin itself does not.
+        IRubyObject result = plugin.callMethod(plugin.getRuntime().getCurrentContext(), MULTI_FILTER_METHOD, rubyEvents);
+
+        if (result.isNil()) {
+            return EMPTY_RESULT;
+        }
+
+        // `result` must be a RubyArray containing RubyEvent's
+        if (result instanceof RubyArray) {
+            @SuppressWarnings("unchecked") // RubyArray is not generic, but satisfies `List`.
+            final List<RubyEvent> newRubyEvents = (RubyArray) result;
+            return newRubyEvents.stream().map(RubyEvent::getEvent).collect(Collectors.toList());
+        } else {
+            throw new IllegalArgumentException("Return value from a filter must be nil or an array of events, but got " + result.getClass().getCanonicalName());
+        }
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/security/KeyStoreBuilder.java b/logstash-core/src/main/java/org/logstash/security/KeyStoreBuilder.java
new file mode 100644
index 00000000000..e396dd994a1
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/security/KeyStoreBuilder.java
@@ -0,0 +1,159 @@
+package org.logstash.security;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import javax.net.ssl.KeyManagerFactory;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.security.*;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.security.spec.InvalidKeySpecException;
+import java.util.Arrays;
+import java.util.Collection;
+
+public class KeyStoreBuilder {
+    private static final String keyManagerAlgorithm = KeyManagerFactory.getDefaultAlgorithm();
+
+    // Based on some quick research, this appears to be the default java trust store location
+    private static final Path defaultTrustStorePath = Paths.get(System.getProperty("java.home"), "lib", "security", "cacerts");
+
+    // 'changeit' appears to be the default passphrase. I suppose it's ok. Or is it?!!!
+    private static final char[] defaultTrustStorePassphrase = "changeit".toCharArray();
+    private static final Logger logger = LogManager.getLogger();
+    // the "hurray" passphrase is only to satisfy the KeyStore.load API
+    // (requires a passphrase, even when loading null).
+    private final char[] IN_MEMORY_KEYSTORE_PASSPHRASE = "hurray".toCharArray();
+    private boolean modified;
+    private KeyStore keyStore;
+    private KeyManagerFactory keyManagerFactory;
+
+    public KeyStoreBuilder() {
+        try {
+            keyManagerFactory = KeyManagerFactory.getInstance(keyManagerAlgorithm);
+        } catch (NoSuchAlgorithmException e) {
+            throw new Error("Failed to get an instance of KeyManagerFactory. Something is wrong with the jvm?", e);
+        }
+        empty();
+        modified = false;
+    }
+
+    /**
+     * Start with an empty keystore.
+     */
+    private void empty() {
+        try {
+            keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
+            keyStore.load(null, IN_MEMORY_KEYSTORE_PASSPHRASE);
+            keyManagerFactory.init(keyStore, IN_MEMORY_KEYSTORE_PASSPHRASE);
+        } catch (IOException | CertificateException | UnrecoverableKeyException | NoSuchAlgorithmException | KeyStoreException e) {
+            throw new Error("Initializing an empty keystore should never fail, but it failed.", e);
+        }
+        modified = true;
+    }
+
+    void useDefaultTrustStore() throws IOException, CertificateException, NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {
+        logger.trace("Using default trust store: {}", defaultTrustStorePath);
+        useKeyStore(defaultTrustStorePath.toFile(), defaultTrustStorePassphrase);
+        modified = true;
+    }
+
+    // XXX: This only supports RSA keys right now.
+    public void addPrivateKeyPEM(Path keyPath, Path certificatePath) throws IOException, InvalidKeySpecException, NoSuchAlgorithmException, CertificateException, KeyStoreException, UnrecoverableKeyException {
+        PrivateKey key;
+        key = KeyStoreUtils.loadPrivateKeyPEM(keyPath);
+        Collection<? extends Certificate> certificates;
+        certificates = parseCertificatesPath(certificatePath);
+
+        logger.info("Adding key+cert named '{}' to internal keystore.", "mykey");
+        keyStore.setKeyEntry("mykey", key, IN_MEMORY_KEYSTORE_PASSPHRASE, certificates.toArray(new Certificate[0]));
+        keyManagerFactory.init(keyStore, IN_MEMORY_KEYSTORE_PASSPHRASE);
+        modified = true;
+    }
+
+    public void addCAPath(Path path) throws CertificateException, IOException, KeyStoreException {
+        if (path == null) {
+            throw new NullPointerException("path must not be null");
+        }
+
+        if (Files.isDirectory(path)) {
+            logger.info("Adding all files in {} to trusted certificate authorities.", path);
+            for (File file : path.toFile().listFiles()) {
+                if (file.isFile()) {
+                    addCAPath(file);
+                } else {
+                    logger.info("Ignoring non-file '{}'", file);
+                }
+            }
+        } else {
+            addCAPath(path.toFile());
+        }
+    }
+
+    void addCAPath(File file) throws CertificateException, IOException, KeyStoreException {
+        for (Certificate cert : parseCertificatesPath(file.toPath())) {
+            logger.debug("Loaded certificate from {}: {}", file, ((X509Certificate) cert).getSubjectX500Principal());
+            String alias = ((X509Certificate) cert).getSubjectX500Principal().toString();
+            keyStore.setCertificateEntry(alias, cert);
+        }
+        modified = true;
+    }
+
+    Collection<? extends Certificate> parseCertificatesPath(Path path) throws IOException, CertificateException {
+        CertificateFactory cf = CertificateFactory.getInstance("X.509");
+        try (FileInputStream in = new FileInputStream(path.toFile())) {
+            return cf.generateCertificates(in);
+        }
+    }
+
+    public void useKeyStore(File path) throws IOException, CertificateException, NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {
+        try {
+            useKeyStore(path, defaultTrustStorePassphrase);
+        } catch (IOException e) {
+            if (e.getCause() instanceof UnrecoverableKeyException) {
+                System.out.printf("Enter passphrase for keyStore %s: ", path);
+                char[] passphrase = System.console().readPassword();
+                useKeyStore(path, passphrase);
+
+                // Make an effort to not keep the passphrase in-memory longer than necessary? Maybe?
+                // This may not matter, anyway, since I'm pretty sure KeyManagerFactor.init() keeps it anyway...
+                Arrays.fill(passphrase, (char) 0);
+            } else {
+                throw e;
+            }
+        }
+    }
+
+    void useKeyStore(File path, char[] passphrase) throws IOException, CertificateException, NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {
+        FileInputStream fs;
+
+        fs = new FileInputStream(path);
+        keyStore.load(fs, passphrase);
+        keyManagerFactory.init(keyStore, passphrase);
+
+        logger.info("Loaded keyStore with {} certificates: {}", (keyStore).size(), path);
+        modified = true;
+    }
+
+    public KeyStore buildKeyStore() throws IOException, CertificateException, NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {
+        if (!modified) {
+            useDefaultTrustStore();
+        }
+        logger.trace("Returning non-default keystore");
+        return keyStore;
+    }
+
+    public KeyManagerFactory buildKeyManagerFactory() throws IOException, CertificateException, NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {
+        buildKeyStore();
+        return keyManagerFactory;
+    }
+
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/security/KeyStoreUtils.java b/logstash-core/src/main/java/org/logstash/security/KeyStoreUtils.java
new file mode 100644
index 00000000000..8db3d056db5
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/security/KeyStoreUtils.java
@@ -0,0 +1,47 @@
+package org.logstash.security;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.security.KeyFactory;
+import java.security.NoSuchAlgorithmException;
+import java.security.PrivateKey;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.PKCS8EncodedKeySpec;
+import java.util.Base64;
+import java.util.LinkedList;
+import java.util.List;
+
+class KeyStoreUtils {
+    private static final String RSA_PEM_HEADER = "-----BEGIN PRIVATE KEY-----";
+    private static final String RSA_PEM_FOOTER = "-----END PRIVATE KEY-----";
+
+    static PrivateKey loadPrivateKeyPEM(Path path) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
+
+        List<String> lines = Files.readAllLines(path);
+        List<String> keyLines = new LinkedList<>();
+
+        // Look for the key entry
+        boolean foundStart = false;
+        for (String line : lines) {
+            if (!foundStart) {
+                if (line.equals(RSA_PEM_HEADER)) {
+                    foundStart = true;
+                    continue;
+                }
+            } else {
+                if (line.equals(RSA_PEM_FOOTER)) {
+                    break;
+                }
+            }
+            keyLines.add(line);
+        }
+
+        byte[] pkcs8bytes = Base64.getDecoder().decode(String.join("", keyLines).getBytes());
+
+        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
+
+        PKCS8EncodedKeySpec pkcs8 = new PKCS8EncodedKeySpec(pkcs8bytes);
+        return keyFactory.generatePrivate(pkcs8);
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/TestUtil.java b/logstash-core/src/test/java/org/logstash/TestUtil.java
new file mode 100644
index 00000000000..6d21168af0c
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/TestUtil.java
@@ -0,0 +1,10 @@
+package org.logstash;
+
+import java.util.Random;
+
+public class TestUtil {
+    /**
+     * A random instance to share in the test suite.
+     */
+    public static final Random random = new Random();
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugin/ConstructingObjectParserTest.java b/logstash-core/src/test/java/org/logstash/plugin/ConstructingObjectParserTest.java
new file mode 100644
index 00000000000..0dbef8875e1
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/ConstructingObjectParserTest.java
@@ -0,0 +1,115 @@
+package org.logstash.plugin;
+
+import org.junit.Test;
+import org.junit.experimental.runners.Enclosed;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.logstash.plugin.example.ExampleInput;
+import org.logstash.plugin.example.ExamplePlugin;
+
+import java.util.*;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Enclosed.class)
+public class ConstructingObjectParserTest {
+    public static class ExampleInputTest {
+        @Test
+        public void testExample() {
+            Plugin example = new ExamplePlugin();
+            Map<String, ConstructingObjectParser<? extends Input>> inputs = example.getInputs();
+            ConstructingObjectParser<? extends Input> inputConstructor = inputs.get("example");
+
+            Map<String, Object> config = new TreeMap<>();
+            config.put("port", 5000);
+
+            Map<String, Object> tlsConfig = new TreeMap<>();
+            tlsConfig.put("truststore", "/path/to/trust");
+            config.put("tls", tlsConfig);
+
+            ExampleInput input = (ExampleInput) inputConstructor.apply(config);
+            System.out.println(input.getClass().getCanonicalName());
+            System.out.println(input.getTLS().getClass().getCanonicalName());
+        }
+    }
+    public static class IntegrationTest {
+        @Test
+        public void testParsing() {
+            ConstructingObjectParser<Example> c = new ConstructingObjectParser<>((args) -> new Example());
+            c.integer("foo", Example::setValue);
+
+            Map<String, Object> config = Collections.singletonMap("foo", 1);
+
+            Example e = c.apply(config);
+            assertEquals(1, e.getValue());
+        }
+
+        private class Example {
+            private int i;
+
+            public Example() {
+            }
+
+            int getValue() {
+                return i;
+            }
+
+            void setValue(int i) {
+                this.i = i;
+            }
+        }
+    }
+
+    @RunWith(Parameterized.class)
+    public static class StringAccepts {
+        private final Object input;
+        private final Object expected;
+
+        public StringAccepts(Object input, Object expected) {
+            this.input = input;
+            this.expected = expected;
+        }
+
+        @Parameters
+        public static Collection<Object[]> data() {
+            return Arrays.asList(new Object[][]{
+                    {"1", "1"},
+                    {1, "1"},
+                    {1L, "1"},
+                    {1F, "1.0"},
+                    {1D, "1.0"},
+            });
+        }
+
+        @Test
+        public void testStringTransform() {
+            String value = ConstructingObjectParser.stringTransform(input);
+            assertEquals(expected, value);
+
+        }
+    }
+
+    @RunWith(Parameterized.class)
+    public static class StringRejections {
+        private Object input;
+
+        public StringRejections(Object input) {
+            this.input = input;
+        }
+
+        @Parameters
+        public static List<Object> data() {
+            return Arrays.asList(
+                    new Object(),
+                    Collections.emptyMap(),
+                    Collections.emptyList()
+            );
+        }
+
+        @Test(expected = IllegalArgumentException.class)
+        public void testFailure() {
+            ConstructingObjectParser.stringTransform(input);
+        }
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/plugin/InputTest.java b/logstash-core/src/test/java/org/logstash/plugin/InputTest.java
new file mode 100644
index 00000000000..bdd79d69b81
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/InputTest.java
@@ -0,0 +1,46 @@
+package org.logstash.plugin;
+
+import org.junit.Test;
+import org.logstash.Event;
+import org.logstash.TestUtil;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.function.Consumer;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public class InputTest {
+    private Collection<Collection<Event>> batches = new LinkedList<>();
+    private int batchCount = TestUtil.random.nextInt(10) + 1;
+
+    @Test
+    public void testInput() {
+        Input i = new TestInput();
+        i.run(batches::add);
+        assertEquals(batchCount, batches.size());
+        for (Collection<Event> events : batches) {
+            assertFalse(events.isEmpty());
+        }
+    }
+
+    private class TestInput implements Input {
+        @Override
+        public void run(Consumer<Collection<Event>> consumer) {
+            for (int b = 0; b < batchCount; b++) {
+                int eventCountPerBatch = TestUtil.random.nextInt(100) + 1;
+                Collection<Event> events = new LinkedList<>();
+                for (int i = 0; i < eventCountPerBatch; i++) {
+                    Event e = new Event();
+                    e.setField("message", "hello world");
+                    e.setField("i", i);
+                    e.setField("b", b);
+                    events.add(e);
+                }
+                consumer.accept(Collections.unmodifiableCollection(events));
+            }
+        }
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugin/PluginTest.java b/logstash-core/src/test/java/org/logstash/plugin/PluginTest.java
new file mode 100644
index 00000000000..a2d71cc55a2
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/PluginTest.java
@@ -0,0 +1,4 @@
+package org.logstash.plugin;
+
+public class PluginTest {
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/plugin/ProcessorTest.java b/logstash-core/src/test/java/org/logstash/plugin/ProcessorTest.java
new file mode 100644
index 00000000000..76cd6ff45da
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/ProcessorTest.java
@@ -0,0 +1,51 @@
+package org.logstash.plugin;
+
+import org.junit.Test;
+import org.logstash.Event;
+import org.logstash.TestUtil;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedList;
+
+import static org.junit.Assert.assertEquals;
+
+public class ProcessorTest {
+    static Collection<Event> generateEvents(int count) {
+        Collection<Event> events = new LinkedList<>();
+        for (long i = 0; i < count; i++) {
+            Event event = new Event();
+            event.setField("message", "hello world");
+            event.setField("i", i);
+            events.add(event);
+        }
+        return Collections.unmodifiableCollection(events);
+    }
+
+    private class TestFilter implements Processor {
+        @Override
+        public Collection<Event> process(Collection<Event> events) {
+            for (Event e : events) {
+                e.setField("visited", "testFilter");
+            }
+            return null;
+        }
+    }
+
+    private Processor processor = new TestFilter();
+    private int eventCount = TestUtil.random.nextInt(100);
+    private Collection<Event> events = generateEvents(eventCount);
+
+    @Test
+    public void testFilter() {
+        Collection<Event> newEvents = processor.process(events);
+
+        assertEquals(null, newEvents);
+
+        long i = 0;
+        for (Event event : events) {
+            assertEquals(i, event.getField("i"));
+            i++;
+        }
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugin/RubyProcessorTest.java b/logstash-core/src/test/java/org/logstash/plugin/RubyProcessorTest.java
new file mode 100644
index 00000000000..fbd6d29ee13
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/RubyProcessorTest.java
@@ -0,0 +1,85 @@
+package org.logstash.plugin;
+
+import org.jruby.Ruby;
+import org.jruby.RubyClass;
+import org.jruby.RubyHash;
+import org.jruby.RubyModule;
+import org.jruby.embed.ScriptingContainer;
+import org.jruby.runtime.Block;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.logstash.Event;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Map;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public class RubyProcessorTest {
+    private ScriptingContainer container = new ScriptingContainer();
+    private Ruby ruby = container.getProvider().getRuntime();
+
+    static {
+        //setupRuby();
+    }
+
+    @Before
+    public void setup() throws IOException {
+        Path root = Paths.get("..").toRealPath();
+
+        // Setup the load path.
+        // XXX: I did this before with ScriptContainer.getLoadPath + setLoadPath but it wasn't working correctly...
+        // XXX: So I choose to modify $: instead.
+        Object loadPath = container.runScriptlet("$:");
+        container.callMethod(loadPath, "<<", root.resolve("lib").toString());
+        container.callMethod(loadPath, "<<", root.resolve("logstash-core/lib").toString());
+        container.callMethod(loadPath, "<<", root.resolve("logstash-core/src/test/resources/org/logstash/plugin/lib/").toString());
+
+        Map env = container.getEnvironment();
+        env.put("GEM_HOME", root.resolve("vendor/bundle/jruby/2.3.0").toString());
+        env.put("GEM_PATH", root.resolve("vendor/bundle/jruby/2.3.0").toString());
+        env.put("GEM_SPEC_CACHE", root.resolve("vendor/bundle/jruby/2.3.0/specifications").toString());
+        container.setEnvironment(env);
+
+        RubyModule kernel = ruby.getKernel();
+        container.callMethod(kernel, "require", "bootstrap/environment");
+        long n = System.nanoTime();
+        container.runScriptlet("LogStash::Bundler.setup!({:without => [:build, :development]})");
+        System.out.println("Bundler setup took: " + (System.nanoTime() - n) / 1000000 + "ms");
+        container.callMethod(kernel, "require", "logstash/plugin");
+    }
+
+    private IRubyObject plugin(String type, String name, Map<String, Object> config) {
+        RubyHash hash = new RubyHash(ruby);
+        if (config != null) {
+            hash.putAll(config);
+        }
+        RubyClass pluginClass = (RubyClass) container.runScriptlet("LogStash::Plugin.lookup('filter', 'test')");
+        IRubyObject plugin = pluginClass.newInstance(ruby.getCurrentContext(), hash, Block.NULL_BLOCK);
+        plugin.callMethod(ruby.getCurrentContext(), "register");
+
+        return plugin;
+    }
+
+    @Test
+    public void testRubyFilter() throws IOException {
+        IRubyObject plugin = plugin("filter", "test", null);
+
+        RubyProcessor processor = new RubyProcessor(plugin);
+
+        Collection<Event> events = Collections.singletonList(new Event());
+        Collection<Event> newEvents = processor.process(events);
+
+        for (Event event : events) {
+            assertEquals(1L, event.getField("test"));
+        }
+
+        assertTrue("The test filter should return null and not create any additional events", newEvents.isEmpty());
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/plugin/example/ExampleInput.java b/logstash-core/src/test/java/org/logstash/plugin/example/ExampleInput.java
new file mode 100644
index 00000000000..02ae0ca81b3
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/example/ExampleInput.java
@@ -0,0 +1,42 @@
+package org.logstash.plugin.example;
+
+import org.logstash.Event;
+import org.logstash.plugin.ConstructingObjectParser;
+import org.logstash.plugin.Input;
+import org.logstash.plugin.Plugin;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.function.Consumer;
+
+public class ExampleInput implements Input, Plugin {
+    static final ConstructingObjectParser<ExampleInput> EXAMPLE = new ConstructingObjectParser<>(args -> new ExampleInput((int) args[0]));
+
+    static {
+        // Pass an integer named "port" as the first constructor argument.
+        EXAMPLE.integer("port");
+        EXAMPLE.string("setting", ExampleInput::setGreeting);
+    }
+
+    private int port;
+
+    // A setting with a default value.
+    private String greeting = "Hello";
+
+    private ExampleInput(int port) {
+        this.port = port;
+    }
+
+    private void setGreeting(String greeting) {
+        this.greeting = greeting;
+    }
+
+    @Override
+    public void run(Consumer<Collection<Event>> consumer) {
+        Event event = new Event();
+        event.setField("message", "Hello from Example");
+        event.setField("port", port);
+        Collection<Event> events = Collections.singleton(event);
+        consumer.accept(events);
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugin/example/ExamplePlugin.java b/logstash-core/src/test/java/org/logstash/plugin/example/ExamplePlugin.java
new file mode 100644
index 00000000000..eb6080b17d2
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/example/ExamplePlugin.java
@@ -0,0 +1,20 @@
+package org.logstash.plugin.example;
+
+import org.logstash.plugin.ConstructingObjectParser;
+import org.logstash.plugin.Input;
+import org.logstash.plugin.Plugin;
+import org.logstash.plugin.Processor;
+
+import java.util.Collections;
+import java.util.Map;
+
+public class ExamplePlugin implements Plugin {
+    public Map<String, ConstructingObjectParser<? extends Input>> getInputs() {
+        return Collections.singletonMap("example", ExampleInput.EXAMPLE);
+    }
+
+    public Map<String, ConstructingObjectParser<? extends Processor>> getProcessors() {
+        return Collections.singletonMap("example", ExampleProcessor.EXAMPLE_PROCESSOR);
+    }
+
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugin/example/ExampleProcessor.java b/logstash-core/src/test/java/org/logstash/plugin/example/ExampleProcessor.java
new file mode 100644
index 00000000000..37bc991c610
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/example/ExampleProcessor.java
@@ -0,0 +1,46 @@
+package org.logstash.plugin.example;
+
+import org.logstash.Event;
+import org.logstash.plugin.ConstructingObjectParser;
+import org.logstash.plugin.Processor;
+
+import java.util.Collection;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class ExampleProcessor implements Processor {
+    static final ConstructingObjectParser<ExampleProcessor> EXAMPLE_PROCESSOR = new ConstructingObjectParser<>(args -> new ExampleProcessor((Pattern) args[0]));
+
+    static {
+        // Since we are using a non-default type "Pattern" we need to call declareConstructorArg
+        // with a custom Function that returns a Pattern given an Object.
+        EXAMPLE_PROCESSOR.declareConstructorArg("pattern", (object) -> Pattern.compile(ConstructingObjectParser.stringTransform(object)));
+        EXAMPLE_PROCESSOR.string("source", ExampleProcessor::setSourceField);
+    }
+
+    private Pattern pattern;
+    private String sourceField = "message";
+
+    ExampleProcessor(Pattern pattern) {
+        this.pattern = pattern;
+    }
+
+    void setSourceField(String sourceField) {
+        this.sourceField = sourceField;
+    }
+
+    @Override
+    public Collection<Event> process(Collection<Event> events) {
+        for (Event event : events) {
+            String value = (String) event.getField(sourceField);
+            if (value != null) {
+                Matcher matcher = pattern.matcher((String) event.getField(sourceField));
+                event.setField("matches", matcher.matches());
+            } else {
+                event.setField("matches", false);
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugin/example/ExampleProcessorTest.java b/logstash-core/src/test/java/org/logstash/plugin/example/ExampleProcessorTest.java
new file mode 100644
index 00000000000..018bf15878f
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugin/example/ExampleProcessorTest.java
@@ -0,0 +1,93 @@
+package org.logstash.plugin.example;
+
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.junit.Test;
+import org.junit.experimental.theories.DataPoint;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
+
+import static org.hamcrest.CoreMatchers.*;
+import static org.junit.Assume.assumeFalse;
+import static org.junit.Assume.assumeThat;
+
+@RunWith(Theories.class)
+public class ExampleProcessorTest {
+    @DataPoint
+    public static Map<String, Object> emptyConfiguration = Collections.emptyMap();
+
+    @DataPoint
+    public static Map<String, Object> sourceOnly = Collections.singletonMap("source", "whatever");
+
+    @DataPoint
+    public static Map<String, Object> patternAndSource = new HashMap<String, Object>() {{
+        put("pattern", "hello");
+        put("source", "whatever");
+    }};
+
+    @DataPoint
+    public static Map<String, Object> patternOnly = new HashMap<String, Object>() {{
+        put("pattern", "hello");
+    }};
+
+    @DataPoint
+    public static Map<String, Object> invalidPattern = new HashMap<String, Object>() {{
+        put("pattern", "***");
+    }};
+
+    @Test(expected = IllegalArgumentException.class)
+    @Theory
+    public void patternIsRequired(Map<String, Object> config) {
+        assumeFalse(config.containsKey("pattern"));
+        ExampleProcessor.EXAMPLE_PROCESSOR.apply(config);
+    }
+
+    @Theory
+    public void whenPatternIsValid(Map<String, Object> config) {
+        assumeThat(config.get("pattern"), both(notNullValue()).and(hasValidPattern()));
+        ExampleProcessor.EXAMPLE_PROCESSOR.apply(config);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    @Theory
+    public void whenPatternIsNotValid(Map<String, Object> config) {
+        assumeThat(config.get("pattern"), both(notNullValue()).and(not(hasValidPattern())));
+        ExampleProcessor.EXAMPLE_PROCESSOR.apply(config);
+    }
+
+    private Matcher hasValidPattern() {
+        return new HasValidPatternMatcher();
+    }
+
+    class HasValidPatternMatcher<T> extends BaseMatcher<T> {
+        @Override
+        public boolean matches(Object item) {
+            try {
+                Pattern.compile((String) item);
+                return true;
+            } catch (PatternSyntaxException e) {
+                return false;
+            }
+        }
+
+        @Override
+        public void describeMismatch(Object item, Description mismatchDescription) {
+            mismatchDescription.appendText("was").appendValue(item);
+        }
+
+        @Override
+        public void describeTo(Description description) {
+            System.out.println("describeTo");
+            description.appendText("Expected valid Pattern");
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/resources/org/logstash/plugin/lib/logstash/filters/test.rb b/logstash-core/src/test/resources/org/logstash/plugin/lib/logstash/filters/test.rb
new file mode 100644
index 00000000000..364741231a8
--- /dev/null
+++ b/logstash-core/src/test/resources/org/logstash/plugin/lib/logstash/filters/test.rb
@@ -0,0 +1,21 @@
+require "logstash/filters/base"
+
+class LogStash::Filters::Test < LogStash::Filters::Base
+    config_name "test"
+
+    config :foo, :validate => :string
+
+    def register
+        # nothing
+    end
+
+    def multi_filter(events)
+        events.each do |event|
+            event.set("test", 1);
+            filter_matched(event)
+        end
+
+        nil
+    end
+end
+
