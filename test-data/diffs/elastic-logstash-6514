diff --git a/logstash-core/lib/logstash/agent.rb b/logstash-core/lib/logstash/agent.rb
index 0a42eeae9ab..c6a1a6e9b30 100644
--- a/logstash-core/lib/logstash/agent.rb
+++ b/logstash-core/lib/logstash/agent.rb
@@ -10,8 +10,8 @@
 require "logstash/pipeline"
 require "logstash/webserver"
 require "logstash/event_dispatcher"
+require "logstash/config/source_loader"
 require "stud/trap"
-require "logstash/config/loader"
 require "uri"
 require "socket"
 require "securerandom"
@@ -43,7 +43,8 @@ def initialize(settings = LogStash::SETTINGS)
     # Generate / load the persistent uuid
     id
 
-    @config_loader = LogStash::Config::Loader.new(@logger)
+    @source_loader = LogStash::Config::SOURCE_LOADER.create(settings)
+
     @reload_interval = setting("config.reload.interval")
     @upgrade_mutex = Mutex.new
 
@@ -72,7 +73,8 @@ def execute
     Stud.stoppable_sleep(@reload_interval) # sleep before looping
 
     if @auto_reload
-      Stud.interval(@reload_interval) { reload_state! }
+      # `sleep_then_run` instead of firing the interval right away
+      Stud.interval(@reload_interval, :sleep_then_run => true) { reload_state! }
     else
       while !Stud.stop?
         if clean_state? || running_pipelines?
@@ -104,8 +106,10 @@ def register_pipeline(settings)
   end
 
   def reload_state!
+    logger.trace("reloading state!")
     @upgrade_mutex.synchronize do
       @pipelines.each do |pipeline_id, pipeline|
+
         next if pipeline.settings.get("config.reload.automatic") == false
         begin
           reload_pipeline!(pipeline_id)
@@ -235,7 +239,7 @@ def collect_metrics?
   def create_pipeline(settings, config=nil)
     if config.nil?
       begin
-        config = fetch_config(settings)
+        config = fetch_config
       rescue => e
         @logger.error("failed to fetch pipeline configuration", :message => e.message)
         return
@@ -243,7 +247,7 @@ def create_pipeline(settings, config=nil)
     end
 
     begin
-      LogStash::Pipeline.new(config, settings, metric)
+      LogStash::Pipeline.new(config.config_string, config.settings, metric)
     rescue => e
       @instance_reload_metric.increment(:failures)
       @pipeline_reload_metric.namespace([settings.get("pipeline.id").to_sym, :reloads]).tap do |n|
@@ -260,16 +264,17 @@ def create_pipeline(settings, config=nil)
     end
   end
 
-  def fetch_config(settings)
-    @config_loader.format_config(settings.get("path.config"), settings.get("config.string"))
+  def fetch_config
+    # TODO(ph) multiple pipeline, we only support one config for now
+    @source_loader.fetch.first
   end
 
   # since this method modifies the @pipelines hash it is
   # wrapped in @upgrade_mutex in the parent call `reload_state!`
   def reload_pipeline!(id)
     old_pipeline = @pipelines[id]
-    new_config = fetch_config(old_pipeline.settings)
-    if old_pipeline.config_str == new_config
+    new_config = fetch_config
+    if old_pipeline.config_hash == new_config.config_hash
       @logger.debug("no configuration change for pipeline",
                     :pipeline => id, :config => new_config)
       return
@@ -359,7 +364,6 @@ def upgrade_pipeline(pipeline_id, new_pipeline)
         n.increment(:successes)
         n.gauge(:last_success_timestamp, LogStash::Timestamp.now)
       end
-      
     end
   end
 
diff --git a/logstash-core/lib/logstash/bootstrap_check/bad_java.rb b/logstash-core/lib/logstash/bootstrap_check/bad_java.rb
new file mode 100644
index 00000000000..5d149991451
--- /dev/null
+++ b/logstash-core/lib/logstash/bootstrap_check/bad_java.rb
@@ -0,0 +1,17 @@
+# encoding: utf-8
+require "logstash/util"
+require "logstash/util/java_version"
+require "logstash/errors"
+
+module LogStash module BootstrapCheck
+  class BadJava
+    def self.check(settings)
+      # Exit on bad java versions
+      java_version = LogStash::Util::JavaVersion.version
+
+      if LogStash::Util::JavaVersion.bad_java_version?(java_version)
+        raise LogStash::BootstrapCheckError, "Java version 1.8.0 or later is required. (You are running: #{java_version})"
+      end
+    end
+  end
+end end
diff --git a/logstash-core/lib/logstash/bootstrap_check/bad_ruby.rb b/logstash-core/lib/logstash/bootstrap_check/bad_ruby.rb
new file mode 100644
index 00000000000..3c090bf0eef
--- /dev/null
+++ b/logstash-core/lib/logstash/bootstrap_check/bad_ruby.rb
@@ -0,0 +1,12 @@
+# encoding: utf-8
+require "logstash/errors"
+
+module LogStash module BootstrapCheck
+  class BadRuby
+    def self.check(settings)
+      if RUBY_VERSION < "1.9.2"
+        raise LogStash::BootstrapCheckError, "Ruby 1.9.2 or later is required. (You are running: " + RUBY_VERSION + ")"
+      end
+    end
+  end
+end end
diff --git a/logstash-core/lib/logstash/bootstrap_check/default_config.rb b/logstash-core/lib/logstash/bootstrap_check/default_config.rb
new file mode 100644
index 00000000000..04e9039826b
--- /dev/null
+++ b/logstash-core/lib/logstash/bootstrap_check/default_config.rb
@@ -0,0 +1,17 @@
+# encoding: utf-8
+require "logstash/errors"
+
+module LogStash module BootstrapCheck
+  class DefaultConfig
+    def self.check(settings)
+      if settings.get("config.string").nil? && settings.get("path.config").nil?
+        raise LogStash::BootstrapCheckError, I18n.t("logstash.runner.missing-configuration")
+      end
+
+      if settings.get("config.reload.automatic") && settings.get("path.config").nil?
+        # there's nothing to reload
+        raise LogStash::BootstrapCheckError, I18n.t("logstash.runner.reload-without-config-path")
+      end
+    end
+  end
+end end
diff --git a/logstash-core/lib/logstash/config/config_part.rb b/logstash-core/lib/logstash/config/config_part.rb
new file mode 100644
index 00000000000..7f04254d3ea
--- /dev/null
+++ b/logstash-core/lib/logstash/config/config_part.rb
@@ -0,0 +1,13 @@
+# encoding: utf-8
+
+module LogStash module Config
+ class ConfigPart
+   attr_reader :reader, :source_id, :config_string
+
+   def initialize(reader, source_id, config_string)
+     @reader = reader
+     @source_id = source_id
+     @config_string = config_string
+   end
+ end
+end end
diff --git a/logstash-core/lib/logstash/config/loader.rb b/logstash-core/lib/logstash/config/loader.rb
deleted file mode 100644
index d894bd71bee..00000000000
--- a/logstash-core/lib/logstash/config/loader.rb
+++ /dev/null
@@ -1,107 +0,0 @@
-require "logstash/config/defaults"
-
-module LogStash; module Config; class Loader
-  def initialize(logger)
-    @logger = logger
-    @config_debug = LogStash::SETTINGS.get_value("config.debug")
-  end
-
-  def format_config(config_path, config_string)
-    config_string = config_string.to_s
-    if config_path
-      # Append the config string.
-      # This allows users to provide both -f and -e flags. The combination
-      # is rare, but useful for debugging.
-      loaded_config = load_config(config_path)
-      if loaded_config.empty? && config_string.empty?
-        # If loaded config from `-f` is empty *and* if config string is empty we raise an error
-        fail(I18n.t("logstash.runner.configuration.file-not-found", :path => config_path))
-      end
-
-      # tell the user we are merging, otherwise it is very confusing
-      if !loaded_config.empty? && !config_string.empty?
-        @logger.info("Created final config by merging config string and config path", :path => config_path)
-      end
-
-      config_string = config_string + loaded_config
-    else
-      # include a default stdin input if no inputs given
-      if config_string !~ /input *{/
-        config_string += LogStash::Config::Defaults.input
-      end
-      # include a default stdout output if no outputs given
-      if config_string !~ /output *{/
-        config_string += LogStash::Config::Defaults.output
-      end
-    end
-    config_string
-  end
-
-  def load_config(path)
-    begin
-      uri = URI.parse(path)
-
-      case uri.scheme
-      when nil then
-        local_config(path)
-      when /http/ then
-        fetch_config(uri)
-      when "file" then
-        local_config(uri.path)
-      else
-        fail(I18n.t("logstash.runner.configuration.scheme-not-supported", :path => path))
-      end
-    rescue URI::InvalidURIError
-      # fallback for windows.
-      # if the parsing of the file failed we assume we can reach it locally.
-      # some relative path on windows arent parsed correctly (.\logstash.conf)
-      local_config(path)
-    end
-  end
-
-  def local_config(path)
-    path = ::File.expand_path(path)
-    path = ::File.join(path, "*") if ::File.directory?(path)
-
-    config = ""
-    if Dir.glob(path).length == 0
-      @logger.info("No config files found in path", :path => path)
-      return config
-    end
-
-    encoding_issue_files = []
-    Dir.glob(path).sort.each do |file|
-      next unless ::File.file?(file)
-      if file.match(/~$/)
-        @logger.debug("NOT reading config file because it is a temp file", :config_file => file)
-        next
-      end
-      @logger.debug("Reading config file", :config_file => file)
-      cfg = ::File.read(file)
-      if !cfg.ascii_only? && !cfg.valid_encoding?
-        encoding_issue_files << file
-      end
-      config << cfg + "\n"
-      if @config_debug
-        @logger.debug? && @logger.debug("\nThe following is the content of a file", :config_file => file.to_s)
-        @logger.debug? && @logger.debug("\n" + cfg + "\n\n")
-      end
-    end
-    if encoding_issue_files.any?
-      fail("The following config files contains non-ascii characters but are not UTF-8 encoded #{encoding_issue_files}")
-    end
-    if @config_debug
-      @logger.debug? && @logger.debug("\nThe following is the merged configuration")
-      @logger.debug? && @logger.debug("\n" + config + "\n\n")
-    end
-    return config
-  end # def load_config
-
-  def fetch_config(uri)
-    begin
-      Net::HTTP.get(uri) + "\n"
-    rescue Exception => e
-      fail(I18n.t("logstash.runner.configuration.fetch-failed", :path => uri.to_s, :message => e.message))
-    end
-  end
-end end end
diff --git a/logstash-core/lib/logstash/config/pipeline_config.rb b/logstash-core/lib/logstash/config/pipeline_config.rb
new file mode 100644
index 00000000000..d7d35c59fe1
--- /dev/null
+++ b/logstash-core/lib/logstash/config/pipeline_config.rb
@@ -0,0 +1,28 @@
+# encoding: utf-8
+require "digest"
+
+module LogStash module Config
+  class PipelineConfig
+    attr_reader :source, :pipeline_id, :config_parts, :settings, :read_at
+
+    def initialize(source, pipeline_id, config_parts, settings)
+      @source = source
+      @pipeline_id = pipeline_id
+      @config_parts = Array(config_parts).sort_by { |config_part| [config_part.reader.to_s, config_part.source_id] }
+      @settings = settings
+      @read_at = Time.now
+    end
+
+    def config_hash
+      @config_hash ||= Digest::SHA1.hexdigest(config_string)
+    end
+
+    def config_string
+      @config_string = config_parts.collect(&:config_string).join("\n")
+    end
+
+    def ==(other)
+      config_hash == other.config_hash && pipeline_id == other.pipeline_id
+    end
+  end
+end end
diff --git a/logstash-core/lib/logstash/config/source/base.rb b/logstash-core/lib/logstash/config/source/base.rb
new file mode 100644
index 00000000000..16cca78faa8
--- /dev/null
+++ b/logstash-core/lib/logstash/config/source/base.rb
@@ -0,0 +1,16 @@
+# encoding: utf-8
+module LogStash module Config module Source
+  class Base
+    def initialize(settings)
+      @settings = settings
+    end
+
+    def pipeline_configs
+      raise NotImplementedError, "`#pipeline_configs` must be implemented!"
+    end
+
+    def self.match?(settings)
+      raise NotImplementedError, "`.match?` must be implemented!"
+    end
+  end
+end end end
diff --git a/logstash-core/lib/logstash/config/source/local.rb b/logstash-core/lib/logstash/config/source/local.rb
new file mode 100644
index 00000000000..1e84b7bd850
--- /dev/null
+++ b/logstash-core/lib/logstash/config/source/local.rb
@@ -0,0 +1,209 @@
+# encoding: utf-8
+require "logstash/config/source/base"
+require "logstash/config/config_part"
+require "logstash/config/pipeline_config"
+require "logstash/util/loggable"
+require "logstash/errors"
+require "uri"
+
+module LogStash module Config module Source
+  # A locally defined configuration source
+  #
+  # Which can aggregate the following config options:
+  #  - settings.config_string: "input { stdin {} }"
+  #  - settings.config_path: /tmp/logstash/*.conf
+  #  - settings.config_path: http://localhost/myconfig.conf
+  #
+  #  All theses option will create a unique pipeline, generated parts will be
+  #  sorted alphabetically. Se `PipelineConfig` class for the sorting algorithm.
+  #
+  class Local < Base
+    class ConfigStringLoader
+      def self.read(config_string)
+        [ConfigPart.new(self.name, "config_string", config_string)]
+      end
+    end
+
+    class ConfigPathLoader
+      include LogStash::Util::Loggable
+
+      TEMPORARY_FILE_RE = /~$/
+      LOCAL_FILE_URI = /^file:\/\//i
+
+      def initialize(path)
+        @path = normalize_path(path)
+      end
+
+      def read
+        config_parts = []
+        encoding_issue_files = []
+
+        get_files.each do |file|
+          next unless ::File.file?(file) # skip directory
+
+          logger.debug("Reading config file", :config_file => file)
+
+          if temporary_file?(file)
+            logger.debug("NOT reading config file because it is a temp file", :config_file => file)
+            next
+          end
+
+          config_string = ::File.read(file)
+
+          if valid_encoding?(config_string)
+            config_parts << ConfigPart.new(self.class.name, file, config_string)
+          else
+            encoding_issue_files << file
+          end
+        end
+
+        if encoding_issue_files.any?
+          raise LogStash::ConfigLoadingError, "The following config files contains non-ascii characters but are not UTF-8 encoded #{encoding_issue_files}"
+        end
+
+        raise LogStash::ConfigLoadingError, "Cannot load configuration for path: #{path}" if config_parts.empty?
+        config_parts
+      end
+
+      def self.read(path)
+        ConfigPathLoader.new(path).read
+      end
+
+      private
+      def normalize_path(path)
+        path.gsub!(LOCAL_FILE_URI, "")
+        ::File.expand_path(path)
+      end
+
+      def get_files
+        Dir.glob(path).sort
+      end
+
+      def path
+        if ::File.directory?(@path)
+          ::File.join(@path, "*")
+        else
+          @path
+        end
+      end
+
+      def valid_encoding?(content)
+        content.ascii_only? && content.valid_encoding?
+      end
+
+      def temporary_file?(filepath)
+        filepath.match(TEMPORARY_FILE_RE)
+      end
+    end
+
+    class ConfigRemoteLoader
+      def self.read(uri)
+        uri = URI.parse(uri)
+
+        Net::HTTP.start(uri.host, uri.port, :use_ssl => uri.scheme == "https") do |http|
+          request = Net::HTTP::Get.new(uri.path)
+          response = http.request(request)
+
+          # since we have fetching config we wont follow any redirection.
+          case response.code.to_i
+          when 200
+            [ConfigPart.new(self.name, uri.to_s, response.body)]
+          when 302
+            raise LogStash::ConfigLoadingError, I18n.t("logstash.runner.configuration.fetch-failed", :path => uri.to_s, :message => "We don't follow redirection for remote configuration")
+          when 404
+            raise LogStash::ConfigLoadingError, I18n.t("logstash.runner.configuration.fetch-failed", :path => uri.to_s, :message => "File not found")
+          when 403
+            raise LogStash::ConfigLoadingError, I18n.t("logstash.runner.configuration.fetch-failed", :path => uri.to_s, :message => "Permission denied")
+          when 500
+            raise LogStash::ConfigLoadingError, I18n.t("logstash.runner.configuration.fetch-failed", :path => uri.to_s, :message => "500 error on remote host")
+          else
+            raise LogStash::ConfigLoadingError, I18n.t("logstash.runner.configuration.fetch-failed", :path => uri.to_s, :message => "code: #{response.code}, message: #{response.class.to_s}")
+          end
+        end
+      end
+    end
+
+    PIPELINE_ID = :main
+    HTTP_RE = /^http(s)?/
+    INPUT_BLOCK_RE = /input *{/
+    OUTPUT_BLOCK_RE = /output *{/
+
+    def initialize(settings)
+      super(settings)
+    end
+
+    def pipeline_configs
+      config_parts = []
+
+      config_parts << ConfigStringLoader.read(config_string) if config_string?
+      config_parts << ConfigPathLoader.read(config_path) if local_config?
+      config_parts << ConfigRemoteLoader.read(config_path) if remote_config?
+
+      config_parts.flatten!
+
+      add_missing_default_inputs_or_outputs(config_parts)
+
+      PipelineConfig.new(self.class, PIPELINE_ID, config_parts, @settings)
+    end
+
+    def self.match?(settings)
+      settings.get("config.string") || settings.get("path.config")
+    end
+
+    private
+    # Make sure we have an input and at least 1 output
+    # if its not the case we will add stdin and stdout
+    # this is for backward compatibility reason
+    def add_missing_default_inputs_or_outputs(config_parts)
+      if !config_parts.any? { |part| INPUT_BLOCK_RE.match(part.config_string) }
+        config_parts << LogStash::Config::ConfigPart.new(self.class.name, "default input", LogStash::Config::Defaults.input)
+      end
+
+      # include a default stdout output if no outputs given
+      if !config_parts.any? { |part| OUTPUT_BLOCK_RE.match(part.config_string) }
+        config_parts << LogStash::Config::ConfigPart.new(self.class.name, "default output", LogStash::Config::Defaults.output)
+      end
+    end
+
+    def config_string
+      @settings.get("config.string")
+    end
+
+    def config_string?
+      !config_string.nil? && !config_string.empty?
+    end
+
+    def config_path
+      @settings.get("path.config")
+    end
+
+    def config_path?
+      !config_path.nil? && !config_path.empty?
+    end
+
+    def local_config?
+      return false unless config_path?
+
+      begin
+        uri = URI.parse(config_path)
+        uri.scheme == "file" || uri.scheme.nil?
+      rescue URI::InvalidURIError
+        # fallback for windows.
+        # if the parsing of the file failed we assume we can reach it locally.
+        # some relative path on windows arent parsed correctly (.\logstash.conf)
+        true
+      end
+    end
+
+    def remote_config?
+      return false unless config_path?
+
+      begin
+        uri = URI.parse(config_path)
+        uri.scheme =~ HTTP_RE
+      rescue URI::InvalidURIError
+        false
+      end
+    end
+  end
+end end end
diff --git a/logstash-core/lib/logstash/config/source_loader.rb b/logstash-core/lib/logstash/config/source_loader.rb
new file mode 100644
index 00000000000..ec74914a84e
--- /dev/null
+++ b/logstash-core/lib/logstash/config/source_loader.rb
@@ -0,0 +1,68 @@
+# encoding: utf-8
+require "logstash/config/source/local"
+require "logstash/errors"
+require "thread"
+require "set"
+
+module LogStash module Config
+  class SourceLoader
+    class Loader
+      def initialize(loaders)
+        @loaders = loaders
+      end
+
+      def fetch
+        @loaders.collect(&:pipeline_configs).flatten
+      end
+    end
+
+    include LogStash::Util::Loggable
+
+    def initialize
+      @source_loaders_mutex = Mutex.new
+      @source_loaders = Set.new([LogStash::Config::Source::Local])
+    end
+
+    # This return a ConfigLoader object that will
+    # abstract the call to the different sources and will return multiples pipeline
+    def create(settings)
+      loaders = []
+
+      source_loaders do |config_source|
+        if config_source.match?(settings)
+          loaders << config_source.new(settings)
+        end
+      end
+
+      if loaders.empty?
+
+        # This shouldn't happen with the settings object or with any external plugins.
+        # but lets add a guard so we fail fast.
+        raise LogStash::InvalidSourceLoaderSettingError, "Can't find an appropriate config loader with current settings"
+      else
+        Loader.new(loaders)
+      end
+    end
+
+    def source_loaders
+      @source_loaders_mutex.synchronize do
+        @source_loaders.each do |config|
+          yield config
+        end
+      end
+    end
+
+    def configure_sources(sources)
+      sources = Array(sources).to_set
+      logger.debug("Configure sources", :sources => sources.collect(&:to_s))
+      @source_loaders_mutex.synchronize { @source_loaders = sources }
+    end
+
+    def add_source(source)
+      logger.debug("Adding source", :source => source.to_s)
+      @source_loaders_mutex.synchronize { @source_loaders << source}
+    end
+  end
+
+  SOURCE_LOADER = SourceLoader.new
+end end
diff --git a/logstash-core/lib/logstash/errors.rb b/logstash-core/lib/logstash/errors.rb
index 8960a7f12bc..d684087b764 100644
--- a/logstash-core/lib/logstash/errors.rb
+++ b/logstash-core/lib/logstash/errors.rb
@@ -6,7 +6,10 @@ class ConfigurationError < Error; end
   class PluginLoadingError < Error; end
   class ShutdownSignal < StandardError; end
   class PluginNoVersionError < Error; end
+  class BootstrapCheckError < Error; end
 
   class Bug < Error; end
   class ThisMethodWasRemoved < Bug; end
+  class ConfigLoadingError < Error; end
+  class InvalidSourceLoaderSettingError < Error; end
 end
diff --git a/logstash-core/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
index f513ce1b86d..a6f37a5de0c 100644
--- a/logstash-core/lib/logstash/pipeline.rb
+++ b/logstash-core/lib/logstash/pipeline.rb
@@ -46,8 +46,10 @@ module LogStash; class Pipeline
 
   def initialize(config_str, settings = SETTINGS, namespaced_metric = nil)
     @logger = self.logger
+
     @config_str = config_str
     @config_hash = Digest::SHA1.hexdigest(@config_str)
+
     # Every time #plugin is invoked this is incremented to give each plugin
     # a unique id when auto-generating plugin ids
     @plugin_counter ||= 0
diff --git a/logstash-core/lib/logstash/runner.rb b/logstash-core/lib/logstash/runner.rb
index 924d42a8f48..dd1c4d7bf9d 100644
--- a/logstash-core/lib/logstash/runner.rb
+++ b/logstash-core/lib/logstash/runner.rb
@@ -19,6 +19,10 @@
 require "logstash/settings"
 require "logstash/version"
 require "logstash/plugins/registry"
+require "logstash/bootstrap_check/default_config"
+require "logstash/bootstrap_check/bad_java"
+require "logstash/bootstrap_check/bad_ruby"
+require "set"
 
 class LogStash::Runner < Clamp::StrictCommand
   include LogStash::Util::Loggable
@@ -29,6 +33,14 @@ class LogStash::Runner < Clamp::StrictCommand
   LogStash::SETTINGS.register(LogStash::Setting::String.new("path.settings", ::File.join(LogStash::Environment::LOGSTASH_HOME, "config")))
   LogStash::SETTINGS.register(LogStash::Setting::String.new("path.logs", ::File.join(LogStash::Environment::LOGSTASH_HOME, "logs")))
 
+  # Ordered list of check to run before starting logstash
+  # theses checks can be changed by a plugin loaded into memory.
+  DEFAULT_BOOTSTRAP_CHECKS = Set.new([
+      LogStash::BootstrapCheck::BadRuby,
+      LogStash::BootstrapCheck::BadJava,
+      LogStash::BootstrapCheck::DefaultConfig
+  ])
+
   # Node Settings
   option ["-n", "--node.name"], "NAME",
     I18n.t("logstash.runner.flag.name"),
@@ -152,9 +164,11 @@ class LogStash::Runner < Clamp::StrictCommand
     :new_flag => "log.level", :new_value => "error"
 
   attr_reader :agent
+  attr_accessor :bootstrap_checks
 
   def initialize(*args)
     @settings = LogStash::SETTINGS
+    @bootstrap_checks = DEFAULT_BOOTSTRAP_CHECKS.dup
     super(*args)
   end
 
@@ -207,22 +221,22 @@ def execute
     # We configure the registry and load any plugin that can register hooks
     # with logstash, this need to be done before any operation.
     LogStash::PLUGIN_REGISTRY.setup!
-    @settings.validate_all
 
-    LogStash::Util::set_thread_name(self.class.name)
+    @dispatcher = LogStash::EventDispatcher.new(self)
+    LogStash::PLUGIN_REGISTRY.hooks.register_emitter(self.class, @dispatcher)
 
-    if RUBY_VERSION < "1.9.2"
-      logger.fatal "Ruby 1.9.2 or later is required. (You are running: " + RUBY_VERSION + ")"
-      return 1
-    end
+    @settings.validate_all
+    @dispatcher.fire(:before_bootstrap_checks)
 
-    # Exit on bad java versions
-    java_version = LogStash::Util::JavaVersion.version
-    if LogStash::Util::JavaVersion.bad_java_version?(java_version)
-      logger.fatal "Java version 1.8.0 or later is required. (You are running: #{java_version})"
+    begin
+      @bootstrap_checks.each { |bootstrap| bootstrap.check(@settings) }
+    rescue LogStash::BootstrapCheckError => e
+      signal_usage_error(e.message)
       return 1
     end
 
+    LogStash::Util::set_thread_name(self.class.name)
+
     LogStash::ShutdownWatcher.unsafe_shutdown = setting("pipeline.unsafe_shutdown")
 
     configure_plugin_paths(setting("path.plugins"))
@@ -236,19 +250,12 @@ def execute
 
     @settings.format_settings.each {|line| logger.debug(line) }
 
-    if setting("config.string").nil? && setting("path.config").nil?
-      fail(I18n.t("logstash.runner.missing-configuration"))
-    end
-
-    if setting("config.reload.automatic") && setting("path.config").nil?
-      # there's nothing to reload
-      signal_usage_error(I18n.t("logstash.runner.reload-without-config-path"))
-    end
-
     if setting("config.test_and_exit")
-      config_loader = LogStash::Config::Loader.new(logger)
-      config_str = config_loader.format_config(setting("path.config"), setting("config.string"))
       begin
+        source_loader = LogStash::Config::SOURCE_LOADER.create(@settings)
+
+        # TODO(ph): multiple pipeline will affect this
+        config_str = source_loader.fetch.first.config_string
         LogStash::Pipeline.new(config_str)
         puts "Configuration OK"
         logger.info "Using config.test_and_exit mode. Config Validation Result: OK. Exiting Logstash"
diff --git a/logstash-core/lib/logstash/settings.rb b/logstash-core/lib/logstash/settings.rb
index 20cf6bff9ed..b48cb1363a7 100644
--- a/logstash-core/lib/logstash/settings.rb
+++ b/logstash-core/lib/logstash/settings.rb
@@ -47,6 +47,7 @@ def set?(setting_name)
     def clone
       get_subset(".*")
     end
+    alias_method :dup, :clone
 
     def get_default(setting_name)
       get_setting(setting_name).default
diff --git a/logstash-core/spec/logstash/agent_spec.rb b/logstash-core/spec/logstash/agent_spec.rb
index 27be48cd7c5..11517173142 100644
--- a/logstash-core/spec/logstash/agent_spec.rb
+++ b/logstash-core/spec/logstash/agent_spec.rb
@@ -2,21 +2,28 @@
 require "spec_helper"
 require "stud/temporary"
 require "logstash/inputs/generator"
+require "logstash/config/pipeline_config"
+require "logstash/config/config_part"
+require "logstash/config/source/local"
 require_relative "../support/mocks_classes"
 require "fileutils"
 require_relative "../support/helpers"
 
-describe LogStash::Agent do
+def create_pipeline_config(config_string)
+  parts = [LogStash::Config::ConfigPart.new(LogStash::Config::Source::Local::ConfigStringLoader, "config_string", config_string)]
+  LogStash::Config::PipelineConfig.new("TestMock", :main, parts, LogStash::SETTINGS)
+end
 
+describe LogStash::Agent do
   let(:agent_settings) { LogStash::SETTINGS }
   let(:default_pipeline_id) { LogStash::SETTINGS.get("pipeline.id") }
-  let(:agent_args) { {} }
+  let(:agent_args) { { "config.string" => "input {} output {}" }  }
   let(:pipeline_settings) { agent_settings.clone }
   let(:pipeline_args) { {} }
   let(:config_file) { Stud::Temporary.pathname }
   let(:config_file_txt) { "input { generator { count => 100000 } } output { }" }
 
-    subject { LogStash::Agent.new(agent_settings) }
+  subject { LogStash::Agent.new(agent_settings) }
 
   before :each do
     # This MUST run first, before `subject` is invoked to ensure clean state
@@ -38,7 +45,7 @@
   end
 
   it "fallback to hostname when no name is provided" do
-    expect(LogStash::Agent.new.name).to eq(Socket.gethostname)
+    expect(LogStash::Agent.new(agent_settings).name).to eq(Socket.gethostname)
   end
 
   describe "register_pipeline" do
@@ -150,7 +157,7 @@
       context "when calling reload_state!" do
         context "with a pipeline with auto reloading turned off" do
           let(:second_pipeline_config) { "input { generator { } } filter { } output { }" }
-          let(:pipeline_args) { { "config.reload.automatic" => false } }
+          let(:agent_args) { super.merge({ "config.reload.automatic" => false }) }
 
           it "does not try to reload the pipeline" do
             t = Thread.new { subject.execute }
@@ -168,7 +175,7 @@
 
         context "with a pipeline with auto reloading turned on" do
           let(:second_pipeline_config) { "input { generator { } } filter { } output { }" }
-          let(:pipeline_args) { { "config.reload.automatic" => true } }
+          let(:agent_args) { super.merge({ "config.reload.automatic" => true }) }
 
           it "tries to reload the pipeline" do
             t = Thread.new { subject.execute }
@@ -249,7 +256,7 @@
   describe "#reload_state!" do
     let(:first_pipeline_config) { "input { } filter { } output { }" }
     let(:second_pipeline_config) { "input { generator {} } filter { } output { }" }
-    let(:pipeline_args) { {
+    let(:agent_args) { {
       "config.string" => first_pipeline_config,
       "pipeline.workers" => 4,
       "config.reload.automatic" => true
@@ -261,14 +268,14 @@
 
     context "when fetching a new state" do
       it "upgrades the state" do
-        expect(subject).to receive(:fetch_config).and_return(second_pipeline_config)
+        expect(subject).to receive(:fetch_config).and_return(create_pipeline_config(second_pipeline_config))
         expect(subject).to receive(:upgrade_pipeline).with(default_pipeline_id, kind_of(LogStash::Pipeline))
         subject.reload_state!
       end
     end
     context "when fetching the same state" do
       it "doesn't upgrade the state" do
-        expect(subject).to receive(:fetch_config).and_return(first_pipeline_config)
+        expect(subject).to receive(:fetch_config).and_return(create_pipeline_config(first_pipeline_config))
         expect(subject).to_not receive(:upgrade_pipeline)
         subject.reload_state!
       end
@@ -294,7 +301,7 @@
       end
 
       it "doesn't upgrade the state" do
-        allow(subject).to receive(:fetch_config).and_return(pipeline_config)
+        allow(subject).to receive(:fetch_config).and_return(create_pipeline_config(pipeline_config))
         subject.register_pipeline(pipeline_settings)
         expect(subject.pipelines[default_pipeline_id].inputs.first.message).to eq("foo-bar")
       end
@@ -303,7 +310,7 @@
 
   describe "#upgrade_pipeline" do
     let(:pipeline_config) { "input { } filter { } output { }" }
-    let(:pipeline_args) { {
+    let(:agent_args) { {
       "config.string" => pipeline_config,
       "pipeline.workers" => 4
     } }
@@ -319,7 +326,7 @@
 
     context "when the upgrade fails" do
       before :each do
-        allow(subject).to receive(:fetch_config).and_return(new_pipeline_config)
+        allow(subject).to receive(:fetch_config).and_return(create_pipeline_config(new_pipeline_config))
         allow(subject).to receive(:create_pipeline).and_return(nil)
         allow(subject).to receive(:stop_pipeline)
       end
@@ -340,7 +347,7 @@
     context "when the upgrade succeeds" do
       let(:new_config) { "input { generator { count => 1 } } output { }" }
       before :each do
-        allow(subject).to receive(:fetch_config).and_return(new_config)
+        allow(subject).to receive(:fetch_config).and_return(create_pipeline_config(new_config))
         allow(subject).to receive(:stop_pipeline)
         allow(subject).to receive(:start_pipeline)
       end
@@ -356,16 +363,6 @@
     end
   end
 
-  describe "#fetch_config" do
-    let(:cli_config) { "filter { drop { } } " }
-    let(:agent_args) { { "config.string" => cli_config, "path.config" => config_file } }
-
-    it "should join the config string and config path content" do
-      fetched_config = subject.send(:fetch_config, agent_settings)
-      expect(fetched_config.strip).to eq(cli_config + IO.read(config_file).strip)
-    end
-  end
-
   context "#started_at" do
     it "return the start time when the agent is started" do
       expect(described_class::STARTED_AT).to be_kind_of(Time)
@@ -388,18 +385,14 @@
       f.close
       f.path
     end
-    let(:pipeline_args) do
-      {
-        "pipeline.workers" => 2,
-        "path.config" => config_path
-      }
-    end
 
     let(:agent_args) do
       {
         "config.reload.automatic" => false,
         "pipeline.batch.size" => 1,
-        "metric.collect" => true
+        "metric.collect" => true,
+        "pipeline.workers" => 2,
+        "path.config" => config_path
       }
     end
 
@@ -545,7 +538,7 @@ class DummyOutput2 < LogStash::Outputs::DroppingDummyOutput; end
     end
 
     context "when reloading a config that raises exception on pipeline.run" do
-      let(:new_config) { "input { generator { count => 10000 } }" }
+      let(:new_config) { "input { generator { count => 10000 } } output { stdout {}}" }
       let(:new_config_generator_counter) { 500 }
 
       class BrokenGenerator < LogStash::Inputs::Generator
@@ -557,6 +550,7 @@ def register
       before :each do
 
         allow(LogStash::Plugin).to receive(:lookup).with("input", "generator").and_return(BrokenGenerator)
+        allow(LogStash::Plugin).to receive(:lookup).with("output", "stdout").and_return(DummyOutput2)
 
         File.open(config_path, "w") do |f|
           f.write(new_config)
diff --git a/logstash-core/spec/logstash/config/config_part_spec.rb b/logstash-core/spec/logstash/config/config_part_spec.rb
new file mode 100644
index 00000000000..265f44a27d2
--- /dev/null
+++ b/logstash-core/spec/logstash/config/config_part_spec.rb
@@ -0,0 +1,17 @@
+# encoding: utf-8
+require "logstash/config/config_part"
+require "logstash/config/source/local"
+
+describe LogStash::Config::ConfigPart do
+  let(:reader) { LogStash::Config::Source::Local::ConfigStringLoader.to_s }
+  let(:source_id) { "config_string" }
+  let(:config_string) { "input { generator {}}  output { stdout {} }"}
+
+  subject { described_class.new(reader, source_id, config_string) }
+
+  it "expose reader, source_id, source as instance methods" do
+    expect(subject.reader).to eq(reader)
+    expect(subject.source_id).to eq(source_id)
+    expect(subject.config_string).to eq(config_string)
+  end
+end
diff --git a/logstash-core/spec/logstash/config/loader_spec.rb b/logstash-core/spec/logstash/config/loader_spec.rb
deleted file mode 100644
index 955feb2f615..00000000000
--- a/logstash-core/spec/logstash/config/loader_spec.rb
+++ /dev/null
@@ -1,38 +0,0 @@
-# encoding: utf-8
-require "spec_helper"
-require "logstash/config/loader"
-
-describe LogStash::Config::Loader do
-  let(:logger) { double("logger") }
-  subject { described_class.new(logger) }
-
-  context "when local" do
-    before { expect(subject).to receive(:local_config).with(path) }
-
-    context "unix" do
-      let(:path) { './test.conf' }
-      it 'works with relative path' do
-        subject.load_config(path)
-      end
-    end
-
-    context "windows" do
-      let(:path) { '.\test.conf' }
-      it 'work with relative windows path' do
-        subject.load_config(path)
-      end
-    end
-  end
-
-  context "when remote" do
-    context 'supported scheme' do
-      let(:path) { "http://test.local/superconfig.conf" }
-      let(:dummy_config) { 'input {}' }
-
-      before { expect(Net::HTTP).to receive(:get) { dummy_config } }
-      it 'works with http' do
-        expect(subject.load_config(path)).to eq("#{dummy_config}\n")
-      end
-    end
-  end
-end
diff --git a/logstash-core/spec/logstash/config/pipeline_config_spec.rb b/logstash-core/spec/logstash/config/pipeline_config_spec.rb
new file mode 100644
index 00000000000..abfa327b480
--- /dev/null
+++ b/logstash-core/spec/logstash/config/pipeline_config_spec.rb
@@ -0,0 +1,60 @@
+# encoding: utf-8
+require "logstash/config/pipeline_config"
+require "logstash/config/config_part"
+require "logstash/config/source/local"
+
+describe LogStash::Config::PipelineConfig do
+  let(:source) { LogStash::Config::Source::Local }
+  let(:pipeline_id) { :main }
+  let(:ordered_config_parts) do
+    [
+      LogStash::Config::ConfigPart.new(LogStash::Config::Source::Local::ConfigPathLoader, "/tmp/1", "input { generator1 }"),
+      LogStash::Config::ConfigPart.new(LogStash::Config::Source::Local::ConfigPathLoader, "/tmp/2", "input { generator2 }"),
+      LogStash::Config::ConfigPart.new(LogStash::Config::Source::Local::ConfigPathLoader, "/tmp/3", "input { generator3 }"),
+      LogStash::Config::ConfigPart.new(LogStash::Config::Source::Local::ConfigPathLoader, "/tmp/4", "input { generator4 }"),
+      LogStash::Config::ConfigPart.new(LogStash::Config::Source::Local::ConfigPathLoader, "/tmp/5", "input { generator5 }"),
+      LogStash::Config::ConfigPart.new(LogStash::Config::Source::Local::ConfigPathLoader, "/tmp/6", "input { generator6 }"),
+      LogStash::Config::ConfigPart.new(LogStash::Config::Source::Local::ConfigStringLoader, "config_string", "input { generator1 }"),
+    ]
+  end
+
+  let(:unordered_config_parts) { ordered_config_parts.shuffle }
+  let(:settings) { LogStash::SETTINGS }
+
+  subject { described_class.new(source, pipeline_id, unordered_config_parts, settings) }
+
+  it "returns the source" do
+    expect(subject.source).to eq(source)
+  end
+
+  it "returns the pipeline id" do
+    expect(subject.pipeline_id).to eq(pipeline_id)
+  end
+
+  it "returns the sorted config parts" do
+    expect(subject.config_parts).to eq(ordered_config_parts)
+  end
+
+  it "returns the config_hash" do
+    expect(subject.config_hash).not_to be_nil
+  end
+
+  it "returns the merged `ConfigPart#config_string`" do
+    expect(subject.config_string).to eq(ordered_config_parts.collect(&:config_string).join("\n"))
+  end
+
+  it "records when the config was read" do
+    expect(subject.read_at).to be <= Time.now
+  end
+
+  it "does object equality on config_hash and pipeline_id" do
+    another_exact_pipeline = described_class.new(source, pipeline_id, ordered_config_parts, settings)
+    expect(subject).to eq(another_exact_pipeline)
+
+    not_matching_pipeline = described_class.new(source, pipeline_id, [], settings)
+    expect(subject).not_to eq(not_matching_pipeline)
+
+    not_same_pipeline_id = described_class.new(source, :another_pipeline, unordered_config_parts, settings)
+    expect(subject).not_to eq(not_same_pipeline_id)
+  end
+end
diff --git a/logstash-core/spec/logstash/config/source/local_spec.rb b/logstash-core/spec/logstash/config/source/local_spec.rb
new file mode 100644
index 00000000000..3e3e5f07f2c
--- /dev/null
+++ b/logstash-core/spec/logstash/config/source/local_spec.rb
@@ -0,0 +1,410 @@
+# encoding: utf-8
+require "logstash/config/source/local"
+require "rspec/expectations"
+require "stud/temporary"
+require "fileutils"
+require "pathname"
+require_relative "../../../support/helpers"
+require "spec_helper"
+require "webmock/rspec"
+
+RSpec::Matchers.define :be_a_config_part do |reader, source_id, config_string = nil|
+  match do |actual|
+   expect(actual.reader).to eq(reader)
+   expect(actual.source_id).to eq(source_id)
+   expect(actual.config_string).to match(config_string) unless config_string.nil?
+  end
+end
+
+def temporary_file(content, file_name = Time.now.to_i.to_s, directory = Stud::Temporary.pathname)
+  FileUtils.mkdir_p(directory)
+  target = ::File.join(directory, file_name)
+
+  File.open(target, "w+") do |f|
+    f.write(content)
+  end
+  target
+end
+
+describe LogStash::Config::Source::Local::ConfigStringLoader do
+  subject { described_class }
+  let(:config_string) { "input { generator {} } output { stdout {} }"}
+
+  it "returns one config_parts" do
+    expect(subject.read(config_string).size).to eq(1)
+  end
+
+  it "returns a valid config part" do
+    config_part = subject.read(config_string).first
+    expect(config_part).to be_a_config_part(described_class.to_s, "config_string", config_string)
+  end
+end
+
+describe LogStash::Config::Source::Local::ConfigPathLoader do
+  subject { described_class }
+
+  context "no configs" do
+    context "in the directory" do
+      let(:directory) do
+        p =  Stud::Temporary.pathname
+        FileUtils.mkdir_p(p)
+        p
+      end
+
+      it "raises a config loading error" do
+        expect { subject.read(directory) }.to raise_error LogStash::ConfigLoadingError, /Cannot load configuration for path/
+      end
+    end
+
+    context "target file doesn't exist" do
+      let(:directory) do
+        p =  Stud::Temporary.pathname
+        FileUtils.mkdir_p(p)
+        ::File.join(p, "ls.conf")
+      end
+
+      it "raises a config loading error" do
+        expect { subject.read(directory) }.to raise_error LogStash::ConfigLoadingError, /Cannot load configuration for path/
+      end
+    end
+  end
+
+  context "when it exist" do
+    shared_examples "read config from files" do
+      let(:directory) { Stud::Temporary.pathname }
+
+      before do
+        files.keys.shuffle.each do |file|
+          content = files[file]
+          temporary_file(content, file, directory)
+        end
+      end
+
+      it "returns a `config_parts` per file" do
+        expect(subject.read(reader_config).size).to eq(files.size)
+      end
+
+      it "returns alphabetically sorted parts" do
+        parts = subject.read(reader_config)
+        expect(parts.collect { |part| ::File.basename(part.source_id) }).to eq(files.keys.sort)
+      end
+
+      it "returns valid `config_parts`" do
+        parts = subject.read(reader_config)
+
+        parts.each do |part|
+          basename = ::File.basename(part.source_id)
+          file_path = ::File.join(directory, basename)
+          content = files[basename]
+          expect(part).to be_a_config_part(described_class.to_s, file_path, content)
+        end
+      end
+    end
+
+    context "when the files have invalid encoding" do
+      let(:config_string) { "\x80" }
+      let(:file_path) { Stud::Temporary.pathname }
+      let(:file) { ::File.join(file_path, "wrong_encoding.conf") }
+
+      before do
+        FileUtils.mkdir_p(file_path)
+        f = File.open(file, "wb") do |file|
+          file.write(config_string)
+        end
+      end
+
+      it "raises an exception" do
+        expect { subject.read(file_path) }.to raise_error LogStash::ConfigLoadingError, /#{file_path}/
+      end
+    end
+
+    context "when we target one file" do
+      let(:reader_config) { ::File.join(directory, files.keys.first) }
+      let(:files) {
+        {
+          "config1.conf" => "input1",
+        }
+      }
+
+      include_examples "read config from files"
+    end
+
+    context "when we target a path with multiples files" do
+      let(:reader_config) { directory }
+
+      let(:files) {
+        {
+          "config1.conf" => "input1",
+          "config2.conf" => "input2",
+          "config3.conf" => "input3",
+          "config4.conf" => "input4"
+        }
+      }
+
+      include_examples "read config from files"
+    end
+
+    context "when there temporary files in the directory" do
+      let(:reader_config) { ::File.join(directory, "conf*.conf") }
+
+      let(:files) {
+        {
+          "config1.conf" => "input1",
+          "config2.conf" => "input2",
+          "config3.conf" => "input3",
+          "config4.conf" => "input4"
+        }
+      }
+
+      let(:other_files) do
+        {
+          "config1.conf~" => "input1",
+          "config2.conf~" => "input2",
+          "config3.conf~" => "input3",
+          "config4.conf~" => "input4"
+        }
+      end
+
+      include_examples "read config from files" do
+        before do
+          other_files.keys.shuffle.each do |file|
+            content = files[file]
+            temporary_file(content, file, directory)
+          end
+
+          # make sure we actually do some filtering
+          expect(Dir.glob(::File.join(directory, "*")).size).to eq(other_files.size + files.size)
+        end
+      end
+    end
+
+    context "when the path is a wildcard" do
+      let(:reader_config) { ::File.join(directory, "conf*.conf") }
+
+      let(:files) {
+        {
+          "config1.conf" => "input1",
+          "config2.conf" => "input2",
+          "config3.conf" => "input3",
+          "config4.conf" => "input4"
+        }
+      }
+
+      let(:other_files) do
+        {
+          "bad1.conf" => "input1",
+          "bad2.conf" => "input2",
+          "bad3.conf" => "input3",
+          "bad4.conf" => "input4"
+        }
+      end
+
+      include_examples "read config from files" do
+        before do
+          other_files.keys.shuffle.each do |file|
+            content = files[file]
+            temporary_file(content, file, directory)
+          end
+
+          # make sure we actually do some filtering
+          expect(Dir.glob(::File.join(directory, "*")).size).to eq(other_files.size + files.size)
+        end
+      end
+    end
+
+    context "URI defined path (file://..)" do
+      let(:reader_config) { "file://#{::File.join(directory, files.keys.first)}" }
+      let(:files) {
+        {
+          "config1.conf" => "input1",
+        }
+      }
+
+      include_examples "read config from files"
+    end
+
+    context "relative path" do
+      let(:reader_config) do
+        current = Pathname.new(::File.dirname(__FILE__))
+        target = Pathname.new(::File.join(directory, files.keys.first))
+        target.relative_path_from(current).to_s
+      end
+
+      let(:files) {
+        {
+          "config1.conf" => "input1",
+        }
+      }
+
+      include_examples "read config from files"
+    end
+  end
+end
+
+describe LogStash::Config::Source::Local::ConfigRemoteLoader do
+  before :all do
+    WebMock.disable_net_connect!
+  end
+
+  after :all do
+    WebMock.allow_net_connect!
+  end
+
+  subject { described_class }
+
+  let(:remote_url) { "http://test.dev/superconfig.conf" }
+
+  context "when the remote configuration exist" do
+    let(:config_string) { "input { generator {} } output { stdout {} }"}
+
+    before do
+      stub_request(:get, remote_url)
+        .to_return({
+        :body => config_string,
+        :status => 200
+      })
+    end
+
+    it "returns one config_parts" do
+      expect(subject.read(remote_url).size).to eq(1)
+    end
+
+    it "returns a valid config part" do
+      config_part = subject.read(remote_url).first
+      expect(config_part).to be_a_config_part(described_class.to_s, remote_url, config_string)
+    end
+  end
+
+  # I am aware that 656 http doesn't exist I am just testing the
+  # catch all block
+  [302, 404, 500, 403, 656].each do |code|
+    context "when the remote return an error code: #{code}" do
+      before do
+        stub_request(:get, remote_url)
+          .to_return({ :status => code })
+      end
+
+      it "raises the exception up" do
+        expect { subject.read(remote_url) }.to raise_error LogStash::ConfigLoadingError
+      end
+    end
+  end
+end
+
+describe LogStash::Config::Source::Local do
+  let(:input_block) { "input { generator {} }" }
+  let(:filter_block) { "filter { mutate {} } " }
+  let(:output_block) { "output { elasticsearch {}}" }
+  subject { described_class.new(settings) }
+
+  context "when `config.string` and `config.path` are set`" do
+    let(:config_file) { temporary_file(input_block) }
+
+    let(:settings) do
+      mock_settings(
+        "config.string" => "#{filter_block} #{output_block}",
+        "path.config" => config_file
+      )
+    end
+
+    it "returns a merged config" do
+      expect(subject.pipeline_configs.config_string).to include(input_block, output_block, filter_block)
+    end
+  end
+
+  context "when only the `config.string` is set" do
+    let(:settings) do
+      mock_settings( "config.string" => filter_block)
+    end
+
+    it "returns a config" do
+      expect(subject.pipeline_configs.config_string).to include(filter_block)
+    end
+  end
+
+  context "when only the `path.config` is set" do
+    let(:config_file) { temporary_file(input_block) }
+    let(:settings) do
+      mock_settings( "path.config" => config_file)
+    end
+
+    it "returns a config" do
+      expect(subject.pipeline_configs.config_string).to include(input_block)
+    end
+  end
+
+  context "when the `path.config` is an url" do
+    let(:remote_url) { "http://test.dev/superconfig.conf" }
+
+    before :all do
+      WebMock.disable_net_connect!
+    end
+
+    after :all do
+      WebMock.allow_net_connect!
+    end
+
+    before do
+      stub_request(:get, remote_url)
+        .to_return({
+        :body => input_block,
+        :status => 200
+      })
+    end
+
+    let(:settings) do
+      mock_settings( "path.config" => remote_url)
+    end
+
+    it "returns a config" do
+      expect(subject.pipeline_configs.config_string).to include(input_block)
+    end
+
+    context "when `config.string` is set" do
+      let(:settings) do
+        mock_settings(
+          "path.config" => remote_url,
+          "config.string" => filter_block
+        )
+      end
+
+      it "returns a merged config" do
+        expect(subject.pipeline_configs.config_string).to include(input_block, filter_block)
+      end
+    end
+  end
+
+  context "incomplete configuration" do
+    context "when the input block is missing" do
+      let(:settings) { mock_settings( "config.string" => "#{filter_block} #{output_block}") }
+
+      it "add stdin input" do
+        expect(subject.pipeline_configs.config_string).to include(LogStash::Config::Defaults.input)
+      end
+    end
+
+    context "when the output block is missing" do
+      let(:settings) { mock_settings( "config.string" => "#{input_block} #{filter_block}") }
+
+      it "add stdout output" do
+        expect(subject.pipeline_configs.config_string).to include(LogStash::Config::Defaults.output)
+      end
+    end
+
+    context "when both the output block and input block are missing" do
+      let(:settings) { mock_settings( "config.string" => "#{filter_block}") }
+
+      it "add stdin and output" do
+        expect(subject.pipeline_configs.config_string).to include(LogStash::Config::Defaults.output, LogStash::Config::Defaults.input)
+      end
+    end
+
+    context "when it has an input and an output" do
+      let(:settings) { mock_settings( "config.string" => "#{input_block} #{filter_block} #{output_block}") }
+
+      it "doesn't add anything" do
+        expect(subject.pipeline_configs.config_string).not_to include(LogStash::Config::Defaults.output, LogStash::Config::Defaults.input)
+      end
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/config/source_loader_spec.rb b/logstash-core/spec/logstash/config/source_loader_spec.rb
new file mode 100644
index 00000000000..55677daf603
--- /dev/null
+++ b/logstash-core/spec/logstash/config/source_loader_spec.rb
@@ -0,0 +1,93 @@
+# encoding: utf-8
+require "logstash/config/source_loader"
+require "logstash/config/source/base"
+require_relative "../../support/helpers"
+
+class DummySource < LogStash::Config::Source::Base
+  def pipeline_configs
+    [self.class]
+  end
+
+  def self.match?(settings)
+    settings.get("path.config") =~ /dummy/
+  end
+end
+
+class AnotherDummySource < LogStash::Config::Source::Base
+  def pipeline_configs
+    [self.class]
+  end
+
+  def self.match?(settings)
+    settings.get("path.config") =~ /another/
+  end
+end
+
+describe LogStash::Config::SourceLoader do
+  subject { described_class.new }
+
+  it "default to local source" do
+    loaders = []
+
+    subject.source_loaders { |loader| loaders << loader }
+
+    expect(loaders.size).to eq(1)
+    expect(loaders).to include(LogStash::Config::Source::Local)
+  end
+
+  it "allows to override the available source loaders" do
+    subject.configure_sources(DummySource)
+    loaders = []
+    subject.source_loaders { |loader| loaders << loader }
+
+    expect(loaders.size).to eq(1)
+    expect(loaders).to include(DummySource)
+  end
+
+  it "allows to add a new source" do
+    loaders = []
+    subject.add_source(DummySource)
+    subject.source_loaders { |loader| loaders << loader }
+
+    expect(loaders.size).to eq(2)
+    expect(loaders).to include(DummySource, LogStash::Config::Source::Local)
+  end
+
+  context "when no source match" do
+    let(:settings) { mock_settings("path.config" => "make it not match") } # match both regex
+
+    it "return the loaders with the matched sources" do
+      subject.configure_sources([DummySource, AnotherDummySource])
+
+      expect { config_loader = subject.create(settings) }.to raise_error
+    end
+  end
+
+  context "when source loader match" do
+    context "when multiple match" do
+      let(:settings) { mock_settings("path.config" => "another dummy") } # match both regex
+
+      it "return the loaders with the matched sources" do
+        subject.configure_sources([DummySource, AnotherDummySource])
+
+        config_loader = subject.create(settings)
+
+        expect(config_loader.fetch.size).to eq(2)
+        expect(config_loader.fetch).to include(DummySource, AnotherDummySource)
+      end
+    end
+
+    context "when multiple match" do
+      let(:settings) { mock_settings("path.config" => "another") } # match both regex
+
+      it "return the loaders with the matched sources" do
+        subject.configure_sources([DummySource, AnotherDummySource])
+
+        config_loader = subject.create(settings)
+
+        expect(config_loader.fetch.size).to eq(1)
+        expect(config_loader.fetch).to include(AnotherDummySource)
+      end
+    end
+  end
+end
diff --git a/logstash-core/spec/support/helpers.rb b/logstash-core/spec/support/helpers.rb
index 6d55ab80339..3bdb45de08a 100644
--- a/logstash-core/spec/support/helpers.rb
+++ b/logstash-core/spec/support/helpers.rb
@@ -14,3 +14,13 @@ def clear_data_dir
     FileUtils.rm_rf(File.join(data_path, f))
   end
 end
+
+def mock_settings(settings_values)
+  settings = LogStash::SETTINGS.clone
+
+  settings_values.each do |key, value|
+    settings.set(key, value)
+  end
+
+  settings
+end
