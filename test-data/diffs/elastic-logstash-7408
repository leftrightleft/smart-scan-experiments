diff --git a/logstash-core/lib/logstash/compiler/lscl.rb b/logstash-core/lib/logstash/compiler/lscl.rb
index 59e729f57cc..0b8729d5b28 100644
--- a/logstash-core/lib/logstash/compiler/lscl.rb
+++ b/logstash-core/lib/logstash/compiler/lscl.rb
@@ -46,10 +46,6 @@ def line_and_column
       [self.input.line_of(start), self.input.column_of(start)]
     end
 
-    def empty_source_meta()
-      org.logstash.common.SourceWithMetadata.new(base_protocol, base_id, nil)
-    end
-
     def jdsl
       org.logstash.config.ir.DSL
     end
@@ -99,11 +95,12 @@ def compile(base_source_with_metadata=nil)
         end
       end
 
+      compiled_section_map = {}
       section_map.keys.each do |key|
-        section_map[key] = compose_for(key).call(empty_source_meta, *section_map[key])
+        compiled_section_map[key] = compose_for(key).call(*section_map[key])
       end
 
-      section_map
+      compiled_section_map
     end
   end
 
diff --git a/logstash-core/lib/logstash/config/source/local.rb b/logstash-core/lib/logstash/config/source/local.rb
index 7c454d8c98c..4a57664d296 100644
--- a/logstash-core/lib/logstash/config/source/local.rb
+++ b/logstash-core/lib/logstash/config/source/local.rb
@@ -19,7 +19,7 @@ module LogStash module Config module Source
   class Local < Base
     class ConfigStringLoader
       def self.read(config_string)
-        [org.logstash.common.SourceWithMetadata.new("string", "config_string", config_string)]
+        [org.logstash.common.SourceWithMetadata.new("string", "config_string", 0, 0, config_string)]
       end
     end
 
@@ -54,7 +54,7 @@ def read
           config_string = ::File.read(file)
 
           if valid_encoding?(config_string)
-            part = org.logstash.common.SourceWithMetadata.new("file", file, config_string)
+            part = org.logstash.common.SourceWithMetadata.new("file", file, 0, 0, config_string)
             config_parts << part
           else
             encoding_issue_files << file
@@ -121,7 +121,7 @@ def self.read(uri)
           # since we have fetching config we wont follow any redirection.
           case response.code.to_i
           when 200
-            [org.logstash.common.SourceWithMetadata.new(uri.scheme, uri.to_s, response.body)]
+            [org.logstash.common.SourceWithMetadata.new(uri.scheme, uri.to_s, 0, 0, response.body)]
           when 302
             raise LogStash::ConfigLoadingError, I18n.t("logstash.runner.configuration.fetch-failed", :path => uri.to_s, :message => "We don't follow redirection for remote configuration")
           when 404
@@ -177,12 +177,12 @@ def match?
     # this is for backward compatibility reason
     def add_missing_default_inputs_or_outputs(config_parts)
       if !config_parts.any? { |part| INPUT_BLOCK_RE.match(part.text) }
-        config_parts << org.logstash.common.SourceWithMetadata.new(self.class.name, "default input", LogStash::Config::Defaults.input)
+        config_parts << org.logstash.common.SourceWithMetadata.new(self.class.name, "default input", 0, 0, LogStash::Config::Defaults.input)
       end
 
       # include a default stdout output if no outputs given
       if !config_parts.any? { |part| OUTPUT_BLOCK_RE.match(part.text) }
-        config_parts << org.logstash.common.SourceWithMetadata.new(self.class.name, "default output", LogStash::Config::Defaults.output)
+        config_parts << org.logstash.common.SourceWithMetadata.new(self.class.name, "default output", 0, 0, LogStash::Config::Defaults.output)
       end
     end
 
diff --git a/logstash-core/lib/logstash/config/source/modules.rb b/logstash-core/lib/logstash/config/source/modules.rb
index 985bf211445..b92816a1aaa 100644
--- a/logstash-core/lib/logstash/config/source/modules.rb
+++ b/logstash-core/lib/logstash/config/source/modules.rb
@@ -14,7 +14,7 @@ def pipeline_configs
       pipelines = LogStash::Config::ModulesCommon.pipeline_configs(@settings)
       pipelines.map do |hash|
         PipelineConfig.new(self, hash["pipeline_id"].to_sym,
-          org.logstash.common.SourceWithMetadata.new("module", hash["alt_name"], hash["config_string"]),
+          org.logstash.common.SourceWithMetadata.new("module", hash["alt_name"], 0, 0, hash["config_string"]),
           hash["settings"])
       end
     end
diff --git a/logstash-core/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
index debb4b0b280..c521bddc3f2 100644
--- a/logstash-core/lib/logstash/pipeline.rb
+++ b/logstash-core/lib/logstash/pipeline.rb
@@ -90,7 +90,7 @@ def dlq_writer
   end
 
   def compile_lir
-    source_with_metadata = SourceWithMetadata.new("str", "pipeline", self.config_str)
+    source_with_metadata = SourceWithMetadata.new("str", "pipeline", 0, 0, self.config_str)
     LogStash::Compiler.compile_sources(source_with_metadata)
   end
 
diff --git a/logstash-core/spec/logstash/compiler/compiler_spec.rb b/logstash-core/spec/logstash/compiler/compiler_spec.rb
index 8fc001f7827..53e81d68cf3 100644
--- a/logstash-core/spec/logstash/compiler/compiler_spec.rb
+++ b/logstash-core/spec/logstash/compiler/compiler_spec.rb
@@ -28,8 +28,8 @@ def j
 
   describe "compiling to Pipeline" do
     subject(:source_id) { "fake_sourcefile" }
-    let(:source_with_metadata) { org.logstash.common.SourceWithMetadata.new(source_protocol, source_id, source) }
-    subject(:compiled) { described_class.compile_pipeline(source_with_metadata) }
+    let(:source_with_metadata) { org.logstash.common.SourceWithMetadata.new(source_protocol, source_id, 0, 0, source) }
+    subject(:compiled) { puts "PCOMP"; described_class.compile_pipeline(source_with_metadata) }
 
     describe "compiling multiple sources" do
       let(:sources) do
@@ -40,7 +40,7 @@ def j
       end
       let(:sources_with_metadata) do
         sources.map.with_index do |source, idx|
-          org.logstash.common.SourceWithMetadata.new("#{source_protocol}_#{idx}", "#{source_id}_#{idx}", source)
+          org.logstash.common.SourceWithMetadata.new("#{source_protocol}_#{idx}", "#{source_id}_#{idx}", 0, 0, source)
         end
       end
 
@@ -92,7 +92,7 @@ def j
 
   describe "compiling imperative" do
     let(:source_id) { "fake_sourcefile" }
-    let(:source_with_metadata) { org.logstash.common.SourceWithMetadata.new(source_protocol, source_id, source) }
+    let(:source_with_metadata) { org.logstash.common.SourceWithMetadata.new(source_protocol, source_id, 0, 0, source) }
     subject(:compiled) { described_class.compile_imperative(source_with_metadata) }
 
     describe "an empty file" do
diff --git a/logstash-core/spec/logstash/config/pipeline_config_spec.rb b/logstash-core/spec/logstash/config/pipeline_config_spec.rb
index bcb34191ac1..d7ed1c56524 100644
--- a/logstash-core/spec/logstash/config/pipeline_config_spec.rb
+++ b/logstash-core/spec/logstash/config/pipeline_config_spec.rb
@@ -7,13 +7,13 @@
   let(:pipeline_id) { :main }
   let(:ordered_config_parts) do
     [
-      org.logstash.common.SourceWithMetadata.new("file", "/tmp/1", "input { generator1 }"),
-      org.logstash.common.SourceWithMetadata.new("file", "/tmp/2", "input { generator2 }"),
-      org.logstash.common.SourceWithMetadata.new("file", "/tmp/3", "input { generator3 }"),
-      org.logstash.common.SourceWithMetadata.new("file", "/tmp/4", "input { generator4 }"),
-      org.logstash.common.SourceWithMetadata.new("file", "/tmp/5", "input { generator5 }"),
-      org.logstash.common.SourceWithMetadata.new("file", "/tmp/6", "input { generator6 }"),
-      org.logstash.common.SourceWithMetadata.new("string", "config_string", "input { generator1 }"),
+      org.logstash.common.SourceWithMetadata.new("file", "/tmp/1", 0, 0, "input { generator1 }"),
+      org.logstash.common.SourceWithMetadata.new("file", "/tmp/2", 0, 0,  "input { generator2 }"),
+      org.logstash.common.SourceWithMetadata.new("file", "/tmp/3", 0, 0, "input { generator3 }"),
+      org.logstash.common.SourceWithMetadata.new("file", "/tmp/4", 0, 0, "input { generator4 }"),
+      org.logstash.common.SourceWithMetadata.new("file", "/tmp/5", 0, 0, "input { generator5 }"),
+      org.logstash.common.SourceWithMetadata.new("file", "/tmp/6", 0, 0, "input { generator6 }"),
+      org.logstash.common.SourceWithMetadata.new("string", "config_string", 0, 0, "input { generator1 }"),
     ]
   end
 
diff --git a/logstash-core/spec/logstash/config/source/local_spec.rb b/logstash-core/spec/logstash/config/source/local_spec.rb
index 4cf701b84be..2beda89d9ac 100644
--- a/logstash-core/spec/logstash/config/source/local_spec.rb
+++ b/logstash-core/spec/logstash/config/source/local_spec.rb
@@ -367,6 +367,7 @@
         file = Stud::Temporary.file
         path = file.path
         file.write(config_string)
+        file.close # we need to flush the write
         path
       end
       let(:settings) { mock_settings( "path.config" => config_path) }
diff --git a/logstash-core/spec/logstash/config/source/multi_local_spec.rb b/logstash-core/spec/logstash/config/source/multi_local_spec.rb
index 9ef2a49d757..7b98b2b7b56 100644
--- a/logstash-core/spec/logstash/config/source/multi_local_spec.rb
+++ b/logstash-core/spec/logstash/config/source/multi_local_spec.rb
@@ -29,7 +29,7 @@
     end
 
     context "when `config.path` are set`" do
-      let(:config_file) { temporary_file("") }
+      let(:config_file) { temporary_file("input {} output {}") }
 
       let(:settings) do
         mock_settings("path.config" => config_file)
@@ -85,8 +85,8 @@
   describe "#pipeline_configs" do
     let(:retrieved_pipelines) do
       [
-        { "pipeline.id" => "main", "config.string" => "" },
-        { "pipeline.id" => "backup", "config.string" => "" }
+        { "pipeline.id" => "main", "config.string" => "input {} output {}" },
+        { "pipeline.id" => "backup", "config.string" => "input {} output {}" }
       ]
     end
     before(:each) do
diff --git a/logstash-core/spec/logstash/config/source_loader_spec.rb b/logstash-core/spec/logstash/config/source_loader_spec.rb
index 8189b2f3724..8f3fad05295 100644
--- a/logstash-core/spec/logstash/config/source_loader_spec.rb
+++ b/logstash-core/spec/logstash/config/source_loader_spec.rb
@@ -4,7 +4,7 @@
 require_relative "../../support/helpers"
 
 def temporary_pipeline_config(id, source, reader = "random_reader")
-  config_part = org.logstash.common.SourceWithMetadata.new("local", "...", "input {} output {}")
+  config_part = org.logstash.common.SourceWithMetadata.new("local", "...", 0, 0, "input {} output {}")
   LogStash::Config::PipelineConfig.new(source, id, [config_part], LogStash::SETTINGS)
 end
 
diff --git a/logstash-core/spec/support/helpers.rb b/logstash-core/spec/support/helpers.rb
index 68cf6430edf..229ec0bc547 100644
--- a/logstash-core/spec/support/helpers.rb
+++ b/logstash-core/spec/support/helpers.rb
@@ -63,7 +63,7 @@ def mock_pipeline_config(pipeline_id, config_string = nil, settings = {})
     settings = mock_settings(settings)
   end
 
-  config_part = org.logstash.common.SourceWithMetadata.new("config_string", "config_string", config_string)
+  config_part = org.logstash.common.SourceWithMetadata.new("config_string", "config_string", 0, 0, config_string)
 
   LogStash::Config::PipelineConfig.new(LogStash::Config::Source::Local, pipeline_id, config_part, settings)
 end
diff --git a/logstash-core/src/main/java/org/logstash/common/IncompleteSourceWithMetadataException.java b/logstash-core/src/main/java/org/logstash/common/IncompleteSourceWithMetadataException.java
new file mode 100644
index 00000000000..c6c0c895051
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/common/IncompleteSourceWithMetadataException.java
@@ -0,0 +1,12 @@
+package org.logstash.common;
+
+import org.logstash.config.ir.InvalidIRException;
+
+/**
+ * Created by andrewvc on 6/12/17.
+ */
+public class IncompleteSourceWithMetadataException extends InvalidIRException {
+    public IncompleteSourceWithMetadataException(String message) {
+        super(message);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/common/SourceWithMetadata.java b/logstash-core/src/main/java/org/logstash/common/SourceWithMetadata.java
index adea906bd86..4a91748ecea 100644
--- a/logstash-core/src/main/java/org/logstash/common/SourceWithMetadata.java
+++ b/logstash-core/src/main/java/org/logstash/common/SourceWithMetadata.java
@@ -1,11 +1,19 @@
 package org.logstash.common;
 
+import org.logstash.config.ir.HashableWithSource;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
 import java.util.Objects;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 /**
  * Created by andrewvc on 9/6/16.
  */
-public class SourceWithMetadata {
+public class SourceWithMetadata implements HashableWithSource {
     // Either 'file' or something else
     private final String protocol;
     // A Unique identifier for the source within the given protocol
@@ -35,32 +43,49 @@ public String getText() {
         return text;
     }
 
-    public SourceWithMetadata(String protocol, String id, Integer line, Integer column, String text) {
+    private static final Pattern emptyString = Pattern.compile("^\\s*$");
+
+    public SourceWithMetadata(String protocol, String id, Integer line, Integer column, String text) throws IncompleteSourceWithMetadataException {
         this.protocol = protocol;
         this.id = id;
         this.line = line;
         this.column = column;
         this.text = text;
-    }
 
-    // Convenience method for dealing with files
-    public SourceWithMetadata(String path, Integer line, Integer column, String text) {
-        this("file", path, line, column, text);
-    }
+        List<Object> badAttributes = this.attributes().stream().filter(a -> {
+            if (a == null) return true;
+            if (a instanceof String) {
+                return emptyString.matcher((String) a).matches();
+            }
+            return false;
+        }).collect(Collectors.toList());
 
-    public SourceWithMetadata(String protocol, String id, String text) {
-        this(protocol, id, 1, 1, text);
+        if (!badAttributes.isEmpty()){
+            String message = "Missing attributes in SourceWithMetadata: (" + badAttributes + ") "
+                    + this.toString();
+            throw new IncompleteSourceWithMetadataException(message);
+        }
     }
 
-    public SourceWithMetadata() {
-        this(null, null, null, null, null);
+    public SourceWithMetadata(String protocol, String id, String text) throws IncompleteSourceWithMetadataException {
+        this(protocol, id, 0, 0, text);
     }
 
     public int hashCode() {
-        return Objects.hash(this.id, this.line, this.column, this.text);
+        return Objects.hash(attributes().toArray());
     }
 
     public String toString() {
-        return "[protocol]" + id + ":" + line + ":" + column + ":```\n" + text + "\n```";
+        return "[" + protocol + "]" + id + ":" + line + ":" + column + ":```\n" + text + "\n```";
+    }
+
+    @Override
+    public String hashSource() {
+        return attributes().stream().map(Object::toString).collect(Collectors.joining("|"));
+    }
+
+    // Fields used in the hashSource and hashCode methods to ensure uniqueness
+    private Collection<Object> attributes() {
+        return Arrays.asList(this.getId(), this.getProtocol(), this.getLine(), this.getColumn(), this.getText());
     }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/DSL.java b/logstash-core/src/main/java/org/logstash/config/ir/DSL.java
index 13770fd6872..a0627a891fa 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/DSL.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/DSL.java
@@ -23,7 +23,7 @@ public static EventValueExpression eEventValue(SourceWithMetadata meta, String f
     }
 
     public static EventValueExpression eEventValue(String fieldName) {
-        return eEventValue(new SourceWithMetadata(), fieldName);
+        return eEventValue(null, fieldName);
     }
 
     public static ValueExpression eValue(SourceWithMetadata meta, Object value) throws InvalidIRException {
@@ -31,7 +31,7 @@ public static ValueExpression eValue(SourceWithMetadata meta, Object value) thro
     }
 
     public static ValueExpression eValue(Object value) throws InvalidIRException {
-        return eValue(new SourceWithMetadata(), value);
+        return eValue(null, value);
     }
 
     public static ValueExpression eRegex(SourceWithMetadata meta, String pattern) throws InvalidIRException {
@@ -39,12 +39,12 @@ public static ValueExpression eRegex(SourceWithMetadata meta, String pattern) th
     }
 
     public static ValueExpression eRegex(String pattern) throws InvalidIRException {
-        return eRegex(new SourceWithMetadata(), pattern);
+        return eRegex(null, pattern);
     }
 
     public static ValueExpression eValue(long value) {
         try {
-            return eValue(new SourceWithMetadata(), value);
+            return eValue(null, value);
         } catch (InvalidIRException e) {
             e.printStackTrace(); // Can't happen with an int
             return null;
@@ -53,7 +53,7 @@ public static ValueExpression eValue(long value) {
 
     public static ValueExpression eValue(double value) {
         try {
-            return eValue(new SourceWithMetadata(), value);
+            return eValue(null, value);
         } catch (InvalidIRException e) {
             e.printStackTrace(); // Can't happen with an int
             return null;
@@ -195,7 +195,7 @@ public static NoopStatement noop(SourceWithMetadata meta) {
     }
 
     public static NoopStatement noop() {
-        return new NoopStatement(new SourceWithMetadata());
+        return new NoopStatement(null);
     }
 
     public static PluginStatement iPlugin(SourceWithMetadata meta, PluginDefinition.Type pluginType, String pluginName, Map<String, Object> pluginArguments) {
@@ -203,7 +203,7 @@ public static PluginStatement iPlugin(SourceWithMetadata meta, PluginDefinition.
     }
 
     public static PluginStatement iPlugin(PluginDefinition.Type type, String pluginName, Map<String, Object> pluginArguments) {
-        return iPlugin(new SourceWithMetadata(), type, pluginName, pluginArguments);
+        return iPlugin(null, type, pluginName, pluginArguments);
     }
 
     public static PluginStatement iPlugin(PluginDefinition.Type type, String pluginName, MapBuilder<String, Object> argBuilder) {
@@ -229,12 +229,12 @@ public static IfStatement iIf(SourceWithMetadata meta,
     public static IfStatement iIf(Expression condition,
                                   Statement ifTrue,
                                   Statement ifFalse) throws InvalidIRException {
-        return iIf(new SourceWithMetadata(), condition, ifTrue, ifFalse);
+        return iIf(null, condition, ifTrue, ifFalse);
     }
 
     public static IfStatement iIf(Expression condition,
                                   Statement ifTrue) throws InvalidIRException {
-        return iIf(new SourceWithMetadata(), condition, ifTrue, noop());
+        return iIf(null, condition, ifTrue, noop());
     }
 
     public static class MapBuilder<K,V> {
@@ -275,7 +275,7 @@ public static PluginVertex gPlugin(SourceWithMetadata sourceWithMetadata, Plugin
     }
 
     public static PluginVertex gPlugin(PluginDefinition.Type type, String pluginName, Map<String, Object> pluginArgs) {
-        return gPlugin(new SourceWithMetadata(), type, pluginName, pluginArgs);
+        return gPlugin(null, type, pluginName, pluginArgs);
     }
 
     public static PluginVertex gPlugin(PluginDefinition.Type type, String pluginName, String id) {
@@ -283,7 +283,7 @@ public static PluginVertex gPlugin(PluginDefinition.Type type, String pluginName
     }
 
     public static PluginVertex gPlugin(PluginDefinition.Type type, String pluginName) {
-        return gPlugin(new SourceWithMetadata(), type, pluginName, new HashMap<>());
+        return gPlugin(null, type, pluginName, new HashMap<>());
     }
 
 
@@ -292,6 +292,6 @@ public static IfVertex gIf(SourceWithMetadata meta, BooleanExpression expression
     }
 
     public static IfVertex gIf(BooleanExpression expression) {
-       return new IfVertex(new SourceWithMetadata(), expression);
+       return new IfVertex(null, expression);
     }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/Hashable.java b/logstash-core/src/main/java/org/logstash/config/ir/Hashable.java
index 5b4445385cb..8bb79b98fe1 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/Hashable.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/Hashable.java
@@ -6,9 +6,5 @@
  * Created by andrewvc on 12/23/16.
  */
 public interface Hashable {
-    String hashSource();
-
-    default String uniqueHash() {
-        return Util.digest(this.hashSource());
-    }
+    String uniqueHash();
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/HashableWithSource.java b/logstash-core/src/main/java/org/logstash/config/ir/HashableWithSource.java
new file mode 100644
index 00000000000..77cd0abcdf8
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/HashableWithSource.java
@@ -0,0 +1,15 @@
+package org.logstash.config.ir;
+
+import org.logstash.common.Util;
+import org.logstash.config.ir.Hashable;
+
+/**
+ * Created by andrewvc on 6/12/17.
+ */
+public interface HashableWithSource extends Hashable {
+    @Override
+    default String uniqueHash() {
+        return Util.digest(hashSource());
+    }
+    String hashSource();
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/PipelineIR.java b/logstash-core/src/main/java/org/logstash/config/ir/PipelineIR.java
index ac708392e1c..a15dd67fe2d 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/PipelineIR.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/PipelineIR.java
@@ -13,6 +13,8 @@
  * Created by andrewvc on 9/20/16.
  */
 public class PipelineIR implements Hashable {
+    private String uniqueHash;
+
     public Graph getGraph() {
         return graph;
     }
@@ -34,11 +36,6 @@ public PipelineIR(Graph inputSection, Graph filterSection, Graph outputSection)
     public PipelineIR(Graph inputSection, Graph filterSection, Graph outputSection, String originalSource) throws InvalidIRException {
         this.originalSource = originalSource;
 
-        // Validate all incoming graphs, we can't turn an invalid graph into a PipelineIR!
-        inputSection.validate();
-        filterSection.validate();
-        outputSection.validate();
-
         Graph tempGraph = inputSection.copy(); // The input section are our roots, so we can import that wholesale
 
         // Connect all the input vertices out to the queue
@@ -50,6 +47,12 @@ public PipelineIR(Graph inputSection, Graph filterSection, Graph outputSection,
 
         // Finally, connect the filter out node to all the outputs
         this.graph = tempGraph.chain(outputSection);
+
+        this.graph.validate();
+
+        if (this.getOriginalSource() != null && this.getOriginalSource().matches("^\\S+$")) {
+            uniqueHash = this.graph.uniqueHash();
+        }
     }
 
     public String getOriginalSource() {
@@ -104,7 +107,7 @@ public Stream<PluginVertex> pluginVertices() {
     }
 
     @Override
-    public String hashSource() {
-        return this.graph.uniqueHash();
+    public String uniqueHash() {
+        return this.uniqueHash;
     }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/PluginDefinition.java b/logstash-core/src/main/java/org/logstash/config/ir/PluginDefinition.java
index 0fec8ca3d59..5fb99dc61f2 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/PluginDefinition.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/PluginDefinition.java
@@ -12,7 +12,7 @@
 /**
  * Created by andrewvc on 9/20/16.
  */
-public class PluginDefinition implements SourceComponent, Hashable {
+public class PluginDefinition implements SourceComponent, HashableWithSource {
     private static ObjectMapper om = new ObjectMapper();
 
     @Override
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java
index e788c30e8ca..9023ee72076 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java
@@ -1,5 +1,6 @@
 package org.logstash.config.ir.expression;
 
+import org.logstash.common.Util;
 import org.logstash.config.ir.SourceComponent;
 import org.logstash.config.ir.InvalidIRException;
 import org.logstash.common.SourceWithMetadata;
@@ -46,8 +47,7 @@ public String toRubyString() {
         return "(" + getLeft().toRubyString() + rubyOperator() + getRight().toRubyString() + ")";
     }
 
-    @Override
-    public String hashSource() {
-        return this.getClass().getCanonicalName() + "[" + getLeft().hashSource() + "|" + getRight().hashSource() + "]";
+    public String uniqueHash() {
+        return Util.digest(this.getClass().getCanonicalName() + "[" + getLeft().hashSource() + "|" + getRight().hashSource() + "]");
     }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java
index 9e21882d127..ebbb75dcd19 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java
@@ -6,6 +6,7 @@
 import org.logstash.config.ir.Hashable;
 import org.logstash.config.ir.BaseSourceComponent;
 import org.logstash.common.SourceWithMetadata;
+import org.logstash.config.ir.HashableWithSource;
 
 /*
  * [foo] == "foostr" eAnd [bar] > 10
@@ -15,7 +16,7 @@
  * notnull(eEventValue("foo"))
  * Created by andrewvc on 9/6/16.
  */
-public abstract class Expression extends BaseSourceComponent implements Hashable {
+public abstract class Expression extends BaseSourceComponent implements HashableWithSource {
     private ScriptingContainer container;
 
     public Expression(SourceWithMetadata meta) {
@@ -40,4 +41,8 @@ public String toString() {
     }
 
     public abstract String toRubyString();
+
+    public String hashSource() {
+        return toRubyString();
+    }
 }
\ No newline at end of file
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java
index 09211570c39..ac3a9481eba 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java
@@ -222,7 +222,6 @@ public Collection<Edge> chainVerticesUnsafe(Edge.EdgeFactory edgeFactory, Vertex
 
     public Collection<Edge> chainVertices(Edge.EdgeFactory edgeFactory, Vertex... argVertices) throws InvalidIRException {
         Collection<Edge> edges = chainVerticesUnsafe(edgeFactory, argVertices);
-        validate();
         return edges;
     }
 
@@ -246,6 +245,7 @@ public Collection<Edge> chainVertices(boolean bool, Vertex... vertices) throws I
     // in.
     public void refresh() throws InvalidIRException {
         this.calculateRanks();
+        this.vertices.forEach(Vertex::clearCache);
         this.calculateTopologicalSort();
     }
 
@@ -268,10 +268,6 @@ public Integer rank(Vertex vertex) {
         return rank;
     }
 
-    public Map<String, List<Vertex>> verticesByHash() {
-        return this.vertices().collect(Collectors.groupingBy(Vertex::uniqueHash));
-    }
-
     public void validate() throws InvalidIRException {
         if (this.isEmpty()) return;
 
@@ -279,14 +275,21 @@ public void validate() throws InvalidIRException {
             throw new InvalidIRException("Graph has no leaf vertices!\n" + this.toString());
         }
 
-        List<List<Vertex>> duplicates = verticesByHash().values().stream().filter((group) -> group.size() > 1).collect(Collectors.toList());
-        if (!duplicates.isEmpty()) {
-            Stream<String> errorMessageGroups = duplicates.stream().
-                    map((group) -> group.stream().map(Object::toString).collect(Collectors.joining("===")));
-
-            String joinedErrorMessageGroups = errorMessageGroups.collect(Collectors.joining("\n---\n"));
-
-            throw new InvalidIRException("Some nodes on the graph are fully redundant!\n" + this + "|" + joinedErrorMessageGroups);
+        // Check for duplicate IDs in the config
+        List<String> duplicateIdErrorMessages = this.vertices().parallel()
+                .collect(Collectors.groupingBy(Vertex::getId))
+                .values()
+                .stream()
+                .filter(group -> group.size() > 1)
+                .map(group -> {
+                    return "ID: " + group.stream().findAny().get().getId() + " " +
+                            group.stream().map(Object::toString).collect(Collectors.joining(","));
+                })
+                .collect(Collectors.toList());
+
+        if (!duplicateIdErrorMessages.isEmpty()) {
+            String dupeErrors = duplicateIdErrorMessages.stream().collect(Collectors.joining("\n"));
+            throw new InvalidIRException("Config has duplicate Ids: \n" + dupeErrors);
         }
     }
 
@@ -419,10 +422,18 @@ public Stream<Edge> edges() {
         return this.edges.stream();
     }
 
-    @Override
-    public String hashSource() {
+    public String uniqueHash() {
         MessageDigest lineageDigest = Util.defaultMessageDigest();
-        List<byte[]> sources = this.vertices.stream().parallel().map(Vertex::uniqueHash).sorted().map(String::getBytes).collect(Collectors.toList());
+
+        // We only need to calculate the hashes of the leaves since those hashes are sensitive to changes
+        // anywhere else on the graph. It would also be OK to use the roots, the decision is arbitrary
+        List<byte[]> sources = this.leaves().parallel()
+                .map(Vertex::uniqueHash)
+                .sorted()
+                .map(String::getBytes)
+                .collect(Collectors.toList());
+        // We don't do this inline with the stream because we need this to be single threaded
+        // not parallel
         sources.forEach(lineageDigest::update);
         return Util.bytesToHexString(lineageDigest.digest());
     }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java
index f7c322670a5..d23de9b98d2 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java
@@ -13,6 +13,8 @@
  * Created by andrewvc on 9/15/16.
  */
 public class IfVertex extends Vertex {
+    private volatile String generatedId;
+
     public BooleanExpression getBooleanExpression() {
         return booleanExpression;
     }
@@ -66,11 +68,6 @@ public boolean acceptsOutgoingEdge(Edge e) {
         return (e instanceof BooleanEdge);
     }
 
-    @Override
-    public String getId() {
-        return this.uniqueHash();
-    }
-
     public Collection<BooleanEdge> getOutgoingBooleanEdges() {
         // Wish there was a way to do this as a java a cast without an operation
         return getOutgoingEdges().stream().map(e -> (BooleanEdge) e).collect(Collectors.toList());
@@ -97,7 +94,7 @@ public IfVertex copy() {
     }
 
     @Override
-    public String individualHashSource() {
+    public String calculateIndividualHashSource() {
         return this.getClass().getCanonicalName() + "{" + this.booleanExpression.hashSource() + "}";
     }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java
index 75ba504516f..1269004acc0 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java
@@ -7,21 +7,15 @@
 import org.logstash.config.ir.PluginDefinition;
 import org.logstash.common.SourceWithMetadata;
 
+import java.util.UUID;
+
 /**
  * Created by andrewvc on 9/15/16.
  */
 public class PluginVertex extends Vertex {
     private final SourceWithMetadata meta;
-    private final String id;
     private final PluginDefinition pluginDefinition;
-
-    public String getId() {
-        if (id != null) return id;
-        if (this.getGraph() == null) {
-            throw new RuntimeException("Attempted to get ID from PluginVertex before attaching it to a graph!");
-        }
-        return this.uniqueHash();
-    }
+    private volatile String generatedId;
 
     public PluginDefinition getPluginDefinition() {
         return pluginDefinition;
@@ -31,15 +25,11 @@ public SourceWithMetadata getSourceWithMetadata() {
         return meta;
     }
 
-
     public PluginVertex(SourceWithMetadata meta, PluginDefinition pluginDefinition) {
-        super(meta);
+        // We know that if the ID value exists it will be as a string
+        super(meta, (String) pluginDefinition.getArguments().get("id"));
         this.meta = meta;
-
         this.pluginDefinition = pluginDefinition;
-
-        Object argId = this.pluginDefinition.getArguments().get("id");
-        this.id = argId != null ? argId.toString() : null;
     }
 
     public String toString() {
@@ -47,11 +37,11 @@ public String toString() {
     }
 
     @Override
-    public String individualHashSource() {
+    public String calculateIndividualHashSource() {
         ObjectMapper objectMapper = new ObjectMapper();
         try {
             return Util.digest(this.getClass().getCanonicalName() + "|" +
-                    (this.id != null ? this.id : "NOID") + "|" +
+                    (this.getExplicitId() != null ? this.getExplicitId() : "NOID") + "|" +
                     this.pluginDefinition.getName() + "|" +
                     this.pluginDefinition.getType().toString() + "|" +
                     objectMapper.writeValueAsString(this.pluginDefinition.getArguments()));
@@ -61,10 +51,6 @@ public String individualHashSource() {
         }
     }
 
-    public String individualHash() {
-        return Util.digest(individualHashSource());
-    }
-
     @Override
     public PluginVertex copy() {
         return new PluginVertex(meta, getPluginDefinition());
@@ -82,4 +68,10 @@ public boolean sourceComponentEquals(SourceComponent other) {
         }
         return false;
     }
+
+    @Override
+    public void clearCache() {
+        super.clearCache();
+        this.generatedId = null;
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/QueueVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/QueueVertex.java
index 81a079045c0..6001e76753b 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/QueueVertex.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/QueueVertex.java
@@ -17,7 +17,7 @@ public String getId() {
     }
 
     @Override
-    public String individualHashSource() {
+    public String calculateIndividualHashSource() {
         return this.getClass().getCanonicalName();
     }
 
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java
index cce48ff46bc..c2a7b104527 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java
@@ -1,7 +1,7 @@
 package org.logstash.config.ir.graph;
 
 import org.logstash.common.Util;
-import org.logstash.config.ir.Hashable;
+import org.logstash.config.ir.HashableWithSource;
 import org.logstash.config.ir.SourceComponent;
 import org.logstash.config.ir.InvalidIRException;
 import org.logstash.common.SourceWithMetadata;
@@ -17,16 +17,26 @@
 /**
  * Created by andrewvc on 9/15/16.
  */
-public abstract class Vertex implements SourceComponent, Hashable {
+public abstract class Vertex implements SourceComponent, HashableWithSource {
     private final SourceWithMetadata sourceWithMetadata;
     private Graph graph = this.getGraph();
+    private volatile String contextualHashCache;
+    private volatile String hashCache;
+    private volatile String individualHashSourceCache;
+    private final String explicitId;
+    private volatile String generatedId;
 
     public Vertex() {
-        this.sourceWithMetadata = null;
+        this(null);
     }
 
     public Vertex(SourceWithMetadata sourceWithMetadata) {
+        this(sourceWithMetadata, null);
+    }
+
+    public Vertex(SourceWithMetadata sourceWithMetadata, String explicitId) {
         this.sourceWithMetadata = sourceWithMetadata;
+        this.explicitId = explicitId;
     }
 
     public abstract Vertex copy();
@@ -122,6 +132,10 @@ public int rank() {
 
     @Override
     public String uniqueHash() {
+        if (this.hashCache != null) {
+            return this.hashCache;
+        }
+
         // Sort the lineage to ensure consistency. We prepend each item with a lexicographically sortable
         // encoding of its rank (using hex notation) so that the sort order is identical to the traversal order.
         // This is a required since there may be individually identical components in different locations in the graph.
@@ -142,9 +156,8 @@ public String uniqueHash() {
                     lineageDigest.update(bytes);
                 });
 
-        String digest = Util.bytesToHexString(lineageDigest.digest());
-
-        return digest;
+        this.hashCache = Util.bytesToHexString(lineageDigest.digest());
+        return hashCache;
     }
 
     @Override
@@ -158,7 +171,11 @@ public String hashPrefix() {
     }
 
     public String contextualHashSource() {
-        // This string must be lexicographically sortable hence the ID at the front. It also must have the individualHashSource
+        if (this.contextualHashCache != null) {
+            return this.contextualHashCache;
+        }
+
+        // This string must be lexicographically sortable hence the ID at the front. It also must have the calculateIndividualHashSource
         // repeated at the front for the case of a graph with two nodes at the same rank, same contents, but different lineages
         StringBuilder result = new StringBuilder();
         result.append(hashPrefix());
@@ -169,10 +186,20 @@ public String contextualHashSource() {
         result.append("O:");
         this.outgoingEdges().map(Edge::individualHashSource).sorted().forEachOrdered(result::append);
 
-        return result.toString();
+        this.contextualHashCache = result.toString();
+        return this.contextualHashCache;
+    }
+
+    public String individualHashSource() {
+        if (this.individualHashSourceCache != null) {
+            return this.individualHashSourceCache;
+        }
+
+        this.individualHashSourceCache = calculateIndividualHashSource();
+        return this.individualHashSourceCache;
     }
 
-    public abstract String individualHashSource();
+    public abstract String calculateIndividualHashSource();
 
     // Can be overriden in subclasses to define multiple
     // expected Edge classes this Vertex can take.
@@ -197,5 +224,35 @@ public boolean acceptsOutgoingEdge(Edge e) {
         return true;
     }
 
-    public abstract String getId();
+    public String getExplicitId() {
+        return this.explicitId;
+    }
+
+    public String getId() {
+        if (explicitId != null) return explicitId;
+        if (generatedId != null) return generatedId;
+
+        if (this.getGraph() == null) {
+            throw new RuntimeException("Attempted to get ID from PluginVertex before attaching it to a graph!");
+        }
+
+        // Generating unique hashes for vertices is very slow!
+        // We try to avoid this where possible, which means that generally only tests hit the path with hashes, since
+        // they have no source metadata. This might also be used in the future by alternate config languages which are
+        // willing to take the hit.
+        if (this.getSourceWithMetadata() != null) {
+            generatedId = this.getGraph().uniqueHash() + "|" + this.getSourceWithMetadata().uniqueHash();
+        } else {
+            generatedId = this.uniqueHash();
+        }
+
+        return generatedId;
+    }
+
+    public void clearCache() {
+        this.hashCache = null;
+        this.contextualHashCache = null;
+        this.individualHashSourceCache = null;
+    }
+
 }
diff --git a/logstash-core/src/test/java/org/logstash/common/SourceWithMetadataTest.java b/logstash-core/src/test/java/org/logstash/common/SourceWithMetadataTest.java
new file mode 100644
index 00000000000..ec0c9541ae9
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/common/SourceWithMetadataTest.java
@@ -0,0 +1,64 @@
+package org.logstash.common;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+import java.util.Collection;
+
+/**
+ * Created by andrewvc on 6/12/17.
+ */
+@RunWith(Parameterized.class)
+public class SourceWithMetadataTest {
+    private final ParameterGroup parameterGroup;
+
+    public static class ParameterGroup {
+        public final String protocol;
+        public final String path;
+        public final Integer line;
+        public final Integer column;
+        public final String text;
+
+        public ParameterGroup(String protocol, String path, Integer line, Integer column, String text) {
+            this.protocol = protocol;
+            this.path = path;
+            this.line = line;
+            this.column = column;
+            this.text = text;
+        }
+    }
+
+    @Parameterized.Parameters
+    public static Iterable<ParameterGroup> data() {
+        return Arrays.asList(
+            new ParameterGroup(null, "path", 1, 1, "foo"),
+            new ParameterGroup("proto", null, 1, 1, "foo"),
+            new ParameterGroup("proto", "path", null, 1, "foo"),
+            new ParameterGroup("proto", "path", 1, null, "foo"),
+            new ParameterGroup("proto", "path", 1, 1, null),
+            new ParameterGroup("", "path", 1, 1, "foo"),
+            new ParameterGroup("proto", "", 1, 1, "foo"),
+            new ParameterGroup("proto", "path", 1, 1, ""),
+            new ParameterGroup(" ", "path", 1, 1, "foo"),
+            new ParameterGroup("proto", "  ", 1, 1, "foo"),
+            new ParameterGroup("proto", "path", 1, 1, "   ")
+        );
+    }
+
+    public SourceWithMetadataTest(ParameterGroup parameterGroup) {
+        this.parameterGroup = parameterGroup;
+    }
+
+    // So, this really isn't parameterized, but it isn't worth making a separate class for this
+    @Test
+    public void itShouldInstantiateCleanlyWhenParamsAreGood() throws IncompleteSourceWithMetadataException {
+        new SourceWithMetadata("proto", "path", 1, 1, "text");
+    }
+
+    @Test(expected = IncompleteSourceWithMetadataException.class)
+    public void itShouldThrowWhenMissingAField() throws IncompleteSourceWithMetadataException {
+        new SourceWithMetadata(parameterGroup.protocol, parameterGroup.path, parameterGroup.line, parameterGroup.column, parameterGroup.text);
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java b/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java
index 6e47ff36c7d..62b4c707e2e 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java
@@ -1,6 +1,7 @@
 package org.logstash.config.ir;
 
 import org.hamcrest.MatcherAssert;
+import org.logstash.common.IncompleteSourceWithMetadataException;
 import org.logstash.common.SourceWithMetadata;
 import org.logstash.config.ir.expression.BooleanExpression;
 import org.logstash.config.ir.expression.ValueExpression;
@@ -52,7 +53,7 @@ public Vertex copy() {
         }
 
         @Override
-        public String individualHashSource() {
+        public String calculateIndividualHashSource() {
             return "TVertex" + "|" + id;
         }
 
@@ -116,8 +117,8 @@ public static BooleanExpression createTestExpression() throws InvalidIRException
         return new Truthy(null, new ValueExpression(null, 1));
     }
 
-    public static SourceWithMetadata testMetadata() {
-        return new SourceWithMetadata("/fake/file", 1, 2, "<fakesource>");
+    public static SourceWithMetadata testMetadata() throws IncompleteSourceWithMetadataException {
+        return new SourceWithMetadata("file", "/fake/file", 1, 2, "<fakesource>");
     }
 
     public static PluginDefinition testPluginDefinition() {
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/GraphTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/GraphTest.java
index ae877065d2b..dda10943f06 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/graph/GraphTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/GraphTest.java
@@ -9,6 +9,7 @@
 
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashSet;
 
 import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.hamcrest.CoreMatchers.is;
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/graph/PluginVertexTest.java b/logstash-core/src/test/java/org/logstash/config/ir/graph/PluginVertexTest.java
index b11b35a8c35..1c7b07b5dd0 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/graph/PluginVertexTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/graph/PluginVertexTest.java
@@ -1,6 +1,8 @@
 package org.logstash.config.ir.graph;
 
 import org.junit.Test;
+import org.logstash.common.IncompleteSourceWithMetadataException;
+import org.logstash.common.SourceWithMetadata;
 import org.logstash.config.ir.InvalidIRException;
 import org.logstash.config.ir.PluginDefinition;
 
@@ -25,7 +27,7 @@ public void testConstructionIdHandlingWhenNoExplicitId() throws InvalidIRExcepti
     }
 
     @Test
-    public void testConstructionIdHandlingWhenExplicitId() {
+    public void testConstructionIdHandlingWhenExplicitId() throws IncompleteSourceWithMetadataException {
         String customId = "mycustomid";
         Map<String, Object> pluginArguments = new HashMap<>();
         pluginArguments.put("id", customId);
