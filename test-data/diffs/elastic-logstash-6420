diff --git a/logstash-core-event-java/.gitignore b/logstash-core-event-java/.gitignore
deleted file mode 100644
index 0224a02d2d8..00000000000
--- a/logstash-core-event-java/.gitignore
+++ /dev/null
@@ -1,5 +0,0 @@
-*.class
-
-# build dirs
-build
-.gradle
diff --git a/logstash-core-event-java/README.md b/logstash-core-event-java/README.md
deleted file mode 100644
index 7b12d19f135..00000000000
--- a/logstash-core-event-java/README.md
+++ /dev/null
@@ -1,63 +0,0 @@
-# logstash-core-event-java
-
-## dev install
-
-1- build code with
-
-```
-$ cd logstash-core-event-java
-$ gradle build
-```
-
-A bunch of warning are expected, it should end with:
-
-```
-BUILD SUCCESSFUL
-```
-
-2- update root logstash `Gemfile` to use this gem with:
-
-```
-# gem "logstash-core-event", "x.y.z", :path => "./logstash-core-event"
-gem "logstash-core-event-java", "x.y.z", :path => "./logstash-core-event-java"
-```
-
-3- update `logstash-core/logstash-core.gemspec` with:
-
-```
-# gem.add_runtime_dependency "logstash-core-event", "x.y.z"
-gem.add_runtime_dependency "logstash-core-event-java", "x.y.z"
-```
-
-4- and install:
-
-```
-$ bin/bundle
-```
-
-- install core plugins for tests
-
-```
-$ rake test:install-core
-```
-
-## specs
-
-```
-$ bin/rspec spec
-$ bin/rspec logstash-core/spec
-$ bin/rspec logstash-core-event/spec
-$ bin/rspec logstash-core-event-java/spec
-```
-
-or
-
-```
-$ rake test:core
-```
-
-also
-
-```
-$ rake test:plugins
-```
\ No newline at end of file
diff --git a/logstash-core-event-java/build.gradle b/logstash-core-event-java/build.gradle
deleted file mode 100644
index 1ff40a0938a..00000000000
--- a/logstash-core-event-java/build.gradle
+++ /dev/null
@@ -1,117 +0,0 @@
-group = 'org.logstash'
-version = '6.0.0-alpha1'
-
-description = "Logstash Core Event Java"
-
-apply plugin: 'java'
-apply plugin: 'idea'
-
-repositories {
-    mavenCentral()
-}
-
-gradle.projectsEvaluated {
-    tasks.withType(JavaCompile) {
-        options.compilerArgs << "-Xlint:deprecation"
-//        options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
-    }
-}
-
-project.sourceCompatibility = 1.8
-project.targetCompatibility = 1.8
-
-task sourcesJar(type: Jar, dependsOn: classes) {
-    from sourceSets.main.allSource
-    classifier 'sources'
-    extension 'jar'
-}
-
-task javadocJar(type: Jar, dependsOn: javadoc) {
-    from javadoc.destinationDir
-    classifier 'javadoc'
-    extension 'jar'
-}
-
-// copy jar file into the gem lib dir but without the version number in filename
-task copyGemjar(type: Copy, dependsOn: sourcesJar) {
-    from project.jar
-    into project.file('lib/logstash-core-event-java/')
-    rename(/(.+)-${project.version}.jar/, '$1.jar')
-}
-
-task cleanGemjar {
-    delete fileTree(project.file('lib/logstash-core-event-java/')) {
-        include '*.jar'
-    }
-}
-
-clean.dependsOn(cleanGemjar)
-jar.finalizedBy(copyGemjar)
-
-task gemspec_jars << {
-    File gemspec_jars = file("./gemspec_jars.rb")
-    gemspec_jars.newWriter().withWriter { w ->
-        w << "# This file is generated by Gradle as part of the build process. It extracts the build.gradle\n"
-        w << "# runtime dependencies to generate this gemspec dependencies file to be eval'ed by the gemspec\n"
-        w << "# for the jar-dependencies requirements.\n\n"
-        configurations.runtime.allDependencies.each { dependency ->
-            w << "gem.requirements << \"jar ${dependency.group}:${dependency.name}, ${dependency.version}\"\n"
-        }
-    }
-}
-build.finalizedBy(gemspec_jars)
-
-configurations.create('sources')
-configurations.create('javadoc')
-configurations.archives {
-    extendsFrom configurations.sources
-    extendsFrom configurations.javadoc
-}
-
-artifacts {
-    sources(sourcesJar) {
-        // Weird Gradle quirk where type will be used for the extension, but only for sources
-        type 'jar'
-    }
-
-    javadoc(javadocJar) {
-        type 'javadoc'
-    }
-}
-
-configurations {
-    provided
-}
-
-project.sourceSets {
-    main.compileClasspath += project.configurations.provided
-    main.runtimeClasspath += project.configurations.provided
-    test.compileClasspath += project.configurations.provided
-    test.runtimeClasspath += project.configurations.provided
-}
-project.javadoc.classpath += project.configurations.provided
-
-idea {
-    module {
-        scopes.PROVIDED.plus += [project.configurations.provided]
-    }
-}
-
-dependencies {
-    compile 'com.fasterxml.jackson.core:jackson-core:2.7.3'
-    compile 'com.fasterxml.jackson.core:jackson-databind:2.7.3'
-    compile 'com.fasterxml.jackson.module:jackson-module-afterburner:2.7.3'
-    compile 'com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:2.7.3'
-    compile 'org.apache.logging.log4j:log4j-api:2.6.2'
-    testCompile 'junit:junit:4.12'
-    testCompile 'net.javacrumbs.json-unit:json-unit:1.9.0'
-    provided 'org.jruby:jruby-core:1.7.25'
-    provided files('../logstash-core/lib/logstash-core/logstash-core.jar')
-}
-
-// See http://www.gradle.org/docs/current/userguide/gradle_wrapper.html
-task wrapper(type: Wrapper) {
-    description = 'Install Gradle wrapper'
-    gradleVersion = '2.8'
-}
-
diff --git a/logstash-core-event-java/gemspec_jars.rb b/logstash-core-event-java/gemspec_jars.rb
deleted file mode 100644
index 9c3acd02195..00000000000
--- a/logstash-core-event-java/gemspec_jars.rb
+++ /dev/null
@@ -1,9 +0,0 @@
-# This file is generated by Gradle as part of the build process. It extracts the build.gradle
-# runtime dependencies to generate this gemspec dependencies file to be eval'ed by the gemspec
-# for the jar-dependencies requirements.
-
-gem.requirements << "jar com.fasterxml.jackson.core:jackson-core, 2.7.3"
-gem.requirements << "jar com.fasterxml.jackson.core:jackson-databind, 2.7.3"
-gem.requirements << "jar com.fasterxml.jackson.module:jackson-module-afterburner, 2.7.3"
-gem.requirements << "jar com.fasterxml.jackson.dataformat:jackson-dataformat-cbor, 2.7.3"
-gem.requirements << "jar org.apache.logging.log4j:log4j-api, 2.6.2"
diff --git a/logstash-core-event-java/gradle.properties b/logstash-core-event-java/gradle.properties
deleted file mode 100644
index b5cdaba6a69..00000000000
--- a/logstash-core-event-java/gradle.properties
+++ /dev/null
@@ -1 +0,0 @@
-VERSION=0.0.1-SNAPSHOT
diff --git a/logstash-core-event-java/lib/logstash-core-event-java.rb b/logstash-core-event-java/lib/logstash-core-event-java.rb
deleted file mode 100644
index 29b487aa192..00000000000
--- a/logstash-core-event-java/lib/logstash-core-event-java.rb
+++ /dev/null
@@ -1 +0,0 @@
-require "logstash-core-event-java/logstash-core-event-java"
\ No newline at end of file
diff --git a/logstash-core-event-java/lib/logstash-core-event-java/logstash-core-event-java.rb b/logstash-core-event-java/lib/logstash-core-event-java/logstash-core-event-java.rb
deleted file mode 100644
index caf90a828ac..00000000000
--- a/logstash-core-event-java/lib/logstash-core-event-java/logstash-core-event-java.rb
+++ /dev/null
@@ -1,28 +0,0 @@
-# encoding: utf-8
-
-require "java"
-
-module LogStash
-end
-
-require "logstash-core-event-java_jars"
-
-# local dev setup
-classes_dir = File.expand_path("../../../build/classes/main", __FILE__)
-
-if File.directory?(classes_dir)
-  # if in local dev setup, add target to classpath
-  $CLASSPATH << classes_dir unless $CLASSPATH.include?(classes_dir)
-else
-  # otherwise use included jar
-  begin
-    require "logstash-core-event-java/logstash-core-event-java.jar"
-  rescue Exception => e
-    raise("Error loading logstash-core-event-java/logstash-core-event-java.jar file, cause: #{e.message}")
-  end
-end
-
-require "jruby_event_ext"
-require "jruby_timestamp_ext"
-require "logstash/event"
-require "logstash/timestamp"
diff --git a/logstash-core-event-java/lib/logstash-core-event-java/version.rb b/logstash-core-event-java/lib/logstash-core-event-java/version.rb
deleted file mode 100644
index f3030c840dd..00000000000
--- a/logstash-core-event-java/lib/logstash-core-event-java/version.rb
+++ /dev/null
@@ -1,8 +0,0 @@
-# encoding: utf-8
-
-# The version of logstash core event java gem.
-#
-# Note to authors: this should not include dashes because 'gem' barfs if
-# you include a dash in the version string.
-
-LOGSTASH_CORE_EVENT_JAVA_VERSION = "6.0.0-alpha1"
diff --git a/logstash-core-event-java/lib/logstash-core-event-java_jars.rb b/logstash-core-event-java/lib/logstash-core-event-java_jars.rb
deleted file mode 100644
index 068f1826201..00000000000
--- a/logstash-core-event-java/lib/logstash-core-event-java_jars.rb
+++ /dev/null
@@ -1,20 +0,0 @@
-# this is a generated file, to avoid over-writing it just delete this comment
-begin
-  require 'jar_dependencies'
-rescue LoadError
-  require 'com/fasterxml/jackson/core/jackson-databind/2.7.3/jackson-databind-2.7.3.jar'
-  require 'org/apache/logging/log4j/log4j-api/2.6.2/log4j-api-2.6.2.jar'
-  require 'com/fasterxml/jackson/core/jackson-annotations/2.7.0/jackson-annotations-2.7.0.jar'
-  require 'com/fasterxml/jackson/module/jackson-module-afterburner/2.7.3/jackson-module-afterburner-2.7.3.jar'
-  require 'com/fasterxml/jackson/dataformat/jackson-dataformat-cbor/2.7.3/jackson-dataformat-cbor-2.7.3.jar'
-  require 'com/fasterxml/jackson/core/jackson-core/2.7.3/jackson-core-2.7.3.jar'
-end
-
-if defined? Jars
-  require_jar( 'com.fasterxml.jackson.core', 'jackson-databind', '2.7.3' )
-  require_jar( 'org.apache.logging.log4j', 'log4j-api', '2.6.2' )
-  require_jar( 'com.fasterxml.jackson.core', 'jackson-annotations', '2.7.0' )
-  require_jar( 'com.fasterxml.jackson.module', 'jackson-module-afterburner', '2.7.3' )
-  require_jar( 'com.fasterxml.jackson.dataformat', 'jackson-dataformat-cbor', '2.7.3' )
-  require_jar( 'com.fasterxml.jackson.core', 'jackson-core', '2.7.3' )
-end
diff --git a/logstash-core-event-java/lib/logstash-core-event.rb b/logstash-core-event-java/lib/logstash-core-event.rb
deleted file mode 100644
index 29b487aa192..00000000000
--- a/logstash-core-event-java/lib/logstash-core-event.rb
+++ /dev/null
@@ -1 +0,0 @@
-require "logstash-core-event-java/logstash-core-event-java"
\ No newline at end of file
diff --git a/logstash-core-event-java/logstash-core-event-java.gemspec b/logstash-core-event-java/logstash-core-event-java.gemspec
deleted file mode 100644
index 89d0bf10577..00000000000
--- a/logstash-core-event-java/logstash-core-event-java.gemspec
+++ /dev/null
@@ -1,30 +0,0 @@
-# -*- encoding: utf-8 -*-
-lib = File.expand_path('../lib', __FILE__)
-$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
-require 'logstash-core-event-java/version'
-
-Gem::Specification.new do |gem|
-  gem.authors       = ["Elastic"]
-  gem.email         = ["info@elastic.co"]
-  gem.description   = %q{The core event component of logstash, the scalable log and event management tool}
-  gem.summary       = %q{logstash-core-event-java - The core event component of logstash}
-  gem.homepage      = "http://www.elastic.co/guide/en/logstash/current/index.html"
-  gem.license       = "Apache License (2.0)"
-
-  gem.files         = Dir.glob(["logstash-core-event-java.gemspec", "gemspec_jars.rb", "lib/**/*.jar", "lib/**/*.rb", "spec/**/*.rb"])
-  gem.test_files    = gem.files.grep(%r{^(test|spec|features)/})
-  gem.name          = "logstash-core-event-java"
-  gem.require_paths = ["lib"]
-  gem.version       = LOGSTASH_CORE_EVENT_JAVA_VERSION
-
-  gem.platform = "java"
-
-  gem.add_runtime_dependency "jar-dependencies"
-
-  # as of Feb 3rd 2016, the ruby-maven gem is resolved to version 3.3.3 and that version
-  # has an rdoc problem that causes a bundler exception. 3.3.9 is the current latest version
-  # which does not have this problem.
-  gem.add_runtime_dependency "ruby-maven", "~> 3.3.9"
-
-  eval(File.read(File.expand_path("../gemspec_jars.rb", __FILE__)))
-end
diff --git a/logstash-core-event-java/settings.gradle b/logstash-core-event-java/settings.gradle
deleted file mode 100644
index 3885bfa1686..00000000000
--- a/logstash-core-event-java/settings.gradle
+++ /dev/null
@@ -1,2 +0,0 @@
-rootProject.name = 'logstash-core-event-java'
-
diff --git a/logstash-core-event/lib/logstash-core-event.rb b/logstash-core-event/lib/logstash-core-event.rb
deleted file mode 100644
index b2979326dac..00000000000
--- a/logstash-core-event/lib/logstash-core-event.rb
+++ /dev/null
@@ -1 +0,0 @@
-require "logstash-core-event/logstash-core-event"
\ No newline at end of file
diff --git a/logstash-core-event/lib/logstash-core-event/logstash-core-event.rb b/logstash-core-event/lib/logstash-core-event/logstash-core-event.rb
deleted file mode 100644
index b0f773e203c..00000000000
--- a/logstash-core-event/lib/logstash-core-event/logstash-core-event.rb
+++ /dev/null
@@ -1,5 +0,0 @@
-# encoding: utf-8
-module LogStash
-end
-
-require "logstash/event"
\ No newline at end of file
diff --git a/logstash-core-event/lib/logstash-core-event/version.rb b/logstash-core-event/lib/logstash-core-event/version.rb
deleted file mode 100644
index 74914785722..00000000000
--- a/logstash-core-event/lib/logstash-core-event/version.rb
+++ /dev/null
@@ -1,8 +0,0 @@
-# encoding: utf-8
-
-# The version of logstash core event gem.
-#
-# Note to authors: this should not include dashes because 'gem' barfs if
-# you include a dash in the version string.
-
-LOGSTASH_CORE_EVENT_VERSION = "6.0.0-alpha1"
diff --git a/logstash-core-event/lib/logstash/event.rb b/logstash-core-event/lib/logstash/event.rb
deleted file mode 100644
index de0cf5fc00d..00000000000
--- a/logstash-core-event/lib/logstash/event.rb
+++ /dev/null
@@ -1,292 +0,0 @@
-# encoding: utf-8
-require "time"
-require "date"
-require "cabin"
-require "logstash/namespace"
-require "logstash/util/accessors"
-require "logstash/timestamp"
-require "logstash/json"
-require "logstash/string_interpolation"
-
-# transcient pipeline events for normal in-flow signaling as opposed to
-# flow altering exceptions. for now having base classes is adequate and
-# in the future it might be necessary to refactor using like a BaseEvent
-# class to have a common interface for all pileline events to support
-# eventual queueing persistence for example, TBD.
-
-module LogStash
-  class SignalEvent
-    def flush?; raise "abstract method"; end;
-    def shutdown?; raise "abstract method"; end;
-  end
-
-  class ShutdownEvent < SignalEvent
-    def flush?; false; end;
-    def shutdown?; true; end;
-  end
-
-  class FlushEvent < SignalEvent
-    def flush?; true; end;
-    def shutdown?; false; end;
-  end
-
-  FLUSH = FlushEvent.new
-
-  # LogStash::SHUTDOWN is used by plugins
-  SHUTDOWN = ShutdownEvent.new
-end
-
-# the logstash event object.
-#
-# An event is simply a tuple of (timestamp, data).
-# The 'timestamp' is an ISO8601 timestamp. Data is anything - any message,
-# context, references, etc that are relevant to this event.
-#
-# Internally, this is represented as a hash with only two guaranteed fields.
-#
-# * "@timestamp" - an ISO8601 timestamp representing the time the event
-#   occurred at.
-# * "@version" - the version of the schema. Currently "1"
-#
-# They are prefixed with an "@" symbol to avoid clashing with your
-# own custom fields.
-#
-# When serialized, this is represented in JSON. For example:
-#
-#     {
-#       "@timestamp": "2013-02-09T20:39:26.234Z",
-#       "@version": "1",
-#       message: "hello world"
-#     }
-class LogStash::Event
-  class DeprecatedMethod < StandardError; end
-
-  CHAR_PLUS = "+"
-  TIMESTAMP = "@timestamp"
-  VERSION = "@version"
-  VERSION_ONE = "1"
-  TIMESTAMP_FAILURE_TAG = "_timestampparsefailure"
-  TIMESTAMP_FAILURE_FIELD = "_@timestamp"
-  TAGS = "tags".freeze
-
-  METADATA = "@metadata".freeze
-  METADATA_BRACKETS = "[#{METADATA}]".freeze
-
-  # Floats outside of these upper and lower bounds are forcibly converted
-  # to scientific notation by Float#to_s
-  MIN_FLOAT_BEFORE_SCI_NOT = 0.0001
-  MAX_FLOAT_BEFORE_SCI_NOT = 1000000000000000.0
-
-  DEFAULT_LOGGER = Cabin::Channel.get(LogStash)
-  @@logger = DEFAULT_LOGGER
-
-  def initialize(data = {})
-    @cancelled = false
-    @data = data
-    @accessors = LogStash::Util::Accessors.new(data)
-    @data[VERSION] ||= VERSION_ONE
-    ts = @data[TIMESTAMP]
-    @data[TIMESTAMP] = ts ? init_timestamp(ts) : LogStash::Timestamp.now
-
-    @metadata = @data.delete(METADATA) || {}
-    @metadata_accessors = LogStash::Util::Accessors.new(@metadata)
-  end
-
-  def cancel
-    @cancelled = true
-  end
-
-  def uncancel
-    @cancelled = false
-  end
-
-  def cancelled?
-    @cancelled
-  end
-
-  # Create a deep-ish copy of this event.
-  def clone
-    copy = {}
-    @data.each do |k,v|
-      # TODO(sissel): Recurse if this is a hash/array?
-      copy[k] = begin v.clone rescue v end
-    end
-
-    self.class.new(copy)
-  end
-
-  def to_s
-    "#{timestamp.to_iso8601} #{self.sprintf("%{host} %{message}")}"
-  end
-
-  def timestamp
-    @data[TIMESTAMP]
-  end
-
-  def timestamp=(val)
-    @data[TIMESTAMP] = val
-  end
-
-  def get(fieldref)
-    if fieldref.start_with?(METADATA_BRACKETS)
-      @metadata_accessors.get(fieldref[METADATA_BRACKETS.length .. -1])
-    elsif fieldref == METADATA
-      @metadata
-    else
-      @accessors.get(fieldref)
-    end
-  end
-
-  def set(fieldref, value)
-    if fieldref == TIMESTAMP && !value.is_a?(LogStash::Timestamp)
-      raise TypeError, "The field '@timestamp' must be a (LogStash::Timestamp, not a #{value.class} (#{value})"
-    end
-    if fieldref.start_with?(METADATA_BRACKETS)
-      @metadata_accessors.set(fieldref[METADATA_BRACKETS.length .. -1], value)
-    elsif fieldref == METADATA
-      @metadata = value
-      @metadata_accessors = LogStash::Util::Accessors.new(@metadata)
-    else
-      @accessors.set(fieldref, value)
-    end
-  end
-
-  def to_json(*args)
-    # ignore arguments to respect accepted to_json method signature
-    LogStash::Json.dump(@data)
-  end
-
-  def to_hash
-    @data
-  end
-
-  def overwrite(event)
-    # pickup new event @data and also pickup @accessors
-    # otherwise it will be pointing on previous data
-    @data = event.instance_variable_get(:@data)
-    @accessors = event.instance_variable_get(:@accessors)
-
-    #convert timestamp if it is a String
-    if @data[TIMESTAMP].is_a?(String)
-      @data[TIMESTAMP] = LogStash::Timestamp.parse_iso8601(@data[TIMESTAMP])
-    end
-  end
-
-  def include?(fieldref)
-    if fieldref.start_with?(METADATA_BRACKETS)
-      @metadata_accessors.include?(fieldref[METADATA_BRACKETS.length .. -1])
-    elsif fieldref == METADATA
-      true
-    else
-      @accessors.include?(fieldref)
-    end
-  end
-
-  # Append an event to this one.
-  def append(event)
-    # non-destructively merge that event with ourselves.
-
-    # no need to reset @accessors here because merging will not disrupt any existing field paths
-    # and if new ones are created they will be picked up.
-    LogStash::Util.hash_merge(@data, event.to_hash)
-  end
-
-  # Remove a field or field reference. Returns the value of that field when deleted
-  def remove(fieldref)
-    @accessors.del(fieldref)
-  end
-
-  # sprintf. This could use a better method name.
-  # The idea is to take an event and convert it to a string based on
-  # any format values, delimited by %{foo} where 'foo' is a field or
-  # metadata member.
-  #
-  # For example, if the event has type == "foo" and host == "bar"
-  # then this string:
-  #   "type is %{type} and source is %{host}"
-  # will return
-  #   "type is foo and source is bar"
-  #
-  # If a %{name} value is an array, then we will join by ','
-  # If a %{name} value does not exist, then no substitution occurs.
-  def sprintf(format)
-    LogStash::StringInterpolation.evaluate(self, format)
-  end
-
-  def tag(value)
-    # Generalize this method for more usability
-    tags = @accessors.get(TAGS) || []
-    tags << value unless tags.include?(value)
-    @accessors.set(TAGS, tags)
-  end
-
-  def to_hash_with_metadata
-    @metadata.empty? ? to_hash : to_hash.merge(METADATA => @metadata)
-  end
-
-  def to_json_with_metadata(*args)
-    # ignore arguments to respect accepted to_json method signature
-    LogStash::Json.dump(to_hash_with_metadata)
-  end
-
-  # this is used by logstash-devutils spec_helper.rb to monkey patch the Event field setter []=
-  # and add systematic encoding validation on every field set in specs.
-  # TODO: (colin) this should be moved, probably in logstash-devutils ?
-  def self.validate_value(value)
-    case value
-    when String
-      raise("expected UTF-8 encoding for value=#{value}, encoding=#{value.encoding.inspect}") unless value.encoding == Encoding::UTF_8
-      raise("invalid UTF-8 encoding for value=#{value}, encoding=#{value.encoding.inspect}") unless value.valid_encoding?
-      value
-    when Array
-      value.each{|v| validate_value(v)} # don't map, return original object
-      value
-    else
-      value
-    end
-  end
-
-  # depracated public methods
-  # TODO: (colin) since these depracated mothods are still exposed in 2.x we should remove them in 3.0
-
-  def unix_timestamp
-    raise DeprecatedMethod
-  end
-
-  def ruby_timestamp
-    raise DeprecatedMethod
-  end
-
-  def fields
-    raise DeprecatedMethod
-  end
-
-  # set a new logger for all Event instances
-  # there is no point in changing it at runtime for other reasons than in tests/specs.
-  # @param logger [Cabin::Channel] logger instance that will be used by all Event instances
-  def self.logger=(logger)
-    @@logger = logger
-  end
-
-  private
-
-  def logger
-    @@logger
-  end
-
-  def init_timestamp(o)
-    begin
-      timestamp = LogStash::Timestamp.coerce(o)
-      return timestamp if timestamp
-
-      logger.warn("Unrecognized #{TIMESTAMP} value, setting current time to #{TIMESTAMP}, original in #{TIMESTAMP_FAILURE_FIELD}field", :value => o.inspect)
-    rescue LogStash::TimestampParserError => e
-      logger.warn("Error parsing #{TIMESTAMP} string, setting current time to #{TIMESTAMP}, original in #{TIMESTAMP_FAILURE_FIELD} field", :value => o.inspect, :exception => e.message)
-    end
-
-    tag(TIMESTAMP_FAILURE_TAG)
-    @accessors.set(TIMESTAMP_FAILURE_FIELD, o)
-
-    LogStash::Timestamp.now
-  end
-end
diff --git a/logstash-core-event/lib/logstash/string_interpolation.rb b/logstash-core-event/lib/logstash/string_interpolation.rb
deleted file mode 100644
index aaa54981165..00000000000
--- a/logstash-core-event/lib/logstash/string_interpolation.rb
+++ /dev/null
@@ -1,152 +0,0 @@
-# encoding: utf-8
-require "thread_safe"
-require "forwardable"
-
-module LogStash
-  module StringInterpolation
-    extend self
-
-    # Floats outside of these upper and lower bounds are forcibly converted
-    # to scientific notation by Float#to_s
-    MIN_FLOAT_BEFORE_SCI_NOT = 0.0001
-    MAX_FLOAT_BEFORE_SCI_NOT = 1000000000000000.0
-
-    CACHE = ThreadSafe::Cache.new
-    TEMPLATE_TAG_REGEXP = /%\{[^}]+\}/
-
-    def evaluate(event, template)
-      if template.is_a?(Float) && (template < MIN_FLOAT_BEFORE_SCI_NOT || template >= MAX_FLOAT_BEFORE_SCI_NOT)
-        return ("%.15f" % template).sub(/0*$/,"")
-      end
-
-      template = template.to_s
-
-      return template if not_cachable?(template)
-
-      compiled = CACHE.get_or_default(template, nil) || CACHE.put(template, compile_template(template))
-      compiled.evaluate(event)
-    end
-
-    # clear the global compiled templates cache
-    def clear_cache
-      CACHE.clear
-    end
-
-    # @return [Fixnum] the compiled templates cache size
-    def cache_size
-      CACHE.size
-    end
-
-    private
-    def not_cachable?(template)
-      template.index("%").nil?
-    end
-
-    def compile_template(template)
-      nodes = Template.new
-
-      position = 0
-      matches = template.to_enum(:scan, TEMPLATE_TAG_REGEXP).map { |m| $~ }
-
-      matches.each do |match|
-        tag = match[0][2..-2]
-        start = match.offset(0).first
-        nodes << StaticNode.new(template[position..(start-1)]) if start > 0
-        nodes << identify(tag)
-        position = match.offset(0).last
-      end
-
-      if position < template.size
-        nodes << StaticNode.new(template[position..-1])
-      end
-
-      optimize(nodes)
-    end
-
-    def optimize(nodes)
-      nodes.size == 1 ?  nodes.first : nodes
-    end
-
-    def identify(tag)
-      if tag == "+%s"
-        EpocNode.new
-      elsif tag[0, 1] == "+"
-        DateNode.new(tag[1..-1])
-      else
-        KeyNode.new(tag)
-      end
-    end
-  end
-
-  class Template
-    extend Forwardable
-    def_delegators :@nodes, :<<, :push, :size, :first
-
-    def initialize
-      @nodes = []
-    end
-
-    def evaluate(event)
-      @nodes.collect { |node| node.evaluate(event) }.join
-    end
-  end
-
-  class EpocNode
-    def evaluate(event)
-      t = event.timestamp
-      raise LogStash::Error, "Unable to format in string \"#{@format}\", #{LogStash::Event::TIMESTAMP} field not found" unless t
-      t.to_i.to_s
-    end
-  end
-
-  class StaticNode
-    def initialize(content)
-      @content = content
-    end
-
-    def evaluate(event)
-      @content
-    end
-  end
-
-  class KeyNode
-    def initialize(key)
-      @key = key
-    end
-
-    def evaluate(event)
-      value = event.get(@key)
-
-      case value
-      when nil
-        "%{#{@key}}"
-      when Array
-        value.join(",")
-      when Hash
-        LogStash::Json.dump(value)
-      else
-        # Make sure we dont work on the refence of the value
-        # The Java Event implementation was always returning a string.
-        "#{value}"
-      end
-    end
-  end
-
-  class DateNode
-    def initialize(format)
-      @format = format
-      @formatter = org.joda.time.format.DateTimeFormat.forPattern(@format)
-          .withZone(org.joda.time.DateTimeZone::UTC)
-    end
-
-    def evaluate(event)
-      t = event.timestamp
-
-      raise LogStash::Error, "Unable to format in string \"#{@format}\", #{LogStash::Event::TIMESTAMP} field not found" unless t
-
-      org.joda.time.Instant.java_class.constructor(Java::long).new_instance(
-        t.tv_sec * 1000 + t.tv_usec / 1000
-      ).to_java.toDateTime.toString(@formatter)
-    end
-  end
-end
diff --git a/logstash-core-event/lib/logstash/timestamp.rb b/logstash-core-event/lib/logstash/timestamp.rb
deleted file mode 100644
index ab6b6edb3bc..00000000000
--- a/logstash-core-event/lib/logstash/timestamp.rb
+++ /dev/null
@@ -1,103 +0,0 @@
-# encoding: utf-8
-require "logstash/environment"
-require "logstash/json"
-require "forwardable"
-require "date"
-require "time"
-
-module LogStash
-  class TimestampParserError < StandardError; end
-
-  class Timestamp
-    extend Forwardable
-    include Comparable
-
-    def_delegators :@time, :tv_usec, :usec, :year, :iso8601, :to_i, :tv_sec, :to_f, :to_edn, :<=>, :+
-
-    attr_reader :time
-
-    ISO8601_STRFTIME = "%04d-%02d-%02dT%02d:%02d:%02d.%06d%+03d:00".freeze
-    ISO8601_PRECISION = 3
-
-    def initialize(time = Time.new)
-      @time = time.utc
-    end
-
-    def self.at(*args)
-      epoch = args.first
-      if epoch.is_a?(BigDecimal)
-        # bug in JRuby prevents correcly parsing a BigDecimal fractional part, see https://github.com/elastic/logstash/issues/4565
-        Timestamp.new(::Time.at(epoch.to_i, epoch.frac.to_f * 1000000))
-      else
-        Timestamp.new(::Time.at(*args))
-      end
-    end
-
-    def self.parse(*args)
-      Timestamp.new(::Time.parse(*args))
-    end
-
-    def self.now
-      Timestamp.new(::Time.now)
-    end
-
-    # coerce tries different strategies based on the time object class to convert into a Timestamp.
-    # @param [String, Time, Timestamp] time the time object to try coerce
-    # @return [Timestamp, nil] Timestamp will be returned if successful otherwise nil
-    # @raise [TimestampParserError] on String with invalid format
-    def self.coerce(time)
-      case time
-      when String
-        LogStash::Timestamp.parse_iso8601(time)
-      when LogStash::Timestamp
-        time
-      when Time
-        LogStash::Timestamp.new(time)
-      else
-        nil
-      end
-    end
-
-    if LogStash::Environment.jruby?
-      JODA_ISO8601_PARSER = org.joda.time.format.ISODateTimeFormat.dateTimeParser
-      UTC = org.joda.time.DateTimeZone.forID("UTC")
-
-      def self.parse_iso8601(t)
-        millis = JODA_ISO8601_PARSER.parseMillis(t)
-        LogStash::Timestamp.at(millis / 1000, (millis % 1000) * 1000)
-      rescue => e
-        raise(TimestampParserError, "invalid timestamp string #{t.inspect}, error=#{e.inspect}")
-      end
-
-    else
-
-      def self.parse_iso8601(t)
-        # warning, ruby's Time.parse is *really* terrible and slow.
-        LogStash::Timestamp.new(::Time.parse(t))
-      rescue => e
-        raise(TimestampParserError, "invalid timestamp string #{t.inspect}, error=#{e.inspect}")
-      end
-    end
-
-    def utc
-      @time.utc # modifies the receiver
-      self
-    end
-    alias_method :gmtime, :utc
-
-    def to_json(*args)
-      # ignore arguments to respect accepted to_json method signature
-      "\"" + to_iso8601 + "\""
-    end
-    alias_method :inspect, :to_json
-
-    def to_iso8601
-      @iso8601 ||= @time.iso8601(ISO8601_PRECISION)
-    end
-    alias_method :to_s, :to_iso8601
-
-    def -(value)
-      @time - (value.is_a?(Timestamp) ? value.time : value)
-    end
-  end
-end
diff --git a/logstash-core-event/lib/logstash/util/accessors.rb b/logstash-core-event/lib/logstash/util/accessors.rb
deleted file mode 100644
index 23248f2c3ea..00000000000
--- a/logstash-core-event/lib/logstash/util/accessors.rb
+++ /dev/null
@@ -1,130 +0,0 @@
-# encoding: utf-8
-require "logstash/namespace"
-require "logstash/util"
-require "thread_safe"
-
-module LogStash::Util
-
-  # PathCache is a singleton which globally caches the relation between a field reference and its
-  # decomposition into a [key, path array] tuple. For example the field reference [foo][bar][baz]
-  # is decomposed into ["baz", ["foo", "bar"]].
-  module PathCache
-    extend self
-
-    # requiring libraries and defining constants is thread safe in JRuby so
-    # PathCache::CACHE will be corretly initialized, once, when accessors.rb
-    # will be first required
-    CACHE = ThreadSafe::Cache.new
-
-    def get(field_reference)
-      # the "get_or_default(x, nil) || put(x, parse(x))" is ~2x faster than "get || put" because the get call is
-      # proxied through the JRuby JavaProxy op_aref method. the correct idiom here would be to use
-      # "compute_if_absent(x){parse(x)}" but because of the closure creation, it is ~1.5x slower than
-      # "get_or_default || put".
-      # this "get_or_default || put" is obviously non-atomic which is not really important here
-      # since all threads will set the same value and this cache will stabilize very quickly after the first
-      # few events.
-      CACHE.get_or_default(field_reference, nil) || CACHE.put(field_reference, parse(field_reference))
-    end
-
-    def parse(field_reference)
-      path = field_reference.split(/[\[\]]/).select{|s| !s.empty?}
-      [path.pop, path]
-    end
-  end
-
-  # Accessors uses a lookup table to speedup access of a field reference of the form
-  # "[hello][world]" to the underlying store hash into {"hello" => {"world" => "foo"}}
-  class Accessors
-
-    # @param store [Hash] the backing data store field refereces point to
-    def initialize(store)
-      @store = store
-
-      # @lut is a lookup table between a field reference and a [target, key] tuple
-      # where target is the containing Hash or Array for key in @store.
-      # this allows us to directly access the containing object for key instead of
-      # walking the field reference path into the inner @store objects
-      @lut = {}
-    end
-
-    # @param field_reference [String] the field reference
-    # @return [Object] the value in @store for this field reference
-    def get(field_reference)
-      target, key = lookup(field_reference)
-      return nil unless target
-      target.is_a?(Array) ? target[key.to_i] : target[key]
-    end
-
-    # @param field_reference [String] the field reference
-    # @param value [Object] the value to set in @store for this field reference
-    # @return [Object] the value set
-    def set(field_reference, value)
-      target, key = lookup_or_create(field_reference)
-      target[target.is_a?(Array) ? key.to_i : key] = value
-    end
-
-    # @param field_reference [String] the field reference to remove
-    # @return [Object] the removed value in @store for this field reference
-    def del(field_reference)
-      target, key = lookup(field_reference)
-      return nil unless target
-      target.is_a?(Array) ? target.delete_at(key.to_i) : target.delete(key)
-    end
-
-    # @param field_reference [String] the field reference to test for inclusion in the store
-    # @return [Boolean] true if the store contains a value for this field reference
-    def include?(field_reference)
-      target, key = lookup(field_reference)
-      return false unless target
-
-      target.is_a?(Array) ? !target[key.to_i].nil? : target.include?(key)
-    end
-
-    private
-
-    # retrieve the [target, key] tuple associated with this field reference
-    # @param field_reference [String] the field referece
-    # @return [[Object, String]] the  [target, key] tuple associated with this field reference
-    def lookup(field_reference)
-      @lut[field_reference] ||= find_target(field_reference)
-    end
-
-    # retrieve the [target, key] tuple associated with this field reference and create inner
-    # container objects if they do not exists
-    # @param field_reference [String] the field referece
-    # @return [[Object, String]] the  [target, key] tuple associated with this field reference
-    def lookup_or_create(field_reference)
-      # flush the @lut to prevent stale cached fieldref which may point to an old target
-      # which was overwritten with a new value. for example, if "[a][b]" is cached and we
-      # set a new value for "[a]" then reading again "[a][b]" would point in a stale target.
-      # flushing the complete @lut is suboptimal, but a hierarchical lut would be required
-      # to be able to invalidate fieldrefs from a common root.
-      # see https://github.com/elastic/logstash/pull/5132
-      @lut.clear
-      @lut[field_reference] = find_or_create_target(field_reference)
-    end
-
-    # find the target container object in store for this field reference
-    # @param field_reference [String] the field referece
-    # @return [Object] the target container object in store associated with this field reference
-    def find_target(field_reference)
-      key, path = PathCache.get(field_reference)
-      target = path.inject(@store) do |r, k|
-        return nil unless r
-        r[r.is_a?(Array) ? k.to_i : k]
-      end
-      target ? [target, key] : nil
-    end
-
-    # find the target container object in store for this field reference and create inner
-    # container objects if they do not exists
-    # @param field_reference [String] the field referece
-    # @return [Object] the target container object in store associated with this field reference
-    def find_or_create_target(accessor)
-      key, path = PathCache.get(accessor)
-      target = path.inject(@store) {|r, k| r[r.is_a?(Array) ? k.to_i : k] ||= {}}
-      [target, key]
-    end
-  end # class Accessors
-end # module LogStash::Util
diff --git a/logstash-core-event/logstash-core-event.gemspec b/logstash-core-event/logstash-core-event.gemspec
deleted file mode 100644
index 9e0a757a870..00000000000
--- a/logstash-core-event/logstash-core-event.gemspec
+++ /dev/null
@@ -1,23 +0,0 @@
-# -*- encoding: utf-8 -*-
-lib = File.expand_path('../lib', __FILE__)
-$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
-require 'logstash-core-event/version'
-
-Gem::Specification.new do |gem|
-  gem.authors       = ["Elastic"]
-  gem.email         = ["info@elastic.co"]
-  gem.description   = %q{The core event component of logstash, the scalable log and event management tool}
-  gem.summary       = %q{logstash-core-event - The core event component of logstash}
-  gem.homepage      = "http://www.elastic.co/guide/en/logstash/current/index.html"
-  gem.license       = "Apache License (2.0)"
-
-  gem.files         = Dir.glob(["logstash-core-event.gemspec", "lib/**/*.rb", "spec/**/*.rb"])
-  gem.test_files    = gem.files.grep(%r{^(test|spec|features)/})
-  gem.name          = "logstash-core-event"
-  gem.require_paths = ["lib"]
-  gem.version       = LOGSTASH_CORE_EVENT_VERSION
-
-  if RUBY_PLATFORM == 'java'
-    gem.platform = RUBY_PLATFORM
-  end
-end
diff --git a/logstash-core-event/spec/logstash/event_spec.rb b/logstash-core-event/spec/logstash/event_spec.rb
deleted file mode 100644
index 3cdd33d12d8..00000000000
--- a/logstash-core-event/spec/logstash/event_spec.rb
+++ /dev/null
@@ -1,636 +0,0 @@
-# encoding: utf-8
-require "spec_helper"
-require "logstash/util/decorators"
-require "json"
-
-describe LogStash::Event do
-
-  shared_examples "all event tests" do
-    context "[]=" do
-      it "should raise an exception if you attempt to set @timestamp to a value type other than a Time object" do
-        expect{subject.set("@timestamp", "crash!")}.to raise_error(TypeError)
-      end
-
-      it "should assign simple fields" do
-        expect(subject.get("foo")).to be_nil
-        expect(subject.set("foo", "bar")).to eq("bar")
-        expect(subject.get("foo")).to eq("bar")
-      end
-
-      it "should overwrite simple fields" do
-        expect(subject.get("foo")).to be_nil
-        expect(subject.set("foo", "bar")).to eq("bar")
-        expect(subject.get("foo")).to eq("bar")
-
-        expect(subject.set("foo", "baz")).to eq("baz")
-        expect(subject.get("foo")).to eq("baz")
-      end
-
-      it "should assign deep fields" do
-        expect(subject.get("[foo][bar]")).to be_nil
-        expect(subject.set("[foo][bar]", "baz")).to eq("baz")
-        expect(subject.get("[foo][bar]")).to eq("baz")
-      end
-
-      it "should overwrite deep fields" do
-        expect(subject.get("[foo][bar]")).to be_nil
-        expect(subject.set("[foo][bar]", "baz")).to eq("baz")
-        expect(subject.get("[foo][bar]")).to eq("baz")
-
-        expect(subject.set("[foo][bar]", "zab")).to eq("zab")
-        expect(subject.get("[foo][bar]")).to eq("zab")
-      end
-
-      it "allow to set the @metadata key to a hash" do
-        subject.set("@metadata", { "action" => "index" })
-        expect(subject.get("[@metadata][action]")).to eq("index")
-      end
-
-      it "should add key when setting nil value" do
-        subject.set("[baz]", nil)
-        expect(subject.to_hash).to include("baz" => nil)
-      end
-
-      it "should set nil element within existing array value" do
-        subject.set("[foo]", ["bar", "baz"])
-
-        expect(subject.set("[foo][0]", nil)).to eq(nil)
-        expect(subject.get("[foo]")).to eq([nil, "baz"])
-      end
-
-      it "should set nil in first element within empty array" do
-        subject.set("[foo]", [])
-
-        expect(subject.set("[foo][0]", nil)).to eq(nil)
-        expect(subject.get("[foo]")).to eq([nil])
-      end
-
-      it "should set nil in second element within empty array" do
-        subject.set("[foo]", [])
-
-        expect(subject.set("[foo][1]", nil)).to eq(nil)
-        expect(subject.get("[foo]")).to eq([nil, nil])
-      end
-    end
-
-    context "#sprintf" do
-      it "should not return a String reference" do
-        data = "NOT-A-REFERENCE"
-        event = LogStash::Event.new({ "reference" => data })
-        LogStash::Util::Decorators.add_fields({"reference_test" => "%{reference}"}, event, "dummy-plugin")
-        data.downcase!
-        expect(event.get("reference_test")).not_to eq(data)
-      end
-
-      it "should not return a Fixnum reference" do
-        data = 1
-        event = LogStash::Event.new({ "reference" => data })
-        LogStash::Util::Decorators.add_fields({"reference_test" => "%{reference}"}, event, "dummy-plugin")
-        data += 41
-        expect(event.get("reference_test")).to eq("1")
-      end
-
-      it "should report a unix timestamp for %{+%s}" do
-        expect(subject.sprintf("%{+%s}")).to eq("1356998400")
-      end
-
-      it "should work if there is no fieldref in the string" do
-        expect(subject.sprintf("bonjour")).to eq("bonjour")
-      end
-
-      it "should raise error when formatting %{+%s} when @timestamp field is missing" do
-        str = "hello-%{+%s}"
-        subj = subject.clone
-        subj.remove("[@timestamp]")
-        expect{ subj.sprintf(str) }.to raise_error(LogStash::Error)
-      end
-
-      it "should report a time with %{+format} syntax", :if => RUBY_ENGINE == "jruby" do
-        expect(subject.sprintf("%{+YYYY}")).to eq("2013")
-        expect(subject.sprintf("%{+MM}")).to eq("01")
-        expect(subject.sprintf("%{+HH}")).to eq("00")
-      end
-
-      it "should support mixed string" do
-        expect(subject.sprintf("foo %{+YYYY-MM-dd} %{type}")).to eq("foo 2013-01-01 sprintf")
-      end
-
-      it "should raise error with %{+format} syntax when @timestamp field is missing", :if => RUBY_ENGINE == "jruby" do
-        str = "logstash-%{+YYYY}"
-        subj = subject.clone
-        subj.remove("[@timestamp]")
-        expect{ subj.sprintf(str) }.to raise_error(LogStash::Error)
-      end
-
-      it "should report fields with %{field} syntax" do
-        expect(subject.sprintf("%{type}")).to eq("sprintf")
-        expect(subject.sprintf("%{message}")).to eq(subject.get("message"))
-      end
-
-      it "should print deep fields" do
-        expect(subject.sprintf("%{[j][k1]}")).to eq("v")
-        expect(subject.sprintf("%{[j][k2][0]}")).to eq("w")
-      end
-
-      it "should be able to take a non-string for the format" do
-        expect(subject.sprintf(2)).to eq("2")
-      end
-
-      it "should allow to use the metadata when calling #sprintf" do
-        expect(subject.sprintf("super-%{[@metadata][fancy]}")).to eq("super-pants")
-      end
-
-      it "should allow to use nested hash from the metadata field" do
-        expect(subject.sprintf("%{[@metadata][have-to-go][deeper]}")).to eq("inception")
-      end
-
-      it "should return a json string if the key is a hash" do
-        expect(subject.sprintf("%{[j][k3]}")).to eq("{\"4\":\"m\"}")
-      end
-
-      it "should not strip last character" do
-        expect(subject.sprintf("%{type}%{message}|")).to eq("sprintfhello world|")
-      end
-
-      it "should render nil array values as leading empty string" do
-        expect(subject.set("foo", [nil, "baz"])).to eq([nil, "baz"])
-
-        expect(subject.get("[foo][0]")).to be_nil
-        expect(subject.get("[foo][1]")).to eq("baz")
-
-        expect(subject.sprintf("%{[foo]}")).to eq(",baz")
-      end
-
-      it "should render nil array values as middle empty string" do
-        expect(subject.set("foo", ["bar", nil, "baz"])).to eq(["bar", nil, "baz"])
-
-        expect(subject.get("[foo][0]")).to eq("bar")
-        expect(subject.get("[foo][1]")).to be_nil
-        expect(subject.get("[foo][2]")).to eq("baz")
-
-        expect(subject.sprintf("%{[foo]}")).to eq("bar,,baz")
-      end
-
-     it "should render nil array values as trailing empty string" do
-        expect(subject.set("foo", ["bar", nil])).to eq(["bar", nil])
-
-        expect(subject.get("[foo][0]")).to eq("bar")
-        expect(subject.get("[foo][1]")).to be_nil
-
-        expect(subject.sprintf("%{[foo]}")).to eq("bar,")
-     end
-
-      it "should render deep arrays with nil value" do
-        subject.set("[foo]", [[12, nil], 56])
-        expect(subject.sprintf("%{[foo]}")).to eq("12,,56")
-      end
-
-      context "#encoding" do
-        it "should return known patterns as UTF-8" do
-          expect(subject.sprintf("%{message}").encoding).to eq(Encoding::UTF_8)
-        end
-
-        it "should return unknown patterns as UTF-8" do
-          expect(subject.sprintf("%{unkown_pattern}").encoding).to eq(Encoding::UTF_8)
-        end
-      end
-    end
-
-    context "#[]" do
-      it "should fetch data" do
-        expect(subject.get("type")).to eq("sprintf")
-      end
-      it "should fetch fields" do
-        expect(subject.get("a")).to eq("b")
-        expect(subject.get('c')['d']).to eq("f")
-      end
-      it "should fetch deep fields" do
-        expect(subject.get("[j][k1]")).to eq("v")
-        expect(subject.get("[c][d]")).to eq("f")
-        expect(subject.get('[f][g][h]')).to eq("i")
-        expect(subject.get('[j][k3][4]')).to eq("m")
-        expect(subject.get('[j][5]')).to eq(7)
-
-      end
-
-      it "should be fast?", :performance => true do
-        count = 1000000
-        2.times do
-          start = Time.now
-          count.times { subject.get("[j][k1]") }
-          duration = Time.now - start
-          puts "event #[] rate: #{"%02.0f/sec" % (count / duration)}, elapsed: #{duration}s"
-        end
-      end
-    end
-
-    context "#include?" do
-      it "should include existing fields" do
-        expect(subject.include?("c")).to eq(true)
-        expect(subject.include?("[c][d]")).to eq(true)
-        expect(subject.include?("[j][k4][0][nested]")).to eq(true)
-      end
-
-      it "should include field with nil value" do
-        expect(subject.include?("nilfield")).to eq(true)
-      end
-
-      it "should include @metadata field" do
-        expect(subject.include?("@metadata")).to eq(true)
-      end
-
-      it "should include field within @metadata" do
-        expect(subject.include?("[@metadata][fancy]")).to eq(true)
-      end
-
-      it "should not include non-existing fields" do
-        expect(subject.include?("doesnotexist")).to eq(false)
-        expect(subject.include?("[j][doesnotexist]")).to eq(false)
-        expect(subject.include?("[tag][0][hello][yes]")).to eq(false)
-      end
-
-      it "should include within arrays" do
-        expect(subject.include?("[tags][0]")).to eq(true)
-        expect(subject.include?("[tags][1]")).to eq(false)
-      end
-    end
-
-    context "#overwrite" do
-      it "should swap data with new content" do
-        new_event = LogStash::Event.new(
-          "type" => "new",
-          "message" => "foo bar",
-        )
-        subject.overwrite(new_event)
-
-        expect(subject.get("message")).to eq("foo bar")
-        expect(subject.get("type")).to eq("new")
-
-        ["tags", "source", "a", "c", "f", "j"].each do |field|
-          expect(subject.get(field)).to be_nil
-        end
-      end
-    end
-
-    context "#append" do
-      it "should append strings to an array" do
-        subject.append(LogStash::Event.new("message" => "another thing"))
-        expect(subject.get("message")).to eq([ "hello world", "another thing" ])
-      end
-
-      it "should concatenate tags" do
-        subject.append(LogStash::Event.new("tags" => [ "tag2" ]))
-        # added to_a for when array is a Java Collection when produced from json input
-        # TODO: we have to find a better way to handle this in tests. maybe override
-        # rspec eq or == to do an explicit to_a when comparing arrays?
-        expect(subject.get("tags").to_a).to eq([ "tag1", "tag2" ])
-      end
-
-      context "when event field is nil" do
-        it "should add single value as string" do
-          subject.append(LogStash::Event.new({"field1" => "append1"}))
-          expect(subject.get("field1")).to eq("append1")
-        end
-        it "should add multi values as array" do
-          subject.append(LogStash::Event.new({"field1" => [ "append1","append2" ]}))
-          expect(subject.get("field1")).to eq([ "append1","append2" ])
-        end
-      end
-
-      context "when event field is a string" do
-        before { subject.set("field1", "original1") }
-
-        it "should append string to values, if different from current" do
-          subject.append(LogStash::Event.new({"field1" => "append1"}))
-          expect(subject.get("field1")).to eq([ "original1", "append1" ])
-        end
-        it "should not change value, if appended value is equal current" do
-          subject.append(LogStash::Event.new({"field1" => "original1"}))
-          expect(subject.get("field1")).to eq("original1")
-        end
-        it "should concatenate values in an array" do
-          subject.append(LogStash::Event.new({"field1" => [ "append1" ]}))
-          expect(subject.get("field1")).to eq([ "original1", "append1" ])
-        end
-        it "should join array, removing duplicates" do
-          subject.append(LogStash::Event.new({"field1" => [ "append1","original1" ]}))
-          expect(subject.get("field1")).to eq([ "original1", "append1" ])
-        end
-      end
-      context "when event field is an array" do
-        before { subject.set("field1", [ "original1", "original2" ] )}
-
-        it "should append string values to array, if not present in array" do
-          subject.append(LogStash::Event.new({"field1" => "append1"}))
-          expect(subject.get("field1")).to eq([ "original1", "original2", "append1" ])
-        end
-        it "should not append string values, if the array already contains it" do
-          subject.append(LogStash::Event.new({"field1" => "original1"}))
-          expect(subject.get("field1")).to eq([ "original1", "original2" ])
-        end
-        it "should join array, removing duplicates" do
-          subject.append(LogStash::Event.new({"field1" => [ "append1","original1" ]}))
-          expect(subject.get("field1")).to eq([ "original1", "original2", "append1" ])
-        end
-      end
-
-    end
-
-    it "timestamp parsing speed", :performance => true do
-      warmup = 10000
-      count = 1000000
-
-      data = { "@timestamp" => "2013-12-21T07:25:06.605Z" }
-      event = LogStash::Event.new(data)
-      expect(event.get("@timestamp")).to be_a(LogStash::Timestamp)
-
-      duration = 0
-      [warmup, count].each do |i|
-        start = Time.now
-        i.times do
-          data = { "@timestamp" => "2013-12-21T07:25:06.605Z" }
-          LogStash::Event.new(data.clone)
-        end
-        duration = Time.now - start
-      end
-      puts "event @timestamp parse rate: #{"%02.0f/sec" % (count / duration)}, elapsed: #{duration}s"
-    end
-
-    context "acceptable @timestamp formats" do
-      subject { LogStash::Event.new }
-
-      formats = [
-        "YYYY-MM-dd'T'HH:mm:ss.SSSZ",
-        "YYYY-MM-dd'T'HH:mm:ss.SSSSSSZ",
-        "YYYY-MM-dd'T'HH:mm:ss.SSS",
-        "YYYY-MM-dd'T'HH:mm:ss",
-        "YYYY-MM-dd'T'HH:mm:ssZ",
-      ]
-      formats.each do |format|
-        it "includes #{format}" do
-          time = subject.sprintf("%{+#{format}}")
-          begin
-            LogStash::Event.new("@timestamp" => time)
-          rescue => e
-            raise StandardError, "Time '#{time}' was rejected. #{e.class}: #{e.to_s}"
-          end
-        end
-      end
-
-      context "from LOGSTASH-1738" do
-        it "does not error" do
-          LogStash::Event.new("@timestamp" => "2013-12-29T23:12:52.371240+02:00")
-        end
-      end
-
-      context "from LOGSTASH-1732" do
-        it "does not error" do
-          LogStash::Event.new("@timestamp" => "2013-12-27T11:07:25+00:00")
-        end
-      end
-    end
-
-    context "timestamp initialization" do
-      it "should coerce timestamp" do
-        t = Time.iso8601("2014-06-12T00:12:17.114Z")
-        expect(LogStash::Event.new("@timestamp" => t).timestamp.to_i).to eq(t.to_i)
-        expect(LogStash::Event.new("@timestamp" => LogStash::Timestamp.new(t)).timestamp.to_i).to eq(t.to_i)
-        expect(LogStash::Event.new("@timestamp" => "2014-06-12T00:12:17.114Z").timestamp.to_i).to eq(t.to_i)
-      end
-
-      it "should assign current time when no timestamp" do
-        expect(LogStash::Event.new({}).timestamp.to_i).to be_within(1).of (Time.now.to_i)
-      end
-
-      it "should tag for invalid value" do
-        event = LogStash::Event.new("@timestamp" => "foo")
-        expect(event.timestamp.to_i).to be_within(1).of Time.now.to_i
-        expect(event.get("tags")).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
-        expect(event.get(LogStash::Event::TIMESTAMP_FAILURE_FIELD)).to eq("foo")
-
-        event = LogStash::Event.new("@timestamp" => 666)
-        expect(event.timestamp.to_i).to be_within(1).of Time.now.to_i
-        expect(event.get("tags")).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
-        expect(event.get(LogStash::Event::TIMESTAMP_FAILURE_FIELD)).to eq(666)
-      end
-
-      it "should warn for invalid value" do
-        LogStash::Event.new("@timestamp" => :foo)
-        LogStash::Event.new("@timestamp" => 666)
-      end
-
-      it "should tag for invalid string format" do
-        event = LogStash::Event.new("@timestamp" => "foo")
-        expect(event.timestamp.to_i).to be_within(1).of Time.now.to_i
-        expect(event.get("tags")).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
-        expect(event.get(LogStash::Event::TIMESTAMP_FAILURE_FIELD)).to eq("foo")
-      end
-
-      it "should warn for invalid string format" do
-        LogStash::Event.new("@timestamp" => "foo")
-      end
-    end
-
-    context "to_json" do
-      it "should support to_json" do
-        new_event = LogStash::Event.new(
-          "@timestamp" => Time.iso8601("2014-09-23T19:26:15.832Z"),
-          "message" => "foo bar",
-        )
-        json = new_event.to_json
-
-        expect(JSON.parse(json)).to eq( JSON.parse("{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}"))
-      end
-
-      it "should support to_json and ignore arguments" do
-        new_event = LogStash::Event.new(
-          "@timestamp" => Time.iso8601("2014-09-23T19:26:15.832Z"),
-          "message" => "foo bar",
-        )
-        json = new_event.to_json(:foo => 1, :bar => "baz")
-
-        expect(JSON.parse(json)).to eq( JSON.parse("{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}"))
-      end
-    end
-
-    context "metadata" do
-      context "with existing metadata" do
-        subject { LogStash::Event.new("hello" => "world", "@metadata" => { "fancy" => "pants" }) }
-
-        it "should not include metadata in to_hash" do
-          expect(subject.to_hash.keys).not_to include("@metadata")
-
-          # 'hello', '@timestamp', and '@version'
-          expect(subject.to_hash.keys.count).to eq(3)
-        end
-
-        it "should still allow normal field access" do
-          expect(subject.get("hello")).to eq("world")
-        end
-      end
-
-      context "with set metadata" do
-        let(:fieldref) { "[@metadata][foo][bar]" }
-        let(:value) { "bar" }
-        subject { LogStash::Event.new("normal" => "normal") }
-        before do
-          # Verify the test is configured correctly.
-          expect(fieldref).to start_with("[@metadata]")
-
-          # Set it.
-          subject.set(fieldref, value)
-        end
-
-        it "should still allow normal field access" do
-          expect(subject.get("normal")).to eq("normal")
-        end
-
-        it "should allow getting" do
-          expect(subject.get(fieldref)).to eq(value)
-        end
-
-        it "should be hidden from .to_json" do
-          require "json"
-          obj = JSON.parse(subject.to_json)
-          expect(obj).not_to include("@metadata")
-        end
-
-        it "should be hidden from .to_hash" do
-          expect(subject.to_hash).not_to include("@metadata")
-        end
-
-        it "should be accessible through #to_hash_with_metadata" do
-          obj = subject.to_hash_with_metadata
-          expect(obj).to include("@metadata")
-          expect(obj["@metadata"]["foo"]["bar"]).to eq(value)
-        end
-      end
-
-      context "with no metadata" do
-        subject { LogStash::Event.new("foo" => "bar") }
-        it "should have no metadata" do
-          expect(subject.get("@metadata")).to be_empty
-        end
-        it "should still allow normal field access" do
-          expect(subject.get("foo")).to eq("bar")
-        end
-
-        it "should not include the @metadata key" do
-          expect(subject.to_hash_with_metadata).not_to include("@metadata")
-        end
-      end
-    end
-
-    context "signal events" do
-      it "should define the shutdown and flush event constants" do
-        # the SHUTDOWN and FLUSH constants are part of the plugin API contract
-        # if they are changed, all plugins must be updated
-        expect(LogStash::SHUTDOWN).to be_a(LogStash::ShutdownEvent)
-        expect(LogStash::FLUSH).to be_a(LogStash::FlushEvent)
-      end
-
-      it "should define the shutdown event with SignalEvent as parent class" do
-        expect(LogStash::SHUTDOWN).to be_a(LogStash::SignalEvent)
-        expect(LogStash::FLUSH).to be_a(LogStash::SignalEvent)
-      end
-
-      it "should define the flush? method" do
-        expect(LogStash::SHUTDOWN.flush?).to be_falsey
-        expect(LogStash::FLUSH.flush?).to be_truthy
-      end
-
-      it "should define the shutdown? method" do
-        expect(LogStash::SHUTDOWN.shutdown?).to be_truthy
-        expect(LogStash::FLUSH.shutdown?).to be_falsey
-      end
-    end
-  end
-
-  let(:event_hash) do
-    {
-      "@timestamp" => "2013-01-01T00:00:00.000Z",
-      "type" => "sprintf",
-      "message" => "hello world",
-      "tags" => [ "tag1" ],
-      "source" => "/home/foo",
-      "a" => "b",
-      "c" => {
-        "d" => "f",
-        "e" => {"f" => "g"}
-      },
-      "f" => { "g" => { "h" => "i" } },
-      "j" => {
-          "k1" => "v",
-          "k2" => [ "w", "x" ],
-          "k3" => {"4" => "m"},
-          "k4" => [ {"nested" => "cool"} ],
-          5 => 6,
-          "5" => 7
-      },
-      "nilfield" => nil,
-      "@metadata" => { "fancy" => "pants", "have-to-go" => { "deeper" => "inception" } }
-    }
-  end
-
-  describe "using normal hash input" do
-    it_behaves_like "all event tests" do
-      subject{LogStash::Event.new(event_hash)}
-    end
-  end
-
-  describe "using hash input from deserialized json" do
-    # this is to test the case when JrJackson deserialises Json and produces
-    # native Java Collections objects for efficiency
-    it_behaves_like "all event tests" do
-      subject{LogStash::Event.new(LogStash::Json.load(LogStash::Json.dump(event_hash)))}
-    end
-  end
-
-
-  describe "#to_s" do
-    let(:timestamp) { LogStash::Timestamp.new }
-    let(:event1) { LogStash::Event.new({ "@timestamp" => timestamp, "host" => "foo", "message" => "bar"}) }
-    let(:event2) { LogStash::Event.new({ "host" => "bar", "message" => "foo"}) }
-
-    it "should cache only one template" do
-      LogStash::StringInterpolation.clear_cache
-      expect {
-        event1.to_s
-        event2.to_s
-      }.to change { LogStash::StringInterpolation.cache_size }.by(1)
-    end
-
-    it "return the string containing the timestamp, the host and the message" do
-      expect(event1.to_s).to eq("#{timestamp.to_iso8601} #{event1.get("host")} #{event1.get("message")}")
-    end
-  end
-
-  describe "Event accessors" do
-    let(:event) { LogStash::Event.new({ "message" => "foo" }) }
-
-    it "should invalidate target caching" do
-      expect(event.get("[a][0]")).to be_nil
-
-      expect(event.set("[a][0]", 42)).to eq(42)
-      expect(event.get("[a][0]")).to eq(42)
-      expect(event.get("[a]")).to eq({"0" => 42})
-
-      expect(event.set("[a]", [42, 24])).to eq([42, 24])
-      expect(event.get("[a]")).to eq([42, 24])
-
-      expect(event.get("[a][0]")).to eq(42)
-
-      expect(event.set("[a]", [24, 42])).to eq([24, 42])
-      expect(event.get("[a][0]")).to eq(24)
-
-      expect(event.set("[a][0]", {"a "=> 99, "b" => 98})).to eq({"a "=> 99, "b" => 98})
-      expect(event.get("[a][0]")).to eq({"a "=> 99, "b" => 98})
-
-      expect(event.get("[a]")).to eq([{"a "=> 99, "b" => 98}, 42])
-      expect(event.get("[a][0]")).to eq({"a "=> 99, "b" => 98})
-      expect(event.get("[a][1]")).to eq(42)
-      expect(event.get("[a][0][b]")).to eq(98)
-    end
-  end
-end
-
diff --git a/logstash-core-event/spec/logstash/timestamp_spec.rb b/logstash-core-event/spec/logstash/timestamp_spec.rb
deleted file mode 100644
index 196b895c39e..00000000000
--- a/logstash-core-event/spec/logstash/timestamp_spec.rb
+++ /dev/null
@@ -1,170 +0,0 @@
-# encoding: utf-8
-require "spec_helper"
-require "logstash/timestamp"
-require "bigdecimal"
-
-describe LogStash::Timestamp do
-
-  it "should parse its own iso8601 output" do
-    t = Time.now
-    ts = LogStash::Timestamp.new(t)
-    expect(LogStash::Timestamp.parse_iso8601(ts.to_iso8601).to_i).to eq(t.to_i)
-  end
-
-  it "should coerce iso8601 string" do
-    t = Time.now
-    ts = LogStash::Timestamp.new(t)
-    expect(LogStash::Timestamp.coerce(ts.to_iso8601).to_i).to eq(t.to_i)
-  end
-
-  it "should coerce Time" do
-    t = Time.now
-    expect(LogStash::Timestamp.coerce(t).to_i).to eq(t.to_i)
-  end
-
-  it "should coerce Timestamp" do
-    t = LogStash::Timestamp.now
-    expect(LogStash::Timestamp.coerce(t).to_i).to eq(t.to_i)
-  end
-
-  it "should raise on invalid string coerce" do
-    expect{LogStash::Timestamp.coerce("foobar")}.to raise_error LogStash::TimestampParserError
-  end
-
-  it "should return nil on invalid object coerce" do
-    expect(LogStash::Timestamp.coerce(:foobar)).to be_nil
-  end
-
-  it "should support to_json" do
-    expect(LogStash::Timestamp.parse_iso8601("2014-09-23T00:00:00-0800").to_json).to eq("\"2014-09-23T08:00:00.000Z\"")
-  end
-
-  it "should support to_json and ignore arguments" do
-    expect(LogStash::Timestamp.parse_iso8601("2014-09-23T00:00:00-0800").to_json(:some => 1, :argumnents => "test")).to eq("\"2014-09-23T08:00:00.000Z\"")
-  end
-
-  it "should support timestamp comparaison" do
-   current = LogStash::Timestamp.new(Time.now) 
-   future = LogStash::Timestamp.new(Time.now + 100)
-
-   expect(future > current).to eq(true)
-   expect(future < current).to eq(false)
-   expect(current == current).to eq(true)
-
-   expect(current <=> current).to eq(0)
-   expect(current <=> future).to eq(-1)
-   expect(future <=> current).to eq(1)
-  end
-
-  it "should allow unary operation +" do
-    current = Time.now
-    t = LogStash::Timestamp.new(current) + 10
-    expect(t).to eq(current + 10)
-  end
-
-  describe "subtraction" do
-    it "should work on a timestamp object" do
-      t = Time.now
-      current = LogStash::Timestamp.new(t)
-      future = LogStash::Timestamp.new(t + 10)
-      expect(future - current).to eq(10)
-    end
-
-    it "should work on with time object" do
-      current = Time.now
-      t = LogStash::Timestamp.new(current + 10)
-      expect(t - current).to eq(10)
-    end
-
-    it "should work with numeric value" do
-      current = Time.now
-      t = LogStash::Timestamp.new(current + 10)
-      expect(t - 10).to eq(current)
-    end
-  end
-
-  context "identity methods" do
-    subject { LogStash::Timestamp.new }
-
-    it "should support utc" do
-      expect(subject.utc).to eq(subject)
-    end
-
-    it "should support gmtime" do
-      expect(subject.gmtime).to eq(subject)
-    end
-  end
-
-  context "numeric casting methods" do
-    let (:now) {Time.now}
-    subject { LogStash::Timestamp.new(now) }
-
-    it "should support to_i" do
-      expect(subject.to_i).to eq(now.to_i)
-    end
-
-    it "should support to_f" do
-      expect(subject.to_f).to eq(now.to_f)
-    end
-  end
-
-  context "at" do
-    context "with integer epoch" do
-      it "should convert to correct date" do
-        expect(LogStash::Timestamp.at(946702800).to_iso8601).to eq("2000-01-01T05:00:00.000Z")
-      end
-
-      it "should return zero usec" do
-        expect(LogStash::Timestamp.at(946702800).usec).to eq(0)
-      end
-
-      it "should return prior to epoch date on negative input" do
-        expect(LogStash::Timestamp.at(-1).to_iso8601).to eq("1969-12-31T23:59:59.000Z")
-      end
-    end
-
-    context "with float epoch" do
-      it "should convert to correct date" do
-        expect(LogStash::Timestamp.at(946702800.123456.to_f).to_iso8601).to eq("2000-01-01T05:00:00.123Z")
-      end
-
-      it "should return usec with a minimum of millisec precision" do
-        expect(LogStash::Timestamp.at(946702800.123456.to_f).usec).to be_within(1000).of(123456)
-      end
-    end
-
-    context "with BigDecimal epoch" do
-      it "should convert to correct date" do
-        expect(LogStash::Timestamp.at(BigDecimal.new("946702800.123456")).to_iso8601).to eq("2000-01-01T05:00:00.123Z")
-      end
-
-      it "should return usec with a minimum of millisec precision" do
-        # since Java Timestamp relies on JodaTime which supports only milliseconds precision
-        # the usec method will only be precise up to milliseconds.
-        expect(LogStash::Timestamp.at(BigDecimal.new("946702800.123456")).usec).to be_within(1000).of(123456)
-      end
-    end
-
-    context "with illegal parameters" do
-      it "should raise exception on nil input" do
-        expect{LogStash::Timestamp.at(nil)}.to raise_error
-      end
-
-      it "should raise exception on invalid input type" do
-        expect{LogStash::Timestamp.at(:foo)}.to raise_error
-      end
-    end
-  end
-
-  context "usec" do
-    it "should support millisecond precision" do
-      expect(LogStash::Timestamp.at(946702800.123).usec).to eq(123000)
-    end
-
-    it "should try to preserve and report microseconds precision if possible" do
-      # since Java Timestamp relies on JodaTime which supports only milliseconds precision
-      # the usec method will only be precise up to milliseconds.
-      expect(LogStash::Timestamp.at(946702800.123456).usec).to be_within(1000).of(123456)
-    end
-  end
-end
diff --git a/logstash-core-event/spec/logstash/util/accessors_spec.rb b/logstash-core-event/spec/logstash/util/accessors_spec.rb
deleted file mode 100644
index e3c1a73e60e..00000000000
--- a/logstash-core-event/spec/logstash/util/accessors_spec.rb
+++ /dev/null
@@ -1,179 +0,0 @@
-# encoding: utf-8
-require "spec_helper"
-
-# this is to skip specs when running agains an alternate logstash-core-event implementation
-# that does not define the Accessors class. For example, in logstash-core-event-java
-# the Accessors class does not exists in the Ruby namespace.
-class_exists = begin
-  require "logstash/util/accessors"
-  true
-rescue LoadError
-  false
-end
-
-describe "LogStash::Util::Accessors", :if => class_exists do
-
-  context "using simple field" do
-
-    it "should get value of word key" do
-      str = "hello"
-      data = { "hello" => "world" }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.get(str)).to eq(data[str])
-    end
-
-    it "should get value of key with spaces" do
-      str = "hel lo"
-      data = { "hel lo" => "world" }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.get(str)).to eq(data[str])
-    end
-
-    it "should get value of numeric key string" do
-      str = "1"
-      data = { "1" => "world" }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.get(str)).to eq(data[str])
-    end
-
-    it "should handle delete" do
-      str = "simple"
-      data = { "simple" => "things" }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.del(str)).to eq("things")
-      expect(data).to be_empty
-    end
-
-    it "should handle delete on non-existent field" do
-      str = "[foo][bar]"
-      data = { "hello" => "world" }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.del(str)).to be_nil
-      expect(data).not_to be_empty
-      # assert no side effects
-      expect(accessors.get("foo")).to be_nil
-      expect(accessors.get("hello")).to eq("world")
-    end
-
-    it "should set string value" do
-      str = "simple"
-      data = {}
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.set(str, "things")).to eq("things")
-      expect(data).to eq({ "simple" => "things" })
-    end
-
-    it "should set array value" do
-      str = "simple"
-      data = {}
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.set(str, ["foo", "bar"])).to eq(["foo", "bar"])
-      expect(data).to eq({ "simple" => ["foo", "bar"]})
-    end
-  end
-
-  context "using field path" do
-
-    it "should get shallow string value of word key" do
-      str = "[hello]"
-      data = { "hello" =>  "world" }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.get(str)).to eq("world")
-    end
-
-    it "should get shallow string value of key with spaces" do
-      str = "[hel lo]"
-      data = { "hel lo" =>  "world" }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.get(str)).to eq("world")
-    end
-
-    it "should get shallow string value of numeric key string" do
-      str = "[1]"
-      data = { "1" =>  "world" }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.get(str)).to eq("world")
-    end
-
-    it "should get deep string value" do
-      str = "[hello][world]"
-      data = { "hello" => { "world" => "foo", "bar" => "baz" } }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.get(str)).to eq(data["hello"]["world"])
-    end
-
-    it "should return nil when getting a non-existant field (with no side-effects on original data)" do
-      str = "[hello][world]"
-      data = {}
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.get(str)).to be_nil
-      expect(data).to  be_empty
-      expect(accessors.set(str, "foo")).to eq("foo")
-      expect(data).to eq({ "hello" => {"world" => "foo"} })
-    end
-
-    it "should handle delete" do
-      str = "[hello][world]"
-      data = { "hello" => { "world" => "foo", "bar" => "baz" } }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.del(str)).to eq("foo")
-
-      # Make sure the "world" key is removed.
-      expect(data["hello"]).to eq({ "bar" => "baz" })
-    end
-
-    it "should set shallow string value" do
-      str = "[hello]"
-      data = {}
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.set(str, "foo")).to eq("foo")
-      expect(data).to eq({ "hello" => "foo" })
-    end
-
-    it "should set deep string value" do
-      str = "[hello][world]"
-      data = {}
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.set(str, "foo")).to eq("foo")
-      expect(data).to eq({ "hello" => { "world" => "foo" } })
-    end
-
-    it "should set deep array value" do
-      str = "[hello][world]"
-      data = {}
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.set(str, ["foo", "bar"])).to eq(["foo", "bar"])
-      expect(data).to eq({ "hello" => { "world" => ["foo", "bar"] } })
-    end
-
-    it "should set element within array value" do
-      str = "[hello][0]"
-      data = {"hello" => ["foo", "bar"]}
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.set(str, "world") ).to eq("world")
-      expect(data).to eq({"hello" => ["world", "bar"]})
-    end
-
-    it "should retrieve array item" do
-      data = { "hello" => { "world" => ["a", "b"], "bar" => "baz" } }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.get("[hello][world][0]")).to eq(data["hello"]["world"][0])
-      expect(accessors.get("[hello][world][1]")).to eq(data["hello"]["world"][1])
-    end
-
-    it "should retrieve array item containing hash" do
-      data = { "hello" => { "world" => [ { "a" => 123 }, { "b" => 345 } ], "bar" => "baz" } }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.get("[hello][world][0][a]")).to eq(data["hello"]["world"][0]["a"])
-      expect(accessors.get("[hello][world][1][b]")).to eq(data["hello"]["world"][1]["b"])
-    end
-
-    it "should handle delete of array element" do
-      str = "[geocoords][0]"
-      data = { "geocoords" => [4, 2] }
-      accessors = LogStash::Util::Accessors.new(data)
-      expect(accessors.del(str)).to eq(4)
-      expect(data).to eq({ "geocoords" => [2] })
-    end
-  end
-end
diff --git a/logstash-core-queue-jruby/build.gradle b/logstash-core-queue-jruby/build.gradle
deleted file mode 100644
index 4f0ed72692e..00000000000
--- a/logstash-core-queue-jruby/build.gradle
+++ /dev/null
@@ -1,123 +0,0 @@
-import org.yaml.snakeyaml.Yaml
-
-apply plugin: 'java'
-apply plugin: 'idea'
-
-// fetch version from Logstash's master versions.yml file
-def versionMap = (Map) (new Yaml()).load(new File("$projectDir/../versions.yml").text)
-
-description = "Logstash Core Queue JRuby"
-group 'org.logstash'
-version = versionMap['logstash-core-queue-jruby']
-
-buildscript {
-    repositories {
-        mavenCentral()
-    }
-    dependencies {
-        classpath 'org.yaml:snakeyaml:1.17'
-    }
-}
-
-repositories {
-    mavenCentral()
-}
-
-gradle.projectsEvaluated {
-    tasks.withType(JavaCompile) {
-        options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
-    }
-}
-
-project.sourceCompatibility = 1.8
-project.targetCompatibility = 1.8
-
-task sourcesJar(type: org.gradle.api.tasks.bundling.Jar, dependsOn: classes) {
-    from sourceSets.main.allSource
-    classifier 'sources'
-    extension 'jar'
-}
-
-task javadocJar(type: org.gradle.api.tasks.bundling.Jar, dependsOn: javadoc) {
-    from javadoc.destinationDir
-    classifier 'javadoc'
-    extension 'jar'
-}
-
-// copy jar file into the gem lib dir but without the version number in filename
-task copyGemjar(type: org.gradle.api.tasks.Copy, dependsOn: sourcesJar) {
-    from project.jar
-    into project.file('lib/logstash-core-queue-jruby/')
-    rename(/(.+)-${project.version}.jar/, '$1.jar')
-}
-
-task cleanGemjar {
-    delete fileTree(project.file('lib/logstash-core-queue-jruby/')) {
-        include '*.jar'
-    }
-}
-
-clean.dependsOn(cleanGemjar)
-jar.finalizedBy(copyGemjar)
-
-task gemspec_jars << {
-    File gemspec_jars = file("./gemspec_jars.rb")
-    gemspec_jars.newWriter().withWriter { w ->
-        w << "# This file is generated by Gradle as part of the build process. It extracts the build.gradle\n"
-        w << "# runtime dependencies to generate this gemspec dependencies file to be eval'ed by the gemspec\n"
-        w << "# for the jar-dependencies requirements.\n\n"
-        configurations.runtime.allDependencies.each { dependency ->
-            w << "gem.requirements << \"jar ${dependency.group}:${dependency.name}, ${dependency.version}\"\n"
-        }
-    }
-}
-build.finalizedBy(gemspec_jars)
-
-configurations.create('sources')
-configurations.create('javadoc')
-configurations.archives {
-    extendsFrom configurations.sources
-    extendsFrom configurations.javadoc
-}
-
-artifacts {
-    sources(sourcesJar) {
-        // Weird Gradle quirk where type will be used for the extension, but only for sources
-        type 'jar'
-    }
-
-    javadoc(javadocJar) {
-        type 'javadoc'
-    }
-}
-
-configurations {
-    provided
-}
-
-project.sourceSets {
-    main.compileClasspath += project.configurations.provided
-    main.runtimeClasspath += project.configurations.provided
-    test.compileClasspath += project.configurations.provided
-    test.runtimeClasspath += project.configurations.provided
-}
-project.javadoc.classpath += project.configurations.provided
-
-idea {
-    module {
-        scopes.PROVIDED.plus += [project.configurations.provided]
-    }
-}
-
-dependencies {
-    testCompile group: 'junit', name: 'junit', version: '4.12'
-    provided group: 'org.jruby', name: 'jruby-core', version: '1.7.25'
-    provided files('../logstash-core-event-java/lib/logstash-core-event-java/logstash-core-event-java.jar')
-    provided files('../logstash-core/lib/logstash-core/logstash-core.jar')
-}
-
-// See http://www.gradle.org/docs/current/userguide/gradle_wrapper.html
-task wrapper(type: Wrapper) {
-    description = 'Install Gradle wrapper'
-    gradleVersion = '2.8'
-}
diff --git a/logstash-core-queue-jruby/gemspec_jars.rb b/logstash-core-queue-jruby/gemspec_jars.rb
deleted file mode 100644
index 80046e4e63a..00000000000
--- a/logstash-core-queue-jruby/gemspec_jars.rb
+++ /dev/null
@@ -1,4 +0,0 @@
-# This file is generated by Gradle as part of the build process. It extracts the build.gradle
-# runtime dependencies to generate this gemspec dependencies file to be eval'ed by the gemspec
-# for the jar-dependencies requirements.
-
diff --git a/logstash-core-queue-jruby/lib/logstash-core-queue-jruby/logstash-core-queue-jruby.rb b/logstash-core-queue-jruby/lib/logstash-core-queue-jruby/logstash-core-queue-jruby.rb
deleted file mode 100644
index 25c471f6842..00000000000
--- a/logstash-core-queue-jruby/lib/logstash-core-queue-jruby/logstash-core-queue-jruby.rb
+++ /dev/null
@@ -1,24 +0,0 @@
-# encoding: utf-8
-
-require "java"
-
-module LogStash
-end
-
-# local dev setup
-classes_dir = File.expand_path("../../../build/classes/main", __FILE__)
-
-if File.directory?(classes_dir)
-  # if in local dev setup, add target to classpath
-  $CLASSPATH << classes_dir unless $CLASSPATH.include?(classes_dir)
-else
-  # otherwise use included jar
-  begin
-    require "logstash-core-queue-jruby/logstash-core-queue-jruby.jar"
-  rescue Exception => e
-    raise("Error loading logstash-core-queue-jruby/logstash-core-queue-jruby.jar file, cause: #{e.message}")
-  end
-end
-
-require "jruby_acked_queue_ext"
-require "jruby_acked_batch_ext"
diff --git a/logstash-core-queue-jruby/lib/logstash-core-queue-jruby/version.rb b/logstash-core-queue-jruby/lib/logstash-core-queue-jruby/version.rb
deleted file mode 100644
index 225cfbbad2f..00000000000
--- a/logstash-core-queue-jruby/lib/logstash-core-queue-jruby/version.rb
+++ /dev/null
@@ -1,3 +0,0 @@
-# encoding: utf-8
-
-LOGSTASH_CORE_QUEUE_JRUBY_VERSION = "6.0.0-alpha1"
diff --git a/logstash-core-queue-jruby/logstash-core-queue-jruby.gemspec b/logstash-core-queue-jruby/logstash-core-queue-jruby.gemspec
deleted file mode 100644
index 463d1dc3454..00000000000
--- a/logstash-core-queue-jruby/logstash-core-queue-jruby.gemspec
+++ /dev/null
@@ -1,23 +0,0 @@
-# -*- encoding: utf-8 -*-
-lib = File.expand_path('../lib', __FILE__)
-$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
-require 'logstash-core-queue-jruby/version'
-
-Gem::Specification.new do |gem|
-  gem.authors       = ["Elastic"]
-  gem.email         = ["info@elastic.co"]
-  gem.description   = %q{The core event component of logstash, the scalable log and event management tool}
-  gem.summary       = %q{logstash-core-event-java - The core event component of logstash}
-  gem.homepage      = "http://www.elastic.co/guide/en/logstash/current/index.html"
-  gem.license       = "Apache License (2.0)"
-
-  gem.files         = Dir.glob(["logstash-core-queue-jruby.gemspec", "gemspec_jars.rb", "lib/**/*.jar", "lib/**/*.rb", "spec/**/*.rb"])
-  gem.test_files    = gem.files.grep(%r{^(test|spec|features)/})
-  gem.name          = "logstash-core-queue-jruby"
-  gem.require_paths = ["lib"]
-  gem.version       = LOGSTASH_CORE_QUEUE_JRUBY_VERSION
-
-  gem.platform = "java"
-
-  eval(File.read(File.expand_path("../gemspec_jars.rb", __FILE__)))
-end
diff --git a/logstash-core-queue-jruby/settings.gradle b/logstash-core-queue-jruby/settings.gradle
deleted file mode 100644
index 31c56eb1ad0..00000000000
--- a/logstash-core-queue-jruby/settings.gradle
+++ /dev/null
@@ -1 +0,0 @@
-rootProject.name = 'logstash-core-queue-jruby'
diff --git a/logstash-core/build.gradle b/logstash-core/build.gradle
index 0d1c318ccf2..088d7aca522 100644
--- a/logstash-core/build.gradle
+++ b/logstash-core/build.gradle
@@ -110,14 +110,17 @@ idea {
 }
 
 dependencies {
+    provided 'org.jruby:jruby-core:1.7.25'
     compile 'org.apache.logging.log4j:log4j-api:2.6.2'
     compile 'org.apache.logging.log4j:log4j-core:2.6.2'
     compile 'com.fasterxml.jackson.core:jackson-core:2.7.4'
     compile 'com.fasterxml.jackson.core:jackson-databind:2.7.4'
+    compile 'com.fasterxml.jackson.module:jackson-module-afterburner:2.7.4'
+    compile 'com.fasterxml.jackson.dataformat:jackson-dataformat-cbor:2.7.4'
     testCompile 'org.apache.logging.log4j:log4j-core:2.6.2:tests'
     testCompile 'org.apache.logging.log4j:log4j-api:2.6.2:tests'
     testCompile 'junit:junit:4.12'
-    provided 'org.jruby:jruby-core:1.7.25'
+    testCompile 'net.javacrumbs.json-unit:json-unit:1.9.0'
 }
 
 // See http://www.gradle.org/docs/current/userguide/gradle_wrapper.html
diff --git a/logstash-core/lib/logstash-core/logstash-core.rb b/logstash-core/lib/logstash-core/logstash-core.rb
index 8c452b0d24a..5dd16eb1a99 100644
--- a/logstash-core/lib/logstash-core/logstash-core.rb
+++ b/logstash-core/lib/logstash-core/logstash-core.rb
@@ -23,3 +23,10 @@ module LogStash
     raise("Error loading logstash-core/logstash-core.jar file, cause: #{e.message}")
   end
 end
+
+require "jruby_event_ext"
+require "jruby_timestamp_ext"
+require "jruby_acked_queue_ext"
+require "jruby_acked_batch_ext"
+require "logstash/event"
+require "logstash/timestamp"
diff --git a/logstash-core-event-java/lib/logstash/event.rb b/logstash-core/lib/logstash/event.rb
similarity index 100%
rename from logstash-core-event-java/lib/logstash/event.rb
rename to logstash-core/lib/logstash/event.rb
diff --git a/logstash-core-event-java/lib/logstash/string_interpolation.rb b/logstash-core/lib/logstash/string_interpolation.rb
similarity index 100%
rename from logstash-core-event-java/lib/logstash/string_interpolation.rb
rename to logstash-core/lib/logstash/string_interpolation.rb
diff --git a/logstash-core-event-java/lib/logstash/timestamp.rb b/logstash-core/lib/logstash/timestamp.rb
similarity index 100%
rename from logstash-core-event-java/lib/logstash/timestamp.rb
rename to logstash-core/lib/logstash/timestamp.rb
diff --git a/logstash-core-event-java/spec/event_spec.rb b/logstash-core/spec/logstash/event_spec.rb
similarity index 100%
rename from logstash-core-event-java/spec/event_spec.rb
rename to logstash-core/spec/logstash/event_spec.rb
diff --git a/logstash-core-event-java/spec/timestamp_spec.rb b/logstash-core/spec/logstash/timestamp_spec.rb
similarity index 100%
rename from logstash-core-event-java/spec/timestamp_spec.rb
rename to logstash-core/spec/logstash/timestamp_spec.rb
diff --git a/logstash-core-queue-jruby/src/main/java/JrubyAckedBatchExtService.java b/logstash-core/src/main/java/JrubyAckedBatchExtService.java
similarity index 100%
rename from logstash-core-queue-jruby/src/main/java/JrubyAckedBatchExtService.java
rename to logstash-core/src/main/java/JrubyAckedBatchExtService.java
diff --git a/logstash-core-queue-jruby/src/main/java/JrubyAckedQueueExtService.java b/logstash-core/src/main/java/JrubyAckedQueueExtService.java
similarity index 100%
rename from logstash-core-queue-jruby/src/main/java/JrubyAckedQueueExtService.java
rename to logstash-core/src/main/java/JrubyAckedQueueExtService.java
diff --git a/logstash-core-event-java/src/main/java/JrubyEventExtService.java b/logstash-core/src/main/java/JrubyEventExtService.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/JrubyEventExtService.java
rename to logstash-core/src/main/java/JrubyEventExtService.java
diff --git a/logstash-core-event-java/src/main/java/JrubyTimestampExtService.java b/logstash-core/src/main/java/JrubyTimestampExtService.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/JrubyTimestampExtService.java
rename to logstash-core/src/main/java/JrubyTimestampExtService.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/Accessors.java b/logstash-core/src/main/java/org/logstash/Accessors.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/Accessors.java
rename to logstash-core/src/main/java/org/logstash/Accessors.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/Cloner.java b/logstash-core/src/main/java/org/logstash/Cloner.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/Cloner.java
rename to logstash-core/src/main/java/org/logstash/Cloner.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/ConvertedList.java b/logstash-core/src/main/java/org/logstash/ConvertedList.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/ConvertedList.java
rename to logstash-core/src/main/java/org/logstash/ConvertedList.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/ConvertedMap.java b/logstash-core/src/main/java/org/logstash/ConvertedMap.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/ConvertedMap.java
rename to logstash-core/src/main/java/org/logstash/ConvertedMap.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/DateNode.java b/logstash-core/src/main/java/org/logstash/DateNode.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/DateNode.java
rename to logstash-core/src/main/java/org/logstash/DateNode.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/EpochNode.java b/logstash-core/src/main/java/org/logstash/EpochNode.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/EpochNode.java
rename to logstash-core/src/main/java/org/logstash/EpochNode.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/Event.java b/logstash-core/src/main/java/org/logstash/Event.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/Event.java
rename to logstash-core/src/main/java/org/logstash/Event.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/FieldReference.java b/logstash-core/src/main/java/org/logstash/FieldReference.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/FieldReference.java
rename to logstash-core/src/main/java/org/logstash/FieldReference.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/Javafier.java b/logstash-core/src/main/java/org/logstash/Javafier.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/Javafier.java
rename to logstash-core/src/main/java/org/logstash/Javafier.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/KeyNode.java b/logstash-core/src/main/java/org/logstash/KeyNode.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/KeyNode.java
rename to logstash-core/src/main/java/org/logstash/KeyNode.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/ObjectMappers.java b/logstash-core/src/main/java/org/logstash/ObjectMappers.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/ObjectMappers.java
rename to logstash-core/src/main/java/org/logstash/ObjectMappers.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/PathCache.java b/logstash-core/src/main/java/org/logstash/PathCache.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/PathCache.java
rename to logstash-core/src/main/java/org/logstash/PathCache.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/Rubyfier.java b/logstash-core/src/main/java/org/logstash/Rubyfier.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/Rubyfier.java
rename to logstash-core/src/main/java/org/logstash/Rubyfier.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/StaticNode.java b/logstash-core/src/main/java/org/logstash/StaticNode.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/StaticNode.java
rename to logstash-core/src/main/java/org/logstash/StaticNode.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/StringInterpolation.java b/logstash-core/src/main/java/org/logstash/StringInterpolation.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/StringInterpolation.java
rename to logstash-core/src/main/java/org/logstash/StringInterpolation.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/Template.java b/logstash-core/src/main/java/org/logstash/Template.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/Template.java
rename to logstash-core/src/main/java/org/logstash/Template.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/TemplateNode.java b/logstash-core/src/main/java/org/logstash/TemplateNode.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/TemplateNode.java
rename to logstash-core/src/main/java/org/logstash/TemplateNode.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/Timestamp.java b/logstash-core/src/main/java/org/logstash/Timestamp.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/Timestamp.java
rename to logstash-core/src/main/java/org/logstash/Timestamp.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/TimestampSerializer.java b/logstash-core/src/main/java/org/logstash/TimestampSerializer.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/TimestampSerializer.java
rename to logstash-core/src/main/java/org/logstash/TimestampSerializer.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/Util.java b/logstash-core/src/main/java/org/logstash/Util.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/Util.java
rename to logstash-core/src/main/java/org/logstash/Util.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/Valuefier.java b/logstash-core/src/main/java/org/logstash/Valuefier.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/Valuefier.java
rename to logstash-core/src/main/java/org/logstash/Valuefier.java
diff --git a/logstash-core-queue-jruby/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedBatchExtLibrary.java b/logstash-core/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedBatchExtLibrary.java
similarity index 100%
rename from logstash-core-queue-jruby/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedBatchExtLibrary.java
rename to logstash-core/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedBatchExtLibrary.java
diff --git a/logstash-core-queue-jruby/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedQueueExtLibrary.java b/logstash-core/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedQueueExtLibrary.java
similarity index 100%
rename from logstash-core-queue-jruby/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedQueueExtLibrary.java
rename to logstash-core/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedQueueExtLibrary.java
diff --git a/logstash-core-queue-jruby/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedQueueMemoryExtLibrary.java b/logstash-core/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedQueueMemoryExtLibrary.java
similarity index 100%
rename from logstash-core-queue-jruby/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedQueueMemoryExtLibrary.java
rename to logstash-core/src/main/java/org/logstash/ackedqueue/ext/JrubyAckedQueueMemoryExtLibrary.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/BiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/BiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/BiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/BiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/BiValueCommon.java b/logstash-core/src/main/java/org/logstash/bivalues/BiValueCommon.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/BiValueCommon.java
rename to logstash-core/src/main/java/org/logstash/bivalues/BiValueCommon.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/BiValues.java b/logstash-core/src/main/java/org/logstash/bivalues/BiValues.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/BiValues.java
rename to logstash-core/src/main/java/org/logstash/bivalues/BiValues.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/BigDecimalBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/BigDecimalBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/BigDecimalBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/BigDecimalBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/BigIntegerBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/BigIntegerBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/BigIntegerBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/BigIntegerBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/BooleanBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/BooleanBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/BooleanBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/BooleanBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/DoubleBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/DoubleBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/DoubleBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/DoubleBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/FloatBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/FloatBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/FloatBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/FloatBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/IntegerBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/IntegerBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/IntegerBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/IntegerBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/JavaProxyBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/JavaProxyBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/JavaProxyBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/JavaProxyBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/LongBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/LongBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/LongBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/LongBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/NullBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/NullBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/NullBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/NullBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/StringBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/StringBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/StringBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/StringBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/SymbolBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/SymbolBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/SymbolBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/SymbolBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/TimeBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/TimeBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/TimeBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/TimeBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/bivalues/TimestampBiValue.java b/logstash-core/src/main/java/org/logstash/bivalues/TimestampBiValue.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/bivalues/TimestampBiValue.java
rename to logstash-core/src/main/java/org/logstash/bivalues/TimestampBiValue.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/ext/JrubyEventExtLibrary.java b/logstash-core/src/main/java/org/logstash/ext/JrubyEventExtLibrary.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/ext/JrubyEventExtLibrary.java
rename to logstash-core/src/main/java/org/logstash/ext/JrubyEventExtLibrary.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/ext/JrubyTimestampExtLibrary.java b/logstash-core/src/main/java/org/logstash/ext/JrubyTimestampExtLibrary.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/ext/JrubyTimestampExtLibrary.java
rename to logstash-core/src/main/java/org/logstash/ext/JrubyTimestampExtLibrary.java
diff --git a/logstash-core-event-java/src/main/java/org/logstash/json/TimestampSerializer.java b/logstash-core/src/main/java/org/logstash/json/TimestampSerializer.java
similarity index 100%
rename from logstash-core-event-java/src/main/java/org/logstash/json/TimestampSerializer.java
rename to logstash-core/src/main/java/org/logstash/json/TimestampSerializer.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/AccessorsTest.java b/logstash-core/src/test/java/org/logstash/AccessorsTest.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/AccessorsTest.java
rename to logstash-core/src/test/java/org/logstash/AccessorsTest.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/EventTest.java b/logstash-core/src/test/java/org/logstash/EventTest.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/EventTest.java
rename to logstash-core/src/test/java/org/logstash/EventTest.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/FieldReferenceTest.java b/logstash-core/src/test/java/org/logstash/FieldReferenceTest.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/FieldReferenceTest.java
rename to logstash-core/src/test/java/org/logstash/FieldReferenceTest.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/JavafierTest.java b/logstash-core/src/test/java/org/logstash/JavafierTest.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/JavafierTest.java
rename to logstash-core/src/test/java/org/logstash/JavafierTest.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/KeyNodeTest.java b/logstash-core/src/test/java/org/logstash/KeyNodeTest.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/KeyNodeTest.java
rename to logstash-core/src/test/java/org/logstash/KeyNodeTest.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/RubyfierTest.java b/logstash-core/src/test/java/org/logstash/RubyfierTest.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/RubyfierTest.java
rename to logstash-core/src/test/java/org/logstash/RubyfierTest.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/StringInterpolationTest.java b/logstash-core/src/test/java/org/logstash/StringInterpolationTest.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/StringInterpolationTest.java
rename to logstash-core/src/test/java/org/logstash/StringInterpolationTest.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/TestBase.java b/logstash-core/src/test/java/org/logstash/TestBase.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/TestBase.java
rename to logstash-core/src/test/java/org/logstash/TestBase.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/TimestampTest.java b/logstash-core/src/test/java/org/logstash/TimestampTest.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/TimestampTest.java
rename to logstash-core/src/test/java/org/logstash/TimestampTest.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/ValuefierTest.java b/logstash-core/src/test/java/org/logstash/ValuefierTest.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/ValuefierTest.java
rename to logstash-core/src/test/java/org/logstash/ValuefierTest.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/bivalues/BiValueTest.java b/logstash-core/src/test/java/org/logstash/bivalues/BiValueTest.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/bivalues/BiValueTest.java
rename to logstash-core/src/test/java/org/logstash/bivalues/BiValueTest.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/bivalues/BiValuesTest.java b/logstash-core/src/test/java/org/logstash/bivalues/BiValuesTest.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/bivalues/BiValuesTest.java
rename to logstash-core/src/test/java/org/logstash/bivalues/BiValuesTest.java
diff --git a/logstash-core-event-java/src/test/java/org/logstash/bivalues/SomeJavaObject.java b/logstash-core/src/test/java/org/logstash/bivalues/SomeJavaObject.java
similarity index 100%
rename from logstash-core-event-java/src/test/java/org/logstash/bivalues/SomeJavaObject.java
rename to logstash-core/src/test/java/org/logstash/bivalues/SomeJavaObject.java
