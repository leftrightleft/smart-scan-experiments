diff --git a/bin/logstash b/bin/logstash
index 02e4446009c..fb1c5371739 100755
--- a/bin/logstash
+++ b/bin/logstash
@@ -22,11 +22,4 @@ unset CDPATH
 . "$(cd `dirname $0`/..; pwd)/bin/logstash.lib.sh"
 setup
 
-case $1 in
-  -*)
-    ruby_exec "${LOGSTASH_HOME}/lib/bootstrap/environment.rb" "logstash/runner.rb" "agent" "$@"
-    ;;
-  *)
-    ruby_exec "${LOGSTASH_HOME}/lib/bootstrap/environment.rb" "logstash/runner.rb" "$@"
-    ;;
-esac
+ruby_exec "${LOGSTASH_HOME}/lib/bootstrap/environment.rb" "logstash/runner.rb" "$@"
diff --git a/bin/logstash.bat b/bin/logstash.bat
index 4d8a8db646e..b773bc6c52d 100644
--- a/bin/logstash.bat
+++ b/bin/logstash.bat
@@ -11,9 +11,9 @@ set first_arg=%1
 setlocal EnableDelayedExpansion
 if "!first_arg:~0,1!" equ "-" (
   if "%VENDORED_JRUBY%" == "" (
-    %RUBYCMD% "%LS_HOME%\lib\bootstrap\environment.rb" "logstash\runner.rb" agent %*
+    %RUBYCMD% "%LS_HOME%\lib\bootstrap\environment.rb" "logstash\runner.rb" %*
   ) else (
-    %JRUBY_BIN% %jruby_opts% "%LS_HOME%\lib\bootstrap\environment.rb" "logstash\runner.rb" agent %*
+    %JRUBY_BIN% %jruby_opts% "%LS_HOME%\lib\bootstrap\environment.rb" "logstash\runner.rb" %*
   )
 ) else (
   if "%VENDORED_JRUBY%" == "" (
diff --git a/lib/bootstrap/environment.rb b/lib/bootstrap/environment.rb
index 50f2211160a..22c388099d6 100644
--- a/lib/bootstrap/environment.rb
+++ b/lib/bootstrap/environment.rb
@@ -64,5 +64,11 @@ def pattern_path(path)
 if $0 == __FILE__
   LogStash::Bundler.setup!({:without => [:build, :development]})
   require ARGV.shift
-  LogStash::Runner.new.main(ARGV)
+  # TODO deprecate these arguments in the next major version. use -i only
+  if ARGV == ["irb"] || ARGV == ["pry"]
+    puts "Warn: option \"#{ARGV.first}\" is deprecated, use \"-i #{ARGV.first}\" or \"--interactive=#{ARGV.first}\" instead"
+    LogStash::Runner.run("bin/logstash", ["--interactive", ARGV.first])
+  else
+    LogStash::Runner.run("bin/logstash", ARGV)
+  end
 end
diff --git a/logstash-core/lib/logstash/agent.rb b/logstash-core/lib/logstash/agent.rb
index 31b46d3a21e..1f307c61838 100644
--- a/logstash-core/lib/logstash/agent.rb
+++ b/logstash-core/lib/logstash/agent.rb
@@ -1,60 +1,42 @@
 # encoding: utf-8
-require "clamp" # gem 'clamp'
 require "logstash/environment"
 require "logstash/errors"
 require "logstash/config/cpu_core_strategy"
+require "logstash/pipeline"
 require "uri"
-require "net/http"
-LogStash::Environment.load_locale!
-
-class LogStash::Agent < Clamp::Command
-  DEFAULT_INPUT = "input { stdin { type => stdin } }"
-  DEFAULT_OUTPUT = "output { stdout { codec => rubydebug } }"
-
-  option ["-f", "--config"], "CONFIG_PATH",
-    I18n.t("logstash.agent.flag.config"),
-    :attribute_name => :config_path
+require "stud/trap"
 
-  option "-e", "CONFIG_STRING",
-    I18n.t("logstash.agent.flag.config-string",
-           :default_input => DEFAULT_INPUT, :default_output => DEFAULT_OUTPUT),
-    :default => "", :attribute_name => :config_string
-
-  option ["-w", "--filterworkers"], "COUNT",
-    I18n.t("logstash.agent.flag.filterworkers"),
-    :attribute_name => :filter_workers,
-    :default => 0, &:to_i
-
-  option ["-l", "--log"], "FILE",
-    I18n.t("logstash.agent.flag.log"),
-    :attribute_name => :log_file
+LogStash::Environment.load_locale!
 
-  # Old support for the '-v' flag'
-  option "-v", :flag,
-    I18n.t("logstash.agent.flag.verbosity"),
-    :attribute_name => :verbosity, :multivalued => true
+class LogStash::Agent
 
-  option "--quiet", :flag, I18n.t("logstash.agent.flag.quiet")
-  option "--verbose", :flag, I18n.t("logstash.agent.flag.verbose")
-  option "--debug", :flag, I18n.t("logstash.agent.flag.debug")
+  attr_writer :logger
 
-  option ["-V", "--version"], :flag,
-    I18n.t("logstash.agent.flag.version")
+  def initialize
+    @pipelines = {}
+  end
 
- option ["-p", "--pluginpath"] , "PATH",
-   I18n.t("logstash.agent.flag.pluginpath"),
-   :multivalued => true,
-   :attribute_name => :plugin_paths
+  def execute
+    # Make SIGINT/SIGTERM shutdown the pipeline.
+    sigint_id = trap_sigint()
+    sigterm_id = trap_sigterm()
 
-  option ["-t", "--configtest"], :flag,
-    I18n.t("logstash.agent.flag.configtest"),
-    :attribute_name => :config_test
+    @pipelines.each {|_, p| p.run } # blocking operation. works now because size <= 1
+    return 0
+  rescue => e
+    @logger.fatal I18n.t("oops", :error => e)
+    @logger.fatal e.backtrace if @logger.debug? || $DEBUGLIST.include?("stacktrace")
+    return 1
+  ensure
+    Stud::untrap("INT", sigint_id) unless sigint_id.nil?
+    Stud::untrap("TERM", sigterm_id) unless sigterm_id.nil?
+  end # def execute
 
-  option "--[no-]allow-unsafe-shutdown", :flag,
-    I18n.t("logstash.agent.flag.unsafe_shutdown"),
-    :attribute_name => :unsafe_shutdown,
-    :default => false
+  def add_pipeline(pipeline_id, config_str, settings = {})
+    @pipelines[pipeline_id] = LogStash::Pipeline.new(config_str, settings)
+  end
 
+  private
   # Emit a warning message.
   def warn(message)
     # For now, all warnings are fatal.
@@ -66,69 +48,23 @@ def fail(message)
     raise LogStash::ConfigurationError, message
   end # def fail
 
-  def report(message)
-    # Print to stdout just in case we're logging to a file
-    puts message
-    @logger.log(message) if log_file
-  end
-
-  # Run the agent. This method is invoked after clamp parses the
-  # flags given to this program.
-  def execute
-    require "logstash/pipeline"
-    require "cabin" # gem 'cabin'
-    require "logstash/plugin"
-    @logger = Cabin::Channel.get(LogStash)
-
-    LogStash::ShutdownController.unsafe_shutdown = unsafe_shutdown?
-    LogStash::ShutdownController.logger = @logger
-
-    if version?
-      show_version
-      return 0
-    end
-
-    # temporarily send logs to stdout as well if a --log is specified
-    # and stdout appears to be a tty
-    show_startup_errors = log_file && STDOUT.tty?
-
-    if show_startup_errors
-      stdout_logs = @logger.subscribe(STDOUT)
-    end
-    configure
-
-    # You must specify a config_string or config_path
-    if @config_string.nil? && @config_path.nil?
-      fail(help + "\n" + I18n.t("logstash.agent.missing-configuration"))
-    end
-
-    @config_string = @config_string.to_s
-
-    if @config_path
-      # Append the config string.
-      # This allows users to provide both -f and -e flags. The combination
-      # is rare, but useful for debugging.
-      @config_string = @config_string + load_config(@config_path)
-    else
-      # include a default stdin input if no inputs given
-      if @config_string !~ /input *{/
-        @config_string += DEFAULT_INPUT
-      end
-      # include a default stdout output if no outputs given
-      if @config_string !~ /output *{/
-        @config_string += DEFAULT_OUTPUT
+  def shutdown_pipelines
+    @pipelines.each do |_, pipeline|
+      pipeline.shutdown do
+        ::LogStash::ShutdownController.start(pipeline)
       end
     end
+  end
 
-    begin
-      pipeline = LogStash::Pipeline.new(@config_string)
-    rescue LoadError => e
-      fail("Configuration problem.")
+  def trap_sigterm
+    Stud::trap("TERM") do
+      @logger.warn(I18n.t("logstash.agent.sigterm"))
+      shutdown_pipelines
     end
+  end
 
-    # Make SIGINT shutdown the pipeline.
-    sigint_id = Stud::trap("INT") do
-
+  def trap_sigint
+    Stud::trap("INT") do
       if @interrupted_once
         @logger.fatal(I18n.t("logstash.agent.forced_sigint"))
         exit
@@ -136,219 +72,8 @@ def execute
         @logger.warn(I18n.t("logstash.agent.sigint"))
         Thread.new(@logger) {|logger| sleep 5; logger.warn(I18n.t("logstash.agent.slow_shutdown")) }
         @interrupted_once = true
-        shutdown(pipeline)
-      end
-    end
-
-    # Make SIGTERM shutdown the pipeline.
-    sigterm_id = Stud::trap("TERM") do
-      @logger.warn(I18n.t("logstash.agent.sigterm"))
-      shutdown(pipeline)
-    end
-
-    Stud::trap("HUP") do
-      @logger.info(I18n.t("logstash.agent.sighup"))
-      configure_logging(log_file)
-    end
-
-    pipeline.configure("filter-workers", filter_workers) if filter_workers > 0
-
-    # Stop now if we are only asking for a config test.
-    if config_test?
-      report "Configuration OK"
-      return
-    end
-
-    @logger.unsubscribe(stdout_logs) if show_startup_errors
-
-    # TODO(sissel): Get pipeline completion status.
-    pipeline.run
-    return 0
-  rescue LogStash::ConfigurationError => e
-    @logger.unsubscribe(stdout_logs) if show_startup_errors
-    report I18n.t("logstash.agent.error", :error => e)
-    if !config_test?
-      report I18n.t("logstash.agent.configtest-flag-information")
-    end
-    return 1
-  rescue => e
-    @logger.unsubscribe(stdout_logs) if show_startup_errors
-    report I18n.t("oops", :error => e)
-    report e.backtrace if @logger.debug? || $DEBUGLIST.include?("stacktrace")
-    return 1
-  ensure
-    @log_fd.close if @log_fd
-    Stud::untrap("INT", sigint_id) unless sigint_id.nil?
-    Stud::untrap("TERM", sigterm_id) unless sigterm_id.nil?
-  end # def execute
-
-  def shutdown(pipeline)
-    pipeline.shutdown do
-      ::LogStash::ShutdownController.start(pipeline)
-    end
-  end
-
-  def show_version
-    show_version_logstash
-
-    if [:info, :debug].include?(verbosity?) || debug? || verbose?
-      show_version_ruby
-      show_version_java if LogStash::Environment.jruby?
-      show_gems if [:debug].include?(verbosity?) || debug?
-    end
-  end # def show_version
-
-  def show_version_logstash
-    require "logstash/version"
-    puts "logstash #{LOGSTASH_VERSION}"
-  end # def show_version_logstash
-
-  def show_version_ruby
-    puts RUBY_DESCRIPTION
-  end # def show_version_ruby
-
-  def show_version_java
-    properties = java.lang.System.getProperties
-    puts "java #{properties["java.version"]} (#{properties["java.vendor"]})"
-    puts "jvm #{properties["java.vm.name"]} / #{properties["java.vm.version"]}"
-  end # def show_version_java
-
-  def show_gems
-    require "rubygems"
-    Gem::Specification.each do |spec|
-      puts "gem #{spec.name} #{spec.version}"
-    end
-  end # def show_gems
-
-  # Do any start-time configuration.
-  #
-  # Log file stuff, plugin path checking, etc.
-  def configure
-    configure_logging(log_file)
-    configure_plugin_paths(plugin_paths)
-  end # def configure
-
-  # Point logging at a specific path.
-  def configure_logging(path)
-    # Set with the -v (or -vv...) flag
-    if quiet?
-      @logger.level = :error
-    elsif verbose?
-      @logger.level = :info
-    elsif debug?
-      @logger.level = :debug
-    else
-      # Old support for the -v and -vv stuff.
-      if verbosity? && verbosity?.any?
-        # this is an array with length of how many times the flag is given
-        if verbosity?.length == 1
-          @logger.warn("The -v flag is deprecated and will be removed in a future release. You should use --verbose instead.")
-          @logger.level = :info
-        else
-          @logger.warn("The -vv flag is deprecated and will be removed in a future release. You should use --debug instead.")
-          @logger.level = :debug
-        end
-      else
-        @logger.level = :warn
-      end
-    end
-
-    if log_file
-      # TODO(sissel): Implement file output/rotation in Cabin.
-      # TODO(sissel): Catch exceptions, report sane errors.
-      begin
-        @log_fd.close if @log_fd
-        @log_fd = File.new(path, "a")
-      rescue => e
-        fail(I18n.t("logstash.agent.configuration.log_file_failed",
-                    :path => path, :error => e))
+        shutdown_pipelines
       end
-
-      puts "Sending logstash logs to #{path}."
-      @logger.unsubscribe(@logger_subscription) if @logger_subscription
-      @logger_subscription = @logger.subscribe(@log_fd)
-    else
-      @logger.subscribe(STDOUT)
-    end
-
-    # TODO(sissel): redirect stdout/stderr to the log as well
-    # http://jira.codehaus.org/browse/JRUBY-7003
-  end # def configure_logging
-
-  # add the given paths for ungemified/bare plugins lookups
-  # @param paths [String, Array<String>] plugins path string or list of path strings to add
-  def configure_plugin_paths(paths)
-    Array(paths).each do |path|
-      fail(I18n.t("logstash.agent.configuration.plugin_path_missing", :path => path)) unless File.directory?(path)
-      LogStash::Environment.add_plugin_path(path)
-    end
-  end
-
-  def load_config(path)
-    begin
-      uri = URI.parse(path)
-
-      case uri.scheme
-      when nil then
-        local_config(path)
-      when /http/ then
-        fetch_config(uri)
-      when "file" then
-        local_config(uri.path)
-      else
-        fail(I18n.t("logstash.agent.configuration.scheme-not-supported", :path => path))
-      end
-    rescue URI::InvalidURIError
-      # fallback for windows.
-      # if the parsing of the file failed we assume we can reach it locally.
-      # some relative path on windows arent parsed correctly (.\logstash.conf)
-      local_config(path)
-    end
-  end
-
-  def local_config(path)
-    path = File.expand_path(path)
-    path = File.join(path, "*") if File.directory?(path)
-
-    if Dir.glob(path).length == 0
-      fail(I18n.t("logstash.agent.configuration.file-not-found", :path => path))
-    end
-
-    config = ""
-    encoding_issue_files = []
-    Dir.glob(path).sort.each do |file|
-      next unless File.file?(file)
-      if file.match(/~$/)
-        @logger.debug("NOT reading config file because it is a temp file", :config_file => file)
-        next
-      end
-      @logger.debug("Reading config file", :config_file => file)
-      cfg = File.read(file)
-      if !cfg.ascii_only? && !cfg.valid_encoding?
-        encoding_issue_files << file
-      end
-      config << cfg + "\n"
-      if config_test?
-        @logger.debug? && @logger.debug("\nThe following is the content of a file", :config_file => file.to_s)
-        @logger.debug? && @logger.debug("\n" + cfg + "\n\n")
-      end
-    end
-    if (encoding_issue_files.any?)
-      fail("The following config files contains non-ascii characters but are not UTF-8 encoded #{encoding_issue_files}")
-    end
-    if config_test?
-      @logger.debug? && @logger.debug("\nThe following is the merged configuration")
-      @logger.debug? && @logger.debug("\n" + config + "\n\n")
-    end
-    return config
-  end # def load_config
-
-  def fetch_config(uri)
-    begin
-      Net::HTTP.get(uri) + "\n"
-    rescue Exception => e
-      fail(I18n.t("logstash.agent.configuration.fetch-failed", :path => uri.to_s, :message => e.message))
     end
   end
-
 end # class LogStash::Agent
diff --git a/logstash-core/lib/logstash/config/config_ast.rb b/logstash-core/lib/logstash/config/config_ast.rb
index ace7322fedb..0c25e05d6ab 100644
--- a/logstash-core/lib/logstash/config/config_ast.rb
+++ b/logstash-core/lib/logstash/config/config_ast.rb
@@ -339,7 +339,7 @@ def validate!
 
       if duplicate_values.size > 0
         raise ConfigurationError.new(
-          I18n.t("logstash.agent.configuration.invalid_plugin_settings_duplicate_keys",
+          I18n.t("logstash.runner.configuration.invalid_plugin_settings_duplicate_keys",
                  :keys => duplicate_values.join(', '),
                  :line => input.line_of(interval.first),
                  :column => input.column_of(interval.first),
diff --git a/logstash-core/lib/logstash/config/mixin.rb b/logstash-core/lib/logstash/config/mixin.rb
index cbfdcf62331..21c54f66ffe 100644
--- a/logstash-core/lib/logstash/config/mixin.rb
+++ b/logstash-core/lib/logstash/config/mixin.rb
@@ -101,7 +101,7 @@ def config_init(params)
 
     if !self.class.validate(params)
       raise LogStash::ConfigurationError,
-        I18n.t("logstash.agent.configuration.invalid_plugin_settings")
+        I18n.t("logstash.runner.configuration.invalid_plugin_settings")
     end
 
     # We remove any config options marked as obsolete,
@@ -287,7 +287,7 @@ def validate_check_required_parameter_names(params)
         elsif config_key.is_a?(String)
           next if params.keys.member?(config_key)
         end
-        @logger.error(I18n.t("logstash.agent.configuration.setting_missing",
+        @logger.error(I18n.t("logstash.runner.configuration.setting_missing",
                              :setting => config_key, :plugin => @plugin_name,
                              :type => @plugin_type))
         is_valid = false
@@ -314,7 +314,7 @@ def validate_check_parameter_values(params)
             # Used for converting values in the config to proper objects.
             params[key] = result if !result.nil?
           else
-            @logger.error(I18n.t("logstash.agent.configuration.setting_invalid",
+            @logger.error(I18n.t("logstash.runner.configuration.setting_invalid",
                                  :plugin => @plugin_name, :type => @plugin_type,
                                  :setting => key, :value => value.inspect,
                                  :value_type => config_val,
diff --git a/logstash-core/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
index ed943f3180c..48aa1c8a83d 100644
--- a/logstash-core/lib/logstash/pipeline.rb
+++ b/logstash-core/lib/logstash/pipeline.rb
@@ -16,7 +16,7 @@
 module LogStash; class Pipeline
   attr_reader :inputs, :filters, :outputs, :input_to_filter, :filter_to_output
 
-  def initialize(configstr)
+  def initialize(config_str, settings = {})
     @logger = Cabin::Channel.get(LogStash)
 
     @inputs = nil
@@ -24,7 +24,7 @@ def initialize(configstr)
     @outputs = nil
 
     grammar = LogStashConfigParser.new
-    @config = grammar.parse(configstr)
+    @config = grammar.parse(config_str)
 
     if @config.nil?
       raise LogStash::ConfigurationError, grammar.failure_reason
@@ -53,6 +53,7 @@ def initialize(configstr)
     # @ready requires thread safety since it is typically polled from outside the pipeline thread
     @ready = Concurrent::AtomicBoolean.new(false)
     @input_threads = []
+    settings.each {|setting, value| configure(setting, value) }
   end # def initialize
 
   def ready?
diff --git a/logstash-core/lib/logstash/runner.rb b/logstash-core/lib/logstash/runner.rb
index 4831d533025..ee9c0dceb61 100644
--- a/logstash-core/lib/logstash/runner.rb
+++ b/logstash-core/lib/logstash/runner.rb
@@ -3,22 +3,82 @@
 Encoding.default_external = Encoding::UTF_8
 $DEBUGLIST = (ENV["DEBUG"] || "").split(",")
 
+require "clamp" # gem 'clamp'
+require "net/http"
 require "logstash/environment"
 
 LogStash::Environment.load_locale!
 
 require "logstash/namespace"
-require "logstash/program"
+require "logstash/agent"
 
-class LogStash::Runner
-  include LogStash::Program
+class LogStash::Runner < Clamp::Command
 
-  def main(args)
+  DEFAULT_INPUT = "input { stdin { type => stdin } }"
+  DEFAULT_OUTPUT = "output { stdout { codec => rubydebug } }"
+
+  option ["-f", "--config"], "CONFIG_PATH",
+    I18n.t("logstash.runner.flag.config"),
+    :attribute_name => :config_path
+
+  option "-e", "CONFIG_STRING",
+    I18n.t("logstash.runner.flag.config-string",
+           :default_input => DEFAULT_INPUT, :default_output => DEFAULT_OUTPUT),
+    :default => "", :attribute_name => :config_string
+
+  option ["-w", "--filterworkers"], "COUNT",
+    I18n.t("logstash.runner.flag.filterworkers"),
+    :attribute_name => :filter_workers,
+    :default => LogStash::Config::CpuCoreStrategy.fifty_percent, &:to_i
+
+  option ["-l", "--log"], "FILE",
+    I18n.t("logstash.runner.flag.log"),
+    :attribute_name => :log_file
+
+  # Old support for the '-v' flag'
+  option "-v", :flag,
+    I18n.t("logstash.runner.flag.verbosity"),
+    :attribute_name => :verbosity, :multivalued => true
+
+  option "--quiet", :flag, I18n.t("logstash.runner.flag.quiet")
+  option "--verbose", :flag, I18n.t("logstash.runner.flag.verbose")
+  option "--debug", :flag, I18n.t("logstash.runner.flag.debug")
+
+  option ["-V", "--version"], :flag,
+    I18n.t("logstash.runner.flag.version")
+
+  option ["-p", "--pluginpath"] , "PATH",
+    I18n.t("logstash.runner.flag.pluginpath"),
+    :multivalued => true,
+    :attribute_name => :plugin_paths
+
+  option ["-t", "--configtest"], :flag,
+    I18n.t("logstash.runner.flag.configtest"),
+    :attribute_name => :config_test
+
+  option "--[no-]allow-unsafe-shutdown", :flag,
+    I18n.t("logstash.agent.flag.unsafe_shutdown"),
+    :attribute_name => :unsafe_shutdown,
+    :default => false
+
+  option ["-i", "--interactive"], "SHELL",
+    I18n.t("logstash.runner.flag.rubyshell"),
+    :attribute_name => :ruby_shell
+
+  attr_reader :agent
+
+  def initialize(*args)
+    @agent = LogStash::Agent.new
+    super(*args)
+  end
+
+  def execute
     require "logstash/util"
     require "logstash/util/java_version"
-    require "stud/trap"
     require "stud/task"
-    @startup_interruption_trap = Stud::trap("INT") { puts "Interrupted"; exit 0 }
+    require "cabin" # gem 'cabin'
+
+    @logger = Cabin::Channel.get(LogStash)
 
     LogStash::Util::set_thread_name(self.class.name)
 
@@ -30,95 +90,256 @@ def main(args)
     # Print a warning to STDERR for bad java versions
     LogStash::Util::JavaVersion.warn_on_bad_java_version
 
-    Stud::untrap("INT", @startup_interruption_trap)
+    LogStash::ShutdownController.unsafe_shutdown = unsafe_shutdown?
+    LogStash::ShutdownController.logger = @logger
+
+    configure
+
+    if version?
+      show_version
+      return 0
+    end
+
+    return start_shell(@ruby_shell, binding) if @ruby_shell
+
+    if @config_string.nil? && @config_path.nil?
+      fail(I18n.t("logstash.runner.missing-configuration"))
+    end
+
+    @agent.logger = @logger
+
+    config_string = format_config(@config_path, @config_string)
 
-    task = run(args)
-    exit(task.wait)
+    @agent.add_pipeline("base", config_string, :filter_workers => filter_workers)
+
+    if config_test?
+      puts "Configuration OK"
+    else
+      task = Stud::Task.new { @agent.execute }
+      return task.wait
+    end
+
+  rescue LoadError => e
+    fail("Configuration problem.")
+  rescue LogStash::ConfigurationError => e
+    @logger.fatal I18n.t("logstash.error", :error => e)
+    if !config_test?
+      @logger.warn I18n.t("logstash.runner.configtest-flag-information")
+    end
+    show_short_help
+    return 1
+  rescue => e
+    @logger.fatal I18n.t("oops", :error => e)
+    @logger.debug e.backtrace if $DEBUGLIST.include?("stacktrace")
+  ensure
+    @log_fd.close if @log_fd
   end # def self.main
 
-  def run(args)
-    command = args.shift
-    commands = {
-      "version" => lambda do
-        require "logstash/agent"
-        agent_args = ["--version"]
-        if args.include?("--verbose")
-          agent_args << "--verbose"
-        end
-        return LogStash::Agent.run($0, agent_args)
-      end,
-      "irb" => lambda do
-        require "irb"
-        return IRB.start(__FILE__)
-      end,
-      "pry" => lambda do
-        require "pry"
-        return binding.pry
-      end,
-      "docgen" => lambda do
-        require 'docs/asciidocgen'
-        opts = OptionParser.new
-        settings = {}
-        opts.on("-o DIR", "--output DIR",
-          "Directory to output to; optional. If not specified,"\
-          "we write to stdout.") do |val|
-          settings[:output] = val
-        end
-        args = opts.parse(ARGV)
-        docs = LogStashConfigAsciiDocGenerator.new
-        args.each do |arg|
-          docs.generate(arg, settings)
-        end
-        return 0
-      end,
-      "agent" => lambda do
-        require "logstash/agent"
-        # Hack up a runner
-        agent = LogStash::Agent.new("/bin/logstash agent", $0)
-        begin
-          agent.parse(args)
-        rescue Clamp::HelpWanted => e
-          show_help(e.command)
-          return 0
-        rescue Clamp::UsageError => e
-          # If 'too many arguments' then give the arguments to
-          # the next command. Otherwise it's a real error.
-          raise if e.message != "too many arguments"
-          remaining = agent.remaining_arguments
+  def show_version
+    show_version_logstash
+
+    if [:info, :debug].include?(verbosity?) || debug? || verbose?
+      show_version_ruby
+      show_version_java if LogStash::Environment.jruby?
+      show_gems if [:debug].include?(verbosity?) || debug?
+    end
+  end # def show_version
+
+  def show_version_logstash
+    require "logstash/version"
+    puts "logstash #{LOGSTASH_VERSION}"
+  end # def show_version_logstash
+
+  def show_version_ruby
+    puts RUBY_DESCRIPTION
+  end # def show_version_ruby
+
+  def show_version_java
+    properties = java.lang.System.getProperties
+    puts "java #{properties["java.version"]} (#{properties["java.vendor"]})"
+    puts "jvm #{properties["java.vm.name"]} / #{properties["java.vm.version"]}"
+  end # def show_version_java
+
+  def show_gems
+    require "rubygems"
+    Gem::Specification.each do |spec|
+      puts "gem #{spec.name} #{spec.version}"
+    end
+  end # def show_gems
+
+  # Do any start-time configuration.
+  #
+  # Log file stuff, plugin path checking, etc.
+  def configure
+    configure_logging(log_file)
+    configure_plugin_paths(plugin_paths)
+  end # def configure
+
+  # add the given paths for ungemified/bare plugins lookups
+  # @param paths [String, Array<String>] plugins path string or list of path strings to add
+  def configure_plugin_paths(paths)
+    Array(paths).each do |path|
+      fail(I18n.t("logstash.runner.configuration.plugin_path_missing", :path => path)) unless File.directory?(path)
+      LogStash::Environment.add_plugin_path(path)
+    end
+  end
+
+  # Point logging at a specific path.
+  def configure_logging(path)
+    # Set with the -v (or -vv...) flag
+    if quiet?
+      @logger.level = :error
+    elsif verbose?
+      @logger.level = :info
+    elsif debug?
+      @logger.level = :debug
+    else
+      # Old support for the -v and -vv stuff.
+      if verbosity? && verbosity?.any?
+        # this is an array with length of how many times the flag is given
+        if verbosity?.length == 1
+          @logger.warn("The -v flag is deprecated and will be removed in a future release. You should use --verbose instead.")
+          @logger.level = :info
+        else
+          @logger.warn("The -vv flag is deprecated and will be removed in a future release. You should use --debug instead.")
+          @logger.level = :debug
         end
+      else
+        @logger.level = :warn
+      end
+    end
 
-        return agent.execute
+    if log_file
+      # TODO(sissel): Implement file output/rotation in Cabin.
+      # TODO(sissel): Catch exceptions, report sane errors.
+      begin
+        @log_fd.close if @log_fd
+        @log_fd = File.new(path, "a")
+      rescue => e
+        fail(I18n.t("logstash.runner.configuration.log_file_failed",
+                    :path => path, :error => e))
       end
-    } # commands
 
-    if commands.include?(command)
-      return Stud::Task.new { commands[command].call }
+      @logger.subscribe(STDOUT, :level => :fatal)
+      @logger.subscribe(@log_fd)
+      @logger.terminal "Sending logstash logs to #{path}."
     else
-      if command.nil?
-        $stderr.puts "No command given"
+      @logger.subscribe(STDOUT)
+    end
+
+    # TODO(sissel): redirect stdout/stderr to the log as well
+    # http://jira.codehaus.org/browse/JRUBY-7003
+  end # def configure_logging
+
+  def format_config(config_path, config_string)
+    config_string = config_string.to_s
+    if config_path
+      # Append the config string.
+      # This allows users to provide both -f and -e flags. The combination
+      # is rare, but useful for debugging.
+      config_string = config_string + load_config(config_path)
+    else
+      # include a default stdin input if no inputs given
+      if config_string !~ /input *{/
+        config_string += DEFAULT_INPUT
+      end
+      # include a default stdout output if no outputs given
+      if config_string !~ /output *{/
+        config_string += DEFAULT_OUTPUT
+      end
+    end
+    config_string
+  end
+
+  def load_config(path)
+    begin
+      uri = URI.parse(path)
+
+      case uri.scheme
+      when nil then
+        local_config(path)
+      when /http/ then
+        fetch_config(uri)
+      when "file" then
+        local_config(uri.path)
       else
-        if !%w(--help -h help).include?(command)
-          # Emit 'no such command' if it's not someone asking for help.
-          $stderr.puts "No such command #{command.inspect}"
-        end
+        fail(I18n.t("logstash.runner.configuration.scheme-not-supported", :path => path))
       end
-      $stderr.puts %q[
-Usage: logstash <command> [command args]
-Run a command with the --help flag to see the arguments.
-For example: logstash agent --help
+    rescue URI::InvalidURIError
+      # fallback for windows.
+      # if the parsing of the file failed we assume we can reach it locally.
+      # some relative path on windows arent parsed correctly (.\logstash.conf)
+      local_config(path)
+    end
+  end
+
+  def local_config(path)
+    path = File.expand_path(path)
+    path = File.join(path, "*") if File.directory?(path)
 
-Available commands:
-  agent - runs the logstash agent
-  version - emits version info about this logstash
-]
-      #$stderr.puts commands.keys.map { |s| "  #{s}" }.join("\n")
-      return Stud::Task.new { 1 }
+    if Dir.glob(path).length == 0
+      fail(I18n.t("logstash.runner.configuration.file-not-found", :path => path))
     end
-  end # def run
 
-  private
+    config = ""
+    encoding_issue_files = []
+    Dir.glob(path).sort.each do |file|
+      next unless File.file?(file)
+      if file.match(/~$/)
+        @logger.debug("NOT reading config file because it is a temp file", :config_file => file)
+        next
+      end
+      @logger.debug("Reading config file", :config_file => file)
+      cfg = File.read(file)
+      if !cfg.ascii_only? && !cfg.valid_encoding?
+        encoding_issue_files << file
+      end
+      config << cfg + "\n"
+      if config_test?
+        @logger.debug? && @logger.debug("\nThe following is the content of a file", :config_file => file.to_s)
+        @logger.debug? && @logger.debug("\n" + cfg + "\n\n")
+      end
+    end
+    if (encoding_issue_files.any?)
+      fail("The following config files contains non-ascii characters but are not UTF-8 encoded #{encoding_issue_files}")
+    end
+    if config_test?
+      @logger.debug? && @logger.debug("\nThe following is the merged configuration")
+      @logger.debug? && @logger.debug("\n" + config + "\n\n")
+    end
+    return config
+  end # def load_config
+
+  def fetch_config(uri)
+    begin
+      Net::HTTP.get(uri) + "\n"
+    rescue Exception => e
+      fail(I18n.t("logstash.runner.configuration.fetch-failed", :path => uri.to_s, :message => e.message))
+    end
+  end
+
+  # Emit a failure message and abort.
+  def fail(message)
+    raise LogStash::ConfigurationError, message
+  end # def fail
 
-  def show_help(command)
-    puts command.help
+  def show_short_help
+    puts I18n.t("logstash.runner.short-help")
+  end
+
+  def start_shell(shell, start_binding)
+    case shell
+    when "pry"
+      require 'pry'
+      start_binding.pry
+    when "irb"
+      require 'irb'
+      ARGV.clear
+      # TODO: set binding to this instance of Runner
+      # currently bugged as per https://github.com/jruby/jruby/issues/384
+      IRB.start(__FILE__)
+    else
+      fail(I18n.t("logstash.runner.invalid-shell"))
+    end
   end
 end # class LogStash::Runner
diff --git a/logstash-core/locales/en.yml b/logstash-core/locales/en.yml
index 3626144521a..1b2ce1dd51c 100644
--- a/logstash-core/locales/en.yml
+++ b/logstash-core/locales/en.yml
@@ -7,6 +7,8 @@ en:
     The error reported is: 
       %{error}
   logstash:
+    error: >-
+      Error: %{error}
     environment:
       jruby-required:  >-
         JRuby is required
@@ -57,11 +59,6 @@ en:
     agent:
       sighup: >-
         SIGHUP received.
-      missing-configuration: >-
-        No configuration file was specified. Perhaps you forgot to provide
-        the '-f yourlogstash.conf' flag?
-      error: >-
-        Error: %{error}
       sigint: >-
         SIGINT received. Shutting down the pipeline.
       sigterm: >-
@@ -72,10 +69,22 @@ en:
         data loss.
       forced_sigint: >-
         SIGINT received. Terminating immediately..
+    runner:
+      short-help: |-
+        usage:
+          bin/logstash -f CONFIG_FILE [-t] [--quiet|verbose|debug] [-w COUNT] [-l LOG]
+          bin/logstash -e CONFIG_STR [-t] [--quiet|verbose|debug] [-w COUNT] [-l LOG]
+          bin/logstash -i SHELL [--quiet|verbose|debug]
+          bin/logstash -V [--verbose|debug]
+          bin/logstash --help
+      missing-configuration: >-
+        No configuration file was specified. Perhaps you forgot to provide
+        the '-f yourlogstash.conf' flag?
+      invalid-shell: >-
+        Invalid option for interactive Ruby shell. Use either "irb" or "pry"
       configtest-flag-information: |-
-        You may be interested in the '--configtest' flag which you can
-        use to validate logstash's configuration before you choose
-        to restart a running system.
+        You may be interested in the '--configtest' flag which you can use to validate
+        logstash's configuration before you choose to restart a running system.
       configuration:
         obsolete: >-
           The setting `%{name}` in plugin `%{plugin}` is obsolete and is no
@@ -192,3 +201,6 @@ en:
           if there are still inflight events in memory.
           By default, logstash will refuse to quit until all
           received events have been pushed to the outputs.
+        rubyshell: |+
+          Drop to shell instead of running as normal.
+          Valid shells are "irb" and "pry"
diff --git a/logstash-core/spec/logstash/agent_spec.rb b/logstash-core/spec/logstash/agent_spec.rb
index 54f994d88f4..9a609ddf886 100644
--- a/logstash-core/spec/logstash/agent_spec.rb
+++ b/logstash-core/spec/logstash/agent_spec.rb
@@ -2,61 +2,4 @@
 require 'spec_helper'
 
 describe LogStash::Agent do
-  subject { LogStash::Agent.new('') }
-  let(:dummy_config) { 'input {}' }
-
-  context "when loading the configuration" do
-    context "when local" do
-      before { expect(subject).to receive(:local_config).with(path) }
-
-      context "unix" do
-        let(:path) { './test.conf' }
-        it 'works with relative path' do
-          subject.load_config(path)
-        end
-      end
-
-      context "windows" do
-        let(:path) { '.\test.conf' }
-        it 'work with relative windows path' do
-          subject.load_config(path)
-        end
-      end
-    end
-
-    context "when remote" do
-      context 'supported scheme' do
-        let(:path) { "http://test.local/superconfig.conf" }
-
-        before { expect(Net::HTTP).to receive(:get) { dummy_config } }
-        it 'works with http' do
-          expect(subject.load_config(path)).to eq("#{dummy_config}\n")
-        end
-      end
-    end
-  end
-
-  context "--pluginpath" do
-    let(:single_path) { "/some/path" }
-    let(:multiple_paths) { ["/some/path1", "/some/path2"] }
-
-    it "should add single valid dir path to the environment" do
-      expect(File).to receive(:directory?).and_return(true)
-      expect(LogStash::Environment).to receive(:add_plugin_path).with(single_path)
-      subject.configure_plugin_paths(single_path)
-    end
-
-    it "should fail with single invalid dir path" do
-      expect(File).to receive(:directory?).and_return(false)
-      expect(LogStash::Environment).not_to receive(:add_plugin_path)
-      expect{subject.configure_plugin_paths(single_path)}.to raise_error(LogStash::ConfigurationError)
-    end
-
-    it "should add multiple valid dir path to the environment" do
-      expect(File).to receive(:directory?).exactly(multiple_paths.size).times.and_return(true)
-      multiple_paths.each{|path| expect(LogStash::Environment).to receive(:add_plugin_path).with(path)}
-      subject.configure_plugin_paths(multiple_paths)
-    end
-  end
 end
-
diff --git a/logstash-core/spec/logstash/runner_spec.rb b/logstash-core/spec/logstash/runner_spec.rb
index b61cab7bf30..3dec2c0e7ef 100644
--- a/logstash-core/spec/logstash/runner_spec.rb
+++ b/logstash-core/spec/logstash/runner_spec.rb
@@ -9,32 +9,92 @@ def run(args); end
 
 describe LogStash::Runner do
 
-  context "argument parsing" do
-    it "should run agent" do
-      expect(Stud::Task).to receive(:new).once.and_return(nil)
-      args = ["agent", "-e", ""]
-      expect(subject.run(args)).to eq(nil)
+  subject { LogStash::Runner }
+  let(:channel) { Cabin::Channel.new }
+
+  before :each do
+    allow(Cabin::Channel).to receive(:get).with(LogStash).and_return(channel)
+  end
+
+  describe "argument parsing" do
+
+    subject { LogStash::Runner.new("") }
+    context "when -e is given" do
+
+      let(:args) { ["-e", ""] }
+
+      it "should execute the agent" do
+        expect(subject.agent).to receive(:add_pipeline).once
+        expect(subject.agent).to receive(:execute).once
+        subject.run(args)
+      end
     end
 
-    it "should run agent help" do
-      expect(subject).to receive(:show_help).once.and_return(nil)
-      args = ["agent", "-h"]
-      expect(subject.run(args).wait).to eq(0)
+    context "with no arguments" do
+      let(:args) { [] }
+      it "should show help" do
+        expect(subject).to receive(:show_short_help).once
+        expect(channel).to receive(:fatal).once
+        expect(channel).to receive(:warn).once
+        subject.run(args)
+      end
     end
+  end
+
+  context "when loading the configuration" do
+    subject { LogStash::Runner.new("") }
+    context "when local" do
+      before { expect(subject).to receive(:local_config).with(path) }
+
+      context "unix" do
+        let(:path) { './test.conf' }
+        it 'works with relative path' do
+          subject.load_config(path)
+        end
+      end
 
-    it "should show help with no arguments" do
-      expect($stderr).to receive(:puts).once.and_return("No command given")
-      expect($stderr).to receive(:puts).once
-      args = []
-      expect(subject.run(args).wait).to eq(1)
+      context "windows" do
+        let(:path) { '.\test.conf' }
+        it 'work with relative windows path' do
+          subject.load_config(path)
+        end
+      end
     end
 
-    it "should show help for unknown commands" do
-      expect($stderr).to receive(:puts).once.and_return("No such command welp")
-      expect($stderr).to receive(:puts).once
-      args = ["welp"]
-      expect(subject.run(args).wait).to eq(1)
+    context "when remote" do
+      context 'supported scheme' do
+        let(:path) { "http://test.local/superconfig.conf" }
+        let(:dummy_config) { 'input {}' }
+
+        before { expect(Net::HTTP).to receive(:get) { dummy_config } }
+        it 'works with http' do
+          expect(subject.load_config(path)).to eq("#{dummy_config}\n")
+        end
+      end
+    end
+  end
+
+  context "--pluginpath" do
+    subject { LogStash::Runner.new("") }
+    let(:single_path) { "/some/path" }
+    let(:multiple_paths) { ["/some/path1", "/some/path2"] }
+
+    it "should add single valid dir path to the environment" do
+      expect(File).to receive(:directory?).and_return(true)
+      expect(LogStash::Environment).to receive(:add_plugin_path).with(single_path)
+      subject.configure_plugin_paths(single_path)
+    end
+
+    it "should fail with single invalid dir path" do
+      expect(File).to receive(:directory?).and_return(false)
+      expect(LogStash::Environment).not_to receive(:add_plugin_path)
+      expect{subject.configure_plugin_paths(single_path)}.to raise_error(LogStash::ConfigurationError)
     end
 
+    it "should add multiple valid dir path to the environment" do
+      expect(File).to receive(:directory?).exactly(multiple_paths.size).times.and_return(true)
+      multiple_paths.each{|path| expect(LogStash::Environment).to receive(:add_plugin_path).with(path)}
+      subject.configure_plugin_paths(multiple_paths)
+    end
   end
 end
diff --git a/rakelib/docs.rake b/rakelib/docs.rake
index 9ba82c334f5..c7eb1d32152 100644
--- a/rakelib/docs.rake
+++ b/rakelib/docs.rake
@@ -1,5 +1,6 @@
 namespace "docs" do
 
+  desc "Generate documentation for all plugins"
   task "generate" do
     Rake::Task['plugin:install-all'].invoke
     Rake::Task['docs:generate-docs'].invoke
@@ -10,16 +11,15 @@ namespace "docs" do
     require "bootstrap/environment"
     pattern = "#{LogStash::Environment.logstash_gem_home}/gems/logstash-*/lib/logstash/{input,output,filter,codec}s/*.rb"
     list    = Dir.glob(pattern).join(" ")
-    cmd     = "bin/logstash docgen -o asciidoc_generated #{list}"
+    cmd     = "bin/bundle exec ruby docs/asciidocgen.rb -o asciidoc_generated #{list}"
     system(cmd)
   end
 
   task "generate-index" do
     list = [ 'inputs', 'outputs', 'filters', 'codecs' ]
     list.each do |type|
-      cmd = "ruby docs/asciidoc_index.rb asciidoc_generated #{type}"
+      cmd = "bin/bundle exec ruby docs/asciidoc_index.rb asciidoc_generated #{type}"
       system(cmd)
     end
   end
-
 end
