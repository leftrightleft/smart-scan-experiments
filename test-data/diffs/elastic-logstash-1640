diff --git a/.travis.yml b/.travis.yml
deleted file mode 100644
index 72700b92444..00000000000
--- a/.travis.yml
+++ /dev/null
@@ -1,12 +0,0 @@
-language: ruby
-rvm:
-  - jruby-19mode
-jdk:
-  - oraclejdk7
-  - openjdk7
-
-script:
-  - JRUBY_OPTS=--debug COVERAGE=true GEM_HOME=./vendor/bundle/jruby/1.9 GEM_PATH= ./vendor/bundle/jruby/1.9/bin/rspec spec/support/*.rb spec/filters/*.rb spec/examples/*.rb spec/codecs/*.rb spec/conditionals/*.rb spec/event.rb 
-install: 
-  - ruby gembag.rb
-  - make vendor-geoip
diff --git a/Makefile b/Makefile
index 28591bfd9ee..db263b80aff 100644
--- a/Makefile
+++ b/Makefile
@@ -1,405 +1,2 @@
-# Requirements to build:
-#   rsync
-#   wget or curl
-#
-JRUBY_VERSION=1.7.16
-ELASTICSEARCH_VERSION=1.1.1
-
-WITH_JRUBY=java -jar $(shell pwd)/$(JRUBY) -S
-JRUBY=vendor/jar/jruby-complete-$(JRUBY_VERSION).jar
-JRUBY_URL=http://jruby.org.s3.amazonaws.com/downloads/$(JRUBY_VERSION)/jruby-complete-$(JRUBY_VERSION).jar
-JRUBY_CMD=bin/logstash env java -jar $(JRUBY)
-
-ELASTICSEARCH_URL=http://download.elasticsearch.org/elasticsearch/elasticsearch
-ELASTICSEARCH=vendor/jar/elasticsearch-$(ELASTICSEARCH_VERSION)
-TYPESDB=vendor/collectd/types.db
-COLLECTD_VERSION=5.4.0
-TYPESDB_URL=https://collectd.org/files/collectd-$(COLLECTD_VERSION).tar.gz
-GEOIP=vendor/geoip/GeoLiteCity.dat
-GEOIP_URL=http://logstash.objects.dreamhost.com/maxmind/GeoLiteCity-2013-01-18.dat.gz
-GEOIP_ASN=vendor/geoip/GeoIPASNum.dat
-GEOIP_ASN_URL=http://logstash.objects.dreamhost.com/maxmind/GeoIPASNum-2014-02-12.dat.gz
-KIBANA_URL=https://download.elasticsearch.org/kibana/kibana/kibana-3.0.1.tar.gz
-PLUGIN_FILES=$(shell find lib -type f| egrep '^lib/logstash/(inputs|outputs|filters|codecs)/[^/]+$$' | egrep -v '/(base|threadable).rb$$|/inputs/ganglia/')
-SCALA_VERSION?=2.9.2
-
-KAFKA_VERSION?=0.8.1.1
-KAFKA_URL=https://archive.apache.org/dist/kafka
-KAFKA=vendor/jar/kafka_$(SCALA_VERSION)-$(KAFKA_VERSION)
-
-QUIET=@
-ifeq (@,$(QUIET))
-	QUIET_OUTPUT=> /dev/null 2>&1
-endif
-
-WGET=$(shell which wget 2>/dev/null)
-CURL=$(shell which curl 2>/dev/null)
-
-# OS-specific options
-TARCHECK=$(shell tar --help|grep wildcard|wc -l|tr -d ' ')
-ifeq (0, $(TARCHECK))
-TAR_OPTS=
-else
-TAR_OPTS=--wildcards
-endif
-
-#spec/outputs/graphite.rb spec/outputs/email.rb)
-default:
-	@echo "Make targets you might be interested in:"
-	@echo "  tarball -- builds the tarball package"
-	@echo "  tarball-test -- runs the test suite against the tarball package"
-
-TESTS=$(wildcard spec/*.rb spec/**/*.rb spec/**/**/*.rb)
-
-# The 'version' is generated based on the logstash version, git revision, etc.
-.VERSION.mk: REVISION=$(shell git rev-parse --short HEAD | tr -d ' ')
-.VERSION.mk: RELEASE=$(shell awk -F\" '/LOGSTASH_VERSION/ {print $$2}' lib/logstash/version.rb | tr -d ' ')
-#.VERSION.mk: TAGGED=$(shell git tag --points-at HEAD | egrep '^v[0-9]')
-.VERSION.mk: DEV=$(shell echo $RELEASE | egrep '\.dev$$')
-.VERSION.mk: MODIFIED=$(shell git diff --shortstat --exit-code > /dev/null ; echo $$?)
-.VERSION.mk:
-	$(QUIET)echo "RELEASE=${RELEASE}" > $@
-	$(QUIET)echo "REVISION=${REVISION}" >> $@
-	$(QUIET)echo "DEV=${DEV}" >> $@
-	$(QUIET)echo "MODIFIED=${MODIFIED}" >> $@
-	$(QUIET)if [ -z "${DEV}" ] ; then \
-		if [ "${MODIFIED}" -eq 1 ] ; then \
-			echo "VERSION=${RELEASE}-modified" ; \
-		else \
-			echo "VERSION=${RELEASE}" ; \
-		fi ; \
-	else \
-		if [ "${MODIFIED}" -eq 1 ] ; then \
-			echo "VERSION=${RELEASE}-${REVISION}-modified" ; \
-		else \
-			echo "VERSION=${RELEASE}-${REVISION}" ; \
-		fi ; \
-	fi >> $@
-
--include .VERSION.mk
-
-version:
-	@echo "Version: $(VERSION)"
-
-# Figure out if we're using wget or curl
-.PHONY: wget-or-curl
-wget-or-curl:
-ifeq ($(CURL),)
-ifeq ($(WGET),)
-	@echo "wget or curl are required."
-	exit 1
-else
-DOWNLOAD_COMMAND=wget -q --no-check-certificate -O
-endif
-else
-DOWNLOAD_COMMAND=curl -s -L -k -o
-endif
-
-# Compile config grammar (ragel -> ruby)
-.PHONY: compile-grammar
-compile-grammar: lib/logstash/config/grammar.rb
-lib/logstash/config/grammar.rb: lib/logstash/config/grammar.treetop
-	$(QUIET)$(MAKE) -C lib/logstash/config grammar.rb
-
-.PHONY: clean
-clean:
-	@echo "=> Cleaning up"
-	-$(QUIET)rm -rf .bundle
-	-$(QUIET)rm -rf build
-	-$(QUIET)rm -f pkg/*.deb
-	-$(QUIET)rm .VERSION.mk
-
-.PHONY: vendor-clean
-vendor-clean:
-	-$(QUIET)rm -rf vendor/kibana vendor/geoip vendor/collectd
-	-$(QUIET)rm -rf vendor/jar vendor/ua-parser
-
-.PHONY: clean-vendor
-clean-vendor:
-	-$(QUIET)rm -rf vendor
-
-.PHONY: compile
-compile: compile-grammar compile-runner | build/ruby
-
-.PHONY: compile-runner
-compile-runner: build/ruby/logstash/runner.class
-build/ruby/logstash/runner.class: lib/logstash/runner.rb | build/ruby $(JRUBY)
-	$(QUIET)(cd lib; java -jar ../$(JRUBY) -rjruby/jrubyc -e 'exit JRuby::Compiler::compile_argv(ARGV)' -- -t ../build/ruby logstash/runner.rb)
-
-.PHONY: copy-ruby-files
-copy-ruby-files: | build/ruby
-	@# Copy lib/ and test/ files to the root
-	$(QUIET)rsync -a --include "*/" --include "*.rb" --include "*.yaml" --exclude "*" ./lib/ ./test/ ./build/ruby
-	$(QUIET)rsync -a ./spec ./build/ruby
-	$(QUIET)rsync -a ./locales ./build/ruby
-	@# Delete any empty directories copied by rsync.
-	$(QUIET)find ./build/ruby -type d -empty -delete
-
-vendor:
-	$(QUIET)mkdir $@
-
-vendor/jar: | vendor
-	$(QUIET)mkdir $@
-
-vendor-jruby: $(JRUBY)
-
-$(JRUBY): | vendor/jar
-	$(QUIET)echo "=> Downloading jruby $(JRUBY_VERSION)"
-	$(QUIET)$(DOWNLOAD_COMMAND) $@ $(JRUBY_URL)
-
-vendor/jar/elasticsearch-$(ELASTICSEARCH_VERSION).tar.gz: | wget-or-curl vendor/jar
-	@echo "=> Fetching elasticsearch"
-	$(QUIET)$(DOWNLOAD_COMMAND) $@ $(ELASTICSEARCH_URL)/elasticsearch-$(ELASTICSEARCH_VERSION).tar.gz
-
-vendor/jar/graphtastic-rmiclient.jar: | wget-or-curl vendor/jar
-	@echo "=> Fetching graphtastic rmi client jar"
-	$(QUIET)$(DOWNLOAD_COMMAND) $@ http://cloud.github.com/downloads/NickPadilla/GraphTastic/graphtastic-rmiclient.jar
-
-vendor/jar/kafka_$(SCALA_VERSION)-$(KAFKA_VERSION).tgz: | wget-or-curl vendor/jar
-	@echo "=> Fetching kafka $(SCALA_VERSION)-$(KAFKA_VERSION)"
-	$(QUIET)$(DOWNLOAD_COMMAND) $@ $(KAFKA_URL)/$(KAFKA_VERSION)/kafka_$(SCALA_VERSION)-$(KAFKA_VERSION).tgz
-
-
-.PHONY: vendor-elasticsearch
-vendor-elasticsearch: $(ELASTICSEARCH)
-$(ELASTICSEARCH): $(ELASTICSEARCH).tar.gz | vendor/jar
-	@echo "=> Pulling the jars out of $<"
-	$(QUIET)tar -C $(shell dirname $@) -xf $< $(TAR_OPTS) --exclude '*sigar*' \
-		'elasticsearch-$(ELASTICSEARCH_VERSION)/lib/*.jar'
-
-vendor/geoip: | vendor
-	$(QUIET)mkdir $@
-
-.PHONY: vendor-geoip
-vendor-geoip: $(GEOIP) $(GEOIP_ASN)
-$(GEOIP): | vendor/geoip
-	$(QUIET)$(DOWNLOAD_COMMAND) $@.tmp.gz $(GEOIP_URL)
-	$(QUIET)gzip -dc $@.tmp.gz > $@.tmp
-	$(QUIET)rm "$@.tmp.gz"
-	$(QUIET)mv $@.tmp $@
-
-$(GEOIP_ASN): | vendor/geoip
-	$(QUIET)$(DOWNLOAD_COMMAND) $@.tmp.gz $(GEOIP_ASN_URL)
-	$(QUIET)gzip -dc $@.tmp.gz > $@.tmp
-	$(QUIET)rm "$@.tmp.gz"
-	$(QUIET)mv $@.tmp $@
-
-vendor/collectd: | vendor
-	$(QUIET)mkdir $@
-
-.PHONY: vendor-collectd
-vendor-collectd: $(TYPESDB)
-$(TYPESDB): | vendor/collectd
-	$(QUIET)$(DOWNLOAD_COMMAND) $@.tar.gz $(TYPESDB_URL)
-	$(QUIET)tar zxf $@.tar.gz -O "collectd-$(COLLECTD_VERSION)/src/types.db" > $@
-	$(QUIET)rm $@.tar.gz
-
-.PHONY: vendor-kafka
-vendor-kafka: $(KAFKA)
-$(KAFKA): $(KAFKA).tgz | vendor/jar
-	@echo "=> Pulling the jars out of $<"
-	$(QUIET)tar -C $(shell dirname $@) -xf $< $(TAR_OPTS) \
-		'kafka_$(SCALA_VERSION)-$(KAFKA_VERSION)/libs/*.jar'
-	$(QUIET)tar -C $(shell dirname $@) -xf $< $(TAR_OPTS) \
-		'kafka_$(SCALA_VERSION)-$(KAFKA_VERSION)/*.jar'
-
-# Always run vendor/bundle
-.PHONY: fix-bundler
-fix-bundler:
-	-$(QUIET)rm -rf .bundle
-
-.PHONY: vendor-gems
-vendor-gems: | vendor/bundle
-
-.PHONY: vendor/bundle
-vendor/bundle: | vendor $(JRUBY)
-	@echo "=> Ensuring ruby gems dependencies are in $@..."
-	$(QUIET)bin/logstash deps $(QUIET_OUTPUT)
-	@# Purge any junk that fattens our jar without need!
-	@# The riak gem includes previous gems in the 'pkg' dir. :(
-	-$(QUIET)rm -rf $@/jruby/1.9/gems/riak-client-1.0.3/pkg
-	@# Purge any rspec or test directories
-	-$(QUIET)rm -rf $@/jruby/1.9/gems/*/spec $@/jruby/1.9/gems/*/test
-	@# Purge any comments in ruby code.
-	@#-find $@/jruby/1.9/gems/ -name '*.rb' | xargs -n1 sed -i -e '/^[ \t]*#/d; /^[ \t]*$$/d'
-
-.PHONY: build
-build:
-	-$(QUIET)mkdir -p $@
-
-build/ruby: | build
-	-$(QUIET)mkdir -p $@
-
-vendor/ua-parser/: | build
-	$(QUIET)mkdir $@
-
-vendor/ua-parser/regexes.yaml: | vendor/ua-parser/
-	@echo "=> Fetching ua-parser regexes.yaml"
-	$(QUIET)$(DOWNLOAD_COMMAND) $@ https://raw.github.com/tobie/ua-parser/master/regexes.yaml
-
-.PHONY: test
-test: QUIET_OUTPUT=
-test: | $(JRUBY) vendor-elasticsearch vendor-geoip vendor-collectd vendor-kafka vendor-gems
-	$(SPEC_ENV) bin/logstash rspec $(SPEC_OPTS) --order rand --fail-fast $(TESTS)
-
-.PHONY: reporting-test
-reporting-test: SPEC_ENV=JRUBY_OPTS=--debug
-reporting-test: SPEC_OPTS=--format CI::Reporter::RSpec
-reporting-test: | test
-
-.PHONY: docs
-docs: docgen doccopy docindex
-
-doccopy: $(addprefix build/,$(shell find docs -type f | grep '^docs/')) | build/docs
-docindex: build/docs/index.html
-
-docgen: $(addprefix build/docs/,$(subst lib/logstash/,,$(subst .rb,.html,$(PLUGIN_FILES))))
-docgen: build/docs/tutorials/getting-started-with-logstash.md
-
-build/docs: build
-	$(QUIET)-mkdir $@
-
-build/docs/tutorials: build/docs
-	$(QUIET)-mkdir $@
-
-
-build/docs/inputs build/docs/filters build/docs/outputs build/docs/codecs: | build/docs
-	$(QUIET)-mkdir $@
-
-build/docs/tutorials/getting-started-with-logstash.md: build/docs/tutorials/getting-started-with-logstash.xml | build/docs/tutorials
-	$(QUIET)( \
-		echo "---"; \
-		echo "title: Metrics from Logs - logstash"; \
-		echo "layout: content_right"; \
-		echo "---"; \
-		pandoc -f docbook -t markdown $< \
-	) \
-	| sed -e 's/%VERSION%/$(VERSION)/g' \
-	| sed -e 's/%ELASTICSEARCH_VERSION%/$(ELASTICSEARCH_VERSION)/g' > $@
-
-build/docs/tutorials/getting-started-with-logstash.xml: docs/tutorials/getting-started-with-logstash.asciidoc | build/docs/tutorials
-	$(QUIET)asciidoc -b docbook -o $@ $<
-
-build/docs/inputs/%.html: lib/logstash/inputs/%.rb docs/docgen.rb docs/plugin-doc.html.erb | build/docs/inputs
-	$(QUIET)$(JRUBY_CMD) docs/docgen.rb -o build/docs $<
-	$(QUIET)sed -i -e 's/%VERSION%/$(VERSION)/g' $@
-	$(QUIET)sed -i -e 's/%ELASTICSEARCH_VERSION%/$(ELASTICSEARCH_VERSION)/g' $@
-build/docs/filters/%.html: lib/logstash/filters/%.rb docs/docgen.rb docs/plugin-doc.html.erb | build/docs/filters
-	$(QUIET)$(JRUBY_CMD) docs/docgen.rb -o build/docs $<
-	$(QUIET)sed -i -e 's/%VERSION%/$(VERSION)/g' $@
-	$(QUIET)sed -i -e 's/%ELASTICSEARCH_VERSION%/$(ELASTICSEARCH_VERSION)/g' $@
-build/docs/outputs/%.html: lib/logstash/outputs/%.rb docs/docgen.rb docs/plugin-doc.html.erb | build/docs/outputs
-	$(QUIET)$(JRUBY_CMD) docs/docgen.rb -o build/docs $<
-	$(QUIET)sed -i -e 's/%VERSION%/$(VERSION)/g' $@
-	$(QUIET)sed -i -e 's/%ELASTICSEARCH_VERSION%/$(ELASTICSEARCH_VERSION)/g' $@
-build/docs/codecs/%.html: lib/logstash/codecs/%.rb docs/docgen.rb docs/plugin-doc.html.erb | build/docs/codecs
-	$(QUIET)$(JRUBY_CMD) docs/docgen.rb -o build/docs $<
-	$(QUIET)sed -i -e 's/%VERSION%/$(VERSION)/g' $@
-
-build/docs/%: docs/% lib/logstash/version.rb Makefile
-	@echo "Copying $< (to $@)"
-	-$(QUIET)mkdir -p $(shell dirname $@)
-	$(QUIET)cp $< $@
-	$(QUIET)case "$(suffix $<)" in \
-		.gz|.bz2|.png|.jpg) ;; \
-		*) \
-			sed -i -e 's/%VERSION%/$(VERSION)/g' $@ ; \
-			sed -i -e 's/%ELASTICSEARCH_VERSION%/$(ELASTICSEARCH_VERSION)/g' $@ ; \
-			;; \
-	esac
-
-build/docs/index.html: $(addprefix build/docs/,$(subst lib/logstash/,,$(subst .rb,.html,$(PLUGIN_FILES))))
-build/docs/index.html: docs/generate_index.rb lib/logstash/version.rb docs/index.html.erb Makefile
-	@echo "Building documentation index.html"
-	$(QUIET)$(JRUBY_CMD) $< build/docs > $@
-	$(QUIET)sed -i -e 's/%VERSION%/$(VERSION)/g' $@
-	$(QUIET)sed -i -e 's/%ELASTICSEARCH_VERSION%/$(ELASTICSEARCH_VERSION)/g' $@
-
-.PHONY: patterns
-patterns:
-	curl https://nodeload.github.com/logstash/grok-patterns/tarball/master | tar zx
-	mv logstash-grok-patterns*/* patterns/
-	rm -rf logstash-grok-patterns*
-
-## JIRA Interaction section
-JIRACLI=/path/to/your/jira-cli-3.1.0/jira.sh
-
-sync-jira-components: $(addprefix create/jiracomponent/,$(subst lib/logstash/,,$(subst .rb,,$(PLUGIN_FILES))))
-	-$(QUIET)$(JIRACLI) --action run --file tmp_jira_action_list --continue > /dev/null 2>&1
-	$(QUIET)rm tmp_jira_action_list
-
-create/jiracomponent/%:
-	$(QUIET)echo "--action addComponent --project LOGSTASH --name $(subst create/jiracomponent/,,$@)" >> tmp_jira_action_list
-
-## Release note section (up to you if/how/when to integrate in docs)
-# Collect the details of:
-#  - merged pull request from GitHub since last release
-#  - issues for FixVersion from JIRA
-
-# Note on used Github logic
-# We parse the commit between the last tag (should be the last release) and HEAD
-# to extract all the notice about merged pull requests.
-
-# Note on used JIRA release note URL
-# The JIRA Release note list all issues (even open ones)
-# with Fix Version assigned to target version
-# So one must verify manually that there is no open issue left (TODO use JIRACLI)
-
-# This is the ID for a version item in jira, can be obtained by CLI
-# or through the Version URL https://logstash.jira.com/browse/LOGSTASH/fixforversion/xxx
-JIRA_VERSION_ID=10820
-
-releaseNote:
-	-$(QUIET)rm releaseNote.html
-	$(QUIET)curl -si "https://logstash.jira.com/secure/ReleaseNote.jspa?version=$(JIRA_VERSION_ID)&projectId=10020" | sed -n '/<textarea.*>/,/<\/textarea>/p' | grep textarea -v >> releaseNote.html
-	$(QUIET)$(JRUBY_CMD) pull_release_note.rb
-
-package: build/logstash-$(VERSION).tar.gz
-	(cd pkg; \
-		./build.sh ubuntu 12.04; \
-		./build.sh centos 6 \
-	)
-
-vendor/kibana: | vendor
-	@echo "=> Fetching kibana"
-	$(QUIET)mkdir vendor/kibana || true
-	$(DOWNLOAD_COMMAND) - $(KIBANA_URL) | tar -C $@ -zx --strip-components=1
-
-build/tarball: | build
-	mkdir $@
-build/tarball/logstash-%: | build/tarball
-	mkdir $@
-
-show:
-	echo $(VERSION)
-
-.PHONY: prepare-tarball
-prepare-tarball tarball zip: WORKDIR=build/tarball/logstash-$(VERSION)
-prepare-tarball: vendor/kibana $(ELASTICSEARCH) $(JRUBY) vendor-geoip $(TYPESDB) $(KAFKA) vendor-gems
-prepare-tarball: vendor/ua-parser/regexes.yaml
-prepare-tarball:
-	@echo "=> Preparing tarball"
-	$(QUIET)$(MAKE) $(WORKDIR)
-	$(QUIET)rsync -a --relative bin lib spec locales patterns vendor/bundle/jruby vendor/geoip vendor/jar vendor/kibana vendor/ua-parser vendor/collectd LICENSE README.md --exclude 'vendor/bundle/jruby/1.9/cache' --exclude 'vendor/bundle/jruby/1.9/gems/*/doc' --exclude 'vendor/jar/elasticsearch-$(ELASTICSEARCH_VERSION).tar.gz' --exclude 'vendor/jar/kafka_$(SCALA_VERSION)-$(KAFKA_VERSION).tgz' $(WORKDIR)
-	$(QUIET)sed -i -e 's/^LOGSTASH_VERSION = .*/LOGSTASH_VERSION = "$(VERSION)"/' $(WORKDIR)/lib/logstash/version.rb
-	$(QUIET)sed -i -e 's/%JRUBY_VERSION%/$(JRUBY_VERSION)/' $(WORKDIR)/bin/logstash.bat
-
-.PHONY: tarball
-tarball: | build/logstash-$(VERSION).tar.gz
-build/logstash-$(VERSION).tar.gz: | prepare-tarball
-	$(QUIET)tar -C $$(dirname $(WORKDIR)) -c $$(basename $(WORKDIR)) \
-		| gzip -9c > $@
-	@echo "=> tarball ready: $@"
-
-.PHONY: zip
-zip: | build/logstash-$(VERSION).zip
-build/logstash-$(VERSION).zip: | prepare-tarball
-	$(QUIET)(cd $$(dirname $(WORKDIR)); find $$(basename $(WORKDIR)) | zip $(PWD)/$@ -@ -9)$(QUIET_OUTPUT)
-	@echo "=> zip ready: $@"
-
-.PHONY: tarball-test
-tarball-test: #build/logstash-$(VERSION).tar.gz
-	$(QUIET)-rm -rf build/test-tarball/
-	$(QUIET)mkdir -p build/test-tarball/
-	tar -C build/test-tarball --strip-components 1 -xf build/logstash-$(VERSION).tar.gz
-	(cd build/test-tarball; bin/logstash rspec $(TESTS) --fail-fast)
+%: 
+	rake $@
diff --git a/README.md b/README.md
index 4ac1c9b8822..a844500203a 100644
--- a/README.md
+++ b/README.md
@@ -29,16 +29,12 @@ You can also find documentation on the <http://logstash.net> site.
 
 ## Developing
 
-Here's how to get started:
+To get started, you'll need *any* ruby available and it should come with the `rake` tool.
 
-    # Install jruby
-    make vendor-jruby
-    
-Now install dependencies:
-
-    # Install logstash ruby dependencies
-    bin/logstash deps
+Here's how to get started with Logstash development:
 
+    rake bootstrap
+    
 Other commands:
 
     # to use Logstash gems or libraries in irb, use the following
@@ -48,11 +44,12 @@ Other commands:
     # Run Logstash
     bin/logstash agent [options]
 
-    # If running bin/logstash agent yields complaints about log4j/other things
-    # This will download the elasticsearch jars so Logstash can use them.
-    make vendor-elasticsearch
+Notes about using other rubies. If you don't use rvm, you can probably skip
+this paragraph. Logstash works with other rubies, and if you wish to use your
+own ruby you must set `USE_RUBY=1` in your environment.
 
-Notes about using other rubies. If you don't use rvm, you can probably skip this paragraph. Logstash works with other rubies, and if you wish to use your own ruby instead of the JRuby the Makefile gives you, you must set `USE_RUBY=1` in your environment.
+We recommend using flatland/drip for faster startup times during development. To
+tell Logstash to use drip, set `USE_DRIP=1` in your environment.
 
 ## Testing
 
@@ -65,14 +62,9 @@ rspec <some spec>` will suffice:
     Finished in 0.123 seconds
     19 examples, 0 failures
 
-Alternately, if you have just built the tarball, you can run the tests
-specifically on those like so:
-
-    make tarball-test
-
 If you want to run all the tests from source, do:
 
-    make test
+    rake test
 
 ## Building
 
@@ -81,11 +73,15 @@ we provide from the Logstash site!
 
 If you want to build the release tarball yourself, run:
 
-    make tarball
+    rake artifact:tar
 
 You can build rpms and debs, if you need those. Building rpms requires you have [fpm](https://github.com/jordansissel/fpm), then do this:
 
-    make package
+    # Build an RPM
+    rake artifact:rpm
+
+    # Build a Debian/Ubuntu package
+    rake artifact:deb
 
 ## Project Principles
 
diff --git a/Rakefile b/Rakefile
new file mode 100644
index 00000000000..e67cca5c5ec
--- /dev/null
+++ b/Rakefile
@@ -0,0 +1,18 @@
+
+$: << File.join(File.dirname(__FILE__), "lib")
+
+task "default" => "help"
+
+task "help" do
+  puts <<HELP
+What do you want to do?
+
+Packaging?
+  `rake artifact:tar`  to build a deployable .tar.gz
+  `rake artifact:rpm`  to build an rpm
+  `rake artifact:deb`  to build an deb
+
+Developing?
+  `rake bootstrap`     installs any dependencies for doing Logstash development
+HELP
+end
diff --git a/bin/logstash b/bin/logstash
index 4dd48808b3d..21e26d9ddf5 100755
--- a/bin/logstash
+++ b/bin/logstash
@@ -8,9 +8,6 @@
 #
 # See 'bin/logstash help' for a list of commands.
 #
-# NOTE: One extra command is available 'deps'
-# The 'deps' command will install dependencies for logstash.
-
 # Defaults you can override with environment variables
 LS_HEAP_SIZE="${LS_HEAP_SIZE:=500m}"
 
@@ -24,20 +21,18 @@ setup
 export HOME SINCEDB_DIR
 
 case $1 in
-  deps) install_deps ;;
-  env) env "$@" ;;
   -*)
     if [ -z "$VENDORED_JRUBY" ] ; then
       exec "${RUBYCMD}" "${basedir}/lib/logstash/runner.rb" "agent" "$@"
     else
-      exec "${JAVACMD}" $JAVA_OPTS "-jar" "$JRUBY_JAR" "${basedir}/lib/logstash/runner.rb" "agent" "$@"
+      exec "$JRUBY_BIN" $(jruby_opts) "${basedir}/lib/logstash/runner.rb" "agent" "$@"
     fi
     ;;
   *)
     if [ -z "$VENDORED_JRUBY" ] ; then
       exec "${RUBYCMD}" "${basedir}/lib/logstash/runner.rb" "$@"
     else
-      exec "${JAVACMD}" $JAVA_OPTS "-jar" "$JRUBY_JAR" "${basedir}/lib/logstash/runner.rb" "$@"
+      exec "$JRUBY_BIN" $(jruby_opts) "${basedir}/lib/logstash/runner.rb" "$@"
     fi
     ;;
-esac
\ No newline at end of file
+esac
diff --git a/bin/logstash.lib.sh b/bin/logstash.lib.sh
index bd4b56824e7..9fba6dddf49 100755
--- a/bin/logstash.lib.sh
+++ b/bin/logstash.lib.sh
@@ -69,7 +69,15 @@ setup_drip() {
 }
 
 setup_vendored_jruby() {
-  JRUBY_JAR=$(ls "${basedir}"/vendor/jar/jruby-complete-*.jar)
+  #JRUBY_JAR=$(ls "${basedir}"/vendor/jruby/jruby-complete-*.jar)
+  JRUBY_BIN="${basedir}/vendor/jruby/bin/jruby"
+
+  if [ ! -f "${JRUBY_BIN}" ] ; then
+    echo "Unable to find JRuby."
+    echo "If you are a user, this is a bug."
+    echo "If you are a developer, please run 'rake bootstrap'. Running 'rake' requires the 'ruby' program be available."
+    exit 1
+  fi
   VENDORED_JRUBY=1
 }
 
@@ -78,6 +86,12 @@ setup_ruby() {
   VENDORED_JRUBY=
 }
 
+jruby_opts() {
+  for i in $JAVA_OPTS ; do
+    echo "-J$i"
+  done
+}
+
 setup() {
   # first check if we want to use drip, which can be used in vendored jruby mode
   # and also when setting USE_RUBY=1 if the ruby interpretor is in fact jruby
@@ -100,15 +114,3 @@ setup() {
 
   export RUBYLIB="${basedir}/lib"
 }
-
-install_deps() {
-  if [ -f "$basedir/logstash.gemspec" ] ; then
-    if [ -z "$VENDORED_JRUBY" ] ; then
-      exec "${RUBYCMD}" "${basedir}/gembag.rb" "${basedir}/logstash.gemspec" "$@"
-    else
-      exec "${JAVACMD}" $JAVA_OPTS "-jar" "$JRUBY_JAR" "${basedir}/gembag.rb" "${basedir}/logstash.gemspec" "$@"
-    fi
-  else
-    echo "Cannot install dependencies; missing logstash.gemspec. This 'deps' command only works from a logstash git clone."
-  fi
-}
\ No newline at end of file
diff --git a/extract_services.rb b/extract_services.rb
deleted file mode 100644
index fa6b71beb12..00000000000
--- a/extract_services.rb
+++ /dev/null
@@ -1,29 +0,0 @@
-# Extract META-INFO/services/* files from jars
-#
-require "optparse"
-
-output = nil
-
-flags = OptionParser.new do |opts|
-  opts.on("-o", "--output DIR",
-          "Where to write the merged META-INF/services/* files") do |dir|
-    output = dir
-  end
-end
-
-flags.parse!(ARGV)
-
-ARGV.each do |jar|
-  # Find any files matching /META-INF/services/* in any jar given on the
-  # command line.
-  # Append all file content to the output directory with the same file name
-  # as is in the jar.
-  glob = "file:///#{File.expand_path(jar)}!/META-INF/services/*"
-  Dir.glob(glob).each do |service|
-    name = File.basename(service)
-    File.open(File.join(output, name), "a") do |fd|
-      puts "Adding #{name} from #{File.basename(jar)}"
-      fd.write(File.read(service))
-    end
-  end
-end
diff --git a/lib/logstash/agent.rb b/lib/logstash/agent.rb
index 000d1ba4eb0..0a6ce1da6bd 100644
--- a/lib/logstash/agent.rb
+++ b/lib/logstash/agent.rb
@@ -2,7 +2,8 @@
 require "clamp" # gem 'clamp'
 require "logstash/environment"
 require "logstash/errors"
-require "i18n"
+require "logstash/environment"
+LogStash::Environment.load_locale!
 
 class LogStash::Agent < Clamp::Command
   option ["-f", "--config"], "CONFIG_PATH",
diff --git a/lib/logstash/config/mixin.rb b/lib/logstash/config/mixin.rb
index c6a92347193..f4b0314db2d 100644
--- a/lib/logstash/config/mixin.rb
+++ b/lib/logstash/config/mixin.rb
@@ -5,7 +5,8 @@
 require "logstash/logging"
 require "logstash/util/password"
 require "logstash/version"
-require "i18n"
+require "logstash/environment"
+LogStash::Environment.load_locale!
 
 # This module is meant as a mixin to classes wishing to be configurable from
 # config files
diff --git a/lib/logstash/environment.rb b/lib/logstash/environment.rb
index 999c54fe679..df483e32ba6 100644
--- a/lib/logstash/environment.rb
+++ b/lib/logstash/environment.rb
@@ -7,6 +7,7 @@ module Environment
 
     LOGSTASH_HOME = ::File.expand_path(::File.join(::File.dirname(__FILE__), "..", ".."))
     JAR_DIR = ::File.join(LOGSTASH_HOME, "vendor", "jar")
+    ELASTICSEARCH_DIR = ::File.join(LOGSTASH_HOME, "vendor", "elasticsearch")
     BUNDLE_DIR = ::File.join(LOGSTASH_HOME, "vendor", "bundle")
     PLUGINS_DIR = ::File.join(LOGSTASH_HOME, "vendor", "plugins")
     GEMFILE_PATH = ::File.join(LOGSTASH_HOME, "tools", "Gemfile")
@@ -17,10 +18,10 @@ def load_elasticsearch_jars!
       raise(LogStash::EnvironmentError, "JRuby is required") unless jruby?
 
       require "java"
-      jars_path = ::File.join(JAR_DIR, "elasticsearch*", "lib", "*.jar")
+      jars_path = ::File.join(ELASTICSEARCH_DIR, "**", "*.jar")
       jar_files = Dir.glob(jars_path)
 
-      raise(LogStash::EnvironmentError, "Could not find Elasticsearch jar files under #{JAR_DIR}") if jar_files.empty?
+      raise(LogStash::EnvironmentError, "Could not find Elasticsearch jar files under #{ELASTICSEARCH_DIR}") if jar_files.empty?
 
       jar_files.each do |jar|
         loaded = require jar
@@ -41,6 +42,7 @@ def set_gem_paths!
       require ::File.join(BUNDLE_DIR, "bundler", "setup.rb")
       ENV["GEM_PATH"] = plugins_home
       ENV["GEM_HOME"] = plugins_home
+      Gem.paths = plugins_home
     end
 
     # @return [String] major.minor ruby version, ex 1.9
@@ -94,5 +96,12 @@ def load_logstash_gemspec!
       Gem::Specification.add_spec logstash_spec
     end
 
+    def load_locale!
+      require "i18n"
+      I18n.enforce_available_locales = true
+      I18n.load_path << LogStash::Environment.locales_path("en.yml")
+      I18n.reload!
+      fail "No locale? This is a bug." if I18n.available_locales.empty?
+    end
   end
 end
diff --git a/lib/logstash/runner.rb b/lib/logstash/runner.rb
index 8aacfced759..ea924a475e9 100644
--- a/lib/logstash/runner.rb
+++ b/lib/logstash/runner.rb
@@ -7,6 +7,7 @@
 require "logstash/environment"
 LogStash::Environment.set_gem_paths!
 LogStash::Environment.load_logstash_gemspec!
+LogStash::Environment.load_locale!
 
 Thread.abort_on_exception = true
 if ENV["PROFILE_BAD_LOG_CALLS"] || $DEBUGLIST.include?("log")
@@ -48,10 +49,6 @@ module Cabin::Mixins::Logger
 require "logstash/namespace"
 require "logstash/program"
 
-require "i18n"
-I18n.enforce_available_locales = true
-I18n.load_path << LogStash::Environment.locales_path("en.yml")
-
 class LogStash::RSpecsRunner
   def initialize(args)
     @args = args
diff --git a/pull_release_note.rb b/pull_release_note.rb
deleted file mode 100644
index 6ccdba92e5f..00000000000
--- a/pull_release_note.rb
+++ /dev/null
@@ -1,25 +0,0 @@
-require "octokit"
-
-
-@repository= "logstash/logstash"
-@releaseNote= "releaseNote.html"
-
-#Last release  == last tag
-lastReleaseSha = Octokit.tags(@repository).first.commit.sha
-
-currentReleaseSha ="HEAD"
-
-#Collect PR Merge in a file
-File.open(@releaseNote, "a") do |f|
-  f.puts "<h2>Merged pull request</h2>"
-  f.puts "<ul>"
-  Octokit.compare(@repository, lastReleaseSha, currentReleaseSha).commits.each do |commit|
-    if commit.commit.message.start_with?("Merge pull")
-      scan_re = Regexp.new(/^Merge pull request #(\d+) from ([^\/]+)\/.*\n\n(.*)/)
-      commit.commit.message.scan(scan_re) do |pullNumber, user, summary|
-        f.puts "<li><a href='https://github.com/logstash/logstash/pull/#{pullNumber}'>Pull ##{pullNumber}<a> by #{user}: #{summary}</li>"
-      end
-    end
-  end
-  f.puts "</ul>"
-end
\ No newline at end of file
diff --git a/rakelib/artifacts.rake b/rakelib/artifacts.rake
new file mode 100644
index 00000000000..d8f4965b316
--- /dev/null
+++ b/rakelib/artifacts.rake
@@ -0,0 +1,149 @@
+def staging
+  "build/staging"
+end
+
+namespace "artifact" do
+  require "logstash/environment"
+  package_files = [
+    "LICENSE",
+    "CHANGELOG",
+    "CONTRIBUTORS",
+    "{bin,lib,spec,locales}/{,**/*}",
+    "patterns/**/*",
+    "vendor/??*/**/*",
+    File.join(LogStash::Environment.gem_home.gsub(Dir.pwd + "/", ""), "{gems,specifications}/**/*"),
+    "Rakefile",
+    "rakelib/*",
+  ]
+  
+  desc "Build a tar.gz of logstash with all dependencies"
+  task "tar" => ["vendor:elasticsearch", "vendor:collectd", "vendor:jruby", "vendor:gems"] do
+    Rake::Task["dependency:archive-tar-minitar"].invoke
+    require "zlib"
+    require "archive/tar/minitar"
+    require "logstash/version"
+    tarpath = "build/logstash-#{LOGSTASH_VERSION}.tar.gz"
+    tarfile = File.new(tarpath, "wb")
+    gz = Zlib::GzipWriter.new(tarfile, Zlib::BEST_COMPRESSION)
+    tar = Archive::Tar::Minitar::Output.new(gz)
+    package_files.each do |glob|
+      Rake::FileList[glob].each do |path|
+        Archive::Tar::Minitar.pack_file(path, tar)
+      end
+    end
+    tar.close
+    gz.close
+    puts "Complete: #{tarpath}"
+  end
+
+  def package(platform, version, package_files)
+    Rake::Task["dependency:fpm"].invoke
+    require "fpm/errors" # TODO(sissel): fix this in fpm
+    require "fpm/package/dir"
+    require "fpm/package/gem" # TODO(sissel): fix this in fpm; rpm needs it.
+
+    dir = FPM::Package::Dir.new
+
+    package_files.each do |glob|
+      Rake::FileList[glob].each do |path|
+        dir.input("#{path}=/opt/logstash/#{path}")
+      end
+    end
+
+    basedir = File.join(File.dirname(__FILE__), "..")
+
+    File.join(basedir, "pkg", "logrotate.conf").tap do |path|
+      dir.input("#{path}=/etc/logrotate.d/logstash")
+    end
+
+    case platform
+      when "redhat", "centos"
+        File.join(basedir, "pkg", "logrotate.conf").tap do |path|
+          dir.input("#{path}=/etc/logrotate.d/logstash")
+        end
+        File.join(basedir, "pkg", "logstash.default").tap do |path|
+          dir.input("#{path}=/etc/sysconfig/logstash")
+        end
+        require "fpm/package/rpm"
+        out = dir.convert(FPM::Package::RPM)
+        out.license = "ASL 2.0" # Red Hat calls 'Apache Software License' == ASL
+        out.attributes[:rpm_use_file_permissions] = true
+        out.attributes[:rpm_user] = "root"
+        out.attributes[:rpm_group] = "root"
+        out.config_files << "etc/sysconfig/logstash"
+        out.config_files << "etc/logrotate.d/logstash"
+      when "debian", "ubuntu"
+        File.join(basedir, "pkg", "logstash.default").tap do |path|
+          dir.input("#{path}=/etc/default/logstash")
+        end
+        require "fpm/package/deb"
+        out = dir.convert(FPM::Package::Deb)
+        out.license = "Apache 2.0"
+        out.attributes[:deb_user] = "root"
+        out.attributes[:deb_group] = "root"
+        out.attributes[:deb_suggests] = "java7-runtime-headless"
+        # TODO(sissel): this file should go away once pleaserun is implemented.
+        out.config_files << "/etc/default/logstash"
+
+        out.config_files << "/etc/logrotate.d/logstash"
+    end
+
+    # Packaging install/removal scripts
+    ["before", "after"].each do |stage|
+      ["install", "remove"].each do |action|
+        script = "#{stage}-#{action}" # like, "before-install"
+        script_sym = script.gsub("-", "_").to_sym
+        script_path = File.join(File.dirname(__FILE__), "..", "pkg", platform, "#{script}.sh")
+        next unless File.exists?(script_path)
+
+        out.scripts[script_sym] = File.read(script_path)
+      end
+    end
+
+    # TODO(sissel): Invoke Pleaserun to generate the init scripts/whatever
+
+    out.name = "logstash"
+    out.version = LOGSTASH_VERSION
+    out.architecture = "all"
+    # TODO(sissel): Include the git commit hash?
+    out.iteration = "1" # what revision?
+    out.url = "http://www.elasticsearch.org/overview/logstash/"
+    out.description = "An extensible logging pipeline"
+    out.vendor = "Elasticsearch"
+    out.dependencies << "logrotate"
+
+    # We don't specify a dependency on Java because:
+    # - On Red Hat, Oracle and Red Hat both label their java packages in
+    #   incompatible ways. Further, there is no way to guarantee a qualified
+    #   version is available to install.
+    # - On Debian and Ubuntu, there is no Oracle package and specifying a
+    #   correct version of OpenJDK is impossible because there is no guarantee that
+    #   is impossible for the same reasons as the Red Hat section above.
+    # References:
+    # - http://www.elasticsearch.org/blog/java-1-7u55-safe-use-elasticsearch-lucene/
+    # - deb: https://github.com/elasticsearch/logstash/pull/1008
+    # - rpm: https://github.com/elasticsearch/logstash/pull/1290
+    # - rpm: https://github.com/elasticsearch/logstash/issues/1673
+    # - rpm: https://logstash.jira.com/browse/LOGSTASH-1020
+    
+    out.attributes[:force?] = true # overwrite the rpm/deb/etc being created
+    begin
+      path = File.join(basedir, "build", out.to_s)
+      x = out.output(path)
+      puts "Completed: #{path}"
+    ensure
+      out.cleanup
+    end
+  end # def package
+
+  desc "Build an RPM of logstash with all dependencies"
+  task "rpm" => ["vendor:elasticsearch", "vendor:collectd", "vendor:jruby", "vendor:gems"] do
+    package("centos", "5", package_files)
+  end
+
+  desc "Build an RPM of logstash with all dependencies"
+  task "deb" do
+    package("ubuntu", "12.04", package_files)
+  end
+end
+
diff --git a/rakelib/bootstrap.rake b/rakelib/bootstrap.rake
new file mode 100644
index 00000000000..477adb4f1e7
--- /dev/null
+++ b/rakelib/bootstrap.rake
@@ -0,0 +1,3 @@
+
+
+task "bootstrap" => [ "vendor:all", "compile:all" ]
diff --git a/rakelib/build.rake b/rakelib/build.rake
new file mode 100644
index 00000000000..2b443add8b7
--- /dev/null
+++ b/rakelib/build.rake
@@ -0,0 +1,6 @@
+directory "build" do |task, args|
+  mkdir_p task.name unless File.directory?(task.name)
+end
+directory "build/bootstrap" => "build" do |task, args|
+  mkdir_p task.name unless File.directory?(task.name)
+end
diff --git a/rakelib/bundler_patch.rb b/rakelib/bundler_patch.rb
new file mode 100644
index 00000000000..a68cb60736d
--- /dev/null
+++ b/rakelib/bundler_patch.rb
@@ -0,0 +1,11 @@
+# Patch bundler to write a .lock file specific to the version of ruby.
+# This keeps MRI/JRuby/RBX from conflicting over the Gemfile.lock updates
+module Bundler
+  module SharedHelpers
+    def default_lockfile
+      ruby = "#{LogStash::Environment.ruby_engine}-#{LogStash::Environment.ruby_abi_version}"
+      return Pathname.new("#{default_gemfile}.#{ruby}.lock")
+    end
+  end
+end
+
diff --git a/rakelib/compile.rake b/rakelib/compile.rake
new file mode 100644
index 00000000000..97744da8396
--- /dev/null
+++ b/rakelib/compile.rake
@@ -0,0 +1,18 @@
+
+rule ".rb" => ".treetop" do |task, args|
+  # TODO(sissel): Treetop 1.5.x doesn't seem to work well, but I haven't
+  # investigated what the cause might be. -Jordan
+  Rake::Task["gem:require"].invoke("treetop", "~> 1.4.0", ENV["GEM_HOME"])
+  require "treetop"
+  compiler = Treetop::Compiler::GrammarCompiler.new
+  compiler.compile(task.source, task.name)
+  puts "Compiling #{task.source}"
+end
+
+namespace "compile" do
+  desc "Compile the config grammar"
+  task "grammar" => "lib/logstash/config/grammar.rb"
+
+  desc "Build everything"
+  task "all" => "grammar"
+end
diff --git a/rakelib/copy.rake b/rakelib/copy.rake
new file mode 100644
index 00000000000..f40747cc049
--- /dev/null
+++ b/rakelib/copy.rake
@@ -0,0 +1,4 @@
+
+def staging
+  "build/staging"
+end
diff --git a/rakelib/dependency.rake b/rakelib/dependency.rake
new file mode 100644
index 00000000000..c66c22f69cc
--- /dev/null
+++ b/rakelib/dependency.rake
@@ -0,0 +1,30 @@
+
+namespace "dependency" do
+  task "bundler" do
+    begin
+      # Special handling because "gem 'bundler', '>=1.3.5'" will fail if
+      # bundler is already loaded.
+      require "bundler/cli"
+    rescue LoadError
+      Rake::Task["gem:require"].invoke("bundler", ">= 1.3.5", ENV["GEM_HOME"])
+      require "bundler/cli"
+    end
+    require_relative "bundler_patch"
+  end
+
+  task "rbx-stdlib" do
+    Rake::Task["gem:require"].invoke("rubysl", ">= 0", ENV["GEM_HOME"])
+  end # task rbx-stdlib
+
+  task "archive-tar-minitar" do
+    Rake::Task["gem:require"].invoke("minitar", ">= 0", ENV["GEM_HOME"])
+  end # task archive-minitar
+
+  task "stud" do
+    Rake::Task["gem:require"].invoke("stud", ">= 0", ENV["GEM_HOME"])
+  end # task stud
+
+  task "fpm" do
+    Rake::Task["gem:require"].invoke("fpm", ">= 0", ENV["GEM_HOME"])
+  end # task stud
+end # namespace dependency
diff --git a/rakelib/fetch.rake b/rakelib/fetch.rake
new file mode 100644
index 00000000000..586233ab69e
--- /dev/null
+++ b/rakelib/fetch.rake
@@ -0,0 +1,82 @@
+directory "vendor/_" => ["vendor"] do |task, args|
+  mkdir task.name
+end
+
+def fetch(url, sha1, output)
+  require "net/http"
+  require "uri"
+  require "digest/sha1"
+
+  puts "Downloading #{url}"
+  actual_sha1 = download(url, output)
+
+  if actual_sha1 != sha1
+    fail "SHA1 does not match (expected '#{sha1}' but got '#{actual_sha1}')"
+  end
+end # def fetch
+
+def file_fetch(url, sha1)
+  filename = File.basename(URI(url).path)
+  output = "vendor/_/#{filename}"
+  task output => [ "vendor/_" ] do
+    begin
+      actual_sha1 = file_sha1(output)
+      if actual_sha1 != sha1
+        fetch(url, sha1, output)
+      end
+    rescue Errno::ENOENT
+      fetch(url, sha1, output)
+    end
+  end.invoke
+
+  return output
+end
+
+def file_sha1(path)
+  digest = Digest::SHA1.new
+  fd = File.new(path, "r")
+  while true
+    begin
+      digest << fd.sysread(16384)
+    rescue EOFError
+      break
+    end
+  end
+  return digest.hexdigest
+ensure
+  fd.close if fd
+end
+
+def download(url, output)
+  uri = URI(url)
+  digest = Digest::SHA1.new
+  tmp = "#{output}.tmp"
+  Net::HTTP.start(uri.host, uri.port, :use_ssl => (uri.scheme == "https")) do |http|
+    request = Net::HTTP::Get.new(uri.path)
+    http.request(request) do |response|
+      fail "HTTP fetch failed for #{url}. #{response}" if response.code != "200"
+      size = (response["content-length"].to_i || -1).to_f
+      count = 0
+      File.open(tmp, "w") do |fd|
+        response.read_body do |chunk|
+          fd.write(chunk)
+          digest << chunk
+          if size > 0 && $stdout.tty?
+            count += chunk.bytesize
+            $stdout.write(sprintf("\r%0.2f%%", count/size * 100))
+          end
+        end
+      end
+      $stdout.write("\r      \r") if $stdout.tty?
+    end
+  end
+
+  File.rename(tmp, output)
+
+  return digest.hexdigest
+rescue SocketError => e
+  puts "Failure while downloading #{url}: #{e}"
+  raise
+ensure
+  File.unlink(tmp) if File.exist?(tmp)
+end # def download
diff --git a/rakelib/gems.rake b/rakelib/gems.rake
new file mode 100644
index 00000000000..bc0bed8f716
--- /dev/null
+++ b/rakelib/gems.rake
@@ -0,0 +1,44 @@
+require "rubygems/specification"
+require "rubygems/commands/install_command"
+require "logstash/JRUBY-PR1448" if RUBY_PLATFORM == "java" && Gem.win_platform?
+
+ENV["GEM_HOME"] = ENV["GEM_PATH"] = "build/bootstrap/"
+Gem.use_paths(ENV["GEM_HOME"], Gem.paths.path)
+
+namespace "gem" do
+  task "require",  :name, :requirement, :target do |task, args|
+    name, requirement, target = args[:name], args[:requirement], args[:target]
+    begin
+      gem name, requirement
+    rescue Gem::LoadError => e
+      puts "Installing #{name} #{requirement} because the build process needs it."
+      Rake::Task["gem:install"].invoke(name, requirement, target)
+    end
+    task.reenable # Allow this task to be run again
+  end
+
+  task "install", [:name, :requirement, :target] =>  ["build/bootstrap"] do |task, args|
+    name, requirement, target = args[:name], args[:requirement], args[:target]
+    puts "[bootstrap] Fetching and installing gem: #{name} (#{requirement})"
+
+    installer = Gem::Commands::InstallCommand.new
+    installer.options[:generate_rdoc] = false
+    installer.options[:generate_ri] = false
+    installer.options[:version] = requirement
+    installer.options[:args] = [name]
+    installer.options[:install_dir] = target
+
+    # ruby 2.0.0 / rubygems 2.x; disable documentation generation
+    installer.options[:document] = []
+    begin
+      installer.execute
+    rescue Gem::SystemExitException => e
+      if e.exit_code != 0
+        puts "Installation of #{name} failed"
+        raise
+      end
+    end
+
+    task.reenable # Allow this task to be run again
+  end # task "install"
+end # namespace "gem"
diff --git a/rakelib/test.rake b/rakelib/test.rake
new file mode 100644
index 00000000000..1801f45d17e
--- /dev/null
+++ b/rakelib/test.rake
@@ -0,0 +1,18 @@
+
+namespace "test" do
+  task "default" => [ "vendor:all" ] do
+    require "logstash/environment"
+    LogStash::Environment.set_gem_paths!
+    require 'rspec/core'
+    RSpec::Core::Runner.run(Rake::FileList["spec/**/*.rb"])
+  end
+
+  task "fail-fast" => [ "vendor:all" ] do
+    require "logstash/environment"
+    LogStash::Environment.set_gem_paths!
+    require 'rspec/core'
+    RSpec::Core::Runner.run(["--fail-fast", *Rake::FileList["spec/**/*.rb"]])
+  end
+end
+
+task "test" => [ "test:default" ] 
diff --git a/rakelib/vendor.rake b/rakelib/vendor.rake
new file mode 100644
index 00000000000..86d7144a0a2
--- /dev/null
+++ b/rakelib/vendor.rake
@@ -0,0 +1,239 @@
+
+DOWNLOADS = {
+  "elasticsearch" => { "version" => "1.3.0", "sha1" => "f9e02e2cdcb55e7e8c5c60e955f793f68b7dec75" },
+  "collectd" => { "version" => "5.4.0", "sha1" => "a90fe6cc53b76b7bdd56dc57950d90787cb9c96e" },
+  #"jruby" => { "version" => "1.7.13", "sha1" => "0dfca68810a5eed7f12ae2007dc2cc47554b4cc6" }, # jruby-complete
+  "jruby" => { "version" => "1.7.16", "sha1" => "4c912b648f6687622ba590ca2a28746d1cd5d550" },
+  "kibana" => { "version" => "3.1.0", "sha1" => "effc20c83c0cb8d5e844d2634bd1854a1858bc43" },
+  "geoip" => {
+    "GeoLiteCity" => { "version" => "2013-01-18", "sha1" => "15aab9a90ff90c4784b2c48331014d242b86bf82", },
+    "GeoIPASNum" => { "version" => "2014-02-12", "sha1" => "6f33ca0b31e5f233e36d1f66fbeae36909b58f91", }
+  },
+  "kafka" => { "version" => "0.8.1.1", "sha1" => "d73cc87fcb01c62fdad8171b7bb9468ac1156e75", "scala_version" => "2.9.2" },
+}
+
+def vendor(*args)
+  return File.join("vendor", *args)
+end
+
+# Untar any files from the given tarball file name.
+#
+# A tar entry is passed to the block. The block should should return 
+# * nil to skip this file
+# * or, the desired string filename to write the file to.
+def untar(tarball, &block)
+  Rake::Task["dependency:archive-tar-minitar"].invoke
+  require "archive/tar/minitar"
+  tgz = Zlib::GzipReader.new(File.open(tarball))
+  # Pull out typesdb
+  tar = Archive::Tar::Minitar::Input.open(tgz)
+  tar.each do |entry|
+    path = block.call(entry)
+    next if path.nil?
+    parent = File.dirname(path)
+    
+    mkdir_p parent unless File.directory?(parent)
+
+    # Skip this file if the output file is the same size
+    if entry.directory?
+      mkdir path unless File.directory?(path)
+    else
+      entry_mode = entry.instance_eval { @mode } & 0777
+      if File.exists?(path)
+        stat = File.stat(path)
+        # TODO(sissel): Submit a patch to archive-tar-minitar upstream to
+        # expose headers in the entry.
+        entry_size = entry.instance_eval { @size }
+        # If file sizes are same, skip writing.
+        next if stat.size == entry_size && (stat.mode & 0777) == entry_mode
+      end
+      puts "Extracting #{entry.full_name} from #{tarball} #{entry_mode.to_s(8)}"
+      File.open(path, "w") do |fd|
+        # eof? check lets us skip empty files. Necessary because the API provided by
+        # Archive::Tar::Minitar::Reader::EntryStream only mostly acts like an
+        # IO object. Something about empty files in this EntryStream causes
+        # IO.copy_stream to throw "can't convert nil into String" on JRuby
+        # TODO(sissel): File a bug about this.
+        while !entry.eof?
+          chunk = entry.read(16384)
+          fd.write(chunk)
+        end
+          #IO.copy_stream(entry, fd)
+      end
+      File.chmod(entry_mode, path)
+    end
+  end
+  tar.close
+end # def untar
+
+namespace "vendor" do
+  task "jruby" do |task, args|
+    name = task.name.split(":")[1]
+    info = DOWNLOADS[name]
+    version = info["version"]
+    #url = "http://jruby.org.s3.amazonaws.com/downloads/#{version}/jruby-complete-#{version}.jar"
+    url = "http://jruby.org.s3.amazonaws.com/downloads/#{version}/jruby-bin-#{version}.tar.gz"
+
+    download = file_fetch(url, info["sha1"])
+    parent = vendor(name).gsub(/\/$/, "")
+    directory parent => "vendor" do
+      mkdir parent
+    end.invoke unless Rake::Task.task_defined?(parent)
+    
+    prefix_re = /^#{Regexp.quote("jruby-#{version}/")}/
+    untar(download) do |entry|
+      out = entry.full_name.gsub(prefix_re, "")
+      next if out =~ /^samples/
+      next if out =~ /@LongLink/
+      vendor(name, out)
+    end # untar
+  end # jruby
+  task "all" => "jruby"
+
+  task "geoip" do |task, args|
+    vendor_name = "geoip"
+    parent = vendor(vendor_name).gsub(/\/$/, "")
+    directory parent => "vendor" do
+      mkdir parent
+    end.invoke unless Rake::Task.task_defined?(parent)
+
+    vendor(vendor_name).tap { |v| mkdir_p v unless File.directory?(v) }
+    files = DOWNLOADS[vendor_name]
+    files.each do |name, info|
+      version = info["version"]
+      url = "http://logstash.objects.dreamhost.com/maxmind/#{name}-#{version}.dat.gz"
+      download = file_fetch(url, info["sha1"])
+      outpath = vendor(vendor_name, "#{name}.dat")
+      tgz = Zlib::GzipReader.new(File.open(download))
+      begin
+        File.open(outpath, "w") do |out|
+          IO::copy_stream(tgz, out)
+        end
+      rescue
+        File.unlink(outpath) if File.file?(outpath)
+        raise
+      end
+      tgz.close
+    end
+  end
+  task "all" => "geoip"
+
+  task "kibana" do |task, args|
+    name = task.name.split(":")[1]
+    info = DOWNLOADS[name]
+    version = info["version"]
+    url = "https://download.elasticsearch.org/kibana/kibana/kibana-#{version}.tar.gz"
+    download = file_fetch(url, info["sha1"])
+
+    parent = vendor(name).gsub(/\/$/, "")
+    directory parent => "vendor" do
+      mkdir parent
+    end.invoke unless Rake::Task.task_defined?(parent)
+
+    prefix_re = /^#{Regexp.quote("kibana-#{version}/")}/
+    untar(download) do |entry|
+      vendor(name, entry.full_name.gsub(prefix_re, ""))
+    end # untar
+  end # task kibana
+  task "all" => "kibana"
+
+  task "kafka" do |task, args|
+    name = task.name.split(":")[1]
+    info = DOWNLOADS[name]
+    version = info["version"]
+    scala_version = info["scala_version"]
+    url = "https://archive.apache.org/dist/kafka/#{version}/kafka_#{scala_version}-#{version}.tgz"
+    download = file_fetch(url, info["sha1"])
+
+    parent = vendor(name).gsub(/\/$/, "")
+    directory parent => "vendor" do
+      mkdir parent
+    end.invoke unless Rake::Task.task_defined?(parent)
+
+    untar(download) do |entry|
+      next unless entry.full_name =~ /\.jar$/
+      vendor(name, File.basename(entry.full_name))
+    end
+  end # task kafka
+  task "all" => "kafka"
+
+  task "elasticsearch" do |task, args|
+    name = task.name.split(":")[1]
+    info = DOWNLOADS[name]
+    version = info["version"]
+    url = "https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-#{version}.tar.gz"
+    download = file_fetch(url, info["sha1"])
+
+    parent = vendor(name).gsub(/\/$/, "")
+    directory parent => "vendor" do
+      mkdir parent
+    end.invoke unless Rake::Task.task_defined?(parent)
+
+    untar(download) do |entry|
+      next unless entry.full_name =~ /\.jar$/
+      vendor(name, File.basename(entry.full_name))
+    end # untar
+  end # task elasticsearch
+  task "all" => "elasticsearch"
+
+  task "collectd" do |task, args|
+    name = task.name.split(":")[1]
+    info = DOWNLOADS[name]
+    version = info["version"]
+    sha1 = info["sha1"]
+    url = "https://collectd.org/files/collectd-#{version}.tar.gz"
+
+    download = file_fetch(url, sha1)
+
+    parent = vendor(name).gsub(/\/$/, "")
+    directory parent => "vendor" do
+      mkdir parent
+    end unless Rake::Task.task_defined?(parent)
+
+    file vendor(name, "types.db") => [download, parent] do |task, args|
+      next if File.exists?(task.name)
+      untar(download) do |entry|
+        next unless entry.full_name == "collectd-#{version}/src/types.db"
+        vendor(name, File.basename(entry.full_name))
+      end # untar
+    end.invoke
+  end
+  task "all" => "collectd"
+
+  task "gems" => [ "dependency:bundler" ] do
+    require "logstash/environment"
+    Rake::Task["dependency:rbx-stdlib"] if LogStash::Environment.ruby_engine == "rbx"
+    Rake::Task["dependency:stud"].invoke
+
+    # Skip bundler if we've already done this recently.
+    donefile = File.join(LogStash::Environment.gem_home, ".done")
+    if File.file?(donefile) 
+      age = (Time.now - File.lstat(donefile).mtime)
+      # Skip if the donefile was last modified recently
+      next if age < 300
+    end
+
+    # Try installing a few times in case we hit the "bad_record_mac" ssl error during installation.
+    10.times do
+      begin
+        #Bundler::CLI.start(["install", "--gemfile=tools/Gemfile", "--path", LogStash::Environment.gem_home, "--clean", "--standalone", "--without", "development", "--jobs", 4])
+        # There doesn't seem to be a way to invoke Bundler::CLI *and* have a
+        # different GEM_HOME set that doesn't impact Bundler's view of what
+        # gems are available. I asked about this in #bundler on freenode, and I
+        # was told to stop using the bundler ruby api. Oh well :(
+        bundler = File.join(Gem.bindir, "bundle")
+        jruby = File.join("vendor", "jruby", "bin", "jruby")
+        cmd = [jruby,  bundler, "install", "--gemfile=tools/Gemfile", "--path", LogStash::Environment::BUNDLE_DIR, "--standalone", "--clean", "--without", "development", "--jobs", "4"]
+        system(*cmd)
+        raise $! unless $?.success?
+        break
+      rescue Gem::RemoteFetcher::FetchError => e
+        puts e.message
+        puts e.backtrace.inspect
+        sleep 5 #slow down a bit before retry
+      end
+    end
+    File.write(donefile, Time.now.to_s)
+  end # task gems
+  task "all" => "gems"
+end
diff --git a/rakelib/z_rubycheck.rake b/rakelib/z_rubycheck.rake
new file mode 100644
index 00000000000..5c634cb31af
--- /dev/null
+++ b/rakelib/z_rubycheck.rake
@@ -0,0 +1,11 @@
+if RUBY_ENGINE != "jruby"
+  puts "Restarting myself under JRuby (currently #{RUBY_ENGINE} #{RUBY_VERSION})" if $DEBUG
+
+  # Make sure we have JRuby, then rerun ourselves under jruby.
+  Rake::Task["vendor:jruby"].invoke
+  
+  jruby = File.join("vendor", "jruby", "bin", "jruby")
+  rake = File.join("vendor", "jruby", "bin", "rake")
+  exec(jruby, "-S", rake, *ARGV)
+end
+
diff --git a/spec/outputs/email_spec.rb b/spec/outputs/email_spec.rb
index 38a8b50ea00..f2a2639c870 100644
--- a/spec/outputs/email_spec.rb
+++ b/spec/outputs/email_spec.rb
@@ -5,8 +5,8 @@
 describe "outputs/email", :broken => true do
     
 
-    @@port=2525
-    let (:rumbster) { Rumbster.new(@@port) }
+    port = 2525
+    let (:rumbster) { Rumbster.new(port) }
     let (:message_observer) { MailMessageObserver.new }
 
     before :each do
@@ -36,7 +36,7 @@
             email {
                 to => "email1@host, email2@host"
                 match => ["mymatch", "dummy_match,ok"]
-                options => ["port", #{@@port}]
+                options => ["port", #{port}]
             }
         }
         CONFIG
@@ -67,7 +67,7 @@
             email {
                 to => "%{to_addr}"
                 match => ["mymatch", "dummy_match,ok"]
-                options => ["port", #{@@port}]
+                options => ["port", #{port}]
             }
         }
         CONFIG
@@ -98,7 +98,7 @@
                 subject => "Hello World"
                 body => "Line1\\nLine2\\nLine3"
                 match => ["mymatch", "dummy_match,*"]
-                options => ["port", #{@@port}]
+                options => ["port", #{port}]
             }
         }
         CONFIG
@@ -130,7 +130,7 @@
                 subject => "Hello World"
                 body => "Line1\\nLine2\\nLine3"
                 match => ["mymatch", "dummy_match,*"]
-                options => ["port", #{@@port}, "authenticationType", "nil"]
+                options => ["port", #{port}, "authenticationType", "nil"]
             }
         }
         CONFIG
@@ -157,7 +157,7 @@
                 subject => "Hello World"
                 body => "Mail body"
                 match => ["messageAndSourceMatch", "message,*hello,,and,source,*generator"]
-                options => ["port", #{@@port}, "authenticationType", "nil"]
+                options => ["port", #{port}, "authenticationType", "nil"]
             }
         }
         CONFIG
diff --git a/spec/util/environment_spec.rb b/spec/util/environment_spec.rb
index d0dea75ffeb..4c43b9c5e27 100644
--- a/spec/util/environment_spec.rb
+++ b/spec/util/environment_spec.rb
@@ -9,7 +9,7 @@
     end
 
     it "should raise when cannot find elasticsarch jars" do
-      stub_const("LogStash::Environment::JAR_DIR", "/some/invalid/path")
+      stub_const("LogStash::Environment::ELASTICSEARCH_DIR", "/some/invalid/path")
       expect{LogStash::Environment.load_elasticsearch_jars!}.to raise_error(LogStash::EnvironmentError)
     end
   end
