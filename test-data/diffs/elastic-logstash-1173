diff --git a/Makefile b/Makefile
index c92edcba203..36f097d2a0e 100644
--- a/Makefile
+++ b/Makefile
@@ -43,7 +43,7 @@ default:
 	@echo "  tarball -- builds the tarball package"
 	@echo "  tarball-test -- runs the test suite against the tarball package"
 
-TESTS=$(wildcard spec/inputs/file.rb spec/inputs/gelf.rb spec/inputs/imap.rb spec/util/*.rb spec/support/*.rb spec/filters/*.rb spec/examples/*.rb spec/codecs/*.rb spec/conditionals/*.rb spec/event.rb spec/jar.rb spec/web.rb)
+TESTS=$(wildcard spec/**/*.rb)
 
 # The 'version' is generated based on the logstash version, git revision, etc.
 .VERSION.mk: REVISION=$(shell git rev-parse --short HEAD | tr -d ' ')
diff --git a/lib/logstash/codecs/json_spooler.rb b/lib/logstash/codecs/json_spooler.rb
index 00544b25003..cbd16dfade4 100644
--- a/lib/logstash/codecs/json_spooler.rb
+++ b/lib/logstash/codecs/json_spooler.rb
@@ -9,7 +9,7 @@ class LogStash::Codecs::JsonSpooler < LogStash::Codecs::Spool
 
   public
   def decode(data)
-    super(JSON.parse(data.force_encoding("UTF-8"))) do |event|
+    super(JSON.parse(data.force_encoding(Encoding::UTF_8))) do |event|
       yield event
     end
   end # def decode
diff --git a/lib/logstash/codecs/multiline.rb b/lib/logstash/codecs/multiline.rb
index 6dcc7543426..ccb79ae4b77 100644
--- a/lib/logstash/codecs/multiline.rb
+++ b/lib/logstash/codecs/multiline.rb
@@ -19,20 +19,20 @@
 #         }
 #       }
 #     }
-# 
+#
 # The `pattern` should match what you believe to be an indicator that the field
 # is part of a multi-line event.
 #
 # The `what` must be "previous" or "next" and indicates the relation
 # to the multi-line event.
 #
-# The `negate` can be "true" or "false" (defaults to "false"). If "true", a 
+# The `negate` can be "true" or "false" (defaults to "false"). If "true", a
 # message not matching the pattern will constitute a match of the multiline
 # filter and the `what` will be applied. (vice-versa is also true)
 #
 # For example, Java stack traces are multiline and usually have the message
 # starting at the far-left, with each subsequent line indented. Do this:
-# 
+#
 #     input {
 #       stdin {
 #         codec => multiline {
@@ -41,7 +41,7 @@
 #         }
 #       }
 #     }
-#     
+#
 # This says that any line starting with whitespace belongs to the previous line.
 #
 # Another example is to merge lines not starting with a date up to the previous
@@ -149,14 +149,16 @@ def register
 
     @buffer = []
     @handler = method("do_#{@what}".to_sym)
+
+    @charset_encoding = Encoding.find(@charset)
   end # def register
-  
+
   public
   def decode(text, &block)
-    text.force_encoding(@charset)
-    if @charset != "UTF-8"
+    text.force_encoding(@charset_encoding)
+    if @charset_encoding != Encoding::UTF_8
       # Convert to UTF-8 if not in that character set.
-      text = text.encode("UTF-8", :invalid => :replace, :undef => :replace)
+      text = text.encode(Encoding::UTF_8, :invalid => :replace, :undef => :replace)
     end
 
     match = @grok.match(text)
diff --git a/lib/logstash/codecs/oldlogstashjson.rb b/lib/logstash/codecs/oldlogstashjson.rb
index 800c1891620..d815ece335e 100644
--- a/lib/logstash/codecs/oldlogstashjson.rb
+++ b/lib/logstash/codecs/oldlogstashjson.rb
@@ -14,7 +14,7 @@ class LogStash::Codecs::OldLogStashJSON < LogStash::Codecs::Base
   public
   def decode(data)
     begin
-      obj = JSON.parse(data.force_encoding("UTF-8"))
+      obj = JSON.parse(data.force_encoding(Encoding::UTF_8))
     rescue JSON::ParserError => e
       @logger.info("JSON parse failure. Falling back to plain-text", :error => e, :data => data)
       yield LogStash::Event.new("message" => data)
diff --git a/lib/logstash/event.rb b/lib/logstash/event.rb
index cd69b7a0f24..f0a277b1b24 100644
--- a/lib/logstash/event.rb
+++ b/lib/logstash/event.rb
@@ -4,6 +4,7 @@
 require "date"
 require "logstash/namespace"
 require "logstash/util/fieldreference"
+require "logstash/util/accessors"
 require "logstash/time_addon"
 
 # Use a custom serialization for jsonifying Time objects.
@@ -31,7 +32,7 @@ def inspect
 # * "@version" - the version of the schema. Currently "1"
 #
 # They are prefixed with an "@" symbol to avoid clashing with your
-# own custom fields. 
+# own custom fields.
 #
 # When serialized, this is represented in JSON. For example:
 #
@@ -53,8 +54,10 @@ def initialize(data={})
     @cancelled = false
 
     @data = data
+    @accessors = LogStash::Util::Accessors.new(data)
+
     data[VERSION] = VERSION_ONE if !@data.include?(VERSION)
-    if data.include?(TIMESTAMP) 
+    if data.include?(TIMESTAMP)
       t = data[TIMESTAMP]
       if t.is_a?(String)
         data[TIMESTAMP] = LogStash::Time.parse_iso8601(t)
@@ -113,59 +116,36 @@ def unix_timestamp
   def ruby_timestamp
     raise DeprecatedMethod
   end # def unix_timestamp
-  
+
   # field-related access
   public
   def [](str)
     if str[0,1] == CHAR_PLUS
       # nothing?
     else
-      return LogStash::Util::FieldReference.exec(str, @data)
+      # return LogStash::Util::FieldReference.exec(str, @data)
+      @accessors.get(str)
     end
   end # def []
-  
+
   public
   def []=(str, value)
     if str == TIMESTAMP && !value.is_a?(Time)
       raise TypeError, "The field '@timestamp' must be a Time, not a #{value.class} (#{value})"
     end
 
-    r = LogStash::Util::FieldReference.exec(str, @data) do |obj, key|
-      obj[key] = value
-    end
-
-    # The assignment can fail if the given field reference (str) does not exist
-    # In this case, we'll want to set the value manually.
-    if r.nil?
-      # TODO(sissel): Implement this in LogStash::Util::FieldReference
-      if str[0,1] != "["
-        return @data[str] = value
-      end
-
-      # No existing element was found, so let's set one.
-      *parents, key = str.scan(/(?<=\[)[^\]]+(?=\])/)
-      obj = @data
-      parents.each do |p|
-        if obj.include?(p)
-          obj = obj[p]
-        else
-          obj[p] = {}
-          obj = obj[p]
-        end
-      end
-      obj[key] = value
-    end
-    return value
+    # return LogStash::Util::FieldReference.set(str, value, @data)
+    @accessors.set(str, value)
   end # def []=
 
   public
   def fields
     raise DeprecatedMethod
   end
-  
+
   public
   def to_json(*args)
-    return @data.to_json(*args) 
+    return @data.to_json(*args)
   end # def to_json
 
   def to_hash
@@ -197,13 +177,14 @@ def append(event)
   # deleted
   public
   def remove(str)
-    return LogStash::Util::FieldReference.exec(str, @data) do |obj, key|
-      next obj.delete(key)
-    end
+    # return LogStash::Util::FieldReference.exec(str, @data) do |obj, key|
+    #   next obj.delete(key)
+    # end
+    @accessors.del(str)
   end # def remove
 
   # sprintf. This could use a better method name.
-  # The idea is to take an event and convert it to a string based on 
+  # The idea is to take an event and convert it to a string based on
   # any format values, delimited by %{foo} where 'foo' is a field or
   # metadata member.
   #
@@ -216,7 +197,7 @@ def remove(str)
   # If a %{name} value is an array, then we will join by ','
   # If a %{name} value does not exist, then no substitution occurs.
   #
-  # TODO(sissel): It is not clear what the value of a field that 
+  # TODO(sissel): It is not clear what the value of a field that
   # is an array (or hash?) should be. Join by comma? Something else?
   public
   def sprintf(format)
diff --git a/lib/logstash/filters/anonymize.rb b/lib/logstash/filters/anonymize.rb
index 027d61cc52c..8ec0b77031f 100644
--- a/lib/logstash/filters/anonymize.rb
+++ b/lib/logstash/filters/anonymize.rb
@@ -49,12 +49,14 @@ def filter(event)
 
   private
   def anonymize_ipv4_network(ip_string)
-    IPAddr.new(ip_string).mask(@key.to_i).to_s
-  end  
+    # in JRuby 1.7.11 outputs as US-ASCII
+    IPAddr.new(ip_string).mask(@key.to_i).to_s.force_encoding(Encoding::UTF_8)
+  end
 
   def anonymize_openssl(data)
     digest = algorithm()
-    OpenSSL::HMAC.hexdigest(digest, @key, data)
+    # in JRuby 1.7.11 outputs as ASCII-8BIT
+    OpenSSL::HMAC.hexdigest(digest, @key, data).force_encoding(Encoding::UTF_8)
   end
 
   def anonymize_murmur3(value)
@@ -67,7 +69,7 @@ def anonymize_murmur3(value)
   end
 
   def algorithm
- 
+
    case @algorithm
       #when 'SHA'
         #return OpenSSL::Digest::SHA.new
@@ -89,5 +91,5 @@ def algorithm
         @logger.error("Unknown algorithm")
     end
   end
-      
+
 end # class LogStash::Filters::Anonymize
diff --git a/lib/logstash/filters/checksum.rb b/lib/logstash/filters/checksum.rb
index 1d06fc3a570..348bc39d06c 100644
--- a/lib/logstash/filters/checksum.rb
+++ b/lib/logstash/filters/checksum.rb
@@ -13,7 +13,7 @@ class LogStash::Filters::Checksum < LogStash::Filters::Base
 
   config_name "checksum"
   milestone 1
-  
+
   ALGORITHMS = ["md5", "sha", "sha1", "sha256", "sha384",]
 
   # A list of keys to use in creating the string to checksum
@@ -43,7 +43,10 @@ def filter(event)
     @to_checksum << "|"
     @logger.debug("Final string built", :to_checksum => @to_checksum)
 
-    digested_string = OpenSSL::Digest.hexdigest(@algorithm, @to_checksum)
+
+    # in JRuby 1.7.11 outputs as ASCII-8BIT
+    digested_string = OpenSSL::Digest.hexdigest(@algorithm, @to_checksum).force_encoding(Encoding::UTF_8)
+
     @logger.debug("Digested string", :digested_string => digested_string)
     event['logstash_checksum'] = digested_string
   end
diff --git a/lib/logstash/filters/dns.rb b/lib/logstash/filters/dns.rb
index 51a362420bc..46bb0755574 100644
--- a/lib/logstash/filters/dns.rb
+++ b/lib/logstash/filters/dns.rb
@@ -72,7 +72,7 @@ def filter(event)
 
     if @resolve
       begin
-        status = Timeout::timeout(@timeout) { 
+        status = Timeout::timeout(@timeout) {
           resolve(event)
         }
       rescue Timeout::Error
@@ -83,7 +83,7 @@ def filter(event)
 
     if @reverse
       begin
-        status = Timeout::timeout(@timeout) { 
+        status = Timeout::timeout(@timeout) {
           reverse(event)
         }
       rescue Timeout::Error
@@ -110,7 +110,8 @@ def resolve(event)
       end
 
       begin
-        address = @resolv.getaddress(raw)
+        # in JRuby 1.7.11 outputs as US-ASCII
+        address = @resolv.getaddress(raw).force_encoding(Encoding::UTF_8)
       rescue Resolv::ResolvError
         @logger.debug("DNS: couldn't resolve the hostname.",
                       :field => field, :value => raw)
@@ -168,7 +169,8 @@ def reverse(event)
         return
       end
       begin
-        hostname = @resolv.getname(raw)
+        # in JRuby 1.7.11 outputs as US-ASCII
+        hostname = @resolv.getname(raw).force_encoding(Encoding::UTF_8)
       rescue Resolv::ResolvError
         @logger.debug("DNS: couldn't resolve the address.",
                       :field => field, :value => raw)
diff --git a/lib/logstash/filters/fingerprint.rb b/lib/logstash/filters/fingerprint.rb
index daa16e70e20..ce39d3c69e5 100644
--- a/lib/logstash/filters/fingerprint.rb
+++ b/lib/logstash/filters/fingerprint.rb
@@ -58,7 +58,7 @@ def filter(event)
           event[@target] = event[field].tr('A-Za-z0-9 \t','')
         end
       else
-        if @concatenate_sources 
+        if @concatenate_sources
           to_string = ''
           @source.sort.each do |k|
             @logger.debug("Adding key to string")
@@ -67,7 +67,7 @@ def filter(event)
           to_string << "|"
           @logger.debug("String built", :to_checksum => to_string)
           event[@target] = anonymize(to_string)
-        else 
+        else
           @source.each do |field|
             next unless event.include?(field)
             if event[field].is_a?(Array)
@@ -83,12 +83,14 @@ def filter(event)
 
   private
   def anonymize_ipv4_network(ip_string)
-    IPAddr.new(ip_string).mask(@key.to_i).to_s
+    # in JRuby 1.7.11 outputs as US-ASCII
+    IPAddr.new(ip_string).mask(@key.to_i).to_s.force_encoding(Encoding::UTF_8)
   end
 
   def anonymize_openssl(data)
     digest = encryption_algorithm()
-    OpenSSL::HMAC.hexdigest(digest, @key, data)
+    # in JRuby 1.7.11 outputs as ASCII-8BIT
+    OpenSSL::HMAC.hexdigest(digest, @key, data).force_encoding(Encoding::UTF_8)
   end
 
   def anonymize_murmur3(value)
diff --git a/lib/logstash/filters/geoip.rb b/lib/logstash/filters/geoip.rb
index 924a579ec46..b8347537860 100644
--- a/lib/logstash/filters/geoip.rb
+++ b/lib/logstash/filters/geoip.rb
@@ -146,8 +146,8 @@ def filter(event)
           value = case value.encoding
             # I have found strings coming from GeoIP that are ASCII-8BIT are actually
             # ISO-8859-1...
-            when Encoding::ASCII_8BIT; value.force_encoding("ISO-8859-1").encode("UTF-8")
-            when Encoding::ISO_8859_1, Encoding::US_ASCII;  value.encode("UTF-8")
+            when Encoding::ASCII_8BIT; value.force_encoding(Encoding::ISO_8859_1).encode(Encoding::UTF_8)
+            when Encoding::ISO_8859_1, Encoding::US_ASCII;  value.encode(Encoding::UTF_8)
             else; value
           end
         end
diff --git a/lib/logstash/filters/mutate.rb b/lib/logstash/filters/mutate.rb
index 8ef29a5b112..89075508c5c 100644
--- a/lib/logstash/filters/mutate.rb
+++ b/lib/logstash/filters/mutate.rb
@@ -40,7 +40,7 @@ class LogStash::Filters::Mutate < LogStash::Filters::Base
   # to help you build a new value from other parts of the event.
   #
   # Example:
-  # 
+  #
   #     filter {
   #       mutate {
   #         replace => [ "message", "%{source_host}: My new message" ]
@@ -52,7 +52,7 @@ class LogStash::Filters::Mutate < LogStash::Filters::Base
   # then no action will be taken.
   #
   # Example:
-  # 
+  #
   #     filter {
   #       mutate {
   #         update => [ "sample", "My new message" ]
@@ -77,7 +77,7 @@ class LogStash::Filters::Mutate < LogStash::Filters::Base
 
   # Convert a string field by applying a regular expression and a replacement.
   # If the field is not a string, no action will be taken.
-  # 
+  #
   # This configuration takes an array consisting of 3 elements per
   # field/substitution.
   #
@@ -101,20 +101,20 @@ class LogStash::Filters::Mutate < LogStash::Filters::Base
   config :gsub, :validate => :array
 
   # Convert a string to its uppercase equivalent.
-  # 
+  #
   # Example:
-  # 
+  #
   #     filter {
   #       mutate {
   #         uppercase => [ "fieldname" ]
   #       }
   #     }
   config :uppercase, :validate => :array
-  
+
   # Convert a string to its lowercase equivalent.
-  # 
+  #
   # Example:
-  # 
+  #
   #     filter {
   #       mutate {
   #         lowercase => [ "fieldname" ]
@@ -128,7 +128,7 @@ class LogStash::Filters::Mutate < LogStash::Filters::Base
   # Example:
   #
   #     filter {
-  #       mutate { 
+  #       mutate {
   #          split => ["fieldname", ","]
   #       }
   #     }
@@ -139,7 +139,7 @@ class LogStash::Filters::Mutate < LogStash::Filters::Base
   # Example:
   #
   #    filter {
-  #      mutate { 
+  #      mutate {
   #        join => ["fieldname", ","]
   #      }
   #    }
@@ -150,7 +150,7 @@ class LogStash::Filters::Mutate < LogStash::Filters::Base
   # Example:
   #
   #     filter {
-  #       mutate { 
+  #       mutate {
   #          strip => ["field1", "field2"]
   #       }
   #     }
@@ -165,7 +165,7 @@ class LogStash::Filters::Mutate < LogStash::Filters::Base
   # Example:
   #
   #     filter {
-  #       mutate { 
+  #       mutate {
   #          merge => ["dest_field", "added_field"]
   #       }
   #     }
@@ -184,7 +184,7 @@ def register
         raise "Bad configuration, aborting."
       end
     end # @convert.each
-    
+
     @gsub_parsed = []
     @gsub.nil? or @gsub.each_slice(3) do |field, needle, replacement|
       if [field, needle, replacement].any? {|n| n.nil?}
@@ -274,7 +274,11 @@ def convert(event)
   end # def convert
 
   def convert_string(value)
-    return value.to_s
+    # since this is a filter and all inputs should be already UTF-8
+    # we wont check valid_encoding? but just force UTF-8 for
+    # the Fixnum#to_s case which always result in US-ASCII
+    # see https://twitter.com/jordansissel/status/444613207143903232
+    return value.to_s.force_encoding(Encoding::UTF_8)
   end # def convert_string
 
   def convert_integer(value)
@@ -312,7 +316,7 @@ def gsub(event)
       end
     end # @gsub_parsed.each
   end # def gsub
-  
+
   private
   def uppercase(event)
     @uppercase.each do |field|
@@ -346,7 +350,7 @@ def split(event)
     @split.each do |field, separator|
       if event[field].is_a?(String)
         event[field] = event[field].split(separator)
-      else 
+      else
         @logger.debug("Can't split something that isn't a string",
                       :field => field, :value => event[field])
       end
diff --git a/lib/logstash/filters/useragent.rb b/lib/logstash/filters/useragent.rb
index 03777a4cd2b..4e892535b00 100644
--- a/lib/logstash/filters/useragent.rb
+++ b/lib/logstash/filters/useragent.rb
@@ -84,24 +84,26 @@ def filter(event)
         target = event[@target] ||= {}
       end
 
-      target[@prefix + "name"] = ua_data.name
+      # UserAgentParser outputs as US-ASCII.
+
+      target[@prefix + "name"] = ua_data.name.force_encoding(Encoding::UTF_8).force_encoding(Encoding::UTF_8)
 
       #OSX, Andriod and maybe iOS parse correctly, ua-agent parsing for Windows does not provide this level of detail
       unless ua_data.os.nil?
-        target[@prefix + "os"] = ua_data.os.to_s
-        target[@prefix + "os_name"] = ua_data.os.name.to_s
-        target[@prefix + "os_major"] = ua_data.os.version.major.to_s unless ua_data.os.version.nil?
-        target[@prefix + "os_minor"] = ua_data.os.version.minor.to_s unless ua_data.os.version.nil?
+        target[@prefix + "os"] = ua_data.os.to_s.force_encoding(Encoding::UTF_8)
+        target[@prefix + "os_name"] = ua_data.os.name.to_s.force_encoding(Encoding::UTF_8)
+        target[@prefix + "os_major"] = ua_data.os.version.major.to_s.force_encoding(Encoding::UTF_8) unless ua_data.os.version.nil?
+        target[@prefix + "os_minor"] = ua_data.os.version.minor.to_s.force_encoding(Encoding::UTF_8) unless ua_data.os.version.nil?
       end
 
-      target[@prefix + "device"] = ua_data.device.to_s if not ua_data.device.nil?
+      target[@prefix + "device"] = ua_data.device.to_s.force_encoding(Encoding::UTF_8) if not ua_data.device.nil?
 
       if not ua_data.version.nil?
         ua_version = ua_data.version
-        target[@prefix + "major"] = ua_version.major
-        target[@prefix + "minor"] = ua_version.minor
-        target[@prefix + "patch"] = ua_version.patch if ua_version.patch
-        target[@prefix + "build"] = ua_version.patch_minor if ua_version.patch_minor 
+        target[@prefix + "major"] = ua_version.major.force_encoding(Encoding::UTF_8)
+        target[@prefix + "minor"] = ua_version.minor.force_encoding(Encoding::UTF_8)
+        target[@prefix + "patch"] = ua_version.patch.force_encoding(Encoding::UTF_8) if ua_version.patch
+        target[@prefix + "build"] = ua_version.patch_minor.force_encoding(Encoding::UTF_8) if ua_version.patch_minor
       end
 
       filter_matched(event)
diff --git a/lib/logstash/inputs/imap.rb b/lib/logstash/inputs/imap.rb
index 5e5837660a9..c3fb794e63f 100644
--- a/lib/logstash/inputs/imap.rb
+++ b/lib/logstash/inputs/imap.rb
@@ -13,6 +13,8 @@ class LogStash::Inputs::IMAP < LogStash::Inputs::Base
   milestone 1
   ISO8601_STRFTIME = "%04d-%02d-%02dT%02d:%02d:%02d.%06d%+03d:00".freeze
 
+  default :codec, "plain"
+
   config :host, :validate => :string, :required => true
   config :port, :validate => :number
 
@@ -91,41 +93,42 @@ def parse_mail(mail)
       message = part.decoded
     end
 
-    event = LogStash::Event.new("message" => message)
-
-    # Use the 'Date' field as the timestamp
-    event["@timestamp"] = mail.date.to_time.gmtime
-
-    # Add fields: Add message.header_fields { |h| h.name=> h.value }
-    mail.header_fields.each do |header|
-      if @lowercase_headers
-        # 'header.name' can sometimes be a Mail::Multibyte::Chars, get it in
-        # String form
-        name = header.name.to_s.downcase
-      else
-        name = header.name.to_s
-      end
-      # Call .decoded on the header in case it's in encoded-word form.
-      # Details at:
-      #   https://github.com/mikel/mail/blob/master/README.md#encodings
-      #   http://tools.ietf.org/html/rfc2047#section-2
-      value = header.decoded
-
-      # Assume we already processed the 'date' above.
-      next if name == "Date"
-
-      case event[name]
-        # promote string to array if a header appears multiple times
-        # (like 'received')
-        when String; event[name] = [event[name], value]
-        when Array; event[name].is_a?(Array)
-        when nil; event[name] = value
-      end
-    end # mail.header_fields.each
-
-    decorate(event)
-
-    return event
+    @codec.decode(message) do |event|
+      # event = LogStash::Event.new("message" => message)
+
+      # Use the 'Date' field as the timestamp
+      event["@timestamp"] = mail.date.to_time.gmtime
+
+      # Add fields: Add message.header_fields { |h| h.name=> h.value }
+      mail.header_fields.each do |header|
+        if @lowercase_headers
+          # 'header.name' can sometimes be a Mail::Multibyte::Chars, get it in
+          # String form
+          name = header.name.to_s.downcase
+        else
+          name = header.name.to_s
+        end
+        # Call .decoded on the header in case it's in encoded-word form.
+        # Details at:
+        #   https://github.com/mikel/mail/blob/master/README.md#encodings
+        #   http://tools.ietf.org/html/rfc2047#section-2
+        value = transcode_to_utf8(header.decoded)
+
+        # Assume we already processed the 'date' above.
+        next if name == "Date"
+
+        case event[name]
+          # promote string to array if a header appears multiple times
+          # (like 'received')
+          when String; event[name] = [event[name], value]
+          when Array; event[name].is_a?(Array)
+          when nil; event[name] = value
+        end
+      end # mail.header_fields.each
+
+      decorate(event)
+      event
+    end
   end # def handle
 
   public
@@ -133,4 +136,13 @@ def teardown
     $stdin.close
     finished
   end # def teardown
+
+  private
+
+  # transcode_to_utf8 is meant for headers transcoding.
+  # the mail gem will set the correct encoding on header strings decoding
+  # and we want to transcode it to utf8
+  def transcode_to_utf8(s)
+    s.encode(Encoding::UTF_8, :invalid => :replace, :undef => :replace)
+  end
 end # class LogStash::Inputs::IMAP
diff --git a/lib/logstash/inputs/invalid_input.rb b/lib/logstash/inputs/invalid_input.rb
new file mode 100644
index 00000000000..30b19d0fa12
--- /dev/null
+++ b/lib/logstash/inputs/invalid_input.rb
@@ -0,0 +1,19 @@
+# encoding: utf-8
+require "logstash/inputs/base"
+require "logstash/namespace"
+require "socket" # for Socket.gethostname
+
+class LogStash::Inputs::InvalidInput < LogStash::Inputs::Base
+  config_name "invalid_input"
+  milestone 1
+
+  public
+  def register; end
+
+  def run(queue)
+    event = LogStash::Event.new("message" =>"hello world 1 ÅÄÖ \xED")
+    decorate(event)
+    queue << event
+    loop do; sleep(1); end
+  end
+end
diff --git a/lib/logstash/inputs/lumberjack.rb b/lib/logstash/inputs/lumberjack.rb
index 4ce8a63ffdd..c4c5cfc1fcd 100644
--- a/lib/logstash/inputs/lumberjack.rb
+++ b/lib/logstash/inputs/lumberjack.rb
@@ -2,7 +2,7 @@
 require "logstash/inputs/base"
 require "logstash/namespace"
 
-# Receive events using the lumberjack protocol. 
+# Receive events using the lumberjack protocol.
 #
 # This is mainly to receive events shipped with lumberjack,
 # <http://github.com/jordansissel/lumberjack>, now represented primarily via the
@@ -46,7 +46,7 @@ def run(output_queue)
     @lumberjack.run do |l|
       @codec.decode(l.delete("line")) do |event|
         decorate(event)
-        l.each { |k,v| event[k] = v; v.force_encoding("UTF-8") }
+        l.each { |k,v| event[k] = v; v.force_encoding(Encoding::UTF_8) }
         output_queue << event
       end
     end
diff --git a/lib/logstash/runner.rb b/lib/logstash/runner.rb
index 78f00ce31a7..a705e856e1e 100644
--- a/lib/logstash/runner.rb
+++ b/lib/logstash/runner.rb
@@ -1,6 +1,6 @@
 # encoding: utf-8
 
-Encoding.default_external = "UTF-8"
+Encoding.default_external = Encoding::UTF_8
 $START = Time.now
 $DEBUGLIST = (ENV["DEBUG"] || "").split(",")
 
@@ -99,7 +99,7 @@ def run(args)
       "version" => lambda do
         require "logstash/agent"
         agent_args = ["--version"]
-        if args.include?("--verbose") 
+        if args.include?("--verbose")
           agent_args << "--verbose"
         end
         LogStash::Agent.run($0, agent_args)
diff --git a/lib/logstash/util/accessors.rb b/lib/logstash/util/accessors.rb
new file mode 100644
index 00000000000..2d525400992
--- /dev/null
+++ b/lib/logstash/util/accessors.rb
@@ -0,0 +1,62 @@
+# encoding: utf-8
+require "logstash/namespace"
+require "logstash/util"
+
+
+module LogStash::Util
+
+  # PathCache is a singleton which globally caches a parsed fields path for the path to the
+  # container hash and key in that hash.
+  module PathCache
+    extend self
+
+    def get(accessor)
+      @cache ||= {}
+      @cache[accessor] ||= parse(accessor)
+    end
+
+    def parse(accessor)
+      path = accessor.split(/[\[\]]/).select{|s| !s.empty?}
+      [path.pop, path]
+    end
+  end
+
+
+  # Accessors uses a lookup table to speedup access of an accessor field of the type
+  # "[hello][world]" to the underlying store hash into {"hello" => {"world" => "foo"}}
+  class Accessors
+
+    def initialize(store)
+      @store = store
+      @lut = {}
+    end
+
+    def get(accessor)
+      target, key = lookup(accessor)
+      target.is_a?(Array) ? target[key.to_i] : target[key]
+    end
+
+    def set(accessor, value)
+      target, key = lookup(accessor)
+      target[key] = value
+    end
+
+    def del(accessor)
+      target, key = lookup(accessor)
+      target.delete(key)
+    end
+
+    private
+
+    def lookup(accessor)
+      @lut[accessor] ||= store_path(accessor)
+    end
+
+    def store_path(accessor)
+      key, path = PathCache.get(accessor)
+      target = path.inject(@store) {|r, k| r[k] ||= {}}
+      [target, key]
+    end
+
+  end
+end # module LogStash::Util::Accessors
diff --git a/lib/logstash/util/charset.rb b/lib/logstash/util/charset.rb
index 29a8efb39d5..a82f1a7bdaa 100644
--- a/lib/logstash/util/charset.rb
+++ b/lib/logstash/util/charset.rb
@@ -7,14 +7,15 @@ class LogStash::Util::Charset
 
   def initialize(charset)
     @charset = charset
+    @charset_encoding = Encoding.find(charset)
   end
 
   def convert(data)
-    data.force_encoding(@charset)
+    data.force_encoding(@charset_encoding)
 
     # NON UTF-8 charset declared.
     # Let's convert it (as cleanly as possible) into UTF-8 so we can use it with JSON, etc.
-    return data.encode("UTF-8", :invalid => :replace, :undef => :replace) unless @charset == "UTF-8"
+    return data.encode(Encoding::UTF_8, :invalid => :replace, :undef => :replace) unless @charset_encoding == Encoding::UTF_8
 
     # UTF-8 charset declared.
     # Some users don't know the charset of their logs or just don't know they
diff --git a/lib/logstash/util/fieldreference.rb b/lib/logstash/util/fieldreference.rb
index 041304a6b8f..0683310533c 100644
--- a/lib/logstash/util/fieldreference.rb
+++ b/lib/logstash/util/fieldreference.rb
@@ -3,47 +3,65 @@
 require "logstash/util"
 
 module LogStash::Util::FieldReference
-  def compile(str)
-    if str[0,1] != '['
+
+  def compile(accessor)
+    if accessor[0,1] != '['
       return <<-"CODE"
-        lambda do |e, &block|
-          return block.call(e, #{str.inspect}) unless block.nil?
-          return e[#{str.inspect}]
+        lambda do |store, &block|
+          return block.nil? ? store[#{accessor.inspect}] : block.call(store, #{accessor.inspect})
         end
       CODE
     end
 
-    code = "lambda do |e, &block|\n"
-    selectors = str.scan(/(?<=\[).+?(?=\])/)
+    code = "lambda do |store, &block|\n"
+    selectors = accessor.scan(/(?<=\[).+?(?=\])/)
     selectors.each_with_index do |tok, i|
       last = (i == selectors.count() - 1)
       code << "   # [#{tok}]#{ last ? " (last selector)" : "" }\n"
-     
+
       if last
         code << <<-"CODE"
-          return block.call(e, #{tok.inspect}) unless block.nil?
+          return block.call(store, #{tok.inspect}) unless block.nil?
         CODE
       end
 
       code << <<-"CODE"
-        if e.is_a?(Array)
-          e = e[#{tok.to_i}]
-        else
-          e = e[#{tok.inspect}]
-        end
-        return e if e.nil?
+        store = store.is_a?(Array) ? store[#{tok.to_i}] : store[#{tok.inspect}]
+        return store if store.nil?
       CODE
-      
+
     end
-    code << "return e\nend"
+    code << "return store\nend"
     #puts code
     return code
   end # def compile
 
-  def exec(str, obj, &block)
+  def exec(accessor, store, &block)
     @__fieldeval_cache ||= {}
-    @__fieldeval_cache[str] ||= eval(compile(str))
-    return @__fieldeval_cache[str].call(obj, &block)
+    @__fieldeval_cache[accessor] ||= eval(compile(accessor))
+    return @__fieldeval_cache[accessor].call(store, &block)
+  end
+
+  def set(accessor, value, store)
+    # The assignment can fail if the given field reference (accessor) does not exist
+    # In this case, we'll want to set the value manually.
+    if exec(accessor, store) { |hash, key| hash[key] = value }.nil?
+      return (store[accessor] = value) if accessor[0,1] != "["
+
+      # No existing element was found, so let's set one.
+      *parents, key = accessor.scan(/(?<=\[)[^\]]+(?=\])/)
+      parents.each do |p|
+        if store.include?(p)
+          store = store[p]
+        else
+          store[p] = {}
+          store = store[p]
+        end
+      end
+      store[key] = value
+    end
+
+    return value
   end
 
   extend self
diff --git a/spec/codecs/plain.rb b/spec/codecs/plain.rb
index 6183910109c..de9fede2734 100644
--- a/spec/codecs/plain.rb
+++ b/spec/codecs/plain.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "logstash/codecs/plain"
 require "logstash/event"
 require "insist"
diff --git a/spec/event.rb b/spec/event.rb
index a9c1ed2fa53..64533f80900 100644
--- a/spec/event.rb
+++ b/spec/event.rb
@@ -9,19 +9,19 @@
       "message" => "hello world",
       "tags" => [ "tag1" ],
       "source" => "/home/foo",
-      "a" => "b", 
+      "a" => "b",
       "c" => {
         "d" => "f",
         "e" => {"f" => "g"}
-      }, 
+      },
       "f" => { "g" => { "h" => "i" } },
-      "j" => { 
-          "k1" => "v", 
+      "j" => {
+          "k1" => "v",
           "k2" => [ "w", "x" ],
           "k3" => {"4" => "m"},
           5 => 6,
           "5" => 7
-      } 
+      }
     )
   end
 
@@ -29,24 +29,54 @@
     it "should raise an exception if you attempt to set @timestamp to a value type other than a Time object" do
       insist { subject["@timestamp"] = "crash!" }.raises(TypeError)
     end
+
+    it "should assign simple fields" do
+      insist { subject["foo"] }.nil?
+      insist { subject["foo"] = "bar"} == "bar"
+      insist { subject["foo"] } == "bar"
+    end
+
+    it "should overwrite simple fields" do
+      insist { subject["foo"] }.nil?
+      insist { subject["foo"] = "bar"} == "bar"
+      insist { subject["foo"] } == "bar"
+
+      insist { subject["foo"] = "baz"} == "baz"
+      insist { subject["foo"] } == "baz"
+    end
+
+    it "should assign deep fields" do
+      insist { subject["[foo][bar]"] }.nil?
+      insist { subject["[foo][bar]"] = "baz"} == "baz"
+      insist { subject["[foo][bar]"] } == "baz"
+    end
+
+    it "should overwrite deep fields" do
+      insist { subject["[foo][bar]"] }.nil?
+      insist { subject["[foo][bar]"] = "baz"} == "baz"
+      insist { subject["[foo][bar]"] } == "baz"
+
+      insist { subject["[foo][bar]"] = "zab"} == "zab"
+      insist { subject["[foo][bar]"] } == "zab"
+    end
   end
 
   context "#sprintf" do
     it "should report a unix timestamp for %{+%s}" do
       insist { subject.sprintf("%{+%s}") } == "1356998400"
     end
-    
+
     it "should report a time with %{+format} syntax", :if => RUBY_ENGINE == "jruby" do
       insist { subject.sprintf("%{+YYYY}") } == "2013"
       insist { subject.sprintf("%{+MM}") } == "01"
       insist { subject.sprintf("%{+HH}") } == "00"
     end
-  
+
     it "should report fields with %{field} syntax" do
       insist { subject.sprintf("%{type}") } == "sprintf"
       insist { subject.sprintf("%{message}") } == subject["message"]
     end
-    
+
     it "should print deep fields" do
       insist { subject.sprintf("%{[j][k1]}") } == "v"
       insist { subject.sprintf("%{[j][k2][0]}") } == "w"
@@ -56,7 +86,7 @@
       insist { subject.sprintf(2) } == "2"
     end
   end
-  
+
   context "#[]" do
     it "should fetch data" do
       insist { subject["type"] } == "sprintf"
@@ -88,12 +118,12 @@
       subject.append(LogStash::Event.new("message" => "another thing"))
       insist { subject["message"] } == [ "hello world", "another thing" ]
     end
-  
+
     it "should concatenate tags" do
       subject.append(LogStash::Event.new("tags" => [ "tag2" ]))
       insist { subject["tags"] } == [ "tag1", "tag2" ]
     end
-  
+
     context "when event field is nil" do
       it "should add single value as string" do
         subject.append(LogStash::Event.new({"field1" => "append1"}))
@@ -104,10 +134,10 @@
         insist { subject[ "field1" ] } == [ "append1","append2" ]
       end
     end
-  
+
     context "when event field is a string" do
       before { subject[ "field1" ] = "original1" }
-  
+
       it "should append string to values, if different from current" do
         subject.append(LogStash::Event.new({"field1" => "append1"}))
         insist { subject[ "field1" ] } == [ "original1", "append1" ]
@@ -127,7 +157,7 @@
     end
     context "when event field is an array" do
       before { subject[ "field1" ] = [ "original1", "original2" ] }
-  
+
       it "should append string values to array, if not present in array" do
         subject.append(LogStash::Event.new({"field1" => "append1"}))
         insist { subject[ "field1" ] } == [ "original1", "original2", "append1" ]
@@ -166,7 +196,7 @@
   context "acceptable @timestamp formats" do
     subject { LogStash::Event.new }
 
-    formats = [ 
+    formats = [
       "YYYY-MM-dd'T'HH:mm:ss.SSSZ",
       "YYYY-MM-dd'T'HH:mm:ss.SSSSSSZ",
       "YYYY-MM-dd'T'HH:mm:ss.SSS",
diff --git a/spec/examples/fail2ban.rb b/spec/examples/fail2ban.rb
index 0e5960fda42..edb0baa9693 100644
--- a/spec/examples/fail2ban.rb
+++ b/spec/examples/fail2ban.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 
 describe "fail2ban logs", :if => RUBY_ENGINE == "jruby"  do
diff --git a/spec/examples/graphite-input.rb b/spec/examples/graphite-input.rb
index eb78318813d..fc86b09c49d 100644
--- a/spec/examples/graphite-input.rb
+++ b/spec/examples/graphite-input.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 
 describe "receive graphite input", :if => RUBY_ENGINE == "jruby" do
@@ -36,6 +38,6 @@
     insist { subject["name"] } == "foo.bar.baz"
     insist { subject["value"] } == 4025.34
     insist { subject["@timestamp"] } == Time.iso8601("2013-03-30T01:22:02.000Z")
-    
+
   end
 end
diff --git a/spec/examples/parse-apache-logs.rb b/spec/examples/parse-apache-logs.rb
index 2bc2a539ecb..c2a20f28b78 100644
--- a/spec/examples/parse-apache-logs.rb
+++ b/spec/examples/parse-apache-logs.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 
 describe "apache common log format", :if => RUBY_ENGINE == "jruby" do
diff --git a/spec/examples/parse-haproxy-logs.rb b/spec/examples/parse-haproxy-logs.rb
index 33bc83954fd..90f272c7a54 100644
--- a/spec/examples/parse-haproxy-logs.rb
+++ b/spec/examples/parse-haproxy-logs.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 
 describe "haproxy httplog format" do
diff --git a/spec/examples/syslog.rb b/spec/examples/syslog.rb
index 885cf9467f7..fe617cf59df 100644
--- a/spec/examples/syslog.rb
+++ b/spec/examples/syslog.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 
 describe "parse syslog", :if => RUBY_ENGINE == "jruby" do
diff --git a/spec/filters/anonymize.rb b/spec/filters/anonymize.rb
index 5d199bd3b58..43f571b8284 100644
--- a/spec/filters/anonymize.rb
+++ b/spec/filters/anonymize.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 require "logstash/filters/anonymize"
 
@@ -24,8 +26,8 @@
 
   describe "anonymize string with MURMUR3 algorithm" do
     config <<-CONFIG
-      filter { 
-        anonymize { 
+      filter {
+        anonymize {
           fields => ["clientip"]
           algorithm => "MURMUR3"
           key => ""
@@ -37,7 +39,7 @@
       insist { subject["clientip"] } == 1541804874
     end
   end
- 
+
    describe "anonymize string with SHA1 alogrithm" do
     # The logstash config goes here.
     # At this time, only filters are supported.
@@ -184,6 +186,6 @@
     end
   end
 
-  
+
 
 end
diff --git a/spec/filters/checksum.rb b/spec/filters/checksum.rb
index 9593a83e564..bb8f2eae887 100644
--- a/spec/filters/checksum.rb
+++ b/spec/filters/checksum.rb
@@ -1,10 +1,12 @@
+# encoding: utf-8
+
 require "test_utils"
 require "logstash/filters/checksum"
 require 'openssl'
 
 describe LogStash::Filters::Checksum do
   extend LogStash::RSpec
-  
+
   LogStash::Filters::Checksum::ALGORITHMS.each do |alg|
     describe "#{alg} checksum with single field" do
       config <<-CONFIG
@@ -21,7 +23,7 @@
         insist { subject["logstash_checksum"] } == OpenSSL::Digest.hexdigest(alg, "|test|foo bar|")
       end
     end
-    
+
     describe "#{alg} checksum with multiple keys" do
       config <<-CONFIG
         filter {
diff --git a/spec/filters/csv.rb b/spec/filters/csv.rb
index 717a80b2df7..ad44a4bcc24 100644
--- a/spec/filters/csv.rb
+++ b/spec/filters/csv.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 require "logstash/filters/csv"
 
diff --git a/spec/filters/dns.rb b/spec/filters/dns.rb
index 9affaa939e7..8ed6dc5b8ab 100644
--- a/spec/filters/dns.rb
+++ b/spec/filters/dns.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 require "logstash/filters/dns"
 require "resolv"
diff --git a/spec/filters/fingerprint.rb b/spec/filters/fingerprint.rb
index 828696f9ea9..22fe49543f6 100644
--- a/spec/filters/fingerprint.rb
+++ b/spec/filters/fingerprint.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 require "logstash/filters/fingerprint"
 
@@ -22,8 +24,8 @@
 
   describe "fingerprint string with MURMUR3 method" do
     config <<-CONFIG
-      filter { 
-        fingerprint { 
+      filter {
+        fingerprint {
           source => ["clientip"]
           method => "MURMUR3"
         }
@@ -34,7 +36,7 @@
       insist { subject["fingerprint"] } == 1541804874
     end
   end
- 
+
    describe "fingerprint string with SHA1 alogrithm" do
     config <<-CONFIG
       filter {
@@ -141,7 +143,7 @@
         }
       }
     CONFIG
-    
+
     sample("field1" => "test1", "field2" => "test2") do
       insist { subject["fingerprint"]} == "872da745e45192c2a1d4bf7c1ff8a370"
     end
diff --git a/spec/filters/grok.rb b/spec/filters/grok.rb
index 45cfe3f93b5..cfc2dddb5f0 100644
--- a/spec/filters/grok.rb
+++ b/spec/filters/grok.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 require "logstash/filters/grok"
 
diff --git a/spec/filters/mutate.rb b/spec/filters/mutate.rb
index 61f0c76e72a..9eb281fccb9 100644
--- a/spec/filters/mutate.rb
+++ b/spec/filters/mutate.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 require "logstash/filters/mutate"
 
@@ -105,7 +107,7 @@
         }
       }'
 
-    sample("unicorns" => [ 
+    sample("unicorns" => [
       "Magnificient extinct animals", "Other extinct ideas" ]
     ) do
       insist { subject["unicorns"] } == [
diff --git a/spec/filters/split.rb b/spec/filters/split.rb
index e422bb57de5..f258dc38952 100644
--- a/spec/filters/split.rb
+++ b/spec/filters/split.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 require "logstash/filters/split"
 
@@ -22,7 +24,7 @@
   describe "custome terminator" do
     config <<-CONFIG
       filter {
-        split { 
+        split {
           terminator => "\t"
         }
       }
@@ -39,7 +41,7 @@
   describe "custom field" do
     config <<-CONFIG
       filter {
-        split { 
+        split {
           field => "custom"
         }
       }
diff --git a/spec/filters/urldecode.rb b/spec/filters/urldecode.rb
index bedbcf85046..4fe3a4f5297 100644
--- a/spec/filters/urldecode.rb
+++ b/spec/filters/urldecode.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 require "logstash/filters/urldecode"
 
@@ -21,8 +23,8 @@
 
   describe "urldecode of incorrect urlencoded data" do
     config <<-CONFIG
-      filter { 
-        urldecode { 
+      filter {
+        urldecode {
         }
       }
     CONFIG
@@ -31,7 +33,7 @@
       insist { subject["message"] } == "http://logstash.net/docs/1.3.2/filters/urldecode"
     end
   end
- 
+
    describe "urldecode with all_fields set to true" do
     # The logstash config goes here.
     # At this time, only filters are supported.
diff --git a/spec/filters/useragent.rb b/spec/filters/useragent.rb
index 1b366699af8..d7d83e0e418 100644
--- a/spec/filters/useragent.rb
+++ b/spec/filters/useragent.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 require "logstash/filters/useragent"
 
diff --git a/spec/inputs/collectd.rb b/spec/inputs/collectd.rb
index ae3b0cef534..77af551beaa 100644
--- a/spec/inputs/collectd.rb
+++ b/spec/inputs/collectd.rb
@@ -2,7 +2,7 @@
 require "socket"
 require "tempfile"
 
-describe "inputs/collectd" do
+describe "inputs/collectd", :socket => true do
   extend LogStash::RSpec
   udp_sock = UDPSocket.new(Socket::AF_INET)
 
diff --git a/spec/inputs/file.rb b/spec/inputs/file.rb
index 6cee54f1b3e..9126719db99 100644
--- a/spec/inputs/file.rb
+++ b/spec/inputs/file.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "test_utils"
 require "tempfile"
 
@@ -18,20 +20,39 @@
     CONFIG
 
     input do |pipeline, queue|
-      File.open(tmp_file, "a") do |fd|
-        fd.puts("ignore me")
+      File.open(tmp_file, "w") do |fd|
+        fd.puts("ignore me 1")
         fd.puts("ignore me 2")
       end
+
       Thread.new { pipeline.run }
       sleep 0.1 while !pipeline.ready?
 
-      File.open(tmp_file, "a") do |fd|
-        fd.puts("hello")
-        fd.puts("world")
+      # at this point even if pipeline.ready? == true the plugins
+      # threads might still be initializing so we cannot know when the
+      # file plugin will have seen the original file, it could see it
+      # after the first(s) hello world appends below, hence the
+      # retry logic.
+
+      retries = 0
+      loop do
+        insist { retries } < 20 # 2 secs should be plenty?
+
+        File.open(tmp_file, "a") do |fd|
+          fd.puts("hello")
+          fd.puts("world")
+        end
+
+        if queue.size >= 2
+          events = 2.times.collect { queue.pop }
+          insist { events[0]["message"] } == "hello"
+          insist { events[1]["message"] } == "world"
+          break
+        end
+
+        sleep(0.1)
+        retries += 1
       end
-      events = 2.times.collect { queue.pop } 
-      insist { events[0]["message"] } == "hello"
-      insist { events[1]["message"] } == "world"
     end
   end
 
@@ -49,20 +70,16 @@
       }
     CONFIG
 
-    before(:each) do
-      File.open(tmp_file, "w") do |fd|
-        fd.puts "hello"
-        fd.puts "world"
+    input do |pipeline, queue|
+      File.open(tmp_file, "a") do |fd|
+        fd.puts("hello")
+        fd.puts("world")
       end
-    end
-
-    after(:each) do
-      tmp_file.close!
-    end
 
-    input do |pipeline, queue|
       Thread.new { pipeline.run }
-      events = 2.times.collect { queue.pop } 
+      sleep 0.1 while !pipeline.ready?
+
+      events = 2.times.collect { queue.pop }
       insist { events[0]["message"] } == "hello"
       insist { events[1]["message"] } == "world"
     end
@@ -84,21 +101,29 @@
     CONFIG
 
     input do |pipeline, queue|
-      File.open(tmp_file, "a") do |fd|
-        fd.puts "hello"
-        fd.puts "world"
+      File.open(tmp_file, "w") do |fd|
+        fd.puts("hello")
+        fd.puts("world")
       end
-      Thread.new { pipeline.run }
-      events = 2.times.collect { queue.pop } 
+
+      t = Thread.new { pipeline.run }
+      sleep 0.1 while !pipeline.ready?
+
+      events = 2.times.collect { queue.pop }
       pipeline.shutdown
+      t.join
 
       File.open(tmp_file, "a") do |fd|
-        fd.puts "foo"
-        fd.puts "bar"
-        fd.puts "baz"
+        fd.puts("foo")
+        fd.puts("bar")
+        fd.puts("baz")
       end
+
       Thread.new { pipeline.run }
-      events = 3.times.collect { queue.pop } 
+      sleep 0.1 while !pipeline.ready?
+
+      events = 3.times.collect { queue.pop }
+
       insist { events[0]["message"] } == "foo"
       insist { events[1]["message"] } == "bar"
       insist { events[2]["message"] } == "baz"
diff --git a/spec/inputs/generator.rb b/spec/inputs/generator.rb
index 342d6cfd48d..b026e9b06f9 100644
--- a/spec/inputs/generator.rb
+++ b/spec/inputs/generator.rb
@@ -1,6 +1,6 @@
 require "test_utils"
 
-describe "inputs/generator" do
+describe "inputs/generator", :performance => true do
   extend LogStash::RSpec
 
   describe "generate events" do
@@ -23,7 +23,7 @@
         insist { event["sequence"] } == i
       end
       duration = Time.now - start
-      puts "Rate: #{event_count / duration}"
+      puts "Generator Rate: #{"%02.0f/sec" % (event_count / duration)}, Elapsed: #{duration}s"
       pipeline.shutdown
     end # input
   end
diff --git a/spec/inputs/imap.rb b/spec/inputs/imap.rb
index ebe8ddff5d0..f665fa5545b 100644
--- a/spec/inputs/imap.rb
+++ b/spec/inputs/imap.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 require "logstash/inputs/imap"
 require "mail"
 
diff --git a/spec/inputs/redis.rb b/spec/inputs/redis.rb
index bec6d6a45d9..c7f6b513fbc 100644
--- a/spec/inputs/redis.rb
+++ b/spec/inputs/redis.rb
@@ -22,7 +22,7 @@ def process(pipeline, queue, event_count)
   pipeline.shutdown
 end # process
 
-describe "inputs/redis" do
+describe "inputs/redis", :redis => true do
   extend LogStash::RSpec
 
   describe "read events from a list" do
diff --git a/spec/inputs/syslog.rb b/spec/inputs/syslog.rb
index 31ab4949e97..37fa3efcfed 100644
--- a/spec/inputs/syslog.rb
+++ b/spec/inputs/syslog.rb
@@ -2,7 +2,7 @@
 require "test_utils"
 require "socket"
 
-describe "inputs/syslog" do
+describe "inputs/syslog", :socket => true do
   extend LogStash::RSpec
 
   describe "properly handles priority, severity and facilities" do
diff --git a/spec/inputs/tcp.rb b/spec/inputs/tcp.rb
index d228eac13bd..2df9db081d6 100644
--- a/spec/inputs/tcp.rb
+++ b/spec/inputs/tcp.rb
@@ -2,7 +2,7 @@
 require "test_utils"
 require "socket"
 
-describe "inputs/tcp" do
+describe "inputs/tcp", :socket => true do
   extend LogStash::RSpec
 
   describe "read json_event" do
diff --git a/spec/outputs/elasticsearch.rb b/spec/outputs/elasticsearch.rb
index 8586e04e877..915959dadc3 100644
--- a/spec/outputs/elasticsearch.rb
+++ b/spec/outputs/elasticsearch.rb
@@ -1,7 +1,7 @@
 require "test_utils"
 require "ftw"
 
-describe "outputs/elasticsearch" do
+describe "outputs/elasticsearch", :elasticsearch => true do
   extend LogStash::RSpec
 
   describe "ship lots of events w/ default index_type" do
@@ -330,9 +330,9 @@
           terms = results["terms"].collect { |t| t["term"] }
 
           insist { terms }.include?("us")
-          
+
           # 'at' is a stopword, make sure stopwords are not ignored.
-          insist { terms }.include?("at") 
+          insist { terms }.include?("at")
         end
       end
     end
diff --git a/spec/outputs/elasticsearch_http.rb b/spec/outputs/elasticsearch_http.rb
index 7aefcb7a984..d1b1072e06a 100644
--- a/spec/outputs/elasticsearch_http.rb
+++ b/spec/outputs/elasticsearch_http.rb
@@ -1,6 +1,6 @@
 require "test_utils"
 
-describe "outputs/elasticsearch_http" do
+describe "outputs/elasticsearch_http", :elasticsearch => true do
   extend LogStash::RSpec
 
   describe "ship lots of events w/ default index_type" do
@@ -232,9 +232,9 @@
       terms = results["terms"].collect { |t| t["term"] }
 
       insist { terms }.include?("us")
-      
+
       # 'at' is a stopword, make sure stopwords are not ignored.
-      insist { terms }.include?("at") 
+      insist { terms }.include?("at")
     end
   end
 end
diff --git a/spec/outputs/email.rb b/spec/outputs/email.rb
index 01ab946698c..fdcb6c3e94d 100644
--- a/spec/outputs/email.rb
+++ b/spec/outputs/email.rb
@@ -2,9 +2,9 @@
 require "rumbster"
 require "message_observers"
 
-describe "outputs/email" do
+describe "outputs/email", :broken => true do
     extend LogStash::RSpec
-    
+
     @@port=2525
     let (:rumbster) { Rumbster.new(@@port) }
     let (:message_observer) { MailMessageObserver.new }
diff --git a/spec/outputs/file.rb b/spec/outputs/file.rb
index aabb82625d1..bdf6a769809 100644
--- a/spec/outputs/file.rb
+++ b/spec/outputs/file.rb
@@ -8,7 +8,7 @@
   describe "ship lots of events to a file" do
     event_count = 10000 + rand(500)
     tmp_file = Tempfile.new('logstash-spec-output-file')
-    
+
     config <<-CONFIG
       input {
         generator {
@@ -60,17 +60,7 @@
     agent do
       line_num = 0
       # Now check all events for order and correctness.
-      Zlib::GzipReader.new(File.open(tmp_file)).each_line do |line|
-        event = LogStash::Event.new(JSON.parse(line))
-        insist {event["message"]} == "hello world"
-        insist {event["sequence"]} == line_num
-        line_num += 1
-      end
-      insist {line_num} == event_count
-
-      #LOGSTASH-997 confirm usage of zcat command on file
-      line_num = 0
-      `zcat #{tmp_file.path()}`.split("\n").each do |line|
+      Zlib::GzipReader.open(tmp_file.path).each_line do |line|
         event = LogStash::Event.new(JSON.parse(line))
         insist {event["message"]} == "hello world"
         insist {event["sequence"]} == line_num
diff --git a/spec/outputs/graphite.rb b/spec/outputs/graphite.rb
index 049e69d77d6..2b5fe1ac428 100644
--- a/spec/outputs/graphite.rb
+++ b/spec/outputs/graphite.rb
@@ -2,7 +2,7 @@
 require "logstash/outputs/graphite"
 require "mocha/api"
 
-describe LogStash::Outputs::Graphite do
+describe LogStash::Outputs::Graphite, :socket => true do
   extend LogStash::RSpec
 
   describe "defaults should include all metrics" do
diff --git a/spec/outputs/redis.rb b/spec/outputs/redis.rb
index 3a50e6a4e4e..442d8b01734 100644
--- a/spec/outputs/redis.rb
+++ b/spec/outputs/redis.rb
@@ -2,7 +2,7 @@
 require "logstash/outputs/redis"
 require "redis"
 
-describe LogStash::Outputs::Redis do
+describe LogStash::Outputs::Redis, :redis => true do
   extend LogStash::RSpec
 
   describe "ship lots of events to a list" do
diff --git a/spec/support/pull375.rb b/spec/support/pull375.rb
index 3ab2e8f9b2c..77295fc61be 100644
--- a/spec/support/pull375.rb
+++ b/spec/support/pull375.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 # This spec covers the question here:
 # https://github.com/logstash/logstash/pull/375
 
diff --git a/spec/test_utils.rb b/spec/test_utils.rb
index 1bd17677c47..6bfc55b175e 100644
--- a/spec/test_utils.rb
+++ b/spec/test_utils.rb
@@ -1,3 +1,5 @@
+# encoding: utf-8
+
 if ENV['COVERAGE']
   require 'simplecov'
   require 'coveralls'
@@ -35,6 +37,10 @@
   $logger.level = :error
 end
 
+RSpec.configure do |config|
+  config.filter_run_excluding :redis => true, :socket => true, :performance => true, :elasticsearch => true, :broken => true
+end
+
 module LogStash
   module RSpec
     def config(configstr)
@@ -44,7 +50,7 @@ def config(configstr)
     def type(default_type)
       let(:default_type) { default_type }
     end
-    
+
     def tags(*tags)
       let(:default_tags) { tags }
       puts "Setting default tags: #{@default_tags}"
@@ -93,7 +99,7 @@ def input(&block)
       it "inputs" do
         pipeline = LogStash::Pipeline.new(config)
         queue = Queue.new
-        pipeline.instance_eval do 
+        pipeline.instance_eval do
           @output_func = lambda { |event| queue << event }
         end
         block.call(pipeline, queue)
diff --git a/spec/util/accessors_spec.rb b/spec/util/accessors_spec.rb
new file mode 100644
index 00000000000..b5097ea5606
--- /dev/null
+++ b/spec/util/accessors_spec.rb
@@ -0,0 +1,118 @@
+# encoding: utf-8
+
+require "test_utils"
+require "logstash/util/accessors"
+
+describe LogStash::Util::Accessors, :if => true do
+
+  context "using simple field" do
+
+    it "should get value of word key" do
+      str = "hello"
+      data = { "hello" => "world" }
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.get(str) } == data[str]
+    end
+
+    it "should get value of key with spaces" do
+      str = "hel lo"
+      data = { "hel lo" => "world" }
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.get(str) } == data[str]
+    end
+
+    it "should get value of numeric key string" do
+      str = "1"
+      data = { "1" => "world" }
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.get(str) } == data[str]
+    end
+
+    it "should handle delete" do
+      str = "simple"
+      data = { "simple" => "things" }
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.del(str) } == "things"
+      insist { data }.empty?
+    end
+
+    it "should set value" do
+      str = "simple"
+      data = {}
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.set(str, "things") } == "things"
+      insist { data } == { "simple" => "things" }
+    end
+  end
+
+  context "using field path" do
+
+    it "should get shallow value of word key" do
+      str = "[hello]"
+      data = { "hello" =>  "world" }
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.get(str) } == "world"
+    end
+
+    it "should get shallow value of key with spaces" do
+      str = "[hel lo]"
+      data = { "hel lo" =>  "world" }
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.get(str) } == "world"
+    end
+
+    it "should get shallow value of numeric key string" do
+      str = "[1]"
+      data = { "1" =>  "world" }
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.get(str) } == "world"
+    end
+
+    it "should get deep value" do
+      str = "[hello][world]"
+      data = { "hello" => { "world" => "foo", "bar" => "baz" } }
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.get(str) } == data["hello"]["world"]
+    end
+
+    it "should get deep value" do
+      str = "[hello][world]"
+      data = { "hello" => { "world" => "foo", "bar" => "baz" } }
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.get(str) } == data["hello"]["world"]
+    end
+
+    it "should handle delete" do
+      str = "[hello][world]"
+      data = { "hello" => { "world" => "foo", "bar" => "baz" } }
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.del(str) } ==  "foo"
+
+      # Make sure the "world" key is removed.
+      insist { data["hello"] } == { "bar" => "baz" }
+    end
+
+    it "should set shallow value" do
+      str = "[hello]"
+      data = {}
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.set(str, "foo") } == "foo"
+      insist { data } == { "hello" => "foo" }
+    end
+
+    it "should set deep value" do
+      str = "[hello][world]"
+      data = {}
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.set(str, "foo") } == "foo"
+      insist { data } == { "hello" => { "world" => "foo" } }
+    end
+
+    it "should retrieve array item" do
+      data = { "hello" => { "world" => ["a", "b"], "bar" => "baz" } }
+      accessors = LogStash::Util::Accessors.new(data)
+      insist { accessors.get("[hello][world][0]") } == data["hello"]["world"][0]
+      insist { accessors.get("[hello][world][1]") } == data["hello"]["world"][1]
+    end
+  end
+end
diff --git a/spec/util/fieldeval_spec.rb b/spec/util/fieldeval_spec.rb
index c2aa1f7dd3d..4cf10597ba2 100644
--- a/spec/util/fieldeval_spec.rb
+++ b/spec/util/fieldeval_spec.rb
@@ -2,43 +2,95 @@
 require "logstash/util/fieldreference"
 
 describe LogStash::Util::FieldReference, :if => true do
-  it "should permit simple key names" do
-    str = "hello"
-    m = eval(subject.compile(str))
-    data = { "hello" => "world" }
-    insist { m.call(data) } == data[str]
-  end
 
-  it "should permit [key][access]" do
-    str = "[hello][world]"
-    m = eval(subject.compile(str))
-    data = { "hello" => { "world" => "foo", "bar" => "baz" } }
-    insist { m.call(data) } == data["hello"]["world"]
-  end
-  it "should permit [key][access]" do
-    str = "[hello][world]"
-    m = eval(subject.compile(str))
-    data = { "hello" => { "world" => "foo", "bar" => "baz" } }
-    insist { m.call(data) } == data["hello"]["world"]
-  end
-  
-  it "should permit blocks" do
-    str = "[hello][world]"
-    code = subject.compile(str)
-    m = eval(subject.compile(str))
-    data = { "hello" => { "world" => "foo", "bar" => "baz" } }
-    m.call(data) { |obj, key| obj.delete(key) }
-
-    # Make sure the "world" key is removed.
-    insist { data["hello"] } == { "bar" => "baz" }
+  context "using simple accessor" do
+
+    it "should retrieve value" do
+      str = "hello"
+      m = eval(subject.compile(str))
+      data = { "hello" => "world" }
+      insist { m.call(data) } == data[str]
+    end
+
+    it "should handle delete in block" do
+      str = "simple"
+      m = eval(subject.compile(str))
+      data = { "simple" => "things" }
+      m.call(data) { |obj, key| obj.delete(key) }
+      insist { data }.empty?
+    end
+
+    it "should handle assignment in block" do
+      str = "simple"
+      m = eval(subject.compile(str))
+      data = {}
+      insist { m.call(data) { |obj, key| obj[key] = "things" }} == "things"
+      insist { data } == { "simple" => "things" }
+    end
+
+    it "should handle assignment using set" do
+      str = "simple"
+      data = {}
+      insist { subject.set(str, "things", data) } == "things"
+      insist { data } == { "simple" => "things" }
+    end
   end
 
-  it "should permit blocks #2" do
-    str = "simple"
-    code = subject.compile(str)
-    m = eval(subject.compile(str))
-    data = { "simple" => "things" }
-    m.call(data) { |obj, key| obj.delete(key) }
-    insist { data }.empty?
+  context "using accessor path" do
+
+    it "should retrieve shallow value" do
+      str = "[hello]"
+      m = eval(subject.compile(str))
+      data = { "hello" =>  "world" }
+      insist { m.call(data) } == "world"
+    end
+
+    it "should retrieve deep value" do
+      str = "[hello][world]"
+      m = eval(subject.compile(str))
+      data = { "hello" => { "world" => "foo", "bar" => "baz" } }
+      insist { m.call(data) } == data["hello"]["world"]
+    end
+
+    it "should handle delete in block" do
+      str = "[hello][world]"
+      m = eval(subject.compile(str))
+      data = { "hello" => { "world" => "foo", "bar" => "baz" } }
+      m.call(data) { |obj, key| obj.delete(key) }
+
+      # Make sure the "world" key is removed.
+      insist { data["hello"] } == { "bar" => "baz" }
+    end
+
+    it "should not handle assignment in block" do
+      str = "[hello][world]"
+      m = eval(subject.compile(str))
+      data = {}
+      insist { m.call(data) { |obj, key| obj[key] = "things" }}.nil?
+      insist { data } == { }
+    end
+
+    it "should set shallow value" do
+      str = "[hello]"
+      data = {}
+      insist { subject.set(str, "foo", data) } == "foo"
+      insist { data } == { "hello" => "foo" }
+    end
+
+    it "should set deep value" do
+      str = "[hello][world]"
+      data = {}
+      insist { subject.set(str, "foo", data) } == "foo"
+      insist { data } == { "hello" => { "world" => "foo" } }
+    end
+
+    it "should retrieve array item" do
+      data = { "hello" => { "world" => ["a", "b"], "bar" => "baz" } }
+      m = eval(subject.compile("[hello][world][0]"))
+      insist { m.call(data) } == data["hello"]["world"][0]
+
+      m = eval(subject.compile("[hello][world][1]"))
+      insist { m.call(data) } == data["hello"]["world"][1]
+    end
   end
 end
