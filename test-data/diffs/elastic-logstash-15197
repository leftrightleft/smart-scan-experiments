diff --git a/.rubocop.yml b/.rubocop.yml
index a543ce718e7..c19d5e8f10a 100644
--- a/.rubocop.yml
+++ b/.rubocop.yml
@@ -77,6 +77,18 @@ Layout/SpaceAroundMethodCallOperator:
   Enabled: true
 Layout/SpaceAroundOperators:
   Enabled: true
+Layout/SpaceBeforeBlockBraces:
+  Enabled: true
+Layout/SpaceBeforeBrackets:
+  Enabled: true
+Layout/SpaceBeforeComma:
+  Enabled: true
+Layout/SpaceBeforeComment:
+  Enabled: true
+Layout/SpaceBeforeFirstArg:
+  Enabled: true
+Layout/SpaceBeforeSemicolon:
+  Enabled: true
 
 ##### Need review #####
 Layout/AccessModifierIndentation:
@@ -199,18 +211,6 @@ Layout/SpaceAfterMethodName:
   Enabled: false
 Layout/SpaceAfterNot:
   Enabled: false
-Layout/SpaceBeforeBlockBraces:
-  Enabled: false
-Layout/SpaceBeforeBrackets:
-  Enabled: false
-Layout/SpaceBeforeComma:
-  Enabled: false
-Layout/SpaceBeforeComment:
-  Enabled: false
-Layout/SpaceBeforeFirstArg:
-  Enabled: false
-Layout/SpaceBeforeSemicolon:
-  Enabled: false
 Layout/SpaceInLambdaLiteral:
   Enabled: false
 Layout/SpaceInsideArrayLiteralBrackets:
diff --git a/lib/pluginmanager/gemfile.rb b/lib/pluginmanager/gemfile.rb
index 3a0d3a55b3f..6e658b762d8 100644
--- a/lib/pluginmanager/gemfile.rb
+++ b/lib/pluginmanager/gemfile.rb
@@ -115,7 +115,7 @@ def initialize
     end
 
     def to_s
-      [sources_to_s, gemspec_to_s, gems_to_s].select{|s| !s.empty?}.join("\n") + "\n"
+      [sources_to_s, gemspec_to_s, gems_to_s].select {|s| !s.empty?}.join("\n") + "\n"
     end
 
     # @return [Gem] found gem or nil if not found
@@ -180,21 +180,21 @@ def no_constrains?(requirements)
 
     def sources_to_s
       return "" if @sources.empty?
-      @sources.map{|source| "source #{source.inspect}"}.join("\n")
+      @sources.map {|source| "source #{source.inspect}"}.join("\n")
     end
 
     def gems_to_s
       return "" if @gems.empty?
       @gems.map do |gem|
-        requirements = gem.requirements.empty? ? nil : gem.requirements.map{|r| r.inspect}.join(", ")
-        options = gem.options.empty? ? nil : gem.options.map{|k, v| "#{k.inspect} => #{v.inspect}"}.join(", ")
+        requirements = gem.requirements.empty? ? nil : gem.requirements.map {|r| r.inspect}.join(", ")
+        options = gem.options.empty? ? nil : gem.options.map {|k, v| "#{k.inspect} => #{v.inspect}"}.join(", ")
         "gem " + [gem.name.inspect, requirements, options].compact.join(", ")
       end.join("\n")
     end
 
     def gemspec_to_s
       return "" if @gemspec.empty?
-      options = @gemspec.map{|k, v| "#{k.inspect} => #{v.inspect}"}.join(", ")
+      options = @gemspec.map {|k, v| "#{k.inspect} => #{v.inspect}"}.join(", ")
       "gemspec #{options}"
     end
   end
@@ -237,7 +237,7 @@ class Gem
 
     def initialize(name, requirements = [], options = {})
       @name = name
-      @requirements = requirements.map{|r| r.to_s.strip}.select{|r| !r.empty?}
+      @requirements = requirements.map {|r| r.to_s.strip}.select {|r| !r.empty?}
       @options = options
     end
 
diff --git a/lib/pluginmanager/list.rb b/lib/pluginmanager/list.rb
index 3d03f19420e..fcdd934f723 100644
--- a/lib/pluginmanager/list.rb
+++ b/lib/pluginmanager/list.rb
@@ -36,7 +36,7 @@ def execute
 
     installed_plugin_names = filtered_specs.collect {|spec| spec.name}
 
-    filtered_specs.sort_by{|spec| spec.name}.each do |spec|
+    filtered_specs.sort_by {|spec| spec.name}.each do |spec|
       line = "#{spec.name}"
       line += " (#{spec.version})" if verbose?
       puts(line)
@@ -63,9 +63,9 @@ def filtered_specs
                           specs = LogStash::PluginManager.find_plugins_gem_specs
 
                           # apply filters
-                          specs = specs.select{|spec| gemfile.find(spec.name)} if installed?
-                          specs = specs.select{|spec| spec_matches_search?(spec) } if plugin
-                          specs = specs.select{|spec| spec.metadata['logstash_group'] == group} if group
+                          specs = specs.select {|spec| gemfile.find(spec.name)} if installed?
+                          specs = specs.select {|spec| spec_matches_search?(spec) } if plugin
+                          specs = specs.select {|spec| spec.metadata['logstash_group'] == group} if group
 
                           specs
                         end
diff --git a/lib/pluginmanager/update.rb b/lib/pluginmanager/update.rb
index 6d3d7a86bf5..4c3651abbd0 100644
--- a/lib/pluginmanager/update.rb
+++ b/lib/pluginmanager/update.rb
@@ -102,7 +102,7 @@ def update_gems!
   # create list of plugins to update
   def plugins_to_update(previous_gem_specs_map)
     if update_all?
-      previous_gem_specs_map.values.map{|spec| spec.name}
+      previous_gem_specs_map.values.map {|spec| spec.name}
     else
       # If the plugins isn't available in the gemspec or in
       # the gemfile defined with a local path, we assume the plugins is not
@@ -153,7 +153,7 @@ def display_updated_plugins(previous_gem_specs_map)
   def find_latest_gem_specs
     LogStash::PluginManager.all_installed_plugins_gem_specs(gemfile).inject({}) do |result, spec|
       previous = result[spec.name.downcase]
-      result[spec.name.downcase] = previous ? [previous, spec].max_by{|s| s.version} : spec
+      result[spec.name.downcase] = previous ? [previous, spec].max_by {|s| s.version} : spec
       result
     end
   end
diff --git a/lib/pluginmanager/util.rb b/lib/pluginmanager/util.rb
index 9c33079f341..af19178fd47 100644
--- a/lib/pluginmanager/util.rb
+++ b/lib/pluginmanager/util.rb
@@ -124,7 +124,7 @@ def self.plugin_file?(plugin)
   # @return [Array<Gem::Specification>] all local logstash plugin gem specs
   def self.find_plugins_gem_specs(name = nil)
     specs = name ? ::Gem::Specification.find_all_by_name(name) : ::Gem::Specification.find_all
-    specs.select{|spec| logstash_plugin_gem_spec?(spec)}
+    specs.select {|spec| logstash_plugin_gem_spec?(spec)}
   end
 
   # list of all locally installed plugins specs specified in the Gemfile.
@@ -135,7 +135,7 @@ def self.find_plugins_gem_specs(name = nil)
   def self.all_installed_plugins_gem_specs(gemfile)
     # we start form the installed gemspecs so we can verify the metadata for valid logstash plugin
     # then filter out those not included in the Gemfile
-    find_plugins_gem_specs.select{|spec| !!gemfile.find(spec.name)}
+    find_plugins_gem_specs.select {|spec| !!gemfile.find(spec.name)}
   end
 
   # @param plugin [String] plugin name
diff --git a/logstash-core/lib/logstash/api/commands/node.rb b/logstash-core/lib/logstash/api/commands/node.rb
index 0ef7f95a57e..db7ef35106d 100644
--- a/logstash-core/lib/logstash/api/commands/node.rb
+++ b/logstash-core/lib/logstash/api/commands/node.rb
@@ -55,7 +55,7 @@ def pipeline(pipeline_id, options = {})
             :config_reload_interval,
             :dead_letter_queue_enabled,
             :dead_letter_queue_path,
-          ).reject{|_, v| v.nil?}
+          ).reject {|_, v| v.nil?}
           if options.fetch(:graph, false)
             extended_stats = extract_metrics([:stats, :pipelines, pipeline_id.to_sym, :config], :graph)
             decorated_vertices = extended_stats[:graph]["graph"]["vertices"].map { |vertex| decorate_with_cluster_uuids(vertex)  }
diff --git a/logstash-core/lib/logstash/api/commands/system/plugins_command.rb b/logstash-core/lib/logstash/api/commands/system/plugins_command.rb
index 051a0feb788..ff99c8e6061 100644
--- a/logstash-core/lib/logstash/api/commands/system/plugins_command.rb
+++ b/logstash-core/lib/logstash/api/commands/system/plugins_command.rb
@@ -37,7 +37,7 @@ def plugins
           end
 
           def find_plugins_gem_specs
-            @specs ||= ::Gem::Specification.find_all.select{|spec| logstash_plugin_gem_spec?(spec)}
+            @specs ||= ::Gem::Specification.find_all.select {|spec| logstash_plugin_gem_spec?(spec)}
           end
 
           def logstash_plugin_gem_spec?(spec)
diff --git a/logstash-core/lib/logstash/compiler/treetop_monkeypatches.rb b/logstash-core/lib/logstash/compiler/treetop_monkeypatches.rb
index fde035ff35c..d5a13ae9248 100644
--- a/logstash-core/lib/logstash/compiler/treetop_monkeypatches.rb
+++ b/logstash-core/lib/logstash/compiler/treetop_monkeypatches.rb
@@ -93,13 +93,13 @@ def _inspect(indent = "")
 
     indent +
     self.class.to_s.sub(/.*:/, '') +
-      em.map{|m| "+" + m.to_s.sub(/.*:/, '')} * "" +
+      em.map {|m| "+" + m.to_s.sub(/.*:/, '')} * "" +
       " offset=#{interval.first}" +
       ", #{tv.inspect}" +
       im +
       (elements && elements.size > 0 ?
         ":" +
-          (elements.select { |e| !e.is_a?(LogStash::Config::AST::Whitespace) && e.elements && e.elements.size > 0 } || []).map{|e|
+          (elements.select { |e| !e.is_a?(LogStash::Config::AST::Whitespace) && e.elements && e.elements.size > 0 } || []).map {|e|
       begin
         "\n" + e.inspect(indent + "  ")
       rescue  # Defend against inspect not taking a parameter
diff --git a/logstash-core/lib/logstash/config/config_ast.rb b/logstash-core/lib/logstash/config/config_ast.rb
index 6773f0e4768..8b5f7fd99ee 100644
--- a/logstash-core/lib/logstash/config/config_ast.rb
+++ b/logstash-core/lib/logstash/config/config_ast.rb
@@ -570,13 +570,13 @@ def _inspect(indent = "")
 
     indent +
     self.class.to_s.sub(/.*:/, '') +
-      em.map{|m| "+" + m.to_s.sub(/.*:/, '')} * "" +
+      em.map {|m| "+" + m.to_s.sub(/.*:/, '')} * "" +
       " offset=#{interval.first}" +
       ", #{tv.inspect}" +
       im +
       (elements && elements.size > 0 ?
         ":" +
-          (elements.select { |e| !e.is_a?(LogStash::Config::AST::Whitespace) && e.elements && e.elements.size > 0 } || []).map{|e|
+          (elements.select { |e| !e.is_a?(LogStash::Config::AST::Whitespace) && e.elements && e.elements.size > 0 } || []).map {|e|
       begin
         "\n" + e.inspect(indent + "  ")
       rescue  # Defend against inspect not taking a parameter
diff --git a/logstash-core/lib/logstash/filters/base.rb b/logstash-core/lib/logstash/filters/base.rb
index 41ddbbd35da..f7bb3ea547e 100644
--- a/logstash-core/lib/logstash/filters/base.rb
+++ b/logstash-core/lib/logstash/filters/base.rb
@@ -173,7 +173,7 @@ def multi_filter(events)
     events.each do |event|
       unless event.cancelled?
         result << event
-        do_filter(event){|new_event| result << new_event}
+        do_filter(event) {|new_event| result << new_event}
       end
     end
     result
diff --git a/logstash-core/lib/logstash/instrument/periodic_poller/cgroup.rb b/logstash-core/lib/logstash/instrument/periodic_poller/cgroup.rb
index c9de321ffa9..5213f83ccfb 100644
--- a/logstash-core/lib/logstash/instrument/periodic_poller/cgroup.rb
+++ b/logstash-core/lib/logstash/instrument/periodic_poller/cgroup.rb
@@ -63,7 +63,7 @@ class CGroupResources
 
       def cgroup_available?
         # don't cache to ivar, in case the files are mounted after logstash starts??
-        CRITICAL_PATHS.all?{|path| ::File.exist?(path)}
+        CRITICAL_PATHS.all? {|path| ::File.exist?(path)}
       end
 
       def controller_groups
diff --git a/logstash-core/lib/logstash/java_pipeline.rb b/logstash-core/lib/logstash/java_pipeline.rb
index 96b039df2b8..6a3152abb27 100644
--- a/logstash-core/lib/logstash/java_pipeline.rb
+++ b/logstash-core/lib/logstash/java_pipeline.rb
@@ -290,7 +290,7 @@ def start_workers
         .map(&:value)
       workers_init_elapsed = Time.now - workers_init_start
 
-      fail("Some worker(s) were not correctly initialized") if worker_loops.any?{|v| v.nil?}
+      fail("Some worker(s) were not correctly initialized") if worker_loops.any? {|v| v.nil?}
 
       @logger.info("Pipeline Java execution initialization time", "seconds" => workers_init_elapsed.round(2))
 
@@ -475,7 +475,7 @@ def shutdown_workers
     @shutdownRequested.set(true)
 
     @worker_threads.each do |t|
-      @logger.debug("Shutdown waiting for worker thread" , default_logging_keys(:thread => t.inspect))
+      @logger.debug("Shutdown waiting for worker thread", default_logging_keys(:thread => t.inspect))
       t.join
     end
 
diff --git a/logstash-core/lib/logstash/modules/settings_merger.rb b/logstash-core/lib/logstash/modules/settings_merger.rb
index 8f32680d2df..05a5151aab6 100644
--- a/logstash-core/lib/logstash/modules/settings_merger.rb
+++ b/logstash-core/lib/logstash/modules/settings_merger.rb
@@ -32,7 +32,7 @@ def merge(cli_settings, yml_settings)
     # union will also coalesce identical hashes
     # this "|" operator is provided to Java List by RubyJavaIntegration
     union_of_settings = (cli_settings | yml_settings)
-    grouped_by_name = union_of_settings.group_by{|e| e["name"]}
+    grouped_by_name = union_of_settings.group_by {|e| e["name"]}
     grouped_by_name.each do |_, array|
       if array.size == 2
         merged << array.last.merge(array.first)
diff --git a/logstash-core/lib/logstash/runner.rb b/logstash-core/lib/logstash/runner.rb
index 8effd286516..f9faed54f42 100644
--- a/logstash-core/lib/logstash/runner.rb
+++ b/logstash-core/lib/logstash/runner.rb
@@ -162,13 +162,13 @@ class LogStash::Runner < Clamp::StrictCommand
     :default => LogStash::SETTINGS.get_default('pipeline.ecs_compatibility')
 
   # Data Path Setting
-  option ["--path.data"] , "PATH",
+  option ["--path.data"], "PATH",
     I18n.t("logstash.runner.flag.datapath"),
     :attribute_name => "path.data",
     :default => LogStash::SETTINGS.get_default("path.data")
 
   # Plugins Settings
-  option ["-p", "--path.plugins"] , "PATH",
+  option ["-p", "--path.plugins"], "PATH",
     I18n.t("logstash.runner.flag.pluginpath"),
     :multivalued => true, :attribute_name => "path.plugins",
     :default => LogStash::SETTINGS.get_default("path.plugins")
diff --git a/logstash-core/lib/logstash/util.rb b/logstash-core/lib/logstash/util.rb
index be839342a88..cae2c62a893 100644
--- a/logstash-core/lib/logstash/util.rb
+++ b/logstash-core/lib/logstash/util.rb
@@ -169,9 +169,9 @@ def self.hash_merge_many(*hashes)
   def self.normalize(o)
     case o
     when Java::JavaUtil::LinkedHashMap
-      o.inject({}){|r, (k, v)| r[k] = normalize(v); r}
+      o.inject({}) {|r, (k, v)| r[k] = normalize(v); r}
     when Java::JavaUtil::ArrayList
-      o.map{|i| normalize(i)}
+      o.map {|i| normalize(i)}
     else
       o
     end
@@ -180,9 +180,9 @@ def self.normalize(o)
   def self.stringify_symbols(o)
     case o
     when Hash
-      o.inject({}){|r, (k, v)| r[k.is_a?(Symbol) ? k.to_s : k] = stringify_symbols(v); r}
+      o.inject({}) {|r, (k, v)| r[k.is_a?(Symbol) ? k.to_s : k] = stringify_symbols(v); r}
     when Array
-      o.map{|i| stringify_symbols(i)}
+      o.map {|i| stringify_symbols(i)}
     when Symbol
       o.to_s
     else
diff --git a/logstash-core/spec/logstash/acked_queue_concurrent_stress_spec.rb b/logstash-core/spec/logstash/acked_queue_concurrent_stress_spec.rb
index 156d554c8a3..f5335f974dc 100644
--- a/logstash-core/spec/logstash/acked_queue_concurrent_stress_spec.rb
+++ b/logstash-core/spec/logstash/acked_queue_concurrent_stress_spec.rb
@@ -114,7 +114,7 @@ def publisher(items, writer)
         sleep 0.1
         expect { queue.close }.not_to raise_error
         sleep 0.1
-        files = Dir.glob(path + '/*').map{|f| f.sub("#{path}/", '')}
+        files = Dir.glob(path + '/*').map {|f| f.sub("#{path}/", '')}
         if files.count != 2
           output_strings << "File count after close mismatch expected: 2 got: #{files.count}"
           output_strings.concat files
@@ -123,7 +123,7 @@ def publisher(items, writer)
         queue.close
 
         if output_strings.any?
-          output_strings << __memoized.reject{|k, v| reject_memo_keys.include?(k)}.inspect
+          output_strings << __memoized.reject {|k, v| reject_memo_keys.include?(k)}.inspect
         end
 
         expect(output_strings).to eq([])
diff --git a/logstash-core/spec/logstash/agent/metrics_spec.rb b/logstash-core/spec/logstash/agent/metrics_spec.rb
index ad3b9e73bcf..fb96df93f54 100644
--- a/logstash-core/spec/logstash/agent/metrics_spec.rb
+++ b/logstash-core/spec/logstash/agent/metrics_spec.rb
@@ -193,7 +193,7 @@ def mhash(*path_elements)
         end
 
         it "increment the pipeline successes" do
-          expect{ subject.converge_state_and_update }.to change { mval(:stats, :pipelines, pipeline_name, :reloads, :successes) }.by(1)
+          expect { subject.converge_state_and_update }.to change { mval(:stats, :pipelines, pipeline_name, :reloads, :successes) }.by(1)
         end
 
         it "record the `last_success_timestamp`" do
@@ -213,7 +213,7 @@ def mhash(*path_elements)
         end
 
         it "increment the pipeline failures" do
-          expect{ subject.converge_state_and_update }.to change { mval(:stats, :pipelines, pipeline_name, :reloads, :failures) }.by(1)
+          expect { subject.converge_state_and_update }.to change { mval(:stats, :pipelines, pipeline_name, :reloads, :failures) }.by(1)
         end
       end
     end
@@ -252,8 +252,8 @@ def mhash(*path_elements)
         # since the pipeline is async, it can actually take some time to have metrics recordings
         # so we try a few times
         try(20) do
-          expect { mhash(:stats, :pipelines, :main, :events) }.not_to raise_error , "Events pipeline stats should exist"
-          expect { mhash(:stats, :pipelines, :main, :flow) }.not_to raise_error , "Events pipeline stats should exist"
+          expect { mhash(:stats, :pipelines, :main, :events) }.not_to raise_error, "Events pipeline stats should exist"
+          expect { mhash(:stats, :pipelines, :main, :flow) }.not_to raise_error, "Events pipeline stats should exist"
           expect { mhash(:stats, :pipelines, :main, :plugins) }.not_to raise_error, "Plugins pipeline stats should exist"
         end
 
diff --git a/logstash-core/spec/logstash/environment_spec.rb b/logstash-core/spec/logstash/environment_spec.rb
index 2544491b76e..e95e98f77b4 100644
--- a/logstash-core/spec/logstash/environment_spec.rb
+++ b/logstash-core/spec/logstash/environment_spec.rb
@@ -57,7 +57,7 @@
     after(:each) { $LOAD_PATH.delete(path) }
 
     it "should add the path to $LOAD_PATH" do
-      expect{subject.add_plugin_path(path)}.to change{$LOAD_PATH.size}.by(1)
+      expect {subject.add_plugin_path(path)}.to change {$LOAD_PATH.size}.by(1)
       expect($LOAD_PATH).to include(path)
     end
   end
diff --git a/logstash-core/spec/logstash/event_spec.rb b/logstash-core/spec/logstash/event_spec.rb
index 50f9a646acd..9c5bd4bd82e 100644
--- a/logstash-core/spec/logstash/event_spec.rb
+++ b/logstash-core/spec/logstash/event_spec.rb
@@ -323,14 +323,14 @@
     end
 
     it "should consistently handle nil" do
-      expect{LogStash::Event.from_json(nil)}.to raise_error(TypeError)
-      expect{LogStash::Event.new(LogStash::Json.load(nil))}.to raise_error # java.lang.ClassCastException
+      expect {LogStash::Event.from_json(nil)}.to raise_error(TypeError)
+      expect {LogStash::Event.new(LogStash::Json.load(nil))}.to raise_error # java.lang.ClassCastException
     end
 
     it "should consistently handle bare string" do
       bare_strings.each do |s|
-        expect{LogStash::Event.from_json(s)}.to raise_error LogStash::Json::ParserError
-        expect{LogStash::Event.new(LogStash::Json.load(s))}.to raise_error LogStash::Json::ParserError
+        expect {LogStash::Event.from_json(s)}.to raise_error LogStash::Json::ParserError
+        expect {LogStash::Event.new(LogStash::Json.load(s))}.to raise_error LogStash::Json::ParserError
        end
     end
 
diff --git a/logstash-core/spec/logstash/filter_delegator_spec.rb b/logstash-core/spec/logstash/filter_delegator_spec.rb
index 6aa7fc46bab..8c5524cf50d 100644
--- a/logstash-core/spec/logstash/filter_delegator_spec.rb
+++ b/logstash-core/spec/logstash/filter_delegator_spec.rb
@@ -55,7 +55,7 @@ def register; end
         config_name "super_plugin"
         config :host, :validate => :string
         def register; end
-        def flush(options = {}); @events ; end
+        def flush(options = {}); @events; end
 
         def filter(event)
           @events ||= []
@@ -102,7 +102,7 @@ def filter(event)
           config_name "super_plugin"
           config :host, :validate => :string
           def register; end
-          def flush(options = {}); @events ; end
+          def flush(options = {}); @events; end
 
           # naive split filter implementation
           def filter(event)
diff --git a/logstash-core/spec/logstash/filters/base_spec.rb b/logstash-core/spec/logstash/filters/base_spec.rb
index 2885c77bebf..f634d66f54a 100644
--- a/logstash-core/spec/logstash/filters/base_spec.rb
+++ b/logstash-core/spec/logstash/filters/base_spec.rb
@@ -36,8 +36,8 @@ def filter(event)
   subject {LogStash::Filters::Base.new({})}
 
   it "should provide method interfaces to override" do
-    expect{subject.register}.to raise_error(RuntimeError)
-    expect{subject.filter(:foo)}.to raise_error(RuntimeError)
+    expect {subject.register}.to raise_error(RuntimeError)
+    expect {subject.filter(:foo)}.to raise_error(RuntimeError)
   end
 
   it "should provide class public API" do
@@ -47,8 +47,8 @@ def filter(event)
   end
 
   context "multi_filter" do
-    let(:event1){LogStash::Event.new}
-    let(:event2){LogStash::Event.new}
+    let(:event1) {LogStash::Event.new}
+    let(:event2) {LogStash::Event.new}
 
     it "should multi_filter without new events" do
       allow(subject).to receive(:filter) do |event, &block|
diff --git a/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb b/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb
index da4953f7f12..dc7050a6a1c 100644
--- a/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb
+++ b/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb
@@ -26,7 +26,7 @@
 
   describe "#increment" do
     it "increment the counter" do
-      expect{ subject.increment }.to change { subject.value }.by(1)
+      expect { subject.increment }.to change { subject.value }.by(1)
     end
   end
 
diff --git a/logstash-core/spec/logstash/java_filter_delegator_spec.rb b/logstash-core/spec/logstash/java_filter_delegator_spec.rb
index 9f39da5dcec..3586debdc77 100644
--- a/logstash-core/spec/logstash/java_filter_delegator_spec.rb
+++ b/logstash-core/spec/logstash/java_filter_delegator_spec.rb
@@ -79,7 +79,7 @@ def register; end
         config_name "super_plugin"
         config :host, :validate => :string
         def register; end
-        def flush(options = {}); @events ; end
+        def flush(options = {}); @events; end
 
         def filter(event)
           @events ||= []
@@ -139,7 +139,7 @@ def filter(event)
           config_name "super_plugin"
           config :host, :validate => :string
           def register; end
-          def flush(options = {}); @events ; end
+          def flush(options = {}); @events; end
 
           # naive split filter implementation
           def filter(event)
diff --git a/logstash-core/spec/logstash/java_integration_spec.rb b/logstash-core/spec/logstash/java_integration_spec.rb
index 31c0393f5f7..b834903a21b 100644
--- a/logstash-core/spec/logstash/java_integration_spec.rb
+++ b/logstash-core/spec/logstash/java_integration_spec.rb
@@ -65,8 +65,8 @@
   context "Java::JavaUtil::Map" do
     # this is to test the Java 8 Map interface change for the merge method
 
-    let(:merger){{:a => 1, :b => 2}}
-    let(:mergee){{:b => 3, :c => 4}}
+    let(:merger) {{:a => 1, :b => 2}}
+    let(:mergee) {{:b => 3, :c => 4}}
 
     shared_examples "map merge" do
       it "should support merging" do
@@ -74,25 +74,25 @@
       end
 
       it "should return a new hash and not change original hash" do
-        expect{subject.merge(mergee)}.to_not change{subject}
+        expect {subject.merge(mergee)}.to_not change {subject}
       end
     end
 
     context "with Java::JavaUtil::LinkedHashMap" do
       it_behaves_like "map merge" do
-        subject{Java::JavaUtil::LinkedHashMap.new(merger)}
+        subject {Java::JavaUtil::LinkedHashMap.new(merger)}
       end
     end
 
     context "with Java::JavaUtil::HashMap" do
       it_behaves_like "map merge" do
-        subject{Java::JavaUtil::HashMap.new(merger)}
+        subject {Java::JavaUtil::HashMap.new(merger)}
       end
     end
   end
 
   context "Java::JavaUtil::Collection" do
-    subject{Java::JavaUtil::ArrayList.new(initial_array)}
+    subject {Java::JavaUtil::ArrayList.new(initial_array)}
 
     context "when inspecting a list" do
       let(:items) { [:a, {:b => :c}] }
@@ -130,7 +130,7 @@
       end
 
       it "should remove the object to delete" do
-        expect{subject.delete("foo")}.to change{subject.to_a}.from(initial_array).to(["bar"])
+        expect {subject.delete("foo")}.to change {subject.to_a}.from(initial_array).to(["bar"])
       end
     end
 
@@ -142,7 +142,7 @@
       end
 
       it "should remove all the objects to delete" do
-        expect{subject.delete("foo")}.to change{subject.to_a}.from(initial_array).to(["bar"])
+        expect {subject.delete("foo")}.to change {subject.to_a}.from(initial_array).to(["bar"])
       end
     end
 
@@ -154,11 +154,11 @@
       end
 
       it "should not change the collection" do
-        expect{subject.delete("baz")}.to_not change{subject.to_a}
+        expect {subject.delete("baz")}.to_not change {subject.to_a}
       end
 
       it "should yield to block when given" do
-        expect(subject.delete("baz"){"foobar"}).to eq("foobar")
+        expect(subject.delete("baz") {"foobar"}).to eq("foobar")
       end
     end
 
@@ -170,7 +170,7 @@
       end
 
       it "should not change the collection" do
-        expect{subject.delete("baz")}.to_not change{subject.to_a}
+        expect {subject.delete("baz")}.to_not change {subject.to_a}
       end
     end
 
@@ -179,7 +179,7 @@
         let(:initial_array) {["foo", "bar", "foo"]}
 
         it "should not change original collection" do
-          expect{subject & ["foo"]}.to_not change{subject.to_a}
+          expect {subject & ["foo"]}.to_not change {subject.to_a}
         end
 
         it "should return a new array containing elements common to the two arrays, excluding any duplicate" do
@@ -214,7 +214,7 @@
         let(:initial_array) {["foo", "bar", "foo"]}
 
         it "should not change original collection" do
-          expect{subject | ["bar", "baz"]}.to_not change{subject.to_a}
+          expect {subject | ["bar", "baz"]}.to_not change {subject.to_a}
         end
 
         it "should return a new array by joining excluding any duplicates and preserving the order from the original array" do
diff --git a/logstash-core/spec/logstash/java_pipeline_spec.rb b/logstash-core/spec/logstash/java_pipeline_spec.rb
index b1f3bfd5859..22915b85501 100644
--- a/logstash-core/spec/logstash/java_pipeline_spec.rb
+++ b/logstash-core/spec/logstash/java_pipeline_spec.rb
@@ -277,7 +277,7 @@ def flush(options)
         sleep 0.01 until pipeline.stopped?
       end
       pipeline.shutdown
-      expect(output.events.map{|e| e.get("message")}).to include("END")
+      expect(output.events.map {|e| e.get("message")}).to include("END")
       expect(output.events.size).to eq(2)
       expect(output.events[0].get("tags")).to eq(["notdropped"])
       expect(output.events[1].get("tags")).to eq(["notdropped"])
@@ -432,7 +432,7 @@ def flush(options)
         # when the pipeline has exited, no input threads should be alive
         wait(5).for {subject.input_threads.any?(&:alive?)}.to be_falsey
 
-        expect{dummyinput.push_once}.to raise_error(/Tried to write to a closed queue/)
+        expect {dummyinput.push_once}.to raise_error(/Tried to write to a closed queue/)
       end
     end
   end
@@ -684,7 +684,7 @@ def flush(options)
       CONFIG
 
        sample_one(["a", "1", "b", "2", "c", "3"]) do
-        expect(subject.map{|e| e.get("message")}).to eq(["a", "1", "b", "2", "c", "3"])
+        expect(subject.map {|e| e.get("message")}).to eq(["a", "1", "b", "2", "c", "3"])
       end
     end
 
@@ -699,7 +699,7 @@ def flush(options)
       let(:pipeline) { mock_java_pipeline_from_string(config, settings) }
 
       it "should raise error" do
-        expect{pipeline.run}.to raise_error(RuntimeError, /pipeline\.ordered/)
+        expect {pipeline.run}.to raise_error(RuntimeError, /pipeline\.ordered/)
         pipeline.close
       end
     end
@@ -723,7 +723,7 @@ def flush(options)
       CONFIG
 
        sample_one(["a", "1", "b", "2", "c", "3"]) do
-        expect(subject.map{|e| e.get("message")}).to eq(["a", "1", "b", "2", "c", "3"])
+        expect(subject.map {|e| e.get("message")}).to eq(["a", "1", "b", "2", "c", "3"])
       end
     end
 
@@ -758,7 +758,7 @@ def flush(options)
       CONFIG
 
       sample_one(["a", "1", "b", "2", "c", "3"]) do
-        expect(subject.map{|e| e.get("message")}).to eq(["1", "2", "3", "a", "b", "c"])
+        expect(subject.map {|e| e.get("message")}).to eq(["1", "2", "3", "a", "b", "c"])
       end
     end
 
@@ -781,7 +781,7 @@ def flush(options)
       CONFIG
 
       sample_one(["a", "1", "b", "2", "c", "3"]) do
-        expect(subject.map{|e| e.get("message")}).to eq(["1", "2", "3", "a", "b", "c"])
+        expect(subject.map {|e| e.get("message")}).to eq(["1", "2", "3", "a", "b", "c"])
       end
     end
   end
diff --git a/logstash-core/spec/logstash/json_spec.rb b/logstash-core/spec/logstash/json_spec.rb
index 384b9f2cc9f..8cd4ffb04ea 100644
--- a/logstash-core/spec/logstash/json_spec.rb
+++ b/logstash-core/spec/logstash/json_spec.rb
@@ -104,7 +104,7 @@
   end
 
   it "should raise Json::ParserError on invalid json" do
-    expect{LogStash::Json.load("abc")}.to raise_error LogStash::Json::ParserError
+    expect {LogStash::Json.load("abc")}.to raise_error LogStash::Json::ParserError
   end
 
   it "should return nil on empty string" do
diff --git a/logstash-core/spec/logstash/legacy_ruby_timestamp_spec.rb b/logstash-core/spec/logstash/legacy_ruby_timestamp_spec.rb
index df74dcc9fd7..b1cafe18300 100644
--- a/logstash-core/spec/logstash/legacy_ruby_timestamp_spec.rb
+++ b/logstash-core/spec/logstash/legacy_ruby_timestamp_spec.rb
@@ -56,7 +56,7 @@
   end
 
   it "should raise on invalid string coerce" do
-    expect{LogStash::Timestamp.coerce("foobar")}.to raise_error LogStash::TimestampParserError
+    expect {LogStash::Timestamp.coerce("foobar")}.to raise_error LogStash::TimestampParserError
   end
 
   it "should return nil on invalid object coerce" do
@@ -203,11 +203,11 @@
 
     context "with illegal parameters" do
       it "should raise exception on nil input" do
-        expect{LogStash::Timestamp.at(nil)}.to raise_error
+        expect {LogStash::Timestamp.at(nil)}.to raise_error
       end
 
       it "should raise exception on invalid input type" do
-        expect{LogStash::Timestamp.at(:foo)}.to raise_error
+        expect {LogStash::Timestamp.at(:foo)}.to raise_error
       end
     end
   end
diff --git a/logstash-core/spec/logstash/modules/kibana_client_spec.rb b/logstash-core/spec/logstash/modules/kibana_client_spec.rb
index 54016272ce9..42e5d9bde41 100644
--- a/logstash-core/spec/logstash/modules/kibana_client_spec.rb
+++ b/logstash-core/spec/logstash/modules/kibana_client_spec.rb
@@ -37,7 +37,7 @@ def call
     context "when supplied with conflicting scheme data" do
       let(:settings) { {"var.kibana.scheme" => "http", "var.kibana.host" => kibana_host} }
       it "a new instance will throw an error" do
-        expect{described_class.new(settings, test_client)}.to raise_error(ArgumentError, /Detected differing Kibana host schemes as sourced from var\.kibana\.host: 'https' and var\.kibana\.scheme: 'http'/)
+        expect {described_class.new(settings, test_client)}.to raise_error(ArgumentError, /Detected differing Kibana host schemes as sourced from var\.kibana\.host: 'https' and var\.kibana\.scheme: 'http'/)
       end
     end
 
@@ -45,7 +45,7 @@ def call
       ["httpd", "ftp", "telnet"].each do |uri_scheme|
         it "a new instance will throw an error" do
           re = /Kibana host scheme given is invalid, given value: '#{uri_scheme}' - acceptable values: 'http', 'https'/
-          expect{described_class.new({"var.kibana.scheme" => uri_scheme}, test_client)}.to raise_error(ArgumentError, re)
+          expect {described_class.new({"var.kibana.scheme" => uri_scheme}, test_client)}.to raise_error(ArgumentError, re)
         end
       end
     end
diff --git a/logstash-core/spec/logstash/modules/scaffold_spec.rb b/logstash-core/spec/logstash/modules/scaffold_spec.rb
index a956bf20066..5544b158481 100644
--- a/logstash-core/spec/logstash/modules/scaffold_spec.rb
+++ b/logstash-core/spec/logstash/modules/scaffold_spec.rb
@@ -148,7 +148,7 @@
       expect(resource2.import_path).to eq("api/kibana/dashboards/import")
       expect(resource2.content).to be_a(Array)
       expect(resource2.content.size).to eq(5)
-      expect(resource2.content.map{|o| o.class}.uniq).to eq([LogStash::Modules::KibanaResource])
+      expect(resource2.content.map {|o| o.class}.uniq).to eq([LogStash::Modules::KibanaResource])
 
       test_object = resource2.content[0]
       expect(test_object.content_id).to eq("foo-*")
diff --git a/logstash-core/spec/logstash/modules/settings_merger_spec.rb b/logstash-core/spec/logstash/modules/settings_merger_spec.rb
index e373535fc47..a6ba1bc48fe 100644
--- a/logstash-core/spec/logstash/modules/settings_merger_spec.rb
+++ b/logstash-core/spec/logstash/modules/settings_merger_spec.rb
@@ -127,7 +127,7 @@ def get(key) @hash[key]; end
     context "when only cloud.auth is supplied" do
       let(:ls_settings) { SubstituteSettingsForRSpec.new({"cloud.auth" => cloud_auth}) }
       it "should raise an error" do
-        expect{ described_class.merge_cloud_settings(mod_settings, ls_settings) }.to raise_exception(ArgumentError)
+        expect { described_class.merge_cloud_settings(mod_settings, ls_settings) }.to raise_exception(ArgumentError)
       end
     end
 
diff --git a/logstash-core/spec/logstash/outputs/base_spec.rb b/logstash-core/spec/logstash/outputs/base_spec.rb
index 0e7df6d521f..e1f52efd32d 100644
--- a/logstash-core/spec/logstash/outputs/base_spec.rb
+++ b/logstash-core/spec/logstash/outputs/base_spec.rb
@@ -63,7 +63,7 @@ def multi_receive_encoded(events_and_encoded)
       params = { "dummy_option" => "potatoes", "codec" => "json", "workers" => 2 }
       worker_params = params.dup; worker_params["workers"] = 1
 
-      expect{ subject }.not_to raise_error
+      expect { subject }.not_to raise_error
     end
 
     it "should set concurrency correctly" do
diff --git a/logstash-core/spec/logstash/patches/puma_spec.rb b/logstash-core/spec/logstash/patches/puma_spec.rb
index 04311c6c4ae..28e3b22e1b7 100644
--- a/logstash-core/spec/logstash/patches/puma_spec.rb
+++ b/logstash-core/spec/logstash/patches/puma_spec.rb
@@ -58,7 +58,7 @@ def self.backtrace
   context "#error" do
     it "should log an :error message and raise LogStash::UnrecoverablePumaError" do
       expect(logger).to receive(:error).with(text)
-      expect{ subject.send(:error, text) }.to raise_error(LogStash::UnrecoverablePumaError, text)
+      expect { subject.send(:error, text) }.to raise_error(LogStash::UnrecoverablePumaError, text)
     end
   end
 
diff --git a/logstash-core/spec/logstash/pipeline_action/create_spec.rb b/logstash-core/spec/logstash/pipeline_action/create_spec.rb
index 771681153f0..16cabacb086 100644
--- a/logstash-core/spec/logstash/pipeline_action/create_spec.rb
+++ b/logstash-core/spec/logstash/pipeline_action/create_spec.rb
@@ -68,7 +68,7 @@
     end
   end
 
-  context  "when the pipeline doesn't start" do
+  context "when the pipeline doesn't start" do
     context "with a syntax error" do
       let(:pipeline_config) { mock_pipeline_config(:main, "input { dummyblockinginput { id => '123' } } output { stdout ") } # bad syntax
 
diff --git a/logstash-core/spec/logstash/plugins/ca_trusted_fingerprint_support_spec.rb b/logstash-core/spec/logstash/plugins/ca_trusted_fingerprint_support_spec.rb
index b0c6115d420..b968e0195e5 100644
--- a/logstash-core/spec/logstash/plugins/ca_trusted_fingerprint_support_spec.rb
+++ b/logstash-core/spec/logstash/plugins/ca_trusted_fingerprint_support_spec.rb
@@ -56,7 +56,7 @@
             allow(plugin_class).to receive(:logger).and_return(logger_stub)
           end
           it 'logs helpfully and raises an exception' do
-            expect{plugin}.to raise_exception(LogStash::ConfigurationError)
+            expect {plugin}.to raise_exception(LogStash::ConfigurationError)
             expect(logger_stub).to have_received(:error).with(a_string_including "Expected a hex-encoded SHA-256 fingerprint")
           end
         end
diff --git a/logstash-core/spec/logstash/runner_spec.rb b/logstash-core/spec/logstash/runner_spec.rb
index 59c62ebe57d..d85c15d861f 100644
--- a/logstash-core/spec/logstash/runner_spec.rb
+++ b/logstash-core/spec/logstash/runner_spec.rb
@@ -120,11 +120,11 @@
 
     it "should fail with single invalid dir path" do
       expect(LogStash::Environment).not_to receive(:add_plugin_path)
-      expect{subject.configure_plugin_paths(invalid_directory)}.to raise_error(Clamp::UsageError)
+      expect {subject.configure_plugin_paths(invalid_directory)}.to raise_error(Clamp::UsageError)
     end
 
     it "should add multiple valid dir path to the environment" do
-      multiple_paths.each{|path| expect(LogStash::Environment).to receive(:add_plugin_path).with(path)}
+      multiple_paths.each {|path| expect(LogStash::Environment).to receive(:add_plugin_path).with(path)}
       subject.configure_plugin_paths(multiple_paths)
     end
   end
diff --git a/logstash-core/spec/logstash/util/accessors_spec.rb b/logstash-core/spec/logstash/util/accessors_spec.rb
index 0acbf6e1ffd..89d994c1b35 100644
--- a/logstash-core/spec/logstash/util/accessors_spec.rb
+++ b/logstash-core/spec/logstash/util/accessors_spec.rb
@@ -120,7 +120,7 @@
       data = {}
       accessors = LogStash::Util::Accessors.new(data)
       expect(accessors.get(str)).to be_nil
-      expect(data).to  be_empty
+      expect(data).to be_empty
       expect(accessors.set(str, "foo")).to eq("foo")
       expect(data).to eq({ "hello" => {"world" => "foo"} })
     end
diff --git a/logstash-core/spec/logstash/util/charset_spec.rb b/logstash-core/spec/logstash/util/charset_spec.rb
index c4cfe0b0aef..62097f3cd0b 100644
--- a/logstash-core/spec/logstash/util/charset_spec.rb
+++ b/logstash-core/spec/logstash/util/charset_spec.rb
@@ -60,7 +60,7 @@
         ["foobar", "foobar"],
         ["\xE0 Montr\xE9al", "à Montréal"],
       ]
-      samples.map{|(a, b)| [a.force_encoding("ISO-8859-1"), b]}.each do |(a, b)|
+      samples.map {|(a, b)| [a.force_encoding("ISO-8859-1"), b]}.each do |(a, b)|
         expect(a.encoding.name).to eq("ISO-8859-1")
         expect(b.encoding.name).to eq("UTF-8")
         expect(a.valid_encoding?).to eq(true)
@@ -78,7 +78,7 @@
         ["\xE0 Montr\xE9al", "� Montr�al"],
         ["\xCE\xBA\xCF\x8C\xCF\x83\xCE\xBC\xCE\xB5", "����������"],
       ]
-      samples.map{|(a, b)| [a.force_encoding("ASCII-8BIT"), b]}.each do |(a, b)|
+      samples.map {|(a, b)| [a.force_encoding("ASCII-8BIT"), b]}.each do |(a, b)|
         expect(a.encoding.name).to eq("ASCII-8BIT")
         expect(b.encoding.name).to eq("UTF-8")
         expect(subject.convert(a).encoding.name).to eq("UTF-8")
diff --git a/logstash-core/spec/logstash/util/cloud_setting_id_spec.rb b/logstash-core/spec/logstash/util/cloud_setting_id_spec.rb
index 9f2d397cc3f..ca3ae889383 100644
--- a/logstash-core/spec/logstash/util/cloud_setting_id_spec.rb
+++ b/logstash-core/spec/logstash/util/cloud_setting_id_spec.rb
@@ -24,7 +24,7 @@
 
   describe "when given unacceptable input" do
     it "a nil input does not raise an exception" do
-      expect{described_class.new(nil)}.not_to raise_exception
+      expect {described_class.new(nil)}.not_to raise_exception
     end
     it "when given a nil input, the accessors are all nil" do
       cloud_id = described_class.new(nil)
@@ -41,7 +41,7 @@
       let(:raw) {%w(first second)}
       let(:input) { described_class.cloud_id_encode(*raw) }
       it "raises an error" do
-        expect{subject}.to raise_exception(ArgumentError, "Cloud Id, after decoding, is invalid. Format: '<segment1>$<segment2>$<segment3>'. Received: \"#{raw[0]}$#{raw[1]}\".")
+        expect {subject}.to raise_exception(ArgumentError, "Cloud Id, after decoding, is invalid. Format: '<segment1>$<segment2>$<segment3>'. Received: \"#{raw[0]}$#{raw[1]}\".")
       end
     end
 
@@ -49,7 +49,7 @@
       let(:raw) {["first", "", "third"]}
       let(:input) { described_class.cloud_id_encode(*raw) }
       it "raises an error" do
-        expect{subject}.to raise_exception(ArgumentError, "Cloud Id, after decoding, is invalid. Format: '<segment1>$<segment2>$<segment3>'. Received: \"#{raw[0]}$#{raw[1]}$#{raw[2]}\".")
+        expect {subject}.to raise_exception(ArgumentError, "Cloud Id, after decoding, is invalid. Format: '<segment1>$<segment2>$<segment3>'. Received: \"#{raw[0]}$#{raw[1]}$#{raw[2]}\".")
       end
     end
 
@@ -57,7 +57,7 @@
       let(:raw) {%w(us-east-1.aws.found.io undefined my-kibana)}
       let(:input) { described_class.cloud_id_encode(*raw) }
       it "raises an error" do
-        expect{subject}.to raise_exception(ArgumentError, "Cloud Id, after decoding, elasticsearch segment is 'undefined', literally.")
+        expect {subject}.to raise_exception(ArgumentError, "Cloud Id, after decoding, elasticsearch segment is 'undefined', literally.")
       end
     end
 
@@ -65,7 +65,7 @@
       let(:raw) {%w(us-east-1.aws.found.io my-elastic-cluster undefined)}
       let(:input) { described_class.cloud_id_encode(*raw) }
       it "raises an error" do
-        expect{subject}.to raise_exception(ArgumentError, "Cloud Id, after decoding, the kibana segment is 'undefined', literally. You may need to enable Kibana in the Cloud UI.")
+        expect {subject}.to raise_exception(ArgumentError, "Cloud Id, after decoding, the kibana segment is 'undefined', literally. You may need to enable Kibana in the Cloud UI.")
       end
     end
   end
diff --git a/logstash-core/spec/logstash/util/safe_uri_spec.rb b/logstash-core/spec/logstash/util/safe_uri_spec.rb
index a50a197c8bb..bd4b082fee8 100644
--- a/logstash-core/spec/logstash/util/safe_uri_spec.rb
+++ b/logstash-core/spec/logstash/util/safe_uri_spec.rb
@@ -72,7 +72,7 @@ module LogStash module Util
         context 'malformed uris via string' do
           MALFORMED_URIS.each do |arg|
             it "#{arg}: should raise an error" do
-              expect{LogStash::Util::SafeURI.new(arg)}.to raise_error(ArgumentError)
+              expect {LogStash::Util::SafeURI.new(arg)}.to raise_error(ArgumentError)
             end
           end
         end
@@ -81,7 +81,7 @@ module LogStash module Util
           MALFORMED_URIS.each do |arg|
             it "#{arg}: should raise an error" do
               java_uri = java.net.URI.new(arg)
-              expect{LogStash::Util::SafeURI.new(java_uri)}.to raise_error(ArgumentError)
+              expect {LogStash::Util::SafeURI.new(java_uri)}.to raise_error(ArgumentError)
             end
           end
         end
@@ -90,7 +90,7 @@ module LogStash module Util
           MALFORMED_URIS.each do |arg|
             it "#{arg}: should raise an error" do
               ruby_uri = URI.parse(arg)
-              expect{LogStash::Util::SafeURI.new(ruby_uri)}.to raise_error(ArgumentError)
+              expect {LogStash::Util::SafeURI.new(ruby_uri)}.to raise_error(ArgumentError)
             end
           end
         end
diff --git a/logstash-core/spec/logstash/webserver_spec.rb b/logstash-core/spec/logstash/webserver_spec.rb
index 8974e7a5130..50c90911eeb 100644
--- a/logstash-core/spec/logstash/webserver_spec.rb
+++ b/logstash-core/spec/logstash/webserver_spec.rb
@@ -230,14 +230,14 @@ def free_ports(servers)
   end
 
   it "responds to sync=(v)" do
-    expect{ subject.sync = true }.not_to raise_error
+    expect { subject.sync = true }.not_to raise_error
   end
 
   it "responds to sync" do
-    expect{ subject.sync }.not_to raise_error
+    expect { subject.sync }.not_to raise_error
   end
 
   it "responds to flush" do
-    expect{ subject.flush }.not_to raise_error
+    expect { subject.flush }.not_to raise_error
   end
 end
diff --git a/qa/docker/spec/spec_helper.rb b/qa/docker/spec/spec_helper.rb
index 3c1fc31d6fb..275174fb2cc 100644
--- a/qa/docker/spec/spec_helper.rb
+++ b/qa/docker/spec/spec_helper.rb
@@ -19,8 +19,8 @@ def qualified_version
 end
 
 def find_image(flavor)
-  Docker::Image.all.detect{
-      |image| image.info['RepoTags'].detect{
+  Docker::Image.all.detect {
+      |image| image.info['RepoTags'].detect {
         |tag| tag == "docker.elastic.co/logstash/logstash-#{flavor}:#{qualified_version}"
     }}
 end
@@ -96,7 +96,7 @@ def get_plugin_info(container, type, id, pipeline = 'main')
     puts "Unable to find plugins from #{pipeline_info}, when looking for #{type} plugins in #{pipeline}"
     return nil
   end
-  all_plugins.find{|plugin| plugin['id'] == id}
+  all_plugins.find {|plugin| plugin['id'] == id}
 end
 
 def logstash_available?(container)
diff --git a/qa/integration/specs/01_logstash_bin_smoke_spec.rb b/qa/integration/specs/01_logstash_bin_smoke_spec.rb
index 30dd347afe1..ba75c6923ba 100644
--- a/qa/integration/specs/01_logstash_bin_smoke_spec.rb
+++ b/qa/integration/specs/01_logstash_bin_smoke_spec.rb
@@ -48,7 +48,7 @@
 
   let(:num_retries) { 50 }
   let(:config1) { config_to_temp_file(@fixture.config("root", { :port => port1, :random_file => file_config1 })) }
-  let(:config2) { config_to_temp_file(@fixture.config("root", { :port => port2 , :random_file => file_config2 })) }
+  let(:config2) { config_to_temp_file(@fixture.config("root", { :port => port2, :random_file => file_config2 })) }
   let(:config3) { config_to_temp_file(@fixture.config("root", { :port => port3, :random_file => file_config3 })) }
   let(:port1) { random_port }
   let(:port2) { random_port }
diff --git a/qa/integration/specs/deprecation_log_spec.rb b/qa/integration/specs/deprecation_log_spec.rb
index 6f018bd326d..034ee8c4813 100644
--- a/qa/integration/specs/deprecation_log_spec.rb
+++ b/qa/integration/specs/deprecation_log_spec.rb
@@ -56,7 +56,7 @@
       "pipeline.separate_logs" => false
     }
     IO.write(@ls.application_settings_file, settings.to_yaml)
-    @ls.spawn_logstash("-w", "1" , "-e", config)
+    @ls.spawn_logstash("-w", "1", "-e", config)
     wait_logstash_process_terminate
 
     deprecation_log_file = "#{temp_dir}/logstash-deprecation.log"
diff --git a/qa/integration/specs/mixed_codec_spec.rb b/qa/integration/specs/mixed_codec_spec.rb
index 50fba82e198..f0d4d3f2521 100644
--- a/qa/integration/specs/mixed_codec_spec.rb
+++ b/qa/integration/specs/mixed_codec_spec.rb
@@ -82,7 +82,7 @@
 
     it "should encode correctly to file and don't log any ERROR" do
       logstash_service.env_variables = {'PATH_TO_OUT' => out_capture.path}
-      logstash_service.spawn_logstash("-w", "1" , "-e", config)
+      logstash_service.spawn_logstash("-w", "1", "-e", config)
       logstash_service.wait_for_logstash
       logstash_service.wait_for_rest_api
 
@@ -105,7 +105,7 @@
     let(:config) { @fixture.config("output_encode") }
 
     it "should encode correctly without any ERROR log" do
-      logstash_service.spawn_logstash("-w", "1" , "-e", config)
+      logstash_service.spawn_logstash("-w", "1", "-e", config)
       logstash_service.wait_for_logstash
       logstash_service.wait_for_rest_api
 
diff --git a/qa/integration/specs/monitoring_api_spec.rb b/qa/integration/specs/monitoring_api_spec.rb
index e5694dc59cd..72ff38afb14 100644
--- a/qa/integration/specs/monitoring_api_spec.rb
+++ b/qa/integration/specs/monitoring_api_spec.rb
@@ -94,7 +94,7 @@
     let(:logstash_service) { @fixture.get_service("logstash") }
 
     before(:each) do
-      logstash_service.spawn_logstash("-w", "1" , "-e", config)
+      logstash_service.spawn_logstash("-w", "1", "-e", config)
       logstash_service.wait_for_logstash
       wait_for_port(tcp_port, 60)
 
diff --git a/qa/integration/specs/pipeline_log_spec.rb b/qa/integration/specs/pipeline_log_spec.rb
index 8f1239aa621..6f21464ad27 100644
--- a/qa/integration/specs/pipeline_log_spec.rb
+++ b/qa/integration/specs/pipeline_log_spec.rb
@@ -56,7 +56,7 @@
       "pipeline.id" => pipeline_name
     }
     IO.write(@ls.application_settings_file, settings.to_yaml)
-    @ls.spawn_logstash("-w", "1" , "-e", config)
+    @ls.spawn_logstash("-w", "1", "-e", config)
     wait_logstash_process_terminate(@ls)
     plainlog_file = "#{temp_dir}/logstash-plain.log"
     expect(File.exist?(plainlog_file)).to be true
@@ -70,7 +70,7 @@
       "pipeline.id" => pipeline_name
     }
     IO.write(@ls.application_settings_file, settings.to_yaml)
-    @ls.spawn_logstash("-w", "1" , "-e", config)
+    @ls.spawn_logstash("-w", "1", "-e", config)
     wait_logstash_process_terminate(@ls)
     plainlog_file = "#{temp_dir}/logstash-plain.log"
     expect(File.exist?(plainlog_file)).to be true
@@ -99,7 +99,7 @@
       "pipeline.separate_logs" => true
     }
     IO.write(@ls.application_settings_file, settings.to_yaml)
-    @ls.spawn_logstash("-w", "1" , "-e", config)
+    @ls.spawn_logstash("-w", "1", "-e", config)
     wait_logstash_process_terminate(@ls)
 
     pipeline_log_file = "#{temp_dir}/pipeline_#{pipeline_name}.log"
@@ -130,7 +130,7 @@
     expect(log_definition).to match(/appender\.rolling\.filePattern\s*=\s*.*\/logstash-plain-%d{yyyy-MM-dd}\.log/)
     FileUtils.cp("fixtures/logs_rollover/log4j2.properties", temp_dir)
 
-    @ls.spawn_logstash("--path.settings", temp_dir, "-w", "1" , "-e", config)
+    @ls.spawn_logstash("--path.settings", temp_dir, "-w", "1", "-e", config)
     wait_logstash_process_terminate(@ls)
 
     logstash_logs = Dir.glob("logstash-plain*.log", base: temp_dir)
@@ -158,7 +158,7 @@
       expect(log_definition).to match(/appender\.routing\.pipeline\.policy\.size\s*=\s*1KB/)
       FileUtils.cp("fixtures/logs_rollover/log4j2.properties", temp_dir)
 
-      @ls.spawn_logstash("--path.settings", temp_dir, "-w", "1" , "-e", config)
+      @ls.spawn_logstash("--path.settings", temp_dir, "-w", "1", "-e", config)
       wait_logstash_process_terminate(@ls)
 
       pipeline_logs = Dir.glob("pipeline*.log", base: temp_dir)
@@ -173,7 +173,7 @@
       "pipeline.separate_logs" => false
     }
     IO.write(@ls.application_settings_file, settings.to_yaml)
-    @ls.spawn_logstash("-w", "1" , "-e", config)
+    @ls.spawn_logstash("-w", "1", "-e", config)
     wait_logstash_process_terminate(@ls)
 
     pipeline_log_file = "#{temp_dir}/pipeline_#{pipeline_name}.log"
diff --git a/qa/integration/specs/plugin_name_log_spec.rb b/qa/integration/specs/plugin_name_log_spec.rb
index 1e6384d3e01..87803571cd2 100644
--- a/qa/integration/specs/plugin_name_log_spec.rb
+++ b/qa/integration/specs/plugin_name_log_spec.rb
@@ -53,7 +53,7 @@
       "log.level" => "debug"
     }
     IO.write(@ls.application_settings_file, settings.to_yaml)
-    @ls.spawn_logstash("-w", "1" , "-e", config)
+    @ls.spawn_logstash("-w", "1", "-e", config)
     wait_logstash_process_terminate()
     plainlog_file = "#{temp_dir}/logstash-plain.log"
     expect(File.exist?(plainlog_file)).to be true
diff --git a/qa/integration/specs/slowlog_spec.rb b/qa/integration/specs/slowlog_spec.rb
index b932dfd6cee..fdad68ac114 100644
--- a/qa/integration/specs/slowlog_spec.rb
+++ b/qa/integration/specs/slowlog_spec.rb
@@ -53,7 +53,7 @@
       "slowlog.threshold.warn" => "500ms"
     }
     IO.write(@ls.application_settings_file, settings.to_yaml)
-    @ls.spawn_logstash("-w", "1" , "-e", config)
+    @ls.spawn_logstash("-w", "1", "-e", config)
     @ls.wait_for_logstash
     sleep 2 until @ls.exited?
     slowlog_file = "#{temp_dir}/logstash-slowlog-plain.log"
diff --git a/qa/platform_config.rb b/qa/platform_config.rb
index 480aba6860e..448f38a8a17 100644
--- a/qa/platform_config.rb
+++ b/qa/platform_config.rb
@@ -90,7 +90,7 @@ def filter_type(type_name, options = {})
 
   def select_names_for(platform, options = {})
     filter_options = { "experimental" => options.fetch("experimental", false) }
-    filter_type(platform, filter_options).map{ |p| p.name }
+    filter_type(platform, filter_options).map { |p| p.name }
   end
 
   def types
diff --git a/qa/rspec/commands.rb b/qa/rspec/commands.rb
index c977ae6f88f..0348796339a 100644
--- a/qa/rspec/commands.rb
+++ b/qa/rspec/commands.rb
@@ -100,7 +100,7 @@ def gem_vendored?(gem_name)
     end
 
     def download(from, to)
-      client.download(from, to , host)
+      client.download(from, to, host)
     end
 
     def replace_in_gemfile(pattern, replace)
diff --git a/rakelib/artifacts.rake b/rakelib/artifacts.rake
index 464a8319c34..b3d5660cdc8 100644
--- a/rakelib/artifacts.rake
+++ b/rakelib/artifacts.rake
@@ -407,7 +407,7 @@ namespace "artifact" do
     gem_line_regex = /^\s*gem\s+["']logstash-core["'](?:\s*,\s*["'][^"^']+["'])?(?:\s*,\s*:path\s*=>\s*["']([^"^']+)["'])?/i
 
     lines = File.readlines("Gemfile")
-    matches = lines.select{|line| line[gem_line_regex]}
+    matches = lines.select {|line| line[gem_line_regex]}
     abort("ERROR: Gemfile format error, need a single logstash-core gem specification") if matches.size != 1
 
     path = matches.first[gem_line_regex, 1]
@@ -427,7 +427,7 @@ namespace "artifact" do
     gem_line_regex = /^\s*gem\s+["']logstash-core-plugin-api["'](?:\s*,\s*["'][^"^']+["'])?(?:\s*,\s*:path\s*=>\s*["']([^"^']+)["'])?/i
 
     lines = File.readlines("Gemfile")
-    matches = lines.select{|line| line[gem_line_regex]}
+    matches = lines.select {|line| line[gem_line_regex]}
     abort("ERROR: Gemfile format error, need a single logstash-core-plugin-api gem specification") if matches.size != 1
 
     path = matches.first[gem_line_regex, 1]
diff --git a/spec/unit/plugin_manager/gemfile_spec.rb b/spec/unit/plugin_manager/gemfile_spec.rb
index e2b76cda77e..1399e69c68e 100644
--- a/spec/unit/plugin_manager/gemfile_spec.rb
+++ b/spec/unit/plugin_manager/gemfile_spec.rb
@@ -58,7 +58,7 @@
           gemspec "boom"
         END
 
-        expect{LogStash::Gemfile.new(StringIO.new(file)).load}.to raise_error(LogStash::GemfileError)
+        expect {LogStash::Gemfile.new(StringIO.new(file)).load}.to raise_error(LogStash::GemfileError)
       end
 
       it "should add gems" do
@@ -79,7 +79,7 @@
           gem "foo"
         END
 
-        expect{LogStash::Gemfile.new(StringIO.new(file)).load}.to raise_error(LogStash::GemfileError)
+        expect {LogStash::Gemfile.new(StringIO.new(file)).load}.to raise_error(LogStash::GemfileError)
       end
 
       it "should add gems with only name" do
diff --git a/x-pack/lib/license_checker/license_manager.rb b/x-pack/lib/license_checker/license_manager.rb
index 3a65c9dcc9b..24c4109f71b 100644
--- a/x-pack/lib/license_checker/license_manager.rb
+++ b/x-pack/lib/license_checker/license_manager.rb
@@ -24,8 +24,8 @@ def initialize(reader, feature, refresh_period = 30, refresh_unit = TimeUnit::SE
         fetch_xpack_info
 
         if @executor.nil?
-            @executor = Executors.new_single_thread_scheduled_executor{ |runnable| create_daemon_thread (runnable)}
-            @executor.schedule_at_fixed_rate(Proc.new{fetch_xpack_info}, refresh_period, refresh_period, refresh_unit)
+            @executor = Executors.new_single_thread_scheduled_executor { |runnable| create_daemon_thread (runnable)}
+            @executor.schedule_at_fixed_rate(Proc.new {fetch_xpack_info}, refresh_period, refresh_period, refresh_unit)
         end
       end
 
diff --git a/x-pack/qa/integration/monitoring/monitoring_is_disabled_spec.rb b/x-pack/qa/integration/monitoring/monitoring_is_disabled_spec.rb
index 1723c72e875..c153c31aaa4 100644
--- a/x-pack/qa/integration/monitoring/monitoring_is_disabled_spec.rb
+++ b/x-pack/qa/integration/monitoring/monitoring_is_disabled_spec.rb
@@ -33,6 +33,6 @@
   let(:monitoring_index) { ".monitoring-logstash-2-*" }
 
   it "doesn't record any metrics" do
-    expect(elasticsearch_client.search(:index => monitoring_index)["hits"]["total"]["value"]).to  eq(0)
+    expect(elasticsearch_client.search(:index => monitoring_index)["hits"]["total"]["value"]).to eq(0)
   end
 end
diff --git a/x-pack/spec/config_management/elasticsearch_source_spec.rb b/x-pack/spec/config_management/elasticsearch_source_spec.rb
index 012421f9109..1b2f898cb45 100644
--- a/x-pack/spec/config_management/elasticsearch_source_spec.rb
+++ b/x-pack/spec/config_management/elasticsearch_source_spec.rb
@@ -253,7 +253,7 @@
 
       it "#fetch_config should raise error" do
         expect(mock_client).to receive(:get).with("#{described_class::SYSTEM_INDICES_API_PATH}/").and_return(elasticsearch_8_err_response.clone)
-        expect{ subject.fetch_config(es_version_8_2, ["apache", "nginx"], mock_client) }.to raise_error(LogStash::ConfigManagement::ElasticsearchSource::RemoteConfigError)
+        expect { subject.fetch_config(es_version_8_2, ["apache", "nginx"], mock_client) }.to raise_error(LogStash::ConfigManagement::ElasticsearchSource::RemoteConfigError)
       end
 
       describe "wildcard" do
@@ -353,12 +353,12 @@
       it "#fetch_config should raise error" do
         expect(mock_client).to receive(:post).with("#{described_class::PIPELINE_INDEX}/_mget", {}, "{\"docs\":[{\"_id\":\"#{pipeline_id}\"},{\"_id\":\"#{another_pipeline_id}\"}]}").and_return(elasticsearch_7_9_err_response)
         expect(mock_logger).to receive(:warn).never
-        expect{ subject.fetch_config(empty_es_version, [pipeline_id, another_pipeline_id], mock_client) }.to raise_error(LogStash::ConfigManagement::ElasticsearchSource::RemoteConfigError)
+        expect { subject.fetch_config(empty_es_version, [pipeline_id, another_pipeline_id], mock_client) }.to raise_error(LogStash::ConfigManagement::ElasticsearchSource::RemoteConfigError)
       end
 
       it "#fetch_config should raise error when response is empty" do
         expect(mock_client).to receive(:post).with("#{described_class::PIPELINE_INDEX}/_mget", {}, "{\"docs\":[{\"_id\":\"#{pipeline_id}\"},{\"_id\":\"#{another_pipeline_id}\"}]}").and_return(LogStash::Json.load("{}"))
-        expect{ subject.fetch_config(empty_es_version, [pipeline_id, another_pipeline_id], mock_client) }.to raise_error(LogStash::ConfigManagement::ElasticsearchSource::RemoteConfigError)
+        expect { subject.fetch_config(empty_es_version, [pipeline_id, another_pipeline_id], mock_client) }.to raise_error(LogStash::ConfigManagement::ElasticsearchSource::RemoteConfigError)
       end
 
       it "#fetch_config should log unmatched pipeline id" do
@@ -557,7 +557,7 @@
             end
 
             it 'should raise an error' do
-              expect{subject.pipeline_configs}.to raise_error(LogStash::LicenseChecker::LicenseError)
+              expect {subject.pipeline_configs}.to raise_error(LogStash::LicenseChecker::LicenseError)
             end
           end
 
@@ -568,7 +568,7 @@
             end
 
             it 'should raise an error' do
-              expect{subject.pipeline_configs}.to raise_error(LogStash::LicenseChecker::LicenseError)
+              expect {subject.pipeline_configs}.to raise_error(LogStash::LicenseChecker::LicenseError)
             end
           end
 
@@ -616,7 +616,7 @@
             let(:license_type) { 'basic' }
 
             it 'should raise an error' do
-              expect{subject.pipeline_configs}.to raise_error(LogStash::LicenseChecker::LicenseError)
+              expect {subject.pipeline_configs}.to raise_error(LogStash::LicenseChecker::LicenseError)
             end
           end
 
@@ -697,7 +697,7 @@
         end
 
         context "when any error returned from elasticsearch [#{es_version}]" do
-          let(:elasticsearch_8_response){"{\"error\" : \"no handler found for uri [/_logstash/pipelines?pretty] and method [GET]\"}" }
+          let(:elasticsearch_8_response) {"{\"error\" : \"no handler found for uri [/_logstash/pipelines?pretty] and method [GET]\"}" }
           let(:elasticsearch_7_9_response) { '{ "error":{"root_cause":[{"type":"illegal_argument_exception","reason":"No endpoint or operation is available at [testing_ph]"}],"type":"illegal_argument_exception","reason":"No endpoint or operation is available at [testing_ph]"},"status":400}' }
 
           before do
@@ -769,7 +769,7 @@
 
     it "responses with an error" do
       allow(mock_client).to receive(:get).with("/").and_return(elasticsearch_8_err_response)
-      expect{ subject.get_es_version }.to raise_error(LogStash::ConfigManagement::ElasticsearchSource::RemoteConfigError)
+      expect { subject.get_es_version }.to raise_error(LogStash::ConfigManagement::ElasticsearchSource::RemoteConfigError)
     end
   end
 
diff --git a/x-pack/spec/filters/geoip/download_manager_spec.rb b/x-pack/spec/filters/geoip/download_manager_spec.rb
index 487916e8323..2e160e44fe2 100644
--- a/x-pack/spec/filters/geoip/download_manager_spec.rb
+++ b/x-pack/spec/filters/geoip/download_manager_spec.rb
@@ -109,7 +109,7 @@
 
       it "should raise error if md5 does not match" do
         allow(Down).to receive(:download)
-        expect{ download_manager.send(:download_database, database_type, dirname, db_info) }.to raise_error /wrong checksum/
+        expect { download_manager.send(:download_database, database_type, dirname, db_info) }.to raise_error /wrong checksum/
       end
 
       it "should download file and return zip path" do
@@ -161,7 +161,7 @@
       end
 
       it "should raise error if file is invalid" do
-        expect{ download_manager.send(:assert_database!, "Gemfile") }.to raise_error /failed to load database/
+        expect { download_manager.send(:assert_database!, "Gemfile") }.to raise_error /failed to load database/
       end
 
       it "should pass validation" do
diff --git a/x-pack/spec/modules/arcsight/arcsight_module_config_spec.rb b/x-pack/spec/modules/arcsight/arcsight_module_config_spec.rb
index 479be0ec295..ed14e3a67c4 100644
--- a/x-pack/spec/modules/arcsight/arcsight_module_config_spec.rb
+++ b/x-pack/spec/modules/arcsight/arcsight_module_config_spec.rb
@@ -9,7 +9,7 @@
   let(:logstash_config_class) { LogStash::Modules::LogStashConfig  }
   let(:module_name) { "arcsight" }
   let(:module_path) { ::File.join(LogStash::Environment::LOGSTASH_HOME, "x-pack", "modules", module_name, "configuration") }
-  let(:mod) { instance_double("arcsight", :directory => module_path , :module_name => module_name) }
+  let(:mod) { instance_double("arcsight", :directory => module_path, :module_name => module_name) }
   let(:settings) { {} }
   subject { logstash_config_class.new(mod, settings) }
 
