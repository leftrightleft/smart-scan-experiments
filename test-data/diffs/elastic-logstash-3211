diff --git a/lib/logstash/codecs/base.rb b/lib/logstash/codecs/base.rb
index 662f054dfde..189ae15fd90 100644
--- a/lib/logstash/codecs/base.rb
+++ b/lib/logstash/codecs/base.rb
@@ -5,46 +5,42 @@
 require "logstash/logging"
 
 # This is the base class for logstash codecs.
-module LogStash::Codecs; class Base < LogStash::Plugin
-  include LogStash::Config::Mixin
-  config_name "codec"
-
-  def initialize(params={})
-    super
-    config_init(params)
-    register if respond_to?(:register)
+module LogStash::Codecs
+  class Base < LogStash::Plugin
+    include LogStash::Config::Mixin
+    config_name "codec"
+
+    def initialize(params={})
+      super
+      config_init(params)
+      register if respond_to?(:register)
+    end
+
+    def decode(data)
+      raise "#{self.class}#decode must be overidden"
+    end # def decode
+
+    alias_method :<<, :decode
+
+    def encode(event)
+      raise "#{self.class}#encode must be overidden"
+    end # def encode
+
+    def teardown
+      # override if needed
+    end
+
+    # @param block [Proc(event, data)] the callback proc passing the original event and the encoded event
+    def on_event(&block)
+      @on_event = block
+    end
+
+    def flush(&block)
+      # override if needed
+    end
+
+    def clone
+      return self.class.new(params)
+    end
   end
-
-  public
-  def decode(data)
-    raise "#{self.class}#decode must be overidden"
-  end # def decode
-
-  alias_method :<<, :decode
-
-  public
-  def encode(event)
-    raise "#{self.class}#encode must be overidden"
-  end # def encode
-
-  public 
-  def teardown; end;
-
-  # @param block [Proc(event, data)] the callback proc passing the original event and the encoded event
-  public
-  def on_event(&block)
-    @on_event = block
-  end
-
-  public
-  def flush(&block)
-    # does nothing by default.
-    # if your codec needs a flush method (like you are spooling things)
-    # you must implement this.
-  end
-
-  public
-  def clone
-    return self.class.new(params)
-  end
-end; end # class LogStash::Codecs::Base
+end
diff --git a/lib/logstash/filters/base.rb b/lib/logstash/filters/base.rb
index 131661cfb54..b76090dfaf1 100644
--- a/lib/logstash/filters/base.rb
+++ b/lib/logstash/filters/base.rb
@@ -129,22 +129,19 @@ class LogStash::Filters::Base < LogStash::Plugin
 
   RESERVED = ["type", "tags", "exclude_tags", "include_fields", "exclude_fields", "add_tag", "remove_tag", "add_field", "remove_field", "include_any", "exclude_any"]
 
-  public
   def initialize(params)
     super
     config_init(params)
     @threadsafe = true
-  end # def initialize
+  end
 
-  public
   def register
     raise "#{self.class}#register must be overidden"
-  end # def register
+  end
 
-  public
   def filter(event)
     raise "#{self.class}#filter must be overidden"
-  end # def filter
+  end
 
   # in 1.5.0 multi_filter is meant to be used in the generated filter function in LogStash::Config::AST::Plugin only
   # and is temporary until we refactor the filter method interface to accept events list and return events list,
@@ -153,7 +150,6 @@ def filter(event)
   #
   # @param events [Array<LogStash::Event] list of events to filter
   # @return [Array<LogStash::Event] filtered events and any new events generated by the filter
-  public
   def multi_filter(events)
     result = []
     events.each do |event|
@@ -165,19 +161,22 @@ def multi_filter(events)
     result
   end
 
-  public
   def execute(event, &block)
     filter(event, &block)
   end # def execute
 
-  public
   def threadsafe?
     @threadsafe
   end
 
+  def teardown
+    # override if needed
+  end
+
+  protected
+
   # a filter instance should call filter_matched from filter if the event
   # matches the filter's conditions (right type, etc)
-  protected
   def filter_matched(event)
     @add_field.each do |field, value|
       field = event.sprintf(field)
@@ -216,9 +215,8 @@ def filter_matched(event)
                                        :tag => tag)
       event["tags"].delete(tag)
     end
-  end # def filter_matched
+  end
 
-  protected
   def filter?(event)
     if !@type.empty?
       if event["type"] != @type
@@ -251,9 +249,4 @@ def filter?(event)
 
     return true
   end
-
-  public
-  def teardown
-    # Nothing to do by default.
-  end
-end # class LogStash::Filters::Base
+end
diff --git a/lib/logstash/inputs/base.rb b/lib/logstash/inputs/base.rb
index 2874b3d3886..cc7d67691f9 100644
--- a/lib/logstash/inputs/base.rb
+++ b/lib/logstash/inputs/base.rb
@@ -80,31 +80,28 @@ def initialize(params={})
 
     # Backwards compat for the 'format' setting
     case @format
-      when "plain"; # do nothing
-      when "json"
-        @codec = LogStash::Plugin.lookup("codec", "json").new
-      when "json_event"
-        @codec = LogStash::Plugin.lookup("codec", "oldlogstashjson").new
+    when "plain"; # do nothing
+    when "json"
+      @codec = LogStash::Plugin.lookup("codec", "json").new
+    when "json_event"
+      @codec = LogStash::Plugin.lookup("codec", "oldlogstashjson").new
     end
+  end
 
-  end # def initialize
-
-  public
   def register
     raise "#{self.class}#register must be overidden"
   end # def register
 
-  public
   def tag(newtag)
     @tags << newtag
   end # def tag
 
   protected
+
   def to_event(raw, source)
     raise LogStash::ThisMethodWasRemoved("LogStash::Inputs::Base#to_event - you should use codecs now instead of to_event. Not sure what this means? Get help on logstash-users@googlegroups.com!")
   end # def to_event
 
-  protected
   def decorate(event)
     # Only set 'type' if not already set. This is backwards-compatible behavior
     event["type"] = @type if @type && !event.include?("type")
@@ -119,19 +116,18 @@ def decorate(event)
     end
   end
 
-  protected
   def fix_streaming_codecs
     require "logstash/codecs/plain"
     require "logstash/codecs/line"
     require "logstash/codecs/json"
     require "logstash/codecs/json_lines"
     case @codec
-      when LogStash::Codecs::Plain
-        @logger.info("Automatically switching from #{@codec.class.config_name} to line codec", :plugin => self.class.config_name)
-        @codec = LogStash::Codecs::Line.new("charset" => @codec.charset)
-      when LogStash::Codecs::JSON
-        @logger.info("Automatically switching from #{@codec.class.config_name} to json_lines codec", :plugin => self.class.config_name)
-        @codec = LogStash::Codecs::JSONLines.new("charset" => @codec.charset)
+    when LogStash::Codecs::Plain
+      @logger.info("Automatically switching from #{@codec.class.config_name} to line codec", :plugin => self.class.config_name)
+      @codec = LogStash::Codecs::Line.new("charset" => @codec.charset)
+    when LogStash::Codecs::JSON
+      @logger.info("Automatically switching from #{@codec.class.config_name} to json_lines codec", :plugin => self.class.config_name)
+      @codec = LogStash::Codecs::JSONLines.new("charset" => @codec.charset)
     end
   end
-end # class LogStash::Inputs::Base
+end
diff --git a/lib/logstash/inputs/threadable.rb b/lib/logstash/inputs/threadable.rb
index 04d834b722c..f02d5d5eb4d 100644
--- a/lib/logstash/inputs/threadable.rb
+++ b/lib/logstash/inputs/threadable.rb
@@ -2,17 +2,16 @@
 require "logstash/namespace"
 require "logstash/inputs/base"
 
-# This is the threadable class for logstash inputs. 
+# This is the threadable class for logstash inputs.
 # Use this class in your inputs if it can support multiple threads
 class LogStash::Inputs::Threadable < LogStash::Inputs::Base
 
   # Set this to the number of threads you want this input to spawn.
   # This is the same as declaring the input multiple times
   config :threads, :validate => :number, :default => 1
- 
+
   def initialize(params)
     super
     @threadable = true
   end
-
-end # class LogStash::Inputs::Threadable
+end
diff --git a/lib/logstash/outputs/base.rb b/lib/logstash/outputs/base.rb
index 44a3bfe079b..9ebd815c11a 100644
--- a/lib/logstash/outputs/base.rb
+++ b/lib/logstash/outputs/base.rb
@@ -35,8 +35,12 @@ class LogStash::Outputs::Base < LogStash::Plugin
 
   attr_reader :worker_plugins
 
-  public
-  def workers_not_supported(message=nil)
+  def initialize(params = {})
+    super
+    config_init(params)
+  end
+
+  def workers_not_supported(message = nil)
     return if @workers == 1
     if message
       @logger.warn(I18n.t("logstash.pipeline.output-worker-unsupported-with-message", :plugin => self.class.config_name, :worker_count => @workers, :message => message))
@@ -46,23 +50,18 @@ def workers_not_supported(message=nil)
     @workers = 1
   end
 
-  public
-  def initialize(params={})
-    super
-    config_init(params)
-  end
-
-  public
   def register
     raise "#{self.class}#register must be overidden"
-  end # def register
+  end
 
-  public
   def receive(event)
     raise "#{self.class}#receive must be overidden"
-  end # def receive
+  end
+
+  def teardown
+    # override if needed
+  end
 
-  public
   def worker_setup
     if @workers == 1
       @worker_plugins = [self]
@@ -83,16 +82,16 @@ def worker_setup
     end
   end
 
-  public
   def handle(event)
     receive(event)
-  end # def handle
+  end
 
   def handle_worker(event)
     @worker_queue.push(event)
   end
 
   private
+
   def output?(event)
     if !@type.empty?
       if event["type"] != @type
@@ -121,4 +120,4 @@ def output?(event)
 
     return true
   end
-end # class LogStash::Outputs::Base
+end
diff --git a/lib/logstash/pipeline.rb b/lib/logstash/pipeline.rb
index 3c0457669bc..b8565d96528 100644
--- a/lib/logstash/pipeline.rb
+++ b/lib/logstash/pipeline.rb
@@ -48,7 +48,7 @@ def initialize(configstr)
     @ready = false
     @started = false
     @input_threads = []
-  end # def initialize
+  end
 
   def ready?
     @run_mutex.synchronize{@ready}
@@ -102,7 +102,7 @@ def run
 
     # exit code
     return 0
-  end # def run
+  end
 
   def wait_inputs
     @input_threads.each(&:join)
@@ -175,64 +175,59 @@ def inputworker(plugin)
     LogStash::Util::set_thread_name("<#{plugin.class.config_name}")
     begin
       plugin.run(@input_to_filter)
-    rescue LogStash::ShutdownSignal
-      # ignore and quit
     rescue => e
+      # if plugin is stopping, ignore uncatched exceptions and exit worker
+      if plugin.stop?
+        @logger.debug("Ignoring stopping plugin exception", :exception => e, "backtrace" => e.backtrace)
+        return
+      end
+
+      # otherwise, report error and restart
       if @logger.debug?
-        @logger.error(I18n.t("logstash.pipeline.worker-error-debug",
-                             :plugin => plugin.inspect, :error => e.to_s,
-                             :exception => e.class,
-                             :stacktrace => e.backtrace.join("\n")))
+        @logger.error(
+          I18n.t("logstash.pipeline.worker-error-debug",
+            :plugin => plugin.inspect,
+            :error => e.to_s,
+            :exception => e,
+            :stacktrace => e.backtrace.join("\n")
+          )
+        )
       else
-        @logger.error(I18n.t("logstash.pipeline.worker-error",
-                             :plugin => plugin.inspect, :error => e))
+        @logger.error(I18n.t("logstash.pipeline.worker-error", :plugin => plugin.inspect, :error => e))
       end
-      puts e.backtrace if @logger.debug?
-      # input teardown must be synchronized since is can be called concurrently by
-      # the input worker thread and from the pipeline thread shutdown method.
-      # this means that input teardown methods must support multiple calls.
-      @run_mutex.synchronize{plugin.teardown}
-      sleep 1
-      retry
-    end
-  ensure
-    begin
-      # input teardown must be synchronized since is can be called concurrently by
-      # the input worker thread and from the pipeline thread shutdown method.
-      # this means that input teardown methods must support multiple calls.
-      @run_mutex.synchronize{plugin.teardown}
-    rescue LogStash::ShutdownSignal
-      # teardown could receive the ShutdownSignal, retry it
+
+      sleep(1)
       retry
+    ensure
+      plugin.close
     end
-  end # def inputworker
+  end
 
   def filterworker
     LogStash::Util::set_thread_name("|worker")
-    begin
-      while true
-        event = @input_to_filter.pop
-
-        case event
-        when LogStash::Event
-          # filter_func returns all filtered events, including cancelled ones
-          filter_func(event).each { |e| @filter_to_output.push(e) unless e.cancelled? }
-        when LogStash::FlushEvent
-          # handle filter flushing here so that non threadsafe filters (thus only running one filterworker)
-          # don't have to deal with thread safety implementing the flush method
-          @flusher_lock.synchronize { flush_filters_to_output! }
-        when LogStash::ShutdownEvent
-          # pass it down to any other filterworker and stop this worker
-          @input_to_filter.push(event)
-          break
-        end
+
+    while true
+      event = @input_to_filter.pop
+
+      case event
+      when LogStash::Event
+        # filter_func returns all filtered events, including cancelled ones
+        filter_func(event).each { |e| @filter_to_output.push(e) unless e.cancelled? }
+      when LogStash::FlushEvent
+        # handle filter flushing here so that non threadsafe filters (thus only running one filterworker)
+        # don't have to deal with thread safety implementing the flush method
+        @flusher_lock.synchronize { flush_filters_to_output! }
+      when LogStash::ShutdownEvent
+        # pass it down to any other filterworker and stop this worker
+        @input_to_filter.push(event)
+        break
       end
-    rescue => e
-      @logger.error("Exception in filterworker", "exception" => e, "backtrace" => e.backtrace)
     end
-
-    @filters.each(&:teardown)
-  end # def filterworker
+  rescue => e
+    @logger.error("Exception in filterworker", "exception" => e, "backtrace" => e.backtrace)
+  ensure
+   @filters.each(&:teardown)
+  end
 
   def outputworker
     LogStash::Util::set_thread_name(">output")
@@ -242,49 +237,19 @@ def outputworker
       event = @filter_to_output.pop
       break if event == LogStash::SHUTDOWN
       output_func(event)
-    end # while true
-
+    end
+  ensure
     @outputs.each do |output|
       output.worker_plugins.each(&:teardown)
     end
-  end # def outputworker
+  end
 
   # Shutdown this pipeline.
   #
   # This method is intended to be called from another thread
   def shutdown
-    @input_threads.each do |thread|
-      # Interrupt all inputs
-      @logger.info("Sending shutdown signal to input thread", :thread => thread)
-
-      # synchronize both ShutdownSignal and teardown below. by synchronizing both
-      # we will avoid potentially sending a shutdown signal when the inputworker is
-      # executing the teardown method.
-      @run_mutex.synchronize do
-        thread.raise(LogStash::ShutdownSignal)
-        begin
-          thread.wakeup # in case it's in blocked IO or sleeping
-        rescue ThreadError
-        end
-      end
-    end
-
-    # sometimes an input is stuck in a blocking I/O so we need to tell it to teardown directly
-    @inputs.each do |input|
-      begin
-        # input teardown must be synchronized since is can be called concurrently by
-        # the input worker thread and from the pipeline thread shutdown method.
-        # this means that input teardown methods must support multiple calls.
-        @run_mutex.synchronize{input.teardown}
-      rescue LogStash::ShutdownSignal
-        # teardown could receive the ShutdownSignal, retry it
-        retry
-      end
-    end
-
-    # No need to send the ShutdownEvent to the filters/outputs nor to wait for
-    # the inputs to finish, because in the #run method we wait for that anyway.
-  end # def shutdown
+    @inputs.each{|input| input.stop}
+  end
 
   def plugin(plugin_type, name, *args)
     args << {} if args.empty?
@@ -320,6 +285,6 @@ def flush_filters_to_output!(options = {})
         @filter_to_output.push(event)
       end
     end
-  end # flush_filters_to_output!
+  end
 
-end # class Pipeline
+end
diff --git a/lib/logstash/plugin.rb b/lib/logstash/plugin.rb
index 5723d7c3ddd..d3c1ad41a62 100644
--- a/lib/logstash/plugin.rb
+++ b/lib/logstash/plugin.rb
@@ -3,6 +3,8 @@
 require "logstash/logging"
 require "logstash/config/mixin"
 require "cabin"
+require "concurrent_ruby"
+
 
 class LogStash::Plugin
   attr_accessor :params
@@ -10,119 +12,115 @@ class LogStash::Plugin
 
   NL = "\n"
 
-  public
   def hash
-    params.hash ^
-    self.class.name.hash
+    params.hash ^ self.class.name.hash
   end
 
-  public
   def eql?(other)
     self.class.name == other.class.name && @params == other.params
   end
 
-  public
   def initialize(params=nil)
     @params = params
     @logger = Cabin::Channel.get(LogStash)
+    @stop_called = Concurrent::AtomicBoolean.new(false)
   end
 
-  # This method is called when someone or something wants this plugin to shut
-  # down. When you successfully shutdown, you must call 'finished'
-  # You must also call 'super' in any subclasses.
-  public
-  def shutdown(queue)
-    # By default, shutdown is assumed a no-op for all plugins.
-    # If you need to take special efforts to shutdown (like waiting for
-    # an operation to complete, etc)
-    teardown
-    @logger.info("Received shutdown signal", :plugin => self)
-
-    @shutdown_queue = queue
-    if @plugin_state == :finished
-      finished
-    else
-      @plugin_state = :terminating
-    end
-  end # def shutdown
-
-  # You should call this method when you (the plugin) are done with work
-  # forever.
-  public
-  def finished
-    # TODO(sissel): I'm not sure what I had planned for this shutdown_queue
-    # thing
-    if @shutdown_queue
-      @logger.info("Sending shutdown event to agent queue", :plugin => self)
-      @shutdown_queue << self
-    end
-
-    if @plugin_state != :finished
-      @logger.info("Plugin is finished", :plugin => self)
-      @plugin_state = :finished
-    end
-  end # def finished
-
-  # Subclasses should implement this teardown method if you need to perform any
-  # special tasks during shutdown (like flushing, etc.)
-  public
-  def teardown
-    # nothing by default
-    finished
+  # if you override stop, don't forgt to call super
+  def stop
+    @logger.debug("stopping", :plugin => self)
+    @stop_called.make_true
   end
 
-  # This method is called when a SIGHUP triggers a reload operation
-  public
-  def reload
-    # Do nothing by default
+  # stop? should never be overriden
+  def stop?
+    @stop_called.value
   end
 
-  public
-  def finished?
-    return @plugin_state == :finished
-  end # def finished?
-
-  public
-  def running?
-    return @plugin_state != :finished
-  end # def finished?
-
-  public
-  def terminating?
-    return @plugin_state == :terminating
-  end # def terminating?
-
-  public
-  def to_s
-    return "#{self.class.name}: #{@params}"
+  # if you override close, don't forgt to call super
+  def close
+    @logger.debug("closing", :plugin => self)
   end
 
-  protected
-  def update_watchdog(state)
-    Thread.current[:watchdog] = Time.now
-    Thread.current[:watchdog_state] = state
-  end
+  # # This method is called when someone or something wants this plugin to shut
+  # # down. When you successfully shutdown, you must call 'finished'
+  # # You must also call 'super' in any subclasses.
+  # public
+  # def shutdown(queue)
+  #   # By default, shutdown is assumed a no-op for all plugins.
+  #   # If you need to take special efforts to shutdown (like waiting for
+  #   # an operation to complete, etc)
+  #   teardown
+  #   @logger.info("Received shutdown signal", :plugin => self)
+
+  #   @shutdown_queue = queue
+  #   if @plugin_state == :finished
+  #     finished
+  #   else
+  #     @plugin_state = :terminating
+  #   end
+  # end # def shutdown
+
+  # # You should call this method when you (the plugin) are done with work
+  # # forever.
+  # public
+  # def finished
+  #   # TODO(sissel): I'm not sure what I had planned for this shutdown_queue
+  #   # thing
+  #   if @shutdown_queue
+  #     @logger.info("Sending shutdown event to agent queue", :plugin => self)
+  #     @shutdown_queue << self
+  #   end
+
+  #   if @plugin_state != :finished
+  #     @logger.info("Plugin is finished", :plugin => self)
+  #     @plugin_state = :finished
+  #   end
+  # end # def finished
+
+  # # Subclasses should implement this teardown method if you need to perform any
+  # # special tasks during shutdown (like flushing, etc.)
+  # public
+  # def teardown
+  #   # nothing by default
+  #   finished
+  # end
+
+  # # This method is called when a SIGHUP triggers a reload operation
+  # public
+  # def reload
+  #   # Do nothing by default
+  # end
+
+  # public
+  # def finished?
+  #   return @plugin_state == :finished
+  # end # def finished?
+
+  # public
+  # def running?
+  #   return @plugin_state != :finished
+  # end # def finished?
+
+  # public
+  # def terminating?
+  #   return @plugin_state == :terminating
+  # end # def terminating?
 
-  protected
-  def clear_watchdog
-    Thread.current[:watchdog] = nil
-    Thread.current[:watchdog_state] = nil
+  def to_s
+    "#{self.class.name}: #{@params}"
   end
 
-  public
   def inspect
-    if !@config.nil?
-      description = @config \
-        .select { |k,v| !v.nil? && (v.respond_to?(:empty?) && !v.empty?) } \
-        .collect { |k,v| "#{k}=>#{v.inspect}" }
-      return "<#{self.class.name} #{description.join(", ")}>"
-    else
-      return "<#{self.class.name} --->"
-    end
+    return "<#{self.class.name} --->" unless @config
+
+    description = @config \
+      .select { |k, v| v.respond_to?(:empty?) && !v.empty? } \
+      .map { |k, v| "#{k}=>#{v.inspect}" }
+    "<#{self.class.name} #{description.join(", ")}>"
   end
 
   # Look up a plugin by type and name.
-  public
   def self.lookup(type, name)
     path = "logstash/#{type}s/#{name}"
 
@@ -142,6 +140,18 @@ def self.lookup(type, name)
     raise(LogStash::PluginLoadingError, I18n.t("logstash.pipeline.plugin-loading-error", :type => type, :name => name, :path => path, :error => e.to_s))
   end
 
+  protected
+
+  def update_watchdog(state)
+    Thread.current[:watchdog] = Time.now
+    Thread.current[:watchdog_state] = state
+  end
+
+  def clear_watchdog
+    Thread.current[:watchdog] = nil
+    Thread.current[:watchdog_state] = nil
+  end
+
   private
 
   # lookup a plugin by type and name in the existing LogStash module namespace
diff --git a/logstash-core.gemspec b/logstash-core.gemspec
index 03c12988ead..3b15a5ff74c 100644
--- a/logstash-core.gemspec
+++ b/logstash-core.gemspec
@@ -20,8 +20,12 @@ Gem::Specification.new do |gem|
   gem.add_runtime_dependency "cabin", "~> 0.7.0" #(Apache 2.0 license)
   gem.add_runtime_dependency "pry", "~> 0.10.1" #(Ruby license)
   gem.add_runtime_dependency "stud", "~> 0.0.19" #(Apache 2.0 license)
-  gem.add_runtime_dependency "clamp", "~> 0.6.5" #(MIT license) for command line args/flags
-  gem.add_runtime_dependency "filesize", "0.0.4" #(MIT license) for :bytes config validator
+  # clamp for command line args/flags
+  gem.add_runtime_dependency "clamp", "~> 0.6.5" #(MIT license)
+  # filesize for :bytes config validator
+  gem.add_runtime_dependency "filesize", "0.0.4" #(MIT license)
+  gem.add_runtime_dependency "concurrent-ruby", "~> 0.8.0" #(MIT license)
+
 
   # TODO(sissel): Treetop 1.5.x doesn't seem to work well, but I haven't
   # investigated what the cause might be. -Jordan
