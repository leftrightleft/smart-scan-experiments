diff --git a/data/.gitkeep b/data/.gitkeep
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/logstash-core/benchmarks/src/main/java/org/logstash/benchmark/QueueRWBenchmark.java b/logstash-core/benchmarks/src/main/java/org/logstash/benchmark/QueueRWBenchmark.java
index 18ad9fa0387..a110d76af47 100644
--- a/logstash-core/benchmarks/src/main/java/org/logstash/benchmark/QueueRWBenchmark.java
+++ b/logstash-core/benchmarks/src/main/java/org/logstash/benchmark/QueueRWBenchmark.java
@@ -15,10 +15,8 @@
 import org.logstash.ackedqueue.Queueable;
 import org.logstash.ackedqueue.Settings;
 import org.logstash.ackedqueue.SettingsImpl;
-import org.logstash.ackedqueue.io.ByteBufferPageIO;
 import org.logstash.ackedqueue.io.CheckpointIOFactory;
 import org.logstash.ackedqueue.io.FileCheckpointIO;
-import org.logstash.ackedqueue.io.MemoryCheckpointIO;
 import org.logstash.ackedqueue.io.MmapPageIO;
 import org.logstash.ackedqueue.io.PageIOFactory;
 import org.openjdk.jmh.annotations.Benchmark;
@@ -44,7 +42,7 @@
 public class QueueRWBenchmark {
 
     private static final int EVENTS_PER_INVOCATION = 500_000;
-    
+
     private static final int BATCH_SIZE = 100;
 
     private static final int ACK_INTERVAL = 1024;
@@ -54,16 +52,14 @@ public class QueueRWBenchmark {
     private ArrayBlockingQueue<Event> queueArrayBlocking;
 
     private Queue queuePersisted;
-    
-    private Queue queueMemory;
 
     private String path;
-    
+
     private ExecutorService exec;
 
     @Setup
     public void setUp() throws IOException {
-        final Settings settingsPersisted = settings(true);
+        final Settings settingsPersisted = settings();
         EVENT.setField("Foo", "Bar");
         EVENT.setField("Foo1", "Bar1");
         EVENT.setField("Foo2", "Bar2");
@@ -72,16 +68,13 @@ public void setUp() throws IOException {
         path = settingsPersisted.getDirPath();
         queuePersisted = new Queue(settingsPersisted);
         queueArrayBlocking = new ArrayBlockingQueue<>(ACK_INTERVAL);
-        queueMemory = new Queue(settings(false));
         queuePersisted.open();
-        queueMemory.open();
         exec = Executors.newSingleThreadExecutor();
     }
 
     @TearDown
     public void tearDown() throws IOException {
         queuePersisted.close();
-        queueMemory.close();
         queueArrayBlocking.clear();
         FileUtils.deleteDirectory(new File(path));
         exec.shutdownNow();
@@ -109,28 +102,6 @@ public final void readFromPersistedQueue(final Blackhole blackhole) throws Excep
         future.get();
     }
 
-    @Benchmark
-    @OperationsPerInvocation(EVENTS_PER_INVOCATION)
-    public final void readFromMemoryQueue(final Blackhole blackhole) throws Exception {
-        final Future<?> future = exec.submit(() -> {
-            for (int i = 0; i < EVENTS_PER_INVOCATION; ++i) {
-                try {
-                    this.queueMemory.write(EVENT);
-                } catch (final IOException ex) {
-                    throw new IllegalStateException(ex);
-                }
-            }
-        });
-        for (int i = 0; i < EVENTS_PER_INVOCATION / BATCH_SIZE; ++i) {
-            try (Batch batch = queueMemory.readBatch(BATCH_SIZE, TimeUnit.SECONDS.toMillis(1))) {
-                for (final Queueable elem : batch.getElements()) {
-                    blackhole.consume(elem);
-                }
-            }
-        }
-        future.get();
-    }
-
     @Benchmark
     @OperationsPerInvocation(EVENTS_PER_INVOCATION)
     public final void readFromArrayBlockingQueue(final Blackhole blackhole) throws Exception {
@@ -149,16 +120,11 @@ public final void readFromArrayBlockingQueue(final Blackhole blackhole) throws E
         future.get();
     }
 
-    private static Settings settings(final boolean persisted) {
+    private static Settings settings() {
         final PageIOFactory pageIOFactory;
         final CheckpointIOFactory checkpointIOFactory;
-        if (persisted) {
-            pageIOFactory = MmapPageIO::new;
-            checkpointIOFactory = FileCheckpointIO::new;
-        } else {
-            pageIOFactory = ByteBufferPageIO::new;
-            checkpointIOFactory = MemoryCheckpointIO::new;
-        }
+        pageIOFactory = MmapPageIO::new;
+        checkpointIOFactory = FileCheckpointIO::new;
         return SettingsImpl.fileSettingsBuilder(Files.createTempDir().getPath())
             .capacity(256 * 1024 * 1024)
             .queueMaxBytes(Long.MAX_VALUE)
diff --git a/logstash-core/lib/logstash/environment.rb b/logstash-core/lib/logstash/environment.rb
index a40803bbc3a..6df963949ab 100644
--- a/logstash-core/lib/logstash/environment.rb
+++ b/logstash-core/lib/logstash/environment.rb
@@ -53,7 +53,7 @@ module Environment
             Setting::String.new("http.host", "127.0.0.1"),
             Setting::PortRange.new("http.port", 9600..9700),
             Setting::String.new("http.environment", "production"),
-            Setting::String.new("queue.type", "memory", true, ["persisted", "memory", "memory_acked"]),
+            Setting::String.new("queue.type", "memory", true, ["persisted", "memory"]),
             Setting::Boolean.new("queue.drain", false),
             Setting::Bytes.new("queue.page_capacity", "64mb"),
             Setting::Bytes.new("queue.max_bytes", "1024mb"),
diff --git a/logstash-core/lib/logstash/queue_factory.rb b/logstash-core/lib/logstash/queue_factory.rb
index beb2d8794cc..b261b25f512 100644
--- a/logstash-core/lib/logstash/queue_factory.rb
+++ b/logstash-core/lib/logstash/queue_factory.rb
@@ -18,10 +18,6 @@ def self.create(settings)
       queue_path = ::File.join(settings.get("path.queue"), settings.get("pipeline.id"))
 
       case queue_type
-      when "memory_acked"
-        # memory_acked is used in tests/specs
-        FileUtils.mkdir_p(queue_path)
-        LogStash::Util::WrappedAckedQueue.create_memory_based(queue_path, queue_page_capacity, queue_max_events, queue_max_bytes)
       when "persisted"
         # persisted is the disk based acked queue
         FileUtils.mkdir_p(queue_path)
@@ -32,7 +28,7 @@ def self.create(settings)
           settings.get("pipeline.batch.size") * settings.get("pipeline.workers") * 2
         )
       else
-        raise ConfigurationError, "Invalid setting `#{queue_type}` for `queue.type`, supported types are: 'memory_acked', 'memory', 'persisted'"
+        raise ConfigurationError, "Invalid setting `#{queue_type}` for `queue.type`, supported types are: 'memory' or 'persisted'"
       end
     end
   end
diff --git a/logstash-core/lib/logstash/util/wrapped_acked_queue.rb b/logstash-core/lib/logstash/util/wrapped_acked_queue.rb
index 3f173344ff4..5415e145053 100644
--- a/logstash-core/lib/logstash/util/wrapped_acked_queue.rb
+++ b/logstash-core/lib/logstash/util/wrapped_acked_queue.rb
@@ -18,12 +18,6 @@ class WrappedAckedQueue
     class QueueClosedError < ::StandardError; end
     class NotImplementedError < ::StandardError; end
 
-    def self.create_memory_based(path, capacity, max_events, max_bytes)
-      self.allocate.with_queue(
-        LogStash::AckedMemoryQueue.new(path, capacity, max_events, max_bytes)
-      )
-    end
-
     def self.create_file_based(path, capacity, max_events, checkpoint_max_writes, checkpoint_max_acks, checkpoint_max_interval, max_bytes)
       self.allocate.with_queue(
         LogStash::AckedQueue.new(path, capacity, max_events, checkpoint_max_writes, checkpoint_max_acks, checkpoint_max_interval, max_bytes)
diff --git a/logstash-core/spec/logstash/instrument/wrapped_write_client_spec.rb b/logstash-core/spec/logstash/instrument/wrapped_write_client_spec.rb
index fc4ff705eda..9333a6f644c 100644
--- a/logstash-core/spec/logstash/instrument/wrapped_write_client_spec.rb
+++ b/logstash-core/spec/logstash/instrument/wrapped_write_client_spec.rb
@@ -107,8 +107,9 @@ def threaded_read_client
     include_examples "queue tests"
   end
 
-  context "AckedMemoryQueue" do
-    let(:queue) { LogStash::Util::WrappedAckedQueue.create_memory_based("", 1024, 10, 4096) }
+  context "WrappedAckedQueue" do
+    let(:path) { Stud::Temporary.directory }
+    let(:queue) { LogStash::Util::WrappedAckedQueue.create_file_based(path, 1024, 10, 1024, 1024, 1024, 4096) }
 
     before do
       read_client.set_events_metric(metric.namespace([:stats, :events]))
diff --git a/logstash-core/spec/logstash/queue_factory_spec.rb b/logstash-core/spec/logstash/queue_factory_spec.rb
index f2d97d93b22..e80e1836b41 100644
--- a/logstash-core/spec/logstash/queue_factory_spec.rb
+++ b/logstash-core/spec/logstash/queue_factory_spec.rb
@@ -8,7 +8,7 @@
   let(:settings_array) do
     [
       LogStash::Setting::WritableDirectory.new("path.queue", Stud::Temporary.pathname),
-      LogStash::Setting::String.new("queue.type", "memory", true, ["persisted", "memory", "memory_acked"]),
+      LogStash::Setting::String.new("queue.type", "memory", true, ["persisted", "memory"]),
       LogStash::Setting::Bytes.new("queue.page_capacity", "64mb"),
       LogStash::Setting::Bytes.new("queue.max_bytes", "1024mb"),
       LogStash::Setting::Numeric.new("queue.max_events", 0),
@@ -59,18 +59,6 @@
     end
   end
 
-  context "when `queue.type` is `memory_acked`" do
-    before do
-      settings.set("queue.type", "memory_acked")
-    end
-
-    it "returns a `WrappedAckedQueue`" do
-      queue =  subject.create(settings)
-      expect(queue).to be_kind_of(LogStash::Util::WrappedAckedQueue)
-      queue.close
-    end
-  end
-
   context "when `queue.type` is `memory`" do
     before do
       settings.set("queue.type", "memory")
diff --git a/logstash-core/spec/logstash/util/wrapped_acked_queue_spec.rb b/logstash-core/spec/logstash/util/wrapped_acked_queue_spec.rb
index 6d2d2794674..3a12c743c8c 100644
--- a/logstash-core/spec/logstash/util/wrapped_acked_queue_spec.rb
+++ b/logstash-core/spec/logstash/util/wrapped_acked_queue_spec.rb
@@ -30,20 +30,6 @@
     end
   end
 
-  context "memory" do
-    let(:page_capacity) { 1024 }
-    let(:max_events) { 0 }
-    let(:max_bytes) { 0 }
-    let(:path) { Stud::Temporary.directory }
-    let(:queue) { LogStash::Util::WrappedAckedQueue.create_memory_based(path, page_capacity, max_events, max_bytes) }
-
-    after do
-      queue.close
-    end
-
-    include_examples "queue tests"
-  end
-
   context "persisted" do
     let(:page_capacity) { 1024 }
     let(:max_events) { 0 }
diff --git a/logstash-core/src/main/java/org/logstash/RubyUtil.java b/logstash-core/src/main/java/org/logstash/RubyUtil.java
index 6b98449ae11..27ada7b6d11 100644
--- a/logstash-core/src/main/java/org/logstash/RubyUtil.java
+++ b/logstash-core/src/main/java/org/logstash/RubyUtil.java
@@ -114,10 +114,6 @@ public final class RubyUtil {
             abstractQueue, AbstractJRubyQueue.RubyAckedQueue::new,
             AbstractJRubyQueue.RubyAckedQueue.class
         );
-        setupLogstashClass(
-            abstractQueue, AbstractJRubyQueue.RubyAckedMemoryQueue::new,
-            AbstractJRubyQueue.RubyAckedMemoryQueue.class
-        );
         RUBY.getGlobalVariables().set("$LS_JARS_LOADED", RUBY.newString("true"));
     }
 
diff --git a/logstash-core/src/main/java/org/logstash/ackedqueue/SettingsImpl.java b/logstash-core/src/main/java/org/logstash/ackedqueue/SettingsImpl.java
index 0ebcf8aad58..9c742788fb1 100644
--- a/logstash-core/src/main/java/org/logstash/ackedqueue/SettingsImpl.java
+++ b/logstash-core/src/main/java/org/logstash/ackedqueue/SettingsImpl.java
@@ -27,15 +27,6 @@ public static Builder fileSettingsBuilder(final String dirForFiles) {
         return new BuilderImpl(dirForFiles);
     }
 
-    public static Builder memorySettingsBuilder() {
-        return memorySettingsBuilder("");
-    }
-
-    public static Builder memorySettingsBuilder(final String dirForFiles) {
-        return new BuilderImpl(dirForFiles).checkpointMaxAcks(1)
-            .checkpointMaxWrites(1);
-    }
-
     private SettingsImpl(final String dirForFiles, final CheckpointIOFactory checkpointIOFactory,
         final PageIOFactory pageIOFactory, final Class<? extends Queueable> elementClass,
         final int capacity, final long queueMaxBytes, final int maxUnread,
@@ -60,7 +51,7 @@ public int getCheckpointMaxAcks() {
     public int getCheckpointMaxWrites() {
         return checkpointMaxWrites;
     }
-    
+
     @Override
     public CheckpointIOFactory getCheckpointIOFactory() {
         return checkpointIOFactory;
@@ -96,7 +87,7 @@ public int getMaxUnread() {
     }
 
     private static final class BuilderImpl implements Builder {
-        
+
         /**
          * The default Queue has a capacity of 0 events, meaning infinite capacity.
          * todo: Remove the ability to set infinite capacity.
@@ -124,7 +115,7 @@ private static final class BuilderImpl implements Builder {
          * Default number of acknowledgements after which we checkpoint.
          */
         private static final int DEFAULT_CHECKPOINT_MAX_WRITES = 1024;
-        
+
         private final String dirForFiles;
 
         private final CheckpointIOFactory checkpointIOFactory;
@@ -142,7 +133,7 @@ private static final class BuilderImpl implements Builder {
         private final int checkpointMaxAcks;
 
         private final int checkpointMaxWrites;
-        
+
         private BuilderImpl(final String dirForFiles) {
             this(dirForFiles, null, null, null, DEFAULT_CAPACITY, DEFAULT_MAX_QUEUE_BYTES,
                 DEFAULT_MAX_UNREAD, DEFAULT_CHECKPOINT_MAX_ACKS, DEFAULT_CHECKPOINT_MAX_WRITES
diff --git a/logstash-core/src/main/java/org/logstash/ackedqueue/ext/AbstractJRubyQueue.java b/logstash-core/src/main/java/org/logstash/ackedqueue/ext/AbstractJRubyQueue.java
index 200be51d343..b4e7c3c2d46 100644
--- a/logstash-core/src/main/java/org/logstash/ackedqueue/ext/AbstractJRubyQueue.java
+++ b/logstash-core/src/main/java/org/logstash/ackedqueue/ext/AbstractJRubyQueue.java
@@ -16,9 +16,7 @@
 import org.logstash.ackedqueue.Batch;
 import org.logstash.ackedqueue.Queue;
 import org.logstash.ackedqueue.SettingsImpl;
-import org.logstash.ackedqueue.io.ByteBufferPageIO;
 import org.logstash.ackedqueue.io.FileCheckpointIO;
-import org.logstash.ackedqueue.io.MemoryCheckpointIO;
 import org.logstash.ackedqueue.io.MmapPageIO;
 import org.logstash.ext.JrubyEventExtLibrary;
 
@@ -140,44 +138,6 @@ public IRubyObject ruby_close(ThreadContext context) {
         return context.nil;
     }
 
-    @JRubyClass(name = "AckedMemoryQueue", parent = "AbstractAckedQueue")
-    public static final class RubyAckedMemoryQueue extends AbstractJRubyQueue {
-
-        private static final long serialVersionUID = 1L;
-
-        public RubyAckedMemoryQueue(Ruby runtime, RubyClass klass) {
-            super(runtime, klass);
-        }
-
-        @JRubyMethod(name = "initialize", optional = 4)
-        public IRubyObject ruby_initialize(ThreadContext context, IRubyObject[] args)
-        {
-            args = Arity.scanArgs(context.runtime, args, 4, 0);
-
-            int capacity = RubyFixnum.num2int(args[1]);
-            int maxUnread = RubyFixnum.num2int(args[2]);
-            long queueMaxBytes = RubyFixnum.num2long(args[3]);
-            this.queue = new Queue(
-                SettingsImpl.memorySettingsBuilder(args[0].asJavaString())
-                    .capacity(capacity)
-                    .maxUnread(maxUnread)
-                    .queueMaxBytes(queueMaxBytes)
-                    .elementIOFactory(ByteBufferPageIO::new)
-                    .checkpointIOFactory(MemoryCheckpointIO::new)
-                    .elementClass(Event.class)
-                    .build()
-            );
-            return context.nil;
-        }
-
-        @JRubyMethod(name = "open")
-        @Override
-        public IRubyObject ruby_open(ThreadContext context) {
-            this.queue.getCheckpointIO().purge();
-            return super.ruby_open(context);
-        }
-    }
-
     @JRubyClass(name = "AckedQueue", parent = "AbstractAckedQueue")
     public static final class RubyAckedQueue extends AbstractJRubyQueue {
 
diff --git a/logstash-core/src/main/java/org/logstash/ackedqueue/io/ByteBufferPageIO.java b/logstash-core/src/main/java/org/logstash/ackedqueue/io/ByteBufferPageIO.java
deleted file mode 100644
index 991a20b4707..00000000000
--- a/logstash-core/src/main/java/org/logstash/ackedqueue/io/ByteBufferPageIO.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.logstash.ackedqueue.io;
-
-import java.nio.ByteBuffer;
-
-public class ByteBufferPageIO extends AbstractByteBufferPageIO {
-
-    private final ByteBuffer buffer;
-
-    public ByteBufferPageIO(int pageNum, int capacity, String path) {
-        this(capacity, new byte[0]);
-    }
-
-    public ByteBufferPageIO(int capacity) {
-        this(capacity, new byte[0]);
-    }
-
-    public ByteBufferPageIO(int capacity, byte[] initialBytes) {
-        super(0, capacity);
-
-        if (initialBytes.length > capacity) {
-            throw new IllegalArgumentException("initial bytes greater than capacity");
-        }
-
-        this.buffer = ByteBuffer.allocate(capacity);
-        this.buffer.put(initialBytes);
-    }
-
-    @Override
-    public void deactivate() { /* nothing */ }
-
-    @Override
-    public void activate() { /* nyet */ }
-
-    @Override
-    public void ensurePersisted() { /* nada */ }
-
-    @Override
-    public void purge() { /* zilch */ }
-
-    @Override
-    public void close() { /* don't look here */ }
-
-
-    @Override
-    protected ByteBuffer getBuffer() { return this.buffer; }
-
-    // below public methods only used by tests
-
-    public int getWritePosition() { return this.head; }
-
-    public byte[] dump() { return this.buffer.array(); }
-}
diff --git a/logstash-core/src/main/java/org/logstash/ackedqueue/io/MemoryCheckpointIO.java b/logstash-core/src/main/java/org/logstash/ackedqueue/io/MemoryCheckpointIO.java
deleted file mode 100644
index 4b6946bbf02..00000000000
--- a/logstash-core/src/main/java/org/logstash/ackedqueue/io/MemoryCheckpointIO.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package org.logstash.ackedqueue.io;
-
-import org.logstash.ackedqueue.Checkpoint;
-
-import java.io.IOException;
-import java.nio.file.NoSuchFileException;
-import java.util.HashMap;
-import java.util.Map;
-
-public class MemoryCheckpointIO implements CheckpointIO {
-
-    private static final String HEAD_CHECKPOINT = "checkpoint.head";
-    private static final String TAIL_CHECKPOINT = "checkpoint.";
-
-    private static final Map<String, Map<String, Checkpoint>> sources = new HashMap<>();
-
-    private final String dirPath;
-
-    public static void clearSources() {
-        sources.clear();
-    }
-
-    public MemoryCheckpointIO(String dirPath) {
-        this.dirPath = dirPath;
-    }
-
-    @Override
-    public Checkpoint read(String fileName) throws IOException {
-
-        Checkpoint cp = null;
-        Map<String, Checkpoint> ns = sources.get(dirPath);
-        if (ns != null) {
-           cp = ns.get(fileName);
-        }
-        if (cp == null) { throw new NoSuchFileException("no memory checkpoint for dirPath: " + this.dirPath + ", fileName: " + fileName); }
-        return cp;
-    }
-
-    @Override
-    public Checkpoint write(String fileName, int pageNum, int firstUnackedPageNum, long firstUnackedSeqNum, long minSeqNum, int elementCount) {
-        Checkpoint checkpoint = new Checkpoint(pageNum, firstUnackedPageNum, firstUnackedSeqNum, minSeqNum, elementCount);
-        write(fileName, checkpoint);
-        return checkpoint;
-    }
-
-    @Override
-    public void write(String fileName, Checkpoint checkpoint) {
-        Map<String, Checkpoint> ns = sources.get(dirPath);
-        if (ns == null) {
-            ns = new HashMap<>();
-            sources.put(this.dirPath, ns);
-        }
-        ns.put(fileName, checkpoint);
-    }
-
-    @Override
-    public void purge(String fileName) {
-        Map<String, Checkpoint> ns = sources.get(dirPath);
-        if (ns != null) {
-           ns.remove(fileName);
-        }
-    }
-
-    @Override
-    public void purge() {
-        sources.remove(this.dirPath);
-    }
-
-    // @return the head page checkpoint file name
-    @Override
-    public String headFileName() {
-        return HEAD_CHECKPOINT;
-    }
-
-    // @return the tail page checkpoint file name for given page number
-    @Override
-    public String tailFileName(int pageNum) {
-        return TAIL_CHECKPOINT + pageNum;
-    }
-
-}
diff --git a/logstash-core/src/test/java/org/logstash/ackedqueue/HeadPageTest.java b/logstash-core/src/test/java/org/logstash/ackedqueue/HeadPageTest.java
index c29d100fda7..8f92fc4ba69 100644
--- a/logstash-core/src/test/java/org/logstash/ackedqueue/HeadPageTest.java
+++ b/logstash-core/src/test/java/org/logstash/ackedqueue/HeadPageTest.java
@@ -2,8 +2,10 @@
 
 import java.io.IOException;
 import java.util.concurrent.TimeUnit;
-
+import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 import org.logstash.ackedqueue.io.PageIO;
 
 import static org.hamcrest.CoreMatchers.equalTo;
@@ -13,13 +15,24 @@
 
 public class HeadPageTest {
 
+    @Rule
+    public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+    private String dataPath;
+
+    @Before
+    public void setUp() throws Exception {
+        dataPath = temporaryFolder.newFolder("data").getPath();
+    }
+
     @Test
     public void newHeadPage() throws IOException {
-        Settings s = TestSettings.volatileQueueSettings(100);
+        Settings s = TestSettings.persistedQueueSettings(100, dataPath);
         // Close method on Page requires an instance of Queue that has already been opened.
         try (Queue q = new Queue(s)) {
             q.open();
-            PageIO pageIO = s.getPageIOFactory().build(0, 100, "dummy");
+            PageIO pageIO = s.getPageIOFactory()
+                .build(0, 100, dataPath);
             pageIO.create();
             try (final Page p = PageFactory.newHeadPage(0, q, pageIO)) {
                 assertThat(p.getPageNum(), is(equalTo(0)));
@@ -35,7 +48,9 @@ public void newHeadPage() throws IOException {
     public void pageWrite() throws IOException {
         Queueable element = new StringElement("foobarbaz");
 
-        Settings s = TestSettings.volatileQueueSettings(singleElementCapacityForByteBufferPageIO(element));
+        Settings s = TestSettings.persistedQueueSettings(
+            singleElementCapacityForByteBufferPageIO(element), dataPath
+        );
         try(Queue q = new Queue(s)) {
             q.open();
             Page p = q.headPage;
@@ -55,7 +70,7 @@ public void pageWriteAndReadSingle() throws IOException {
         Queueable element = new StringElement("foobarbaz");
         int singleElementCapacity = singleElementCapacityForByteBufferPageIO(element);
 
-        Settings s = TestSettings.volatileQueueSettings(singleElementCapacity);
+        Settings s = TestSettings.persistedQueueSettings(singleElementCapacity, dataPath);
         try(Queue q = new Queue(s)) {
             q.open();
             Page p = q.headPage;
@@ -78,7 +93,7 @@ public void pageWriteAndReadSingle() throws IOException {
     public void inEmpty() throws IOException {
         Queueable element = new StringElement("foobarbaz");
 
-        Settings s = TestSettings.volatileQueueSettings(1000);
+        Settings s = TestSettings.persistedQueueSettings(1000, dataPath);
         try(Queue q = new Queue(s)) {
             q.open();
             Page p = q.headPage;
@@ -98,7 +113,9 @@ public void pageWriteAndReadMulti() throws IOException {
         long seqNum = 1L;
         Queueable element = new StringElement("foobarbaz");
 
-        Settings s = TestSettings.volatileQueueSettings(singleElementCapacityForByteBufferPageIO(element));
+        Settings s = TestSettings.persistedQueueSettings(
+            singleElementCapacityForByteBufferPageIO(element), dataPath
+        );
         try(Queue q = new Queue(s)) {
             q.open();
             Page p = q.headPage;
diff --git a/logstash-core/src/test/java/org/logstash/ackedqueue/QueueTest.java b/logstash-core/src/test/java/org/logstash/ackedqueue/QueueTest.java
index 0a9ceb3a736..3e3d6f19413 100644
--- a/logstash-core/src/test/java/org/logstash/ackedqueue/QueueTest.java
+++ b/logstash-core/src/test/java/org/logstash/ackedqueue/QueueTest.java
@@ -59,7 +59,7 @@ public void tearDown() throws Exception {
 
     @Test
     public void newQueue() throws IOException {
-        try (Queue q = new Queue(TestSettings.volatileQueueSettings(10))) {
+        try (Queue q = new Queue(TestSettings.persistedQueueSettings(10, dataPath))) {
             q.open();
 
             assertThat(q.nonBlockReadBatch(1), nullValue());
@@ -68,7 +68,7 @@ public void newQueue() throws IOException {
 
     @Test
     public void singleWriteRead() throws IOException {
-        try (Queue q = new Queue(TestSettings.volatileQueueSettings(100))) {
+        try (Queue q = new Queue(TestSettings.persistedQueueSettings(100, dataPath))) {
             q.open();
 
             Queueable element = new StringElement("foobarbaz");
@@ -94,7 +94,7 @@ public void writeToFullyAckedHeadpage() throws IOException {
         final int page = element.serialize().length * 2 + AbstractByteBufferPageIO.MIN_CAPACITY;
         // Queue that can only hold one element per page.
         try (Queue q = new Queue(
-            TestSettings.volatileQueueSettings(page, page * 2 - 1))) {
+            TestSettings.persistedQueueSettings(page, page * 2 - 1, dataPath))) {
             q.open();
             for (int i = 0; i < 5; ++i) {
                 q.write(element);
@@ -117,7 +117,7 @@ public void writeWhenPageEqualsQueueSize() throws IOException {
         final Queueable element = new StringElement("foobarbaz");
         // Queue that can only hold one element per page.
         try (Queue q = new Queue(
-            TestSettings.volatileQueueSettings(1024, 1024L))) {
+            TestSettings.persistedQueueSettings(1024, 1024L, dataPath))) {
             q.open();
             for (int i = 0; i < 3; ++i) {
                 q.write(element);
@@ -132,7 +132,7 @@ public void writeWhenPageEqualsQueueSize() throws IOException {
 
     @Test
     public void singleWriteMultiRead() throws IOException {
-        try (Queue q = new Queue(TestSettings.volatileQueueSettings(100))) {
+        try (Queue q = new Queue(TestSettings.persistedQueueSettings(100, dataPath))) {
             q.open();
 
             Queueable element = new StringElement("foobarbaz");
@@ -148,7 +148,7 @@ public void singleWriteMultiRead() throws IOException {
 
     @Test
     public void multiWriteSamePage() throws IOException {
-        try (Queue q = new Queue(TestSettings.volatileQueueSettings(100))) {
+        try (Queue q = new Queue(TestSettings.persistedQueueSettings(100, dataPath))) {
             q.open();
             List<Queueable> elements = Arrays
                 .asList(new StringElement("foobarbaz1"), new StringElement("foobarbaz2"),
@@ -176,7 +176,7 @@ public void writeMultiPage() throws IOException {
         List<Queueable> elements = Arrays.asList(new StringElement("foobarbaz1"), new StringElement("foobarbaz2"), new StringElement("foobarbaz3"), new StringElement("foobarbaz4"));
         int singleElementCapacity = singleElementCapacityForByteBufferPageIO(elements.get(0));
         try (Queue q = new Queue(
-            TestSettings.volatileQueueSettings(2 * singleElementCapacity))) {
+            TestSettings.persistedQueueSettings(2 * singleElementCapacity, dataPath))) {
             q.open();
 
             for (Queueable e : elements) {
@@ -220,7 +220,7 @@ public void writeMultiPageWithInOrderAcking() throws IOException {
         List<Queueable> elements = Arrays.asList(new StringElement("foobarbaz1"), new StringElement("foobarbaz2"), new StringElement("foobarbaz3"), new StringElement("foobarbaz4"));
         int singleElementCapacity = singleElementCapacityForByteBufferPageIO(elements.get(0));
         try (Queue q = new Queue(
-            TestSettings.volatileQueueSettings(2 * singleElementCapacity))) {
+            TestSettings.persistedQueueSettings(2 * singleElementCapacity, dataPath))) {
             q.open();
 
             for (Queueable e : elements) {
@@ -263,7 +263,7 @@ public void writeMultiPageWithInOrderAckingCheckpoints() throws IOException {
         int singleElementCapacity = singleElementCapacityForByteBufferPageIO(elements1.get(0));
 
         Settings settings = SettingsImpl.builder(
-            TestSettings.volatileQueueSettings(2 * singleElementCapacity)
+            TestSettings.persistedQueueSettings(2 * singleElementCapacity, dataPath)
         ).checkpointMaxWrites(1024) // arbitrary high enough threshold so that it's not reached (default for TestSettings is 1)
         .build();
         try (Queue q = new Queue(settings)) {
@@ -350,7 +350,7 @@ public void randomAcking() throws IOException {
 
         // 10 tests of random queue sizes
         for (int loop = 0; loop < 10; loop++) {
-            int page_count = random.nextInt(10000) + 1;
+            int page_count = random.nextInt(100) + 1;
 
             // String format call below needs to at least print one digit
             final int digits = Math.max((int) Math.ceil(Math.log10(page_count)), 1);
@@ -362,7 +362,7 @@ public void randomAcking() throws IOException {
             }
             int singleElementCapacity = singleElementCapacityForByteBufferPageIO(elements.get(0));
             try (Queue q = new Queue(
-                TestSettings.volatileQueueSettings(singleElementCapacity))) {
+                TestSettings.persistedQueueSettings(singleElementCapacity, dataPath))) {
                 q.open();
 
                 for (Queueable e : elements) {
@@ -383,24 +383,24 @@ public void randomAcking() throws IOException {
                 for (Batch b : batches) {
                     b.close();
                 }
-                
+
                 assertThat(q.tailPages.size(), is(0));
             }
         }
     }
 
-    @Test(timeout = 5000)
+    @Test(timeout = 50_000)
     public void reachMaxUnread() throws IOException, InterruptedException, ExecutionException {
         Queueable element = new StringElement("foobarbaz");
         int singleElementCapacity = singleElementCapacityForByteBufferPageIO(element);
 
         Settings settings = SettingsImpl.builder(
-            TestSettings.volatileQueueSettings(singleElementCapacity)
+            TestSettings.persistedQueueSettings(singleElementCapacity, dataPath)
         ).maxUnread(2) // 2 so we know the first write should not block and the second should
         .build();
         try (Queue q = new Queue(settings)) {
             q.open();
-            
+
             long seqNum = q.write(element);
             assertThat(seqNum, is(1L));
             assertThat(q.isFull(), is(false));
@@ -438,7 +438,7 @@ public void reachMaxUnreadWithAcking() throws IOException, InterruptedException,
 
         // TODO: add randomized testing on the page size (but must be > single element size)
         Settings settings = SettingsImpl.builder(
-            TestSettings.volatileQueueSettings(256) // 256 is arbitrary, large enough to hold a few elements
+            TestSettings.persistedQueueSettings(256, dataPath) // 256 is arbitrary, large enough to hold a few elements
         ).maxUnread(2)
         .build(); // 2 so we know the first write should not block and the second should
         try (Queue q = new Queue(settings)) {
@@ -481,14 +481,16 @@ public void reachMaxUnreadWithAcking() throws IOException, InterruptedException,
         }
     }
 
-    @Test(timeout = 5000)
+    @Test(timeout = 50_000)
     public void reachMaxSizeTest() throws IOException, InterruptedException {
         Queueable element = new StringElement("0123456789"); // 10 bytes
 
         int singleElementCapacity = singleElementCapacityForByteBufferPageIO(element);
 
         // allow 10 elements per page but only 100 events in total
-        Settings settings = TestSettings.volatileQueueSettings(singleElementCapacity * 10, singleElementCapacity * 100);
+        Settings settings = TestSettings.persistedQueueSettings(
+            singleElementCapacity * 10, singleElementCapacity * 100L, dataPath
+        );
         try (Queue q = new Queue(settings)) {
             q.open();
 
@@ -508,7 +510,7 @@ public void reachMaxSizeTest() throws IOException, InterruptedException {
         }
     }
 
-    @Test(timeout = 5000)
+    @Test(timeout = 50_000)
     public void ackingMakesQueueNotFullAgainTest() throws IOException, InterruptedException, ExecutionException {
 
         Queueable element = new StringElement("0123456789"); // 10 bytes
@@ -516,7 +518,9 @@ public void ackingMakesQueueNotFullAgainTest() throws IOException, InterruptedEx
         int singleElementCapacity = singleElementCapacityForByteBufferPageIO(element);
 
         // allow 10 elements per page but only 100 events in total
-        Settings settings = TestSettings.volatileQueueSettings(singleElementCapacity * 10, singleElementCapacity * 100);
+        Settings settings = TestSettings.persistedQueueSettings(
+            singleElementCapacity * 10, singleElementCapacity * 100L, dataPath
+        );
         try (Queue q = new Queue(settings)) {
             q.open();
             // should be able to write 90 + 9 events (9 pages + 1 head-page) before getting full
@@ -525,39 +529,41 @@ public void ackingMakesQueueNotFullAgainTest() throws IOException, InterruptedEx
                 q.write(element);
             }
             assertThat(q.isFull(), is(false));
-            
+
             // we expect this next write call to block so let's wrap it in a Future
             Future<Long> future = executor.submit(() -> q.write(element));
             assertThat(future.isDone(), is(false));
-            
+
             while (!q.isFull()) {
                 Thread.sleep(10);
             }
             assertThat(q.isFull(), is(true));
-            
+
             Batch b = q.readBatch(10, TimeUnit.SECONDS.toMillis(1)); // read 1 page (10 events)
             b.close();  // purge 1 page
-            
+
             while (q.isFull()) { Thread.sleep(10); }
             assertThat(q.isFull(), is(false));
-            
+
             assertThat(future.get(), is(elementCount + 1));
         }
     }
 
-    @Test(timeout = 5000)
+    @Test(timeout = 50_000)
     public void resumeWriteOnNoLongerFullQueueTest() throws IOException, InterruptedException, ExecutionException {
         Queueable element = new StringElement("0123456789"); // 10 bytes
 
         int singleElementCapacity = singleElementCapacityForByteBufferPageIO(element);
 
         // allow 10 elements per page but only 100 events in total
-        Settings settings = TestSettings.volatileQueueSettings(singleElementCapacity * 10, singleElementCapacity * 100);
+        Settings settings = TestSettings.persistedQueueSettings(
+            singleElementCapacity * 10, singleElementCapacity * 100L, dataPath
+        );
         try (Queue q = new Queue(settings)) {
             q.open();
             // should be able to write 90 + 9 events (9 pages + 1 head-page) before getting full
             int elementCount = 99;
-            for (int i = 0; i < elementCount; i++) { 
+            for (int i = 0; i < elementCount; i++) {
                 q.write(element);
             }
 
@@ -582,7 +588,7 @@ public void resumeWriteOnNoLongerFullQueueTest() throws IOException, Interrupted
         }
     }
 
-    @Test(timeout = 5000)
+    @Test(timeout = 50_000)
     public void queueStillFullAfterPartialPageAckTest() throws IOException, InterruptedException {
 
         Queueable element = new StringElement("0123456789"); // 10 bytes
@@ -590,7 +596,9 @@ public void queueStillFullAfterPartialPageAckTest() throws IOException, Interrup
         int singleElementCapacity = singleElementCapacityForByteBufferPageIO(element);
 
         // allow 10 elements per page but only 100 events in total
-        Settings settings = TestSettings.volatileQueueSettings(singleElementCapacity * 10, singleElementCapacity * 100);
+        Settings settings = TestSettings.persistedQueueSettings(
+            singleElementCapacity * 10, singleElementCapacity * 100L, dataPath
+        );
         try (Queue q = new Queue(settings)) {
             q.open();
 
@@ -619,7 +627,7 @@ public void queueStillFullAfterPartialPageAckTest() throws IOException, Interrup
     public void queueStableUnderStressHugeCapacity() throws Exception {
         stableUnderStress(100_000);
     }
-    
+
     @Test
     public void queueStableUnderStressLowCapacity() throws Exception {
         stableUnderStress(50);
@@ -682,18 +690,18 @@ public void testAckedCount() throws IOException {
         }
     }
 
-    @Test(timeout = 5000)
+    @Test(timeout = 50_000)
     public void concurrentWritesTest() throws IOException, InterruptedException, ExecutionException {
 
         final int WRITER_COUNT = 5;
 
         final ExecutorService executorService = Executors.newFixedThreadPool(WRITER_COUNT);
         // very small pages to maximize page creation
-        Settings settings = TestSettings.volatileQueueSettings(100);
+        Settings settings = TestSettings.persistedQueueSettings(100, dataPath);
         try (Queue q = new Queue(settings)) {
             q.open();
 
-            int ELEMENT_COUNT = 10000;
+            int ELEMENT_COUNT = 1000;
             AtomicInteger element_num = new AtomicInteger(0);
 
             // we expect this next write call to block so let's wrap it in a Future
@@ -737,7 +745,7 @@ public void fullyAckedHeadPageBeheadingTest() throws IOException {
         Queueable element = new StringElement("foobarbaz1");
         int singleElementCapacity = singleElementCapacityForByteBufferPageIO(element);
         try (Queue q = new Queue(
-            TestSettings.volatileQueueSettings(2 * singleElementCapacity))) {
+            TestSettings.persistedQueueSettings(2 * singleElementCapacity, dataPath))) {
             q.open();
 
             Batch b;
@@ -863,7 +871,7 @@ private void stableUnderStress(final int capacity) throws IOException {
 
     @Test
     public void inEmpty() throws IOException {
-        try(Queue q = new Queue(TestSettings.volatileQueueSettings(1000))) {
+        try(Queue q = new Queue(TestSettings.persistedQueueSettings(1000, dataPath))) {
             q.open();
             assertThat(q.isEmpty(), is(true));
 
diff --git a/logstash-core/src/test/java/org/logstash/ackedqueue/QueueTestHelpers.java b/logstash-core/src/test/java/org/logstash/ackedqueue/QueueTestHelpers.java
index 252291c175b..495490c44e3 100644
--- a/logstash-core/src/test/java/org/logstash/ackedqueue/QueueTestHelpers.java
+++ b/logstash-core/src/test/java/org/logstash/ackedqueue/QueueTestHelpers.java
@@ -1,8 +1,7 @@
 package org.logstash.ackedqueue;
 
-import org.logstash.ackedqueue.io.ByteBufferPageIO;
-
 import java.io.IOException;
+import org.logstash.ackedqueue.io.AbstractByteBufferPageIO;
 
 /**
  * Class containing common methods to help DRY up acked queue tests.
@@ -10,18 +9,12 @@
 public class QueueTestHelpers {
 
     /**
-     * Returns the minimum capacity required for {@link ByteBufferPageIO}
-     * @return int - minimum capacity required
-     */
-    public static final int BYTE_BUF_PAGEIO_MIN_CAPACITY = ByteBufferPageIO.WRAPPER_SIZE;
-
-    /**
-     * Returns the {@link ByteBufferPageIO} capacity required for the supplied element
+     * Returns the {@link org.logstash.ackedqueue.io.MmapPageIO} capacity required for the supplied element
      * @param element
      * @return int - capacity required for the supplied element
      * @throws IOException Throws if a serialization error occurs
      */
     public static int singleElementCapacityForByteBufferPageIO(final Queueable element) throws IOException {
-        return ByteBufferPageIO.WRAPPER_SIZE + element.serialize().length;
+        return AbstractByteBufferPageIO.WRAPPER_SIZE + element.serialize().length;
     }
 }
diff --git a/logstash-core/src/test/java/org/logstash/ackedqueue/TestSettings.java b/logstash-core/src/test/java/org/logstash/ackedqueue/TestSettings.java
index dac914b43dd..6d78e280b79 100644
--- a/logstash-core/src/test/java/org/logstash/ackedqueue/TestSettings.java
+++ b/logstash-core/src/test/java/org/logstash/ackedqueue/TestSettings.java
@@ -1,31 +1,12 @@
 package org.logstash.ackedqueue;
 
-import org.logstash.ackedqueue.io.ByteBufferPageIO;
 import org.logstash.ackedqueue.io.CheckpointIOFactory;
 import org.logstash.ackedqueue.io.FileCheckpointIO;
-import org.logstash.ackedqueue.io.MemoryCheckpointIO;
 import org.logstash.ackedqueue.io.MmapPageIO;
 import org.logstash.ackedqueue.io.PageIOFactory;
 
 public class TestSettings {
 
-    public static Settings volatileQueueSettings(int capacity) {
-        MemoryCheckpointIO.clearSources();
-        PageIOFactory pageIOFactory = (pageNum, size, path) -> new ByteBufferPageIO(pageNum, size, path);
-        CheckpointIOFactory checkpointIOFactory = (source) -> new MemoryCheckpointIO(source);
-        return SettingsImpl.memorySettingsBuilder().capacity(capacity).elementIOFactory(pageIOFactory)
-            .checkpointIOFactory(checkpointIOFactory).elementClass(StringElement.class).build();
-    }
-
-    public static Settings volatileQueueSettings(int capacity, long size) {
-        MemoryCheckpointIO.clearSources();
-        PageIOFactory pageIOFactory = (pageNum, pageSize, path) -> new ByteBufferPageIO(pageNum, pageSize, path);
-        CheckpointIOFactory checkpointIOFactory = (source) -> new MemoryCheckpointIO(source);
-        return SettingsImpl.memorySettingsBuilder().capacity(capacity).queueMaxBytes(size)
-            .elementIOFactory(pageIOFactory).checkpointIOFactory(checkpointIOFactory)
-            .elementClass(StringElement.class).build();
-    }
-
     public static Settings persistedQueueSettings(int capacity, String folder) {
         PageIOFactory pageIOFactory = (pageNum, size, path) -> new MmapPageIO(pageNum, size, path);
         CheckpointIOFactory checkpointIOFactory = (source) -> new FileCheckpointIO(source);
@@ -33,4 +14,12 @@ public static Settings persistedQueueSettings(int capacity, String folder) {
             .checkpointMaxWrites(1).checkpointIOFactory(checkpointIOFactory)
             .elementClass(StringElement.class).build();
     }
+
+    public static Settings persistedQueueSettings(int capacity, long size, String folder) {
+        PageIOFactory pageIOFactory = (pageNum, pageSize, path) -> new MmapPageIO(pageNum, pageSize, path);
+        CheckpointIOFactory checkpointIOFactory = (source) -> new FileCheckpointIO(source);
+        return SettingsImpl.fileSettingsBuilder(folder).capacity(capacity).elementIOFactory(pageIOFactory)
+            .queueMaxBytes(size).checkpointMaxWrites(1).checkpointIOFactory(checkpointIOFactory)
+            .elementClass(StringElement.class).build();
+    }
 }
diff --git a/logstash-core/src/test/java/org/logstash/ackedqueue/io/ByteBufferPageIOTest.java b/logstash-core/src/test/java/org/logstash/ackedqueue/io/ByteBufferPageIOTest.java
deleted file mode 100644
index bc459517733..00000000000
--- a/logstash-core/src/test/java/org/logstash/ackedqueue/io/ByteBufferPageIOTest.java
+++ /dev/null
@@ -1,381 +0,0 @@
-package org.logstash.ackedqueue.io;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
-import org.logstash.ackedqueue.Queueable;
-import org.logstash.ackedqueue.SequencedList;
-import org.logstash.ackedqueue.StringElement;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-import java.util.concurrent.Callable;
-import java.util.stream.Collectors;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.MatcherAssert.assertThat;
-import static org.logstash.ackedqueue.QueueTestHelpers.BYTE_BUF_PAGEIO_MIN_CAPACITY;
-import static org.logstash.ackedqueue.QueueTestHelpers.singleElementCapacityForByteBufferPageIO;
-
-public class ByteBufferPageIOTest {
-
-    // convert any checked exceptions into uncheck RuntimeException
-    public static <V> V uncheck(Callable<V> callable) {
-        try {
-            return callable.call();
-        } catch (RuntimeException e) {
-            throw e;
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private interface BufferGenerator {
-        byte[] generate() throws IOException;
-    }
-
-    private static int CAPACITY = 1024;
-
-    private static ByteBufferPageIO newEmptyPageIO() throws IOException {
-        return newEmptyPageIO(CAPACITY);
-    }
-
-    private static ByteBufferPageIO newEmptyPageIO(int capacity) throws IOException {
-        ByteBufferPageIO io = new ByteBufferPageIO(capacity);
-        io.create();
-        return io;
-    }
-
-    private static ByteBufferPageIO newPageIO(int capacity, byte[] bytes) {
-        return new ByteBufferPageIO(capacity, bytes);
-    }
-
-    private Queueable buildStringElement(String str) {
-        return new StringElement(str);
-    }
-
-    @Test
-    public void getWritePosition() throws IOException {
-        assertThat(newEmptyPageIO().getWritePosition(), is(equalTo(1)));
-    }
-
-    @Test
-    public void getElementCount() throws IOException {
-        assertThat(newEmptyPageIO().getElementCount(), is(equalTo(0)));
-    }
-
-    @Test
-    public void getStartSeqNum() throws IOException {
-        assertThat(newEmptyPageIO().getMinSeqNum(), is(equalTo(0L)));
-    }
-
-    @Test
-    public void hasSpace() throws IOException {
-        assertThat(newEmptyPageIO(BYTE_BUF_PAGEIO_MIN_CAPACITY).hasSpace(0), is(true));
-        assertThat(newEmptyPageIO(BYTE_BUF_PAGEIO_MIN_CAPACITY).hasSpace(1), is(false));
-    }
-
-    @Test
-    public void hasSpaceAfterWrite() throws IOException {
-        Queueable element = new StringElement("foobarbaz");
-        long seqNum = 1L;
-
-        ByteBufferPageIO io = newEmptyPageIO(singleElementCapacityForByteBufferPageIO(element));
-
-        assertThat(io.hasSpace(element.serialize().length), is(true));
-        io.write(element.serialize(), seqNum);
-        assertThat(io.hasSpace(element.serialize().length), is(false));
-        assertThat(io.hasSpace(1), is(false));
-    }
-
-    @Test
-    public void write() throws IOException {
-        Queueable element = new StringElement("foobarbaz");
-        long seqNum = 42L;
-        ByteBufferPageIO io = newEmptyPageIO();
-        io.write(element.serialize(), seqNum);
-        assertThat(io.getWritePosition(), is(equalTo(singleElementCapacityForByteBufferPageIO(element))));
-        assertThat(io.getElementCount(), is(equalTo(1)));
-        assertThat(io.getMinSeqNum(), is(equalTo(seqNum)));
-    }
-
-    @Test
-    public void openValidState() throws IOException {
-        Queueable element = new StringElement("foobarbaz");
-        long seqNum = 42L;
-        ByteBufferPageIO io = newEmptyPageIO();
-        io.write(element.serialize(), seqNum);
-
-        byte[] initialState = io.dump();
-        io = newPageIO(initialState.length, initialState);
-        io.open(seqNum, 1);
-        assertThat(io.getElementCount(), is(equalTo(1)));
-        assertThat(io.getMinSeqNum(), is(equalTo(seqNum)));
-    }
-
-    @Test
-    public void recoversValidState() throws IOException {
-        Queueable element = new StringElement("foobarbaz");
-        long seqNum = 42L;
-        ByteBufferPageIO io = newEmptyPageIO();
-        io.write(element.serialize(), seqNum);
-
-        byte[] initialState = io.dump();
-        io = newPageIO(initialState.length, initialState);
-        io.recover();
-        assertThat(io.getElementCount(), is(equalTo(1)));
-        assertThat(io.getMinSeqNum(), is(equalTo(seqNum)));
-    }
-
-    @Test
-    public void recoverEmptyWriteRecover() throws IOException {
-        Queueable element = new StringElement("foobarbaz");
-        long seqNum = 42L;
-        ByteBufferPageIO io = newEmptyPageIO();
-        byte[] initialState = io.dump();
-
-        io = newPageIO(initialState.length, initialState);
-        io.recover();
-        assertThat(io.getElementCount(), is(equalTo(0)));
-
-        io.write(element.serialize(), seqNum);
-        initialState = io.dump();
-
-        io = newPageIO(initialState.length, initialState);
-        io.recover();
-        assertThat(io.getElementCount(), is(equalTo(1)));
-        assertThat(io.getMinSeqNum(), is(equalTo(seqNum)));
-    }
-
-    @Test
-    public void recoverNonEmptyWriteRecover() throws IOException {
-        Queueable element = new StringElement("foobarbaz");
-
-        ByteBufferPageIO io = newEmptyPageIO();
-        io.write(element.serialize(), 1L);
-        byte[] initialState = io.dump();
-
-        io = newPageIO(initialState.length, initialState);
-        io.recover();
-        assertThat(io.getElementCount(), is(equalTo(1)));
-
-        io.write(element.serialize(), 2L);
-        initialState = io.dump();
-
-        io = newPageIO(initialState.length, initialState);
-        io.recover();
-        assertThat(io.getElementCount(), is(equalTo(2)));
-    }
-
-    @Test(expected = IOException.class)
-    public void openUnexpectedSeqNum() throws IOException {
-        Queueable element = new StringElement("foobarbaz");
-        long seqNum = 42L;
-        ByteBufferPageIO io = newEmptyPageIO();
-        io.write(element.serialize(), seqNum);
-
-        byte[] initialState = io.dump();
-        newPageIO(initialState.length, initialState);
-        io.open(1L, 1);
-    }
-
-    @RunWith(Parameterized.class)
-    public static class SingleInvalidElementTest {
-
-        private static final List<BufferGenerator> singleGenerators = Arrays.asList(
-            // invalid length
-            () -> {
-                Queueable element = new StringElement("foobarbaz");
-                ByteBufferPageIO io = newEmptyPageIO();
-                byte[] bytes = element.serialize();
-                io.write(bytes, 1L, 514, io.checksum(bytes));
-                return io.dump();
-            },
-
-            // invalid checksum
-            () -> {
-                Queueable element = new StringElement("foobarbaz");
-                ByteBufferPageIO io = newEmptyPageIO();
-                byte[] bytes = element.serialize();
-                io.write(bytes, 1L, bytes.length, 77);
-                return io.dump();
-            },
-
-            // invalid payload
-            () -> {
-                Queueable element = new StringElement("foobarbaz");
-                ByteBufferPageIO io = newEmptyPageIO();
-                byte[] bytes = element.serialize();
-                int checksum = io.checksum(bytes);
-                bytes[1] = 0x01;
-                io.write(bytes, 1L, bytes.length, checksum);
-                return io.dump();
-            }
-        );
-
-        @Parameters
-        public static Collection<byte[]> singleElementParameters() {
-            return singleGenerators.stream().map(g -> uncheck(g::generate)).collect(Collectors.toList());
-        }
-
-        @Parameter
-        public byte[] singleElementParameter;
-
-        @Test
-        public void openInvalidSingleElement() throws IOException {
-            // none of these should generate an exception with open()
-
-            ByteBufferPageIO io = newPageIO(singleElementParameter.length, singleElementParameter);
-            io.open(1L, 1);
-
-            assertThat(io.getElementCount(), is(equalTo(1)));
-            assertThat(io.getMinSeqNum(), is(equalTo(1L)));
-        }
-
-        @Test
-        public void recoverInvalidSingleElement() throws IOException {
-            for (BufferGenerator generator : singleGenerators) {
-                byte[] bytes = generator.generate();
-                ByteBufferPageIO io = newPageIO(bytes.length, bytes);
-                io.recover();
-
-                assertThat(io.getElementCount(), is(equalTo(0)));
-            }
-        }
-    }
-
-    @RunWith(Parameterized.class)
-    public static class DoubleInvalidElementTest {
-
-        private static final List<BufferGenerator> doubleGenerators = Arrays.asList(
-            // invalid length
-            () -> {
-                Queueable element = new StringElement("foobarbaz");
-                ByteBufferPageIO io = newEmptyPageIO();
-                byte[] bytes = element.serialize();
-                io.write(bytes.clone(), 1L, bytes.length, io.checksum(bytes));
-                io.write(bytes, 2L, 514, io.checksum(bytes));
-                return io.dump();
-            },
-
-            // invalid checksum
-            () -> {
-                Queueable element = new StringElement("foobarbaz");
-                ByteBufferPageIO io = newEmptyPageIO();
-                byte[] bytes = element.serialize();
-                io.write(bytes.clone(), 1L, bytes.length, io.checksum(bytes));
-                io.write(bytes, 2L, bytes.length, 77);
-                return io.dump();
-            },
-
-            // invalid payload
-            () -> {
-                Queueable element = new StringElement("foobarbaz");
-                ByteBufferPageIO io = newEmptyPageIO();
-                byte[] bytes = element.serialize();
-                int checksum = io.checksum(bytes);
-                io.write(bytes.clone(), 1L, bytes.length, io.checksum(bytes));
-                bytes[1] = 0x01;
-                io.write(bytes, 2L, bytes.length, checksum);
-                return io.dump();
-            }
-        );
-
-        @Parameters
-        public static Collection<byte[]> doubleElementParameters() {
-            return doubleGenerators.stream().map(g -> uncheck(g::generate)).collect(Collectors.toList());
-        }
-
-        @Parameter
-        public byte[] doubleElementParameter;
-
-        @Test
-        public void openInvalidDoubleElement() throws IOException {
-            // none of these will generate an exception with open()
-
-            ByteBufferPageIO io = newPageIO(doubleElementParameter.length, doubleElementParameter);
-            io.open(1L, 2);
-
-            assertThat(io.getElementCount(), is(equalTo(2)));
-            assertThat(io.getMinSeqNum(), is(equalTo(1L)));
-        }
-
-        @Test
-        public void recoverInvalidDoubleElement() throws IOException {
-            ByteBufferPageIO io = newPageIO(doubleElementParameter.length, doubleElementParameter);
-            io.recover();
-
-            assertThat(io.getElementCount(), is(equalTo(1)));
-         }
-    }
-
-    @Test(expected = AbstractByteBufferPageIO.PageIOInvalidElementException.class)
-    public void openInvalidDeqNumDoubleElement() throws IOException {
-        Queueable element = new StringElement("foobarbaz");
-        ByteBufferPageIO io = newEmptyPageIO();
-        byte[] bytes = element.serialize();
-        io.write(bytes.clone(), 1L, bytes.length, io.checksum(bytes));
-        io.write(bytes, 3L, bytes.length, io.checksum(bytes));
-
-        io = newPageIO(io.dump().length, io.dump());
-        io.open(1L, 2);
-    }
-
-    @Test
-    public void recoverInvalidDeqNumDoubleElement() throws IOException {
-        Queueable element = new StringElement("foobarbaz");
-        ByteBufferPageIO io = newEmptyPageIO();
-        byte[] bytes = element.serialize();
-        io.write(bytes.clone(), 1L, bytes.length, io.checksum(bytes));
-        io.write(bytes, 3L, bytes.length, io.checksum(bytes));
-
-        io = newPageIO(io.dump().length, io.dump());
-        io.recover();
-
-        assertThat(io.getElementCount(), is(equalTo(1)));
-    }
-
-    @Test
-    public void writeRead() throws IOException {
-        long seqNum = 42L;
-        Queueable element = buildStringElement("foobarbaz");
-        ByteBufferPageIO io = newEmptyPageIO();
-        io.write(element.serialize(), seqNum);
-        SequencedList<byte[]> result = io.read(seqNum, 1);
-        assertThat(result.getElements().size(), is(equalTo(1)));
-        Queueable readElement = StringElement.deserialize(result.getElements().get(0));
-        assertThat(result.getSeqNums().get(0), is(equalTo(seqNum)));
-        assertThat(readElement.toString(), is(equalTo(element.toString())));
-    }
-
-    @Test
-    public void writeReadMulti() throws IOException {
-        Queueable element1 = buildStringElement("foo");
-        Queueable element2 = buildStringElement("bar");
-        Queueable element3 = buildStringElement("baz");
-        Queueable element4 = buildStringElement("quux");
-        ByteBufferPageIO io = newEmptyPageIO();
-        io.write(element1.serialize(), 40L);
-        io.write(element2.serialize(), 41L);
-        io.write(element3.serialize(), 42L);
-        io.write(element4.serialize(), 43L);
-        int batchSize = 11;
-        SequencedList<byte[]> result = io.read(40L, batchSize);
-        assertThat(result.getElements().size(), is(equalTo(4)));
-
-        assertThat(result.getSeqNums().get(0), is(equalTo(40L)));
-        assertThat(result.getSeqNums().get(1), is(equalTo(41L)));
-        assertThat(result.getSeqNums().get(2), is(equalTo(42L)));
-        assertThat(result.getSeqNums().get(3), is(equalTo(43L)));
-
-        assertThat(StringElement.deserialize(result.getElements().get(0)).toString(), is(equalTo(element1.toString())));
-        assertThat(StringElement.deserialize(result.getElements().get(1)).toString(), is(equalTo(element2.toString())));
-        assertThat(StringElement.deserialize(result.getElements().get(2)).toString(), is(equalTo(element3.toString())));
-        assertThat(StringElement.deserialize(result.getElements().get(3)).toString(), is(equalTo(element4.toString())));
-    }
-}
diff --git a/logstash-core/src/test/java/org/logstash/ackedqueue/io/MemoryCheckpointTest.java b/logstash-core/src/test/java/org/logstash/ackedqueue/io/MemoryCheckpointTest.java
deleted file mode 100644
index 4acf329d9ff..00000000000
--- a/logstash-core/src/test/java/org/logstash/ackedqueue/io/MemoryCheckpointTest.java
+++ /dev/null
@@ -1,86 +0,0 @@
-package org.logstash.ackedqueue.io;
-
-import java.io.IOException;
-import java.nio.file.NoSuchFileException;
-import org.junit.Before;
-import org.junit.Test;
-import org.logstash.ackedqueue.Checkpoint;
-import org.logstash.ackedqueue.SettingsImpl;
-import org.logstash.ackedqueue.Settings;
-
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.MatcherAssert.assertThat;
-
-public class MemoryCheckpointTest {
-
-    private CheckpointIO io;
-
-    @Before
-    public void setUp() {
-        CheckpointIOFactory factory = (dirPath) -> new MemoryCheckpointIO(dirPath);
-        Settings settings = 
-            SettingsImpl.memorySettingsBuilder().checkpointIOFactory(factory).build();
-        this.io = settings.getCheckpointIOFactory().build(settings.getDirPath());
-    }
-
-    @Test
-    public void writeNewReadExisting() throws IOException {
-        io.write("checkpoint.head", 1, 2, 3, 4, 5);
-
-        Checkpoint checkpoint = io.read("checkpoint.head");
-
-        assertThat(checkpoint.getPageNum(), is(equalTo(1)));
-        assertThat(checkpoint.getFirstUnackedPageNum(), is(equalTo(2)));
-        assertThat(checkpoint.getFirstUnackedSeqNum(), is(equalTo(3L)));
-        assertThat(checkpoint.getMinSeqNum(), is(equalTo(4L)));
-        assertThat(checkpoint.getElementCount(), is(equalTo(5)));
-    }
-
-    @Test(expected = NoSuchFileException.class)
-    public void readNonexistent() throws IOException {
-        io.read("checkpoint.invalid");
-    }
-
-    @Test
-    public void readWriteDirPathNamespaced() throws IOException {
-        CheckpointIO io1 = new MemoryCheckpointIO("path1");
-        CheckpointIO io2 = new MemoryCheckpointIO("path2");
-        io1.write("checkpoint.head", 1, 0, 0, 0, 0);
-        io2.write("checkpoint.head", 2, 0, 0, 0, 0);
-
-        Checkpoint checkpoint;
-
-        checkpoint = io1.read("checkpoint.head");
-        assertThat(checkpoint.getPageNum(), is(equalTo(1)));
-
-        checkpoint = io2.read("checkpoint.head");
-        assertThat(checkpoint.getPageNum(), is(equalTo(2)));
-    }
-
-    @Test(expected = NoSuchFileException.class)
-    public void purgeDirPathNamespaced1() throws IOException {
-        CheckpointIO io1 = new MemoryCheckpointIO("path1");
-        CheckpointIO io2 = new MemoryCheckpointIO("path2");
-        io1.write("checkpoint.head", 1, 0, 0, 0, 0);
-        io2.write("checkpoint.head", 2, 0, 0, 0, 0);
-
-        io1.purge("checkpoint.head");
-
-        Checkpoint checkpoint = io1.read("checkpoint.head");
-    }
-
-    @Test
-    public void purgeDirPathNamespaced2() throws IOException {
-        CheckpointIO io1 = new MemoryCheckpointIO("path1");
-        CheckpointIO io2 = new MemoryCheckpointIO("path2");
-        io1.write("checkpoint.head", 1, 0, 0, 0, 0);
-        io2.write("checkpoint.head", 2, 0, 0, 0, 0);
-
-        io1.purge("checkpoint.head");
-
-        Checkpoint checkpoint;
-        checkpoint = io2.read("checkpoint.head");
-        assertThat(checkpoint.getPageNum(), is(equalTo(2)));
-    }
-}
diff --git a/logstash-core/src/test/java/org/logstash/stress/Concurrent.java b/logstash-core/src/test/java/org/logstash/stress/Concurrent.java
index fb8d5792df4..9b0323a2aee 100644
--- a/logstash-core/src/test/java/org/logstash/stress/Concurrent.java
+++ b/logstash-core/src/test/java/org/logstash/stress/Concurrent.java
@@ -15,10 +15,8 @@
 import org.logstash.ackedqueue.Queue;
 import org.logstash.ackedqueue.Settings;
 import org.logstash.ackedqueue.StringElement;
-import org.logstash.ackedqueue.io.ByteBufferPageIO;
 import org.logstash.ackedqueue.io.CheckpointIOFactory;
 import org.logstash.ackedqueue.io.FileCheckpointIO;
-import org.logstash.ackedqueue.io.MemoryCheckpointIO;
 import org.logstash.ackedqueue.io.MmapPageIO;
 import org.logstash.ackedqueue.io.PageIOFactory;
 
@@ -27,17 +25,10 @@ public class Concurrent {
     final static int BATCH_SIZE = 1000;
     static Settings settings;
 
-    public static Settings memorySettings(int capacity) {
-        PageIOFactory pageIOFactory = (pageNum, size, path) -> new ByteBufferPageIO(pageNum, size, path);
-        CheckpointIOFactory checkpointIOFactory = (source) -> new MemoryCheckpointIO(source);
-        return SettingsImpl.memorySettingsBuilder().capacity(capacity).elementIOFactory(pageIOFactory)
-            .checkpointIOFactory(checkpointIOFactory).elementClass(StringElement.class).build();
-    }
-
     public static Settings fileSettings(int capacity) {
         PageIOFactory pageIOFactory = (pageNum, size, path) -> new MmapPageIO(pageNum, size, path);
         CheckpointIOFactory checkpointIOFactory = (source) -> new FileCheckpointIO(source);
-        return SettingsImpl.memorySettingsBuilder("/tmp/queue").capacity(capacity)
+        return SettingsImpl.fileSettingsBuilder("/tmp/queue").capacity(capacity)
             .elementIOFactory(pageIOFactory)
             .checkpointIOFactory(checkpointIOFactory).elementClass(StringElement.class).build();
     }
@@ -171,12 +162,6 @@ public static void oneProducersOneMultipleConsumer() throws IOException, Interru
 
 
     public static void main(String[] args) throws IOException, InterruptedException {
-        System.out.println(">>> starting in-memory stress test");
-
-        settings = memorySettings(1024 * 1024); // 1MB
-        oneProducersOneConsumer();
-        oneProducersOneMultipleConsumer();
-
         System.out.println("\n>>> starting file-based stress test in /tmp/queue");
 
         settings = fileSettings(1024 * 1024); // 1MB
diff --git a/spec/spec_helper.rb b/spec/spec_helper.rb
index 9807b38f8d1..a6de295946a 100644
--- a/spec/spec_helper.rb
+++ b/spec/spec_helper.rb
@@ -57,7 +57,7 @@ def puts(payload)
     # Some tests mess with the settings. This ensures one test cannot pollute another
     LogStash::SETTINGS.reset
 
-    LogStash::SETTINGS.set("queue.type", "memory_acked")
+    LogStash::SETTINGS.set("queue.type", "persisted")
     LogStash::SETTINGS.set("queue.page_capacity", 1024 * 1024)
     LogStash::SETTINGS.set("queue.max_events", 250)
   end
