diff --git a/lib/bootstrap/environment.rb b/lib/bootstrap/environment.rb
index 22c388099d6..2316f993abe 100644
--- a/lib/bootstrap/environment.rb
+++ b/lib/bootstrap/environment.rb
@@ -67,8 +67,9 @@ def pattern_path(path)
   # TODO deprecate these arguments in the next major version. use -i only
   if ARGV == ["irb"] || ARGV == ["pry"]
     puts "Warn: option \"#{ARGV.first}\" is deprecated, use \"-i #{ARGV.first}\" or \"--interactive=#{ARGV.first}\" instead"
-    LogStash::Runner.run("bin/logstash", ["--interactive", ARGV.first])
+    exit_status = LogStash::Runner.run("bin/logstash", ["--interactive", ARGV.first])
   else
-    LogStash::Runner.run("bin/logstash", ARGV)
+    exit_status = LogStash::Runner.run("bin/logstash", ARGV)
   end
+  exit(exit_status || 0)
 end
diff --git a/logstash-core/lib/logstash/agent.rb b/logstash-core/lib/logstash/agent.rb
index 20d78d799ce..89dd0c8e9c5 100644
--- a/logstash-core/lib/logstash/agent.rb
+++ b/logstash-core/lib/logstash/agent.rb
@@ -4,6 +4,7 @@
 require "logstash/config/cpu_core_strategy"
 require "logstash/pipeline"
 require "stud/trap"
+require "logstash/config/loader"
 require "uri"
 require "socket"
 require "securerandom"
@@ -11,78 +12,167 @@
 LogStash::Environment.load_locale!
 
 class LogStash::Agent
+  attr_reader :logger, :pipelines
 
-  attr_writer :logger
-  attr_reader :node_name
-
-  def initialize(options = {})
+  # initialize method for LogStash::Agent
+  # @param params [Hash] potential parameters are:
+  #   :node_name [String] - identifier for the agent
+  #   :auto_reload [Boolean] - enable reloading of pipelines
+  #   :reload_interval [Integer] - reload pipelines every X seconds
+  #   :logger [Cabin::Channel] - logger instance
+  def initialize(params)
+    @logger = params[:logger]
+    @auto_reload = params[:auto_reload]
     @pipelines = {}
-     
-    @node_name = options[:node_name] || Socket.gethostname
+
+    @node_name = params[:node_name] || Socket.gethostname
+    @config_loader = LogStash::Config::Loader.new(@logger)
+    @reload_interval = params[:reload_interval] || 3 # seconds
+    @upgrade_mutex = Mutex.new
   end
 
   def execute
-    # Make SIGINT/SIGTERM shutdown the pipeline.
-    sigint_id = trap_sigint()
-    sigterm_id = trap_sigterm()
+    @thread = Thread.current # this var is implicilty used by Stud.stop?
+    @logger.info("starting agent")
+
+    start_pipelines
+
+    return 1 if clean_state?
+
+    Stud.stoppable_sleep(@reload_interval) # sleep before looping
 
-    @pipelines.each {|_, p| p.run } # blocking operation. works now because size <= 1
-    return 0
-  rescue => e
-    @logger.fatal I18n.t("oops", :error => e)
-    @logger.fatal e.backtrace if @logger.debug? || $DEBUGLIST.include?("stacktrace")
-    return 1
-  ensure
-    Stud::untrap("INT", sigint_id) unless sigint_id.nil?
-    Stud::untrap("TERM", sigterm_id) unless sigterm_id.nil?
-  end # def execute
+    if @auto_reload
+      Stud.interval(@reload_interval) { reload_state! }
+    else
+      while !Stud.stop?
+        if clean_state? || running_pipelines?
+          sleep 0.5
+        else
+          break
+        end
+      end
+    end
+  end
 
-  def add_pipeline(pipeline_id, config_str, settings = {})
-    @pipelines[pipeline_id] = LogStash::Pipeline.new(config_str, settings.merge(:pipeline_id => pipeline_id))
+  # register_pipeline - adds a pipeline to the agent's state
+  # @param pipeline_id [String] pipeline string identifier
+  # @param settings [Hash] settings that will be passed when creating the pipeline.
+  #   keys should be symbols such as :pipeline_workers and :pipeline_batch_delay
+  def register_pipeline(pipeline_id, settings)
+    pipeline = create_pipeline(settings.merge(:pipeline_id => pipeline_id))
+    return unless pipeline.is_a?(LogStash::Pipeline)
+    @pipelines[pipeline_id] = pipeline
   end
 
-  def node_uuid
-    @node_uuid ||= SecureRandom.uuid
+  def reload_state!
+    @upgrade_mutex.synchronize do
+      @pipelines.each do |pipeline_id, _|
+        begin
+          reload_pipeline!(pipeline_id)
+        rescue => e
+          @logger.error I18n.t("oops", :error => e, :backtrace => e.backtrace)
+        end
+      end
+    end
+  end
+
+  def shutdown
+    shutdown_pipelines
   end
 
   private
-  # Emit a warning message.
-  def warn(message)
-    # For now, all warnings are fatal.
-    raise LogStash::ConfigurationError, message
-  end # def warn
+  def node_uuid
+    @node_uuid ||= SecureRandom.uuid
+  end
 
-  # Emit a failure message and abort.
-  def fail(message)
-    raise LogStash::ConfigurationError, message
-  end # def fail
+  def create_pipeline(settings)
+    begin
+      config = fetch_config(settings)
+    rescue => e
+      @logger.error("failed to fetch pipeline configuration", :message => e.message)
+      return
+    end
 
-  def shutdown_pipelines
-    @pipelines.each do |_, pipeline|
-      pipeline.shutdown do
-        ::LogStash::ShutdownWatcher.start(pipeline)
-      end
+    begin
+      LogStash::Pipeline.new(config, settings)
+    rescue => e
+      @logger.error("fetched an invalid config", :config => config, :reason => e.message)
+      return
     end
   end
 
-  def trap_sigterm
-    Stud::trap("TERM") do
-      @logger.warn(I18n.t("logstash.agent.sigterm"))
-      shutdown_pipelines
+  def fetch_config(settings)
+    @config_loader.format_config(settings[:config_path], settings[:config_string])
+  end
+
+  # since this method modifies the @pipelines hash it is
+  # wrapped in @upgrade_mutex in the parent call `reload_state!`
+  def reload_pipeline!(id)
+    old_pipeline = @pipelines[id]
+    new_pipeline = create_pipeline(old_pipeline.original_settings)
+    return if new_pipeline.nil?
+
+    if old_pipeline.config_str == new_pipeline.config_str
+      @logger.debug("no configuration change for pipeline",
+                    :pipeline => id, :config => old_pipeline.config_str)
+    else
+      @logger.warn("fetched new config for pipeline. upgrading..",
+                   :pipeline => id, :config => new_pipeline.config_str)
+      upgrade_pipeline(id, new_pipeline)
     end
   end
 
-  def trap_sigint
-    Stud::trap("INT") do
-      if @interrupted_once
-        @logger.fatal(I18n.t("logstash.agent.forced_sigint"))
-        exit
-      else
-        @logger.warn(I18n.t("logstash.agent.sigint"))
-        Thread.new(@logger) {|logger| sleep 5; logger.warn(I18n.t("logstash.agent.slow_shutdown")) }
-        @interrupted_once = true
-        shutdown_pipelines
+  def start_pipeline(id)
+    pipeline = @pipelines[id]
+    return unless pipeline.is_a?(LogStash::Pipeline)
+    return if pipeline.ready?
+    @logger.info("starting pipeline", :id => id)
+    Thread.new do
+      LogStash::Util.set_thread_name("pipeline.#{id}")
+      begin
+        pipeline.run
+      rescue => e
+        @logger.error("Pipeline aborted due to error", :exception => e, :backtrace => e.backtrace)
       end
     end
+    sleep 0.01 until pipeline.ready?
+  end
+
+  def stop_pipeline(id)
+    pipeline = @pipelines[id]
+    return unless pipeline
+    @logger.warn("stopping pipeline", :id => id)
+    pipeline.shutdown { LogStash::ShutdownWatcher.start(pipeline) }
+    @pipelines[id].thread.join
+  end
+
+  def start_pipelines
+    @pipelines.each { |id, _| start_pipeline(id) }
+  end
+
+  def shutdown_pipelines
+    @pipelines.each { |id, _| stop_pipeline(id) }
+  end
+
+  def running_pipelines?
+    @upgrade_mutex.synchronize do
+      @pipelines.select {|pipeline_id, _| running_pipeline?(pipeline_id) }.any?
+    end
+  end
+
+  def running_pipeline?(pipeline_id)
+    thread = @pipelines[pipeline_id].thread
+    thread.is_a?(Thread) && thread.alive?
   end
+
+  def upgrade_pipeline(pipeline_id, new_pipeline)
+    stop_pipeline(pipeline_id)
+    @pipelines[pipeline_id] = new_pipeline
+    start_pipeline(pipeline_id)
+  end
+
+  def clean_state?
+    @pipelines.empty?
+  end
+
 end # class LogStash::Agent
diff --git a/logstash-core/lib/logstash/config/defaults.rb b/logstash-core/lib/logstash/config/defaults.rb
index ac3466f771d..c0c18fd7c04 100644
--- a/logstash-core/lib/logstash/config/defaults.rb
+++ b/logstash-core/lib/logstash/config/defaults.rb
@@ -6,6 +6,14 @@ module LogStash module Config module Defaults
 
   extend self
 
+  def input
+    "input { stdin { type => stdin } }"
+  end
+
+  def output
+    "output { stdout { codec => rubydebug } }"
+  end
+
   def cpu_cores
     Concurrent.processor_count
   end
diff --git a/logstash-core/lib/logstash/config/loader.rb b/logstash-core/lib/logstash/config/loader.rb
new file mode 100644
index 00000000000..37179518ed5
--- /dev/null
+++ b/logstash-core/lib/logstash/config/loader.rb
@@ -0,0 +1,90 @@
+require "logstash/config/defaults"
+
+module LogStash; module Config; class Loader
+  def initialize(logger)
+    @logger = logger
+  end
+
+  def format_config(config_path, config_string)
+    config_string = config_string.to_s
+    if config_path
+      # Append the config string.
+      # This allows users to provide both -f and -e flags. The combination
+      # is rare, but useful for debugging.
+      config_string = config_string + load_config(config_path)
+    else
+      # include a default stdin input if no inputs given
+      if config_string !~ /input *{/
+        config_string += LogStash::Config::Defaults.input
+      end
+      # include a default stdout output if no outputs given
+      if config_string !~ /output *{/
+        config_string += LogStash::Config::Defaults.output
+      end
+    end
+    config_string
+  end
+
+  def load_config(path)
+    begin
+      uri = URI.parse(path)
+
+      case uri.scheme
+      when nil then
+        local_config(path)
+      when /http/ then
+        fetch_config(uri)
+      when "file" then
+        local_config(uri.path)
+      else
+        fail(I18n.t("logstash.runner.configuration.scheme-not-supported", :path => path))
+      end
+    rescue URI::InvalidURIError
+      # fallback for windows.
+      # if the parsing of the file failed we assume we can reach it locally.
+      # some relative path on windows arent parsed correctly (.\logstash.conf)
+      local_config(path)
+    end
+  end
+
+  def local_config(path)
+    path = ::File.expand_path(path)
+    path = ::File.join(path, "*") if ::File.directory?(path)
+
+    if Dir.glob(path).length == 0
+      fail(I18n.t("logstash.runner.configuration.file-not-found", :path => path))
+    end
+
+    config = ""
+    encoding_issue_files = []
+    Dir.glob(path).sort.each do |file|
+      next unless ::File.file?(file)
+      if file.match(/~$/)
+        @logger.debug("NOT reading config file because it is a temp file", :config_file => file)
+        next
+      end
+      @logger.debug("Reading config file", :config_file => file)
+      cfg = ::File.read(file)
+      if !cfg.ascii_only? && !cfg.valid_encoding?
+        encoding_issue_files << file
+      end
+      config << cfg + "\n"
+      @logger.debug? && @logger.debug("\nThe following is the content of a file", :config_file => file.to_s)
+      @logger.debug? && @logger.debug("\n" + cfg + "\n\n")
+    end
+    if encoding_issue_files.any?
+      fail("The following config files contains non-ascii characters but are not UTF-8 encoded #{encoding_issue_files}")
+    end
+    @logger.debug? && @logger.debug("\nThe following is the merged configuration")
+    @logger.debug? && @logger.debug("\n" + config + "\n\n")
+    return config
+  end # def load_config
+
+  def fetch_config(uri)
+    begin
+      Net::HTTP.get(uri) + "\n"
+    rescue Exception => e
+      fail(I18n.t("logstash.runner.configuration.fetch-failed", :path => uri.to_s, :message => e.message))
+    end
+  end
+end end end
diff --git a/logstash-core/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
index d29206aa20f..29a8e27aee1 100644
--- a/logstash-core/lib/logstash/pipeline.rb
+++ b/logstash-core/lib/logstash/pipeline.rb
@@ -17,7 +17,7 @@
 require "logstash/output_delegator"
 
 module LogStash; class Pipeline
-  attr_reader :inputs, :filters, :outputs, :worker_threads, :events_consumed, :events_filtered, :reporter, :pipeline_id, :logger
+  attr_reader :inputs, :filters, :outputs, :worker_threads, :events_consumed, :events_filtered, :reporter, :pipeline_id, :logger, :thread, :config_str, :original_settings
 
   DEFAULT_SETTINGS = {
     :default_pipeline_workers => LogStash::Config::CpuCoreStrategy.maximum,
@@ -28,9 +28,20 @@ module LogStash; class Pipeline
   }
   MAX_INFLIGHT_WARN_THRESHOLD = 10_000
 
+  def self.validate_config(config_str, settings = {})
+    begin
+      # There should be a better way to test this
+      self.new(config_str, settings)
+    rescue => e
+      e.message
+    end
+  end
+
   def initialize(config_str, settings = {})
-    @pipeline_id = settings[:pipeline_id] || self.object_id
+    @config_str = config_str
+    @original_settings = settings
     @logger = Cabin::Channel.get(LogStash)
+    @pipeline_id = settings[:pipeline_id] || self.object_id
     @settings = DEFAULT_SETTINGS.clone
     settings.each {|setting, value| configure(setting, value) }
     @reporter = LogStash::PipelineReporter.new(@logger, self)
@@ -117,8 +128,8 @@ def filters?
   end
 
   def run
-    LogStash::Util.set_thread_name("[#{pipeline_id}]-pipeline-manager")
     @logger.terminal(LogStash::Util::DefaultsPrinter.print(@settings))
+    @thread = Thread.current
 
     start_workers
 
diff --git a/logstash-core/lib/logstash/runner.rb b/logstash-core/lib/logstash/runner.rb
index d36f3b92ea3..a9e56a3507a 100644
--- a/logstash-core/lib/logstash/runner.rb
+++ b/logstash-core/lib/logstash/runner.rb
@@ -11,20 +11,19 @@
 
 require "logstash/namespace"
 require "logstash/agent"
+require "logstash/config/defaults"
 
 class LogStash::Runner < Clamp::Command
 
-  DEFAULT_INPUT = "input { stdin { type => stdin } }"
-  DEFAULT_OUTPUT = "output { stdout { codec => rubydebug } }"
-
   option ["-f", "--config"], "CONFIG_PATH",
     I18n.t("logstash.runner.flag.config"),
     :attribute_name => :config_path
 
   option "-e", "CONFIG_STRING",
     I18n.t("logstash.runner.flag.config-string",
-           :default_input => DEFAULT_INPUT, :default_output => DEFAULT_OUTPUT),
-    :default => "", :attribute_name => :config_string
+           :default_input => LogStash::Config::Defaults.input,
+           :default_output => LogStash::Config::Defaults.output),
+    :default => nil, :attribute_name => :config_string
 
   option ["-w", "--pipeline-workers"], "COUNT",
     I18n.t("logstash.runner.flag.pipeline-workers"),
@@ -79,10 +78,9 @@ class LogStash::Runner < Clamp::Command
     I18n.t("logstash.runner.flag.node_name"),
     :attribute_name => :node_name
 
-  def initialize(*args)
-    super(*args)
-    @pipeline_settings ||= { :pipeline_id => "main" }
-  end
+  option ["-r", "--[no-]auto-reload"], :flag,
+    I18n.t("logstash.runner.flag.auto_reload"),
+    :attribute_name => :auto_reload, :default => false
 
   def pipeline_workers=(pipeline_workers_value)
     @pipeline_settings[:pipeline_workers] = validate_positive_integer(pipeline_workers_value)
@@ -107,16 +105,18 @@ def validate_positive_integer(str_arg)
 
   attr_reader :agent
 
+  def initialize(*args)
+    @logger = Cabin::Channel.get(LogStash)
+    @pipeline_settings ||= { :pipeline_id => "main" }
+    super(*args)
+  end
+
   def execute
     require "logstash/util"
     require "logstash/util/java_version"
     require "stud/task"
     require "cabin" # gem 'cabin'
 
-    @agent = LogStash::Agent.new({ :node_name => node_name })
-
-    @logger = Cabin::Channel.get(LogStash)
-
     LogStash::Util::set_thread_name(self.class.name)
 
     if RUBY_VERSION < "1.9.2"
@@ -139,36 +139,63 @@ def execute
 
     return start_shell(@ruby_shell, binding) if @ruby_shell
 
-    if @config_string.nil? && @config_path.nil?
+    if config_string.nil? && config_path.nil?
       fail(I18n.t("logstash.runner.missing-configuration"))
     end
 
-    @agent.logger = @logger
-
-    config_string = format_config(@config_path, @config_string)
-
-    @agent.add_pipeline("base", config_string, @pipeline_settings)
+    if @auto_reload && config_path.nil?
+      # there's nothing to reload
+      signal_usage_error(I18n.t("logstash.runner.reload-without-config-path"))
+    end
 
     if config_test?
-      puts "Configuration OK"
-    else
-      task = Stud::Task.new { @agent.execute }
-      return task.wait
+      config_loader = LogStash::Config::Loader.new(@logger, config_test?)
+      config_str = config_loader.format_config(config_path, config_string)
+      config_error = LogStash::Pipeline.config_valid?(config_str)
+      if config_error == true
+        @logger.terminal "Configuration OK"
+        return 0
+      else
+        @logger.fatal I18n.t("logstash.error", :error => config_error)
+        return 1
+      end
     end
 
-  rescue LoadError => e
-    fail("Configuration problem.")
-  rescue LogStash::ConfigurationError => e
-    @logger.fatal I18n.t("logstash.error", :error => e)
-    if !config_test?
-      @logger.warn I18n.t("logstash.runner.configtest-flag-information")
-    end
+    @agent = create_agent(:logger => @logger,
+                          :auto_reload => @auto_reload)
+
+    @agent.register_pipeline("main", @pipeline_settings.merge({
+                          :config_string => config_string,
+                          :config_path => config_path
+                          }))
+
+    # enable sigint/sigterm before starting the agent
+    # to properly handle a stalled agent
+    sigint_id = trap_sigint()
+    sigterm_id = trap_sigterm()
+
+    @agent_task = Stud::Task.new { @agent.execute }
+
+    # no point in enabling config reloading before the agent starts
+    sighup_id = trap_sighup()
+
+    agent_return = @agent_task.wait
+
+    @agent.shutdown
+
+    agent_return
+
+  rescue Clamp::UsageError => e
+    $stderr.puts "ERROR: #{e.message}"
     show_short_help
     return 1
   rescue => e
-    @logger.fatal I18n.t("oops", :error => e)
-    @logger.debug e.backtrace if $DEBUGLIST.include?("stacktrace")
+    @logger.fatal I18n.t("oops", :error => e, :backtrace => e.backtrace)
+    return 1
   ensure
+    Stud::untrap("INT", sigint_id) unless sigint_id.nil?
+    Stud::untrap("TERM", sigterm_id) unless sigterm_id.nil?
+    Stud::untrap("HUP", sighup_id) unless sighup_id.nil?
     @log_fd.close if @log_fd
   end # def self.main
 
@@ -221,6 +248,10 @@ def configure_plugin_paths(paths)
     end
   end
 
+  def create_agent(*args)
+    LogStash::Agent.new(*args)
+  end
+
   # Point logging at a specific path.
   def configure_logging(path)
     # Set with the -v (or -vv...) flag
@@ -268,96 +299,9 @@ def configure_logging(path)
     # http://jira.codehaus.org/browse/JRUBY-7003
   end # def configure_logging
 
-  def format_config(config_path, config_string)
-    config_string = config_string.to_s
-    if config_path
-      # Append the config string.
-      # This allows users to provide both -f and -e flags. The combination
-      # is rare, but useful for debugging.
-      config_string = config_string + load_config(config_path)
-    else
-      # include a default stdin input if no inputs given
-      if config_string !~ /input *{/
-        config_string += DEFAULT_INPUT
-      end
-      # include a default stdout output if no outputs given
-      if config_string !~ /output *{/
-        config_string += DEFAULT_OUTPUT
-      end
-    end
-    config_string
-  end
-
-  def load_config(path)
-    begin
-      uri = URI.parse(path)
-
-      case uri.scheme
-      when nil then
-        local_config(path)
-      when /http/ then
-        fetch_config(uri)
-      when "file" then
-        local_config(uri.path)
-      else
-        fail(I18n.t("logstash.runner.configuration.scheme-not-supported", :path => path))
-      end
-    rescue URI::InvalidURIError
-      # fallback for windows.
-      # if the parsing of the file failed we assume we can reach it locally.
-      # some relative path on windows arent parsed correctly (.\logstash.conf)
-      local_config(path)
-    end
-  end
-
-  def local_config(path)
-    path = File.expand_path(path)
-    path = File.join(path, "*") if File.directory?(path)
-
-    if Dir.glob(path).length == 0
-      fail(I18n.t("logstash.runner.configuration.file-not-found", :path => path))
-    end
-
-    config = ""
-    encoding_issue_files = []
-    Dir.glob(path).sort.each do |file|
-      next unless File.file?(file)
-      if file.match(/~$/)
-        @logger.debug("NOT reading config file because it is a temp file", :config_file => file)
-        next
-      end
-      @logger.debug("Reading config file", :config_file => file)
-      cfg = File.read(file)
-      if !cfg.ascii_only? && !cfg.valid_encoding?
-        encoding_issue_files << file
-      end
-      config << cfg + "\n"
-      if config_test?
-        @logger.debug? && @logger.debug("\nThe following is the content of a file", :config_file => file.to_s)
-        @logger.debug? && @logger.debug("\n" + cfg + "\n\n")
-      end
-    end
-    if (encoding_issue_files.any?)
-      fail("The following config files contains non-ascii characters but are not UTF-8 encoded #{encoding_issue_files}")
-    end
-    if config_test?
-      @logger.debug? && @logger.debug("\nThe following is the merged configuration")
-      @logger.debug? && @logger.debug("\n" + config + "\n\n")
-    end
-    return config
-  end # def load_config
-
-  def fetch_config(uri)
-    begin
-      Net::HTTP.get(uri) + "\n"
-    rescue Exception => e
-      fail(I18n.t("logstash.runner.configuration.fetch-failed", :path => uri.to_s, :message => e.message))
-    end
-  end
-
   # Emit a failure message and abort.
   def fail(message)
-    raise LogStash::ConfigurationError, message
+    signal_usage_error(message)
   end # def fail
 
   def show_short_help
@@ -379,4 +323,33 @@ def start_shell(shell, start_binding)
       fail(I18n.t("logstash.runner.invalid-shell"))
     end
   end
+
+  def trap_sighup
+    Stud::trap("HUP") do
+      @logger.warn(I18n.t("logstash.agent.sighup"))
+      @agent.reload_state!
+    end
+  end
+
+  def trap_sigterm
+    Stud::trap("TERM") do
+      @logger.warn(I18n.t("logstash.agent.sigterm"))
+      @agent_task.stop!
+    end
+  end
+
+  def trap_sigint
+    Stud::trap("INT") do
+      if @interrupted_once
+        @logger.fatal(I18n.t("logstash.agent.forced_sigint"))
+        exit
+      else
+        @logger.warn(I18n.t("logstash.agent.sigint"))
+        Thread.new(@logger) {|logger| sleep 5; logger.warn(I18n.t("logstash.agent.slow_shutdown")) }
+        @interrupted_once = true
+        @agent_task.stop!
+      end
+    end
+  end
+
 end # class LogStash::Runner
diff --git a/logstash-core/lib/logstash/shutdown_watcher.rb b/logstash-core/lib/logstash/shutdown_watcher.rb
index 82d5aa216a7..fa0d1f01fd4 100644
--- a/logstash-core/lib/logstash/shutdown_watcher.rb
+++ b/logstash-core/lib/logstash/shutdown_watcher.rb
@@ -34,8 +34,8 @@ def self.logger
     end
 
     def self.start(pipeline, cycle_period=CHECK_EVERY, report_every=REPORT_EVERY, abort_threshold=ABORT_AFTER)
-      watcher = self.new(pipeline, cycle_period, report_every, abort_threshold)
-      Thread.new(watcher) { |watcher| watcher.start }
+      controller = self.new(pipeline, cycle_period, report_every, abort_threshold)
+      Thread.new(controller) { |controller| controller.start }
     end
 
     def logger
@@ -47,6 +47,7 @@ def start
       cycle_number = 0
       stalled_count = 0
       Stud.interval(@cycle_period) do
+        break unless @pipeline.thread.alive?
         @reports << pipeline_report_snapshot
         @reports.delete_at(0) if @reports.size > @report_every # expire old report
         if cycle_number == (@report_every - 1) # it's report time!
diff --git a/logstash-core/locales/en.yml b/logstash-core/locales/en.yml
index f2d1666ee11..163f7ea7ef2 100644
--- a/logstash-core/locales/en.yml
+++ b/logstash-core/locales/en.yml
@@ -5,7 +5,7 @@
 en:
   oops: |-
     The error reported is: 
-      %{error}
+      %{error} %{backtrace}
   logstash:
     error: >-
       Error: %{error}
@@ -60,9 +60,9 @@ en:
       sighup: >-
         SIGHUP received.
       sigint: >-
-        SIGINT received. Shutting down the pipeline.
+        SIGINT received. Shutting down the agent.
       sigterm: >-
-        SIGTERM received. Shutting down the pipeline.
+        SIGTERM received. Shutting down the agent.
       slow_shutdown: |-
         Received shutdown signal, but pipeline is still waiting for in-flight events
         to be processed. Sending another ^C will force quit Logstash, but this may cause
@@ -72,7 +72,7 @@ en:
     runner:
       short-help: |-
         usage:
-          bin/logstash -f CONFIG_FILE [-t] [--quiet|verbose|debug] [-w COUNT] [-l LOG]
+          bin/logstash -f CONFIG_PATH [-t] [-r] [--quiet|verbose|debug] [-w COUNT] [-l LOG]
           bin/logstash -e CONFIG_STR [-t] [--quiet|verbose|debug] [-w COUNT] [-l LOG]
           bin/logstash -i SHELL [--quiet|verbose|debug]
           bin/logstash -V [--verbose|debug]
@@ -80,6 +80,8 @@ en:
       missing-configuration: >-
         No configuration file was specified. Perhaps you forgot to provide
         the '-f yourlogstash.conf' flag?
+      reload-without-config-path: >-
+        Configuration reloading also requires passing a configuration path with '-f yourlogstash.conf'
       invalid-shell: >-
         Invalid option for interactive Ruby shell. Use either "irb" or "pry"
       configtest-flag-information: |-
@@ -171,6 +173,10 @@ en:
         pipeline-batch-delay: |+
           When creating pipeline batches, how long to wait while polling
           for the next event.
+        auto_reload: |+
+          Monitor configuration changes and reload
+          whenever it is changed.
+          NOTE: use SIGHUP to manually reload the config
         log: |+
           Write logstash internal logs to the given
           file. Without this flag, logstash will emit
@@ -212,3 +218,5 @@ en:
         node_name: |+
           Specify the name of this logstash instance, if no value is given
           it will default to the current hostname.
+        agent: |+
+          Specify an alternate agent plugin name.
diff --git a/logstash-core/spec/logstash/agent_spec.rb b/logstash-core/spec/logstash/agent_spec.rb
index 4caf2059995..1fae820b32a 100644
--- a/logstash-core/spec/logstash/agent_spec.rb
+++ b/logstash-core/spec/logstash/agent_spec.rb
@@ -1,27 +1,187 @@
 # encoding: utf-8
-require "logstash/agent"
-require "spec_helper"
+require 'spec_helper'
+require 'stud/temporary'
 
 describe LogStash::Agent do
-  context "#node_name" do
-    let(:hostname) { "the-logstash" }
 
-    before do
-      allow(Socket).to receive(:gethostname).and_return(hostname)
+  let(:logger) { double("logger") }
+  let(:agent_args) { { :logger => logger } }
+  subject { LogStash::Agent.new(agent_args) }
+
+  before :each do
+    [:info, :warn, :error, :fatal, :debug].each do |level|
+      allow(logger).to receive(level)
+    end
+    [:info?, :warn?, :error?, :fatal?, :debug?].each do |level|
+      allow(logger).to receive(level)
+    end
+  end
+
+  describe "register_pipeline" do
+    let(:pipeline_id) { "main" }
+    let(:settings) { {
+      :config_string => "input { } filter { } output { }",
+      :pipeline_workers => 4
+    } }
+
+    let(:agent_args) { {
+      :logger => logger,
+      :auto_reload => false,
+      :reload_interval => 0.01
+    } }
+
+    it "should delegate settings to new pipeline" do
+      expect(LogStash::Pipeline).to receive(:new).with(settings[:config_string], hash_including(settings))
+      subject.register_pipeline(pipeline_id, settings)
+    end
+  end
+
+  describe "#execute" do
+    let(:sample_config) { "input { generator { count => 100000 } } output { stdout { } }" }
+    let(:config_file) { Stud::Temporary.pathname }
+
+    before :each do
+      File.open(config_file, "w") {|f| f.puts sample_config }
+    end
+
+    after :each do
+      File.unlink(config_file)
+    end
+
+    context "when auto_reload is false" do
+      let(:agent_args) { { :logger => logger, :auto_reload => false, :reload_interval => 0.01, :config_path => config_file } }
+
+      before :each do
+        allow(subject).to receive(:sleep)
+        allow(subject).to receive(:clean_state?).and_return(false)
+        allow(subject).to receive(:running_pipelines?).and_return(true)
+      end
+
+      context "if state is clean" do
+        it "should not reload_state!" do
+          expect(subject).to_not receive(:reload_state!)
+          t = Thread.new { subject.execute }
+          sleep 0.1
+          Stud.stop!(t)
+          t.join
+        end
+      end
+    end
+
+    context "when auto_reload is true" do
+      let(:agent_args) { { :logger => logger, :auto_reload => true, :reload_interval => 0.01 } }
+      context "if state is clean" do
+        it "should periodically reload_state" do
+          allow(subject).to receive(:clean_state?).and_return(false)
+          expect(subject).to receive(:reload_state!).at_least(3).times
+          t = Thread.new { subject.execute }
+          sleep 0.1
+          Stud.stop!(t)
+          t.join
+        end
+      end
     end
+  end
+
+  describe "#reload_state!" do
+    let(:pipeline_id) { "main" }
+    let(:first_pipeline_config) { "input { } filter { } output { }" }
+    let(:second_pipeline_config) { "input { generator {} } filter { } output { }" }
+    let(:pipeline_settings) { {
+      :config_string => first_pipeline_config,
+      :pipeline_workers => 4
+    } }
 
-    it "fallback to hostname when no name is provided" do
-      expect(LogStash::Agent.new.node_name).to be(hostname)
+    before(:each) do
+      subject.register_pipeline(pipeline_id, pipeline_settings)
     end
 
-    it "uses the user provided name" do
-      expect(LogStash::Agent.new({ :node_name => "a-name" }).node_name).to eq("a-name")
+    context "when fetching a new state" do
+      it "upgrades the state" do
+        expect(subject).to receive(:fetch_config).and_return(second_pipeline_config)
+        expect(subject).to receive(:upgrade_pipeline).with(pipeline_id, kind_of(LogStash::Pipeline))
+        subject.send(:reload_state!)
+      end
+    end
+    context "when fetching the same state" do
+      it "doesn't upgrade the state" do
+        expect(subject).to receive(:fetch_config).and_return(first_pipeline_config)
+        expect(subject).to_not receive(:upgrade_pipeline)
+        subject.send(:reload_state!)
+      end
     end
   end
 
-  context "#node_uuid" do
-    it "create a unique uuid between agent instances" do
-      expect(LogStash::Agent.new.node_uuid).not_to be(LogStash::Agent.new.node_uuid)
+  describe "#upgrade_pipeline" do
+    let(:pipeline_id) { "main" }
+    let(:pipeline_config) { "input { } filter { } output { }" }
+    let(:pipeline_settings) { {
+      :config_string => pipeline_config,
+      :pipeline_workers => 4
+    } }
+    let(:new_pipeline_config) { "input { generator {} } output { }" }
+
+    before(:each) do
+      subject.register_pipeline(pipeline_id, pipeline_settings)
+    end
+
+    context "when the upgrade fails" do
+      before :each do
+        allow(subject).to receive(:fetch_config).and_return(new_pipeline_config)
+        allow(subject).to receive(:create_pipeline).and_return(nil)
+        allow(subject).to receive(:stop_pipeline)
+      end
+
+      it "leaves the state untouched" do
+        subject.send(:reload_state!)
+        expect(subject.pipelines[pipeline_id].config_str).to eq(pipeline_config)
+      end
+
+      context "and current state is empty" do
+        it "should not start a pipeline" do
+          expect(subject).to_not receive(:start_pipeline)
+          subject.send(:reload_state!)
+        end
+      end
+    end
+
+    context "when the upgrade succeeds" do
+      let(:new_config) { "input { generator { count => 1 } } output { }" }
+      before :each do
+        allow(subject).to receive(:fetch_config).and_return(new_config)
+        allow(subject).to receive(:stop_pipeline)
+      end
+      it "updates the state" do
+        subject.send(:reload_state!)
+        expect(subject.pipelines[pipeline_id].config_str).to eq(new_config)
+      end
+      it "starts the pipeline" do
+        expect(subject).to receive(:stop_pipeline)
+        expect(subject).to receive(:start_pipeline)
+        subject.send(:reload_state!)
+      end
     end
   end
+
+  describe "#fetch_config" do
+    let(:file_config) { "input { generator { count => 100 } } output { stdout { } }" }
+    let(:cli_config) { "filter { drop { } } " }
+    let(:tmp_config_path) { Stud::Temporary.pathname }
+    let(:agent_args) { { :logger => logger, :config_string => "filter { drop { } } ", :config_path => tmp_config_path } }
+
+    before :each do
+      IO.write(tmp_config_path, file_config)
+    end
+
+    after :each do
+      File.unlink(tmp_config_path)
+    end
+
+    it "should join the config string and config path content" do
+      settings = { :config_path => tmp_config_path, :config_string => cli_config }
+      fetched_config = subject.send(:fetch_config, settings)
+      expect(fetched_config.strip).to eq(cli_config + IO.read(tmp_config_path))
+    end
+
+  end
 end
diff --git a/logstash-core/spec/logstash/config/loader_spec.rb b/logstash-core/spec/logstash/config/loader_spec.rb
new file mode 100644
index 00000000000..b51272ee13a
--- /dev/null
+++ b/logstash-core/spec/logstash/config/loader_spec.rb
@@ -0,0 +1,36 @@
+# encoding: utf-8
+require "spec_helper"
+require "logstash/config/loader"
+
+describe LogStash::Config::Loader do
+  subject { described_class.new(Cabin::Channel.get) }
+  context "when local" do
+    before { expect(subject).to receive(:local_config).with(path) }
+
+    context "unix" do
+      let(:path) { './test.conf' }
+      it 'works with relative path' do
+        subject.load_config(path)
+      end
+    end
+
+    context "windows" do
+      let(:path) { '.\test.conf' }
+      it 'work with relative windows path' do
+        subject.load_config(path)
+      end
+    end
+  end
+
+  context "when remote" do
+    context 'supported scheme' do
+      let(:path) { "http://test.local/superconfig.conf" }
+      let(:dummy_config) { 'input {}' }
+
+      before { expect(Net::HTTP).to receive(:get) { dummy_config } }
+      it 'works with http' do
+        expect(subject.load_config(path)).to eq("#{dummy_config}\n")
+      end
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/runner_spec.rb b/logstash-core/spec/logstash/runner_spec.rb
index 711bb18183c..a2faefe7a5c 100644
--- a/logstash-core/spec/logstash/runner_spec.rb
+++ b/logstash-core/spec/logstash/runner_spec.rb
@@ -18,15 +18,22 @@ def run(args); end
   end
 
   describe "argument parsing" do
-
     subject { LogStash::Runner.new("") }
     context "when -e is given" do
 
-      let(:args) { ["-e", ""] }
+      let(:args) { ["-e", "input {} output {}"] }
+      let(:agent) { double("agent") }
+      let(:agent_logger) { double("agent logger") }
+
+      before do
+        allow(agent).to receive(:logger=).with(anything)
+        allow(agent).to receive(:shutdown)
+        allow(agent).to receive(:register_pipeline)
+      end
 
       it "should execute the agent" do
-        expect_any_instance_of(LogStash::Agent).to receive(:add_pipeline).once
-        expect_any_instance_of(LogStash::Agent).to receive(:execute).once
+        expect(subject).to receive(:create_agent).and_return(agent)
+        expect(agent).to receive(:execute).once
         subject.run(args)
       end
     end
@@ -34,47 +41,14 @@ def run(args); end
     context "with no arguments" do
       let(:args) { [] }
       it "should show help" do
+        expect($stderr).to receive(:puts).once
+        expect(subject).to receive(:signal_usage_error).once.and_call_original
         expect(subject).to receive(:show_short_help).once
-        expect(channel).to receive(:fatal).once
-        expect(channel).to receive(:warn).once
         subject.run(args)
       end
     end
   end
 
-  context "when loading the configuration" do
-    subject { LogStash::Runner.new("") }
-    context "when local" do
-      before { expect(subject).to receive(:local_config).with(path) }
-
-      context "unix" do
-        let(:path) { './test.conf' }
-        it 'works with relative path' do
-          subject.load_config(path)
-        end
-      end
-
-      context "windows" do
-        let(:path) { '.\test.conf' }
-        it 'work with relative windows path' do
-          subject.load_config(path)
-        end
-      end
-    end
-
-    context "when remote" do
-      context 'supported scheme' do
-        let(:path) { "http://test.local/superconfig.conf" }
-        let(:dummy_config) { 'input {}' }
-
-        before { expect(Net::HTTP).to receive(:get) { dummy_config } }
-        it 'works with http' do
-          expect(subject.load_config(path)).to eq("#{dummy_config}\n")
-        end
-      end
-    end
-  end
-
   context "--pluginpath" do
     subject { LogStash::Runner.new("") }
     let(:single_path) { "/some/path" }
@@ -89,7 +63,7 @@ def run(args); end
     it "should fail with single invalid dir path" do
       expect(File).to receive(:directory?).and_return(false)
       expect(LogStash::Environment).not_to receive(:add_plugin_path)
-      expect{subject.configure_plugin_paths(single_path)}.to raise_error(LogStash::ConfigurationError)
+      expect{subject.configure_plugin_paths(single_path)}.to raise_error(Clamp::UsageError)
     end
 
     it "should add multiple valid dir path to the environment" do
@@ -99,28 +73,43 @@ def run(args); end
     end
   end
 
+  context "--auto-reload" do
+    subject { LogStash::Runner.new("") }
+    context "when -f is not given" do
+
+      let(:args) { ["-r", "-e", "input {} output {}"] }
+
+      it "should exit immediately" do
+        expect(subject).to receive(:signal_usage_error).and_call_original
+        expect(subject).to receive(:show_short_help)
+        expect(subject.run(args)).to eq(1)
+      end
+    end
+  end
+
   describe "pipeline settings" do
     let(:pipeline_string) { "input { stdin {} } output { stdout {} }" }
-    let(:base_pipeline_settings) { { :pipeline_id => "base" } }
+    let(:main_pipeline_settings) { { :pipeline_id => "main" } }
     let(:pipeline) { double("pipeline") }
 
     before(:each) do
       task = Stud::Task.new { 1 }
       allow(pipeline).to receive(:run).and_return(task)
+      allow(pipeline).to receive(:shutdown)
     end
 
-    context "when pipeline workers is not defined by the user" do
+    context "when :pipeline_workers is not defined by the user" do
       it "should not pass the value to the pipeline" do
-        expect(LogStash::Pipeline).to receive(:new).with(pipeline_string, base_pipeline_settings).and_return(pipeline)
+        expect(LogStash::Pipeline).to receive(:new).once.with(pipeline_string, hash_excluding(:pipeline_workers)).and_return(pipeline)
         args = ["-e", pipeline_string]
         subject.run("bin/logstash", args)
       end
     end
 
-    context "when pipeline workers is defined by the user" do
+    context "when :pipeline_workers is defined by the user" do
       it "should pass the value to the pipeline" do
-        base_pipeline_settings[:pipeline_workers] = 2
-        expect(LogStash::Pipeline).to receive(:new).with(pipeline_string, base_pipeline_settings).and_return(pipeline)
+        main_pipeline_settings[:pipeline_workers] = 2
+        expect(LogStash::Pipeline).to receive(:new).with(pipeline_string, hash_including(main_pipeline_settings)).and_return(pipeline)
         args = ["-w", "2", "-e", pipeline_string]
         subject.run("bin/logstash", args)
       end
diff --git a/logstash-core/spec/logstash/shutdown_watcher_spec.rb b/logstash-core/spec/logstash/shutdown_watcher_spec.rb
index 28dfa2f12c0..118e126ea5d 100644
--- a/logstash-core/spec/logstash/shutdown_watcher_spec.rb
+++ b/logstash-core/spec/logstash/shutdown_watcher_spec.rb
@@ -17,6 +17,7 @@
     LogStash::ShutdownWatcher.logger = channel
 
     allow(pipeline).to receive(:reporter).and_return(reporter)
+    allow(pipeline).to receive(:thread).and_return(Thread.current)
     allow(reporter).to receive(:snapshot).and_return(reporter_snapshot)
     allow(reporter_snapshot).to receive(:o_simple_hash).and_return({})
 
