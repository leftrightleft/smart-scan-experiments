diff --git a/logstash-core/lib/logstash/codecs/base.rb b/logstash-core/lib/logstash/codecs/base.rb
index db4cde703ce..081a3b376e3 100644
--- a/logstash-core/lib/logstash/codecs/base.rb
+++ b/logstash-core/lib/logstash/codecs/base.rb
@@ -92,6 +92,8 @@ def flush(&block)
 
   public
   def clone
-    return self.class.new(params)
+    LogStash::Plugins::Contextualizer.initialize_plugin(execution_context, self.class, params).tap do |klone|
+      klone.metric = @metric if klone.instance_variable_get(:@metric).nil?
+    end
   end
 end; end # class LogStash::Codecs::Base
diff --git a/logstash-core/lib/logstash/config/config_ast.rb b/logstash-core/lib/logstash/config/config_ast.rb
index e3d413bf5e4..c7c5f9cfee0 100644
--- a/logstash-core/lib/logstash/config/config_ast.rb
+++ b/logstash-core/lib/logstash/config/config_ast.rb
@@ -249,12 +249,12 @@ def compile_initializer
       # If any parent is a Plugin, this must be a codec.
 
       if attributes.elements.nil?
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, line_to_source(#{source_meta.line}, #{source_meta.column}))" << (plugin_type == "codec" ? "" : "\n")
+        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, {}, line_to_source(#{source_meta.line}, #{source_meta.column}))" << (plugin_type == "codec" ? "" : "\n")
       else
         settings = attributes.recursive_select(Attribute).collect(&:compile).reject(&:empty?)
 
         attributes_code = "LogStash::Util.hash_merge_many(#{settings.map { |c| "{ #{c} }" }.join(", ")})"
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, line_to_source(#{source_meta.line}, #{source_meta.column}), #{attributes_code})" << (plugin_type == "codec" ? "" : "\n")
+        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, #{attributes_code}, line_to_source(#{source_meta.line}, #{source_meta.column}))" << (plugin_type == "codec" ? "" : "\n")
       end
     end
 
@@ -271,7 +271,7 @@ def compile
       when "codec"
         settings = attributes.recursive_select(Attribute).collect(&:compile).reject(&:empty?)
         attributes_code = "LogStash::Util.hash_merge_many(#{settings.map { |c| "{ #{c} }" }.join(", ")})"
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, line_to_source(#{source_meta.line}, #{source_meta.column}), #{attributes_code})"
+        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, #{attributes_code}, line_to_source(#{source_meta.line}, #{source_meta.column}))"
       end
     end
 
diff --git a/logstash-core/lib/logstash/config/mixin.rb b/logstash-core/lib/logstash/config/mixin.rb
index a8febea0b0e..ac03ac3b28c 100644
--- a/logstash-core/lib/logstash/config/mixin.rb
+++ b/logstash-core/lib/logstash/config/mixin.rb
@@ -99,6 +99,17 @@ def config_init(params)
       params[name.to_s] = deep_replace(value)
     end
 
+    # Intercept codecs that have not been instantiated
+    params.each do |name, value|
+      validator = self.class.validator_find(name)
+      next unless validator && validator[:validate] == :codec && value.kind_of?(String)
+
+      codec_klass = LogStash::Plugin.lookup("codec", value)
+      codec_instance = LogStash::Plugins::Contextualizer.initialize_plugin(execution_context, codec_klass)
+
+      params[name.to_s] = LogStash::Codecs::Delegator.new(codec_instance)
+    end
+
     if !self.class.validate(params)
       raise LogStash::ConfigurationError,
         I18n.t("logstash.runner.configuration.invalid_plugin_settings")
diff --git a/logstash-core/lib/logstash/inputs/base.rb b/logstash-core/lib/logstash/inputs/base.rb
index a01b011e3f8..e12d805b981 100644
--- a/logstash-core/lib/logstash/inputs/base.rb
+++ b/logstash-core/lib/logstash/inputs/base.rb
@@ -122,16 +122,6 @@ def metric=(metric)
     metric
   end
 
-  def execution_context=(context)
-    super
-    # There is no easy way to propage an instance variable into the codec, because the codec
-    # are created at the class level
-    # TODO(talevy): Codecs should have their own execution_context, for now they will inherit their
-    #               parent plugin's
-    @codec.execution_context = context
-    context
-  end
-
   protected
   def decorate(event)
     # Only set 'type' if not already set. This is backwards-compatible behavior
diff --git a/logstash-core/lib/logstash/outputs/base.rb b/logstash-core/lib/logstash/outputs/base.rb
index c52dad18f9b..59f30a422aa 100644
--- a/logstash-core/lib/logstash/outputs/base.rb
+++ b/logstash-core/lib/logstash/outputs/base.rb
@@ -125,16 +125,6 @@ def metric=(metric)
     metric
   end
 
-  def execution_context=(context)
-    super
-    # There is no easy way to propage an instance variable into the codec, because the codec
-    # are created at the class level
-    # TODO(talevy): Codecs should have their own execution_context, for now they will inherit their
-    #               parent plugin's
-    @codec.execution_context = context
-    context
-  end
-
   private
   def output?(event)
     # TODO: noop for now, remove this once we delete this call from all plugins
diff --git a/logstash-core/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
index 54089d5180a..6b3ec1733eb 100644
--- a/logstash-core/lib/logstash/pipeline.rb
+++ b/logstash-core/lib/logstash/pipeline.rb
@@ -89,8 +89,8 @@ def non_reloadable_plugins
   private
 
 
-  def plugin(plugin_type, name, source, *args)
-    @plugin_factory.plugin(plugin_type, name, source, *args)
+  def plugin(plugin_type, name, args, source)
+    @plugin_factory.plugin(plugin_type, name, args, source)
   end
 
   def default_logging_keys(other_keys = {})
diff --git a/logstash-core/lib/logstash/plugin.rb b/logstash-core/lib/logstash/plugin.rb
index b376bd7d71f..4d2a625c582 100644
--- a/logstash-core/lib/logstash/plugin.rb
+++ b/logstash-core/lib/logstash/plugin.rb
@@ -24,7 +24,8 @@
 class LogStash::Plugin
   include LogStash::Util::Loggable
 
-  attr_accessor :params, :execution_context
+  attr_accessor :params
+  attr_reader :execution_context
 
   NL = "\n"
 
@@ -60,7 +61,7 @@ def eql?(other)
     self.class.name == other.class.name && @params == other.params
   end
 
-  def initialize(params=nil)
+  def initialize(params={})
     @logger = self.logger
     @deprecation_logger = self.deprecation_logger
     # need to access settings statically because plugins are initialized in config_ast with no context.
@@ -177,4 +178,34 @@ def self.lookup(type, name)
   def plugin_metadata
     LogStash::PluginMetadata.for_plugin(self.id)
   end
+
+  # Deprecated attr_writer for execution_context
+  def execution_context=(new_context)
+    @deprecation_logger.deprecated("LogStash::Plugin#execution_context=(new_ctx) is deprecated. Use LogStash::Plugins::Contextualizer#initialize_plugin(new_ctx, klass, args) instead", :caller => caller.first)
+    @execution_context = new_context
+  end
+
+  private
+
+  ##
+  # Returns the setting's value, or yields to the provided block.
+  #
+  # @param setting_name [String]
+  # @yieldparam setting_name [String]: the name of the setting is yielded if the setting is not available
+  # @yieldreturn [Object]: the default value, if the specified setting is not available
+  def get_setting(setting_name)
+    fail("block required!") unless block_given?
+
+    pipeline = execution_context && execution_context.pipeline
+    settings = pipeline && pipeline.settings
+
+    if settings.nil?
+      @logger.warn("Per-pipeline settings not available; using global settings instead")
+      settings = LogStash::SETTINGS
+    end
+
+    return settings.get_value(setting_name) if settings.registered?(setting_name)
+
+    return yield(setting_name)
+  end
 end # class LogStash::Plugin
diff --git a/logstash-core/src/main/java/org/logstash/RubyUtil.java b/logstash-core/src/main/java/org/logstash/RubyUtil.java
index d802679235b..b4b06c45465 100644
--- a/logstash-core/src/main/java/org/logstash/RubyUtil.java
+++ b/logstash-core/src/main/java/org/logstash/RubyUtil.java
@@ -74,6 +74,7 @@
 import org.logstash.log.SlowLoggerExt;
 import org.logstash.plugins.HooksRegistryExt;
 import org.logstash.plugins.UniversalPluginExt;
+import org.logstash.plugins.factory.ContextualizerExt;
 import org.logstash.util.UtilExt;
 import org.logstash.plugins.factory.ExecutionContextFactoryExt;
 import org.logstash.plugins.factory.PluginMetricsFactoryExt;
@@ -199,6 +200,8 @@ public final class RubyUtil {
 
     public static final RubyClass PLUGIN_FACTORY_CLASS;
 
+    public static final RubyModule PLUGIN_CONTEXTUALIZER_MODULE;
+
     public static final RubyClass LOGGER;
 
     public static final RubyModule LOGGABLE_MODULE;
@@ -551,6 +554,8 @@ public final class RubyUtil {
             "PluginFactory", RUBY.getObject(), PluginFactoryExt::new
         );
         PLUGIN_FACTORY_CLASS.defineAnnotatedMethods(PluginFactoryExt.class);
+        PLUGIN_CONTEXTUALIZER_MODULE = PLUGINS_MODULE.defineOrGetModuleUnder("Contextualizer");
+        PLUGIN_CONTEXTUALIZER_MODULE.defineAnnotatedMethods(ContextualizerExt.class);
         UNIVERSAL_PLUGIN_CLASS =
             setupLogstashClass(UniversalPluginExt::new, UniversalPluginExt.class);
         EVENT_DISPATCHER_CLASS =
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java b/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
index 092e1c0e578..026ef64c999 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
@@ -164,8 +164,9 @@ private Map<String, AbstractOutputDelegatorExt> setupOutputs(ConfigVariableExpan
         outs.forEach(v -> {
             final PluginDefinition def = v.getPluginDefinition();
             final SourceWithMetadata source = v.getSourceWithMetadata();
+            final Map<String, Object> args = expandArguments(def, cve);
             res.put(v.getId(), pluginFactory.buildOutput(
-                RubyUtil.RUBY.newString(def.getName()), source, convertArgs(def), convertJavaArgs(def, cve)
+                RubyUtil.RUBY.newString(def.getName()), convertArgs(args), source
             ));
         });
         return res;
@@ -181,8 +182,9 @@ private Map<String, AbstractFilterDelegatorExt> setupFilters(ConfigVariableExpan
         for (final PluginVertex vertex : filterPlugins) {
             final PluginDefinition def = vertex.getPluginDefinition();
             final SourceWithMetadata source = vertex.getSourceWithMetadata();
+            final Map<String, Object> args = expandArguments(def, cve);
             res.put(vertex.getId(), pluginFactory.buildFilter(
-                RubyUtil.RUBY.newString(def.getName()), source, convertArgs(def), convertJavaArgs(def, cve)
+                RubyUtil.RUBY.newString(def.getName()), convertArgs(args), source
             ));
         }
         return res;
@@ -197,71 +199,47 @@ private Collection<IRubyObject> setupInputs(ConfigVariableExpander cve) {
         vertices.forEach(v -> {
             final PluginDefinition def = v.getPluginDefinition();
             final SourceWithMetadata source = v.getSourceWithMetadata();
+            final Map<String, Object> args = expandArguments(def, cve);
             IRubyObject o = pluginFactory.buildInput(
-                RubyUtil.RUBY.newString(def.getName()), source, convertArgs(def), convertJavaArgs(def, cve));
+                RubyUtil.RUBY.newString(def.getName()), convertArgs(args), source);
             nodes.add(o);
         });
         return nodes;
     }
 
-    /**
-     * Converts plugin arguments from the format provided by {@link PipelineIR} into coercible
-     * Ruby types.
-     * @param def PluginDefinition as provided by {@link PipelineIR}
-     * @return RubyHash of plugin arguments as understood by {@link RubyIntegration.PluginFactory}
-     * methods
-     */
-    private RubyHash convertArgs(final PluginDefinition def) {
+
+    final RubyHash convertArgs(final Map<String, Object> input) {
         final RubyHash converted = RubyHash.newHash(RubyUtil.RUBY);
-        for (final Map.Entry<String, Object> entry : def.getArguments().entrySet()) {
+        for (final Map.Entry<String, Object> entry : input.entrySet()) {
             final Object value = entry.getValue();
             final String key = entry.getKey();
-            final Object toput;
-            if (value instanceof PluginStatement) {
-                final PluginDefinition codec = ((PluginStatement) value).getPluginDefinition();
-                SourceWithMetadata source = ((PluginStatement) value).getSourceWithMetadata();
-                toput = pluginFactory.buildCodec(
-                    RubyUtil.RUBY.newString(codec.getName()),
-                    source,
-                    Rubyfier.deep(RubyUtil.RUBY, codec.getArguments()),
-                    codec.getArguments()
-                );
-            } else {
-                toput = value;
-            }
-            converted.put(key, toput);
+            converted.put(key, value);
         }
+
         return converted;
     }
 
-    /**
-     * Converts plugin arguments from the format provided by {@link PipelineIR} into coercible
-     * Java types for consumption by Java plugins.
-     * @param def PluginDefinition as provided by {@link PipelineIR}
-     * @return Map of plugin arguments as understood by the {@link RubyIntegration.PluginFactory}
-     * methods that create Java plugins
-     */
-    private Map<String, Object> convertJavaArgs(final PluginDefinition def, ConfigVariableExpander cve) {
-        Map<String, Object> args = expandConfigVariables(cve, def.getArguments());
-        for (final Map.Entry<String, Object> entry : args.entrySet()) {
-            final Object value = entry.getValue();
+
+    private Map<String, Object> expandArguments(final PluginDefinition pluginDefinition, final ConfigVariableExpander cve) {
+        Map<String, Object> arguments = expandConfigVariables(cve, pluginDefinition.getArguments());
+
+        // Intercept codec definitions from LIR
+        for (final Map.Entry<String, Object> entry : arguments.entrySet()) {
             final String key = entry.getKey();
-            final IRubyObject toput;
+            final Object value = entry.getValue();
             if (value instanceof PluginStatement) {
-                final PluginDefinition codec = ((PluginStatement) value).getPluginDefinition();
-                SourceWithMetadata source = ((PluginStatement) value).getSourceWithMetadata();
-                Map<String, Object> codecArgs = expandConfigVariables(cve, codec.getArguments());
-                toput = pluginFactory.buildCodec(
-                    RubyUtil.RUBY.newString(codec.getName()),
-                    source,
-                    Rubyfier.deep(RubyUtil.RUBY, codec.getArguments()),
-                    codecArgs
-                );
-                Codec javaCodec = (Codec)JavaUtil.unwrapJavaValue(toput);
-                args.put(key, javaCodec);
+                final PluginStatement codecPluginStatement = (PluginStatement) value;
+                final PluginDefinition codecDefinition = codecPluginStatement.getPluginDefinition();
+                final SourceWithMetadata codecSource = codecPluginStatement.getSourceWithMetadata();
+                final Map<String, Object> codecArguments = expandArguments(codecDefinition, cve);
+                IRubyObject codecInstance = pluginFactory.buildCodec(RubyUtil.RUBY.newString(codecDefinition.getName()),
+                        Rubyfier.deep(RubyUtil.RUBY, codecArguments),
+                        codecSource);
+                arguments.put(key, codecInstance);
             }
         }
-        return args;
+
+        return arguments;
     }
 
     @SuppressWarnings({"rawtypes", "unchecked"})
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/OutputStrategyExt.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/OutputStrategyExt.java
index c5afaac0592..59948ee1828 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/OutputStrategyExt.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/OutputStrategyExt.java
@@ -35,6 +35,9 @@
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.logstash.RubyUtil;
+import org.logstash.execution.ExecutionContextExt;
+
+import static org.logstash.RubyUtil.PLUGIN_CONTEXTUALIZER_MODULE;
 
 public final class OutputStrategyExt {
 
@@ -184,13 +187,14 @@ public IRubyObject initialize(final ThreadContext context, final IRubyObject[] a
             final int count = workerCount.convertToInteger().getIntValue();
             workerQueue = new ArrayBlockingQueue<>(count);
             workers = context.runtime.newArray(count);
+            final ExecutionContextExt executionContext = (ExecutionContextExt) args[2];
             for (int i = 0; i < count; ++i) {
                 final RubyClass outputClass = (RubyClass) args[0];
+                // TODO: this comment is a warning sign that I'll need to fix up mocks
                 // Calling "new" here manually to allow mocking the ctor in RSpec Tests
-                final IRubyObject output = outputClass.callMethod(context, "new", pluginArgs);
+                final IRubyObject output = PLUGIN_CONTEXTUALIZER_MODULE.callMethod("initialize_plugin", executionContext, outputClass, pluginArgs);
                 initOutputCallsite(outputClass);
                 output.callMethod(context, "metric=", args[1]);
-                output.callMethod(context, "execution_context=", args[2]);
                 workers.append(output);
                 workerQueue.add(output);
             }
@@ -248,11 +252,12 @@ protected SimpleAbstractOutputStrategyExt(final Ruby runtime, final RubyClass me
         @JRubyMethod(required = 4)
         public IRubyObject initialize(final ThreadContext context, final IRubyObject[] args) {
             final RubyClass outputClass = (RubyClass) args[0];
+            final ExecutionContextExt executionContext = (ExecutionContextExt) args[2];
+            // TODO: fixup mocks
             // Calling "new" here manually to allow mocking the ctor in RSpec Tests
-            output = args[0].callMethod(context, "new", args[3]);
+            output = PLUGIN_CONTEXTUALIZER_MODULE.callMethod("initialize_plugin", executionContext, outputClass, args[3]);
             initOutputCallsite(outputClass);
             output.callMethod(context, "metric=", args[1]);
-            output.callMethod(context, "execution_context=", args[2]);
             return this;
         }
 
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/PluginFactory.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/PluginFactory.java
deleted file mode 100644
index e476ad4368b..00000000000
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/PluginFactory.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Licensed to Elasticsearch B.V. under one or more contributor
- * license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright
- * ownership. Elasticsearch B.V. licenses this file to you under
- * the Apache License, Version 2.0 (the "License"); you may
- * not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *	http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-
-package org.logstash.config.ir.compiler;
-
-import co.elastic.logstash.api.Codec;
-import org.jruby.RubyString;
-import org.jruby.runtime.builtin.IRubyObject;
-import co.elastic.logstash.api.Configuration;
-import co.elastic.logstash.api.Context;
-import co.elastic.logstash.api.Filter;
-import co.elastic.logstash.api.Input;
-import org.logstash.common.SourceWithMetadata;
-
-import java.util.Map;
-
-/**
- * Factory that can instantiate Java plugins as well as Ruby plugins.
- */
-public interface PluginFactory extends RubyIntegration.PluginFactory {
-
-    Input buildInput(String name, String id, Configuration configuration, Context context);
-
-    Filter buildFilter(String name, String id, Configuration configuration, Context context);
-
-    final class Default implements PluginFactory {
-
-        private final RubyIntegration.PluginFactory rubyFactory;
-
-        public Default(final RubyIntegration.PluginFactory rubyFactory) {
-            this.rubyFactory = rubyFactory;
-        }
-
-        @Override
-        public Input buildInput(final String name, final String id, final Configuration configuration, final Context context) {
-            return null;
-        }
-
-        @Override
-        public Filter buildFilter(final String name, final String id, final Configuration configuration, final Context context) {
-            return null;
-        }
-
-        @Override
-        public IRubyObject buildInput(final RubyString name, SourceWithMetadata source,
-                                      final IRubyObject args, Map<String, Object> pluginArgs) {
-            return rubyFactory.buildInput(name, source, args, pluginArgs);
-        }
-
-        @Override
-        public AbstractOutputDelegatorExt buildOutput(final RubyString name, SourceWithMetadata source,
-                                                      final IRubyObject args, final Map<String, Object> pluginArgs) {
-            return rubyFactory.buildOutput(name, source, args, pluginArgs);
-        }
-
-        @Override
-        public AbstractFilterDelegatorExt buildFilter(final RubyString name, SourceWithMetadata source,
-                                                      final IRubyObject args, final Map<String, Object> pluginArgs) {
-            return rubyFactory.buildFilter(name, source, args, pluginArgs);
-        }
-
-        @Override
-        public IRubyObject buildCodec(final RubyString name, SourceWithMetadata source, final IRubyObject args,
-                                      Map<String, Object> pluginArgs) {
-            return rubyFactory.buildCodec(name, source, args, pluginArgs);
-        }
-
-        @Override
-        public Codec buildDefaultCodec(final String codecName) {
-            return null;
-        }
-    }
-}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java
index faac9f66d38..bc66371c67a 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java
@@ -41,17 +41,13 @@ private RubyIntegration() {
      */
     public interface PluginFactory {
 
-        IRubyObject buildInput(RubyString name, SourceWithMetadata source,
-                               IRubyObject args, Map<String, Object> pluginArgs);
+        IRubyObject buildInput(RubyString name, IRubyObject args, SourceWithMetadata source);
 
-        AbstractOutputDelegatorExt buildOutput(RubyString name, SourceWithMetadata source,
-                                               IRubyObject args, Map<String, Object> pluginArgs);
+        AbstractOutputDelegatorExt buildOutput(RubyString name, IRubyObject args, SourceWithMetadata source);
 
-        AbstractFilterDelegatorExt buildFilter(RubyString name, SourceWithMetadata source, IRubyObject args,
-                                               Map<String, Object> pluginArgs);
+        AbstractFilterDelegatorExt buildFilter(RubyString name, IRubyObject args, SourceWithMetadata source);
 
-        IRubyObject buildCodec(RubyString name, SourceWithMetadata source, IRubyObject args,
-                               Map<String, Object> pluginArgs);
+        IRubyObject buildCodec(RubyString name, IRubyObject args, SourceWithMetadata source);
 
         Codec buildDefaultCodec(String codecName);
 
diff --git a/logstash-core/src/main/java/org/logstash/execution/Engine.java b/logstash-core/src/main/java/org/logstash/execution/Engine.java
new file mode 100644
index 00000000000..112b6bf2d84
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/execution/Engine.java
@@ -0,0 +1,7 @@
+package org.logstash.execution;
+
+public enum Engine {
+    RUBY,
+    JAVA,
+    ;
+}
diff --git a/logstash-core/src/main/java/org/logstash/execution/JavaBasePipelineExt.java b/logstash-core/src/main/java/org/logstash/execution/JavaBasePipelineExt.java
index aea003dde43..7d58f2c1a15 100644
--- a/logstash-core/src/main/java/org/logstash/execution/JavaBasePipelineExt.java
+++ b/logstash-core/src/main/java/org/logstash/execution/JavaBasePipelineExt.java
@@ -77,7 +77,8 @@ public JavaBasePipelineExt initialize(final ThreadContext context, final IRubyOb
                 new ExecutionContextFactoryExt(
                     context.runtime, RubyUtil.EXECUTION_CONTEXT_FACTORY_CLASS
                 ).initialize(context, args[3], this, dlqWriter(context)),
-                RubyUtil.FILTER_DELEGATOR_CLASS
+                RubyUtil.FILTER_DELEGATOR_CLASS,
+                Engine.JAVA
             ),
             getSecretStore(context)
         );
diff --git a/logstash-core/src/main/java/org/logstash/plugins/factory/ContextualizerExt.java b/logstash-core/src/main/java/org/logstash/plugins/factory/ContextualizerExt.java
new file mode 100644
index 00000000000..74fe1029ad1
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugins/factory/ContextualizerExt.java
@@ -0,0 +1,88 @@
+package org.logstash.plugins.factory;
+
+import org.jruby.RubyClass;
+import org.jruby.RubyModule;
+import org.jruby.anno.JRubyMethod;
+import org.jruby.anno.JRubyModule;
+import org.jruby.runtime.Block;
+import org.jruby.runtime.ThreadContext;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.logstash.execution.ExecutionContextExt;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.jruby.runtime.Helpers.invokeSuper;
+
+/**
+ * The {@link ContextualizerExt} is used to inject {@link org.logstash.execution.ExecutionContextExt } to plugins
+ * before they are initialized.
+ *
+ * @see ContextualizerExt#initializePlugin(ThreadContext, IRubyObject, IRubyObject[], Block)
+ */
+@JRubyModule(name = "Contextualizer")
+public class ContextualizerExt {
+
+    private static final String EXECUTION_CONTEXT_IVAR_NAME = "@execution_context";
+
+    /*
+     * @overload PluginContextualizer::initialize_plugin(execution_context, plugin_class, *plugin_args, &pluginBlock)
+     */
+    @JRubyMethod(name = "initialize_plugin", meta = true, required = 2, rest = true)
+    public static IRubyObject initializePlugin(final ThreadContext context,
+                                               final IRubyObject recv,
+                                               final IRubyObject[] args,
+                                               final Block block) {
+        final List<IRubyObject> argsList = new ArrayList<>(Arrays.asList(args));
+        final IRubyObject executionContext = argsList.remove(0); // ExecutionContextExt, NilClass
+        final RubyClass pluginClass = (RubyClass) argsList.remove(0);
+        final IRubyObject[] pluginArgs = argsList.toArray(new IRubyObject[]{});
+
+        return initializePlugin(context, (RubyModule) recv, executionContext, pluginClass, pluginArgs, block);
+    }
+
+    public static IRubyObject initializePlugin(final ThreadContext context,
+                                               final RubyModule recv,
+                                               final IRubyObject executionContext, // ExecutionContextExt, NilClass
+                                               final RubyClass pluginClass,
+                                               final IRubyObject[] pluginArgs,
+                                               final Block block) {
+        synchronized (ContextualizerExt.class) {
+            if (!pluginClass.hasModuleInPrepends(recv)) {
+                pluginClass.prepend(context, new IRubyObject[]{recv});
+            }
+        }
+
+        final IRubyObject[] pluginInitArgs;
+        if (executionContext.isNil()) {
+            pluginInitArgs = pluginArgs;
+        } else {
+            List<IRubyObject> pluginInitArgList = new ArrayList<>(1 + pluginArgs.length);
+            pluginInitArgList.add(executionContext);
+            pluginInitArgList.addAll(Arrays.asList(pluginArgs));
+            pluginInitArgs = pluginInitArgList.toArray(new IRubyObject[]{});
+        }
+
+        // We must use IRubyObject#callMethod(...,"new",...) here to continue supporting
+        // mocking/validating from rspec.
+        return  pluginClass.callMethod(context, "new", pluginInitArgs, block);
+    }
+
+    @JRubyMethod(name = "initialize", rest = true, frame = true) // framed for invokeSuper
+    public static IRubyObject initialize(final ThreadContext context,
+                                         final IRubyObject recv,
+                                         final IRubyObject[] args,
+                                         final Block block) {
+        final List<IRubyObject> argsList = new ArrayList<>(Arrays.asList(args));
+
+        if (args.length > 0 && args[0] instanceof ExecutionContextExt) {
+            final ExecutionContextExt executionContext = (ExecutionContextExt) argsList.remove(0);
+            recv.getInstanceVariables().setInstanceVariable(EXECUTION_CONTEXT_IVAR_NAME, executionContext);
+        }
+
+        final IRubyObject[] restArgs = argsList.toArray(new IRubyObject[]{});
+
+        return invokeSuper(context, recv, restArgs, block);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/factory/PluginFactoryExt.java b/logstash-core/src/main/java/org/logstash/plugins/factory/PluginFactoryExt.java
index a226e57d56d..c18b2aa82a8 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/factory/PluginFactoryExt.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/factory/PluginFactoryExt.java
@@ -5,6 +5,7 @@
 import org.jruby.anno.JRubyClass;
 import org.jruby.anno.JRubyMethod;
 import org.jruby.javasupport.JavaUtil;
+import org.jruby.runtime.Block;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.logstash.RubyUtil;
@@ -13,6 +14,7 @@
 import org.logstash.config.ir.PipelineIR;
 import org.logstash.config.ir.compiler.*;
 import org.logstash.config.ir.graph.Vertex;
+import org.logstash.execution.Engine;
 import org.logstash.execution.ExecutionContextExt;
 import org.logstash.instrument.metrics.AbstractMetricExt;
 import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
@@ -21,6 +23,9 @@
 import org.logstash.plugins.PluginLookup;
 
 import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+
+import static org.logstash.RubyUtil.PLUGIN_CONTEXTUALIZER_MODULE;
 
 @JRubyClass(name = "PluginFactory")
 public final class PluginFactoryExt extends RubyBasicObject
@@ -35,7 +40,9 @@ public interface PluginResolver {
 
     private static final RubyString ID_KEY = RubyUtil.RUBY.newString("id");
 
-    private final Collection<String> pluginsById = new HashSet<>();
+    private final Collection<String> pluginsById = ConcurrentHashMap.newKeySet();
+
+    private Engine engine;
 
     private PipelineIR lir;
 
@@ -43,7 +50,7 @@ public interface PluginResolver {
 
     private PluginMetricsFactoryExt metrics;
 
-    private RubyClass filterClass;
+    private RubyClass filterDelegatorClass;
 
     private ConfigVariableExpander configVariables;
 
@@ -54,16 +61,21 @@ public interface PluginResolver {
     @JRubyMethod(name = "filter_delegator", meta = true, required = 5)
     public static IRubyObject filterDelegator(final ThreadContext context,
                                               final IRubyObject recv, final IRubyObject... args) {
+        //  filterDelegatorClass, klass, rubyArgs, typeScopedMetric, executionCntx
+        final RubyClass filterDelegatorClass = (RubyClass) args[0];
+        final RubyClass klass = (RubyClass) args[1];
         final RubyHash arguments = (RubyHash) args[2];
-        final IRubyObject filterInstance = args[1].callMethod(context, "new", arguments);
+        final AbstractMetricExt typeScopedMetric = (AbstractMetricExt) args[3];
+        final ExecutionContextExt executionContext = (ExecutionContextExt) args[4];
+
+        final IRubyObject filterInstance = PLUGIN_CONTEXTUALIZER_MODULE.callMethod("initialize_plugin", executionContext, klass, arguments);
         final RubyString id = (RubyString) arguments.op_aref(context, ID_KEY);
         filterInstance.callMethod(
                 context, "metric=",
-                ((AbstractMetricExt) args[3]).namespace(context, id.intern())
+                typeScopedMetric.namespace(context, id.intern())
         );
-        filterInstance.callMethod(context, "execution_context=", args[4]);
-        return new FilterDelegatorExt(context.runtime, RubyUtil.FILTER_DELEGATOR_CLASS)
-                .initialize(context, filterInstance, id);
+
+        return filterDelegatorClass.newInstance(context, filterInstance, id, Block.NULL_BLOCK);
     }
 
     public PluginFactoryExt(final Ruby runtime, final RubyClass metaClass) {
@@ -80,25 +92,33 @@ public PluginFactoryExt initialize(final ThreadContext context,
                                        final IRubyObject[] args) {
         return init(
                 args[0].toJava(PipelineIR.class),
-                (PluginMetricsFactoryExt) args[1], (ExecutionContextFactoryExt) args[2],
-                (RubyClass) args[3]
+                (PluginMetricsFactoryExt) args[1],
+                (ExecutionContextFactoryExt) args[2],
+                (RubyClass) args[3],
+                EnvironmentVariableProvider.defaultProvider(),
+                Engine.RUBY
         );
     }
 
-    public PluginFactoryExt init(final PipelineIR lir, final PluginMetricsFactoryExt metrics,
-                                 final ExecutionContextFactoryExt executionContextFactoryExt,
-                                 final RubyClass filterClass) {
-        return this.init(lir, metrics, executionContextFactoryExt, filterClass, EnvironmentVariableProvider.defaultProvider());
+    public PluginFactoryExt init(final PipelineIR lir,
+                                     final PluginMetricsFactoryExt metrics,
+                                     final ExecutionContextFactoryExt executionContextFactoryExt,
+                                     final RubyClass filterClass,
+                                     final Engine engine) {
+        return this.init(lir, metrics, executionContextFactoryExt, filterClass, EnvironmentVariableProvider.defaultProvider(), engine);
     }
 
-    PluginFactoryExt init(final PipelineIR lir, final PluginMetricsFactoryExt metrics,
+    PluginFactoryExt init(final PipelineIR lir,
+                          final PluginMetricsFactoryExt metrics,
                           final ExecutionContextFactoryExt executionContextFactoryExt,
                           final RubyClass filterClass,
-                          final EnvironmentVariableProvider envVars) {
+                          final EnvironmentVariableProvider envVars,
+                          final Engine engine) {
         this.lir = lir;
         this.metrics = metrics;
         this.executionContextFactory = executionContextFactoryExt;
-        this.filterClass = filterClass;
+        this.filterDelegatorClass = filterClass;
+        this.engine = engine;
         this.pluginCreatorsRegistry.put(PluginLookup.PluginType.INPUT, new InputPluginCreator(this));
         this.pluginCreatorsRegistry.put(PluginLookup.PluginType.CODEC, new CodecPluginCreator());
         this.pluginCreatorsRegistry.put(PluginLookup.PluginType.FILTER, new FilterPluginCreator());
@@ -109,71 +129,102 @@ PluginFactoryExt init(final PipelineIR lir, final PluginMetricsFactoryExt metric
 
     @SuppressWarnings("unchecked")
     @Override
-    public IRubyObject buildInput(final RubyString name, SourceWithMetadata source,
-                                  final IRubyObject args, Map<String, Object> pluginArgs) {
+    public IRubyObject buildInput(final RubyString name,
+                                  final IRubyObject args,
+                                  final SourceWithMetadata source) {
         return plugin(
-                RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.INPUT, name.asJavaString(),
-                source, (Map<String, IRubyObject>) args, pluginArgs
+                RubyUtil.RUBY.getCurrentContext(),
+                PluginLookup.PluginType.INPUT,
+                name.asJavaString(),
+                (Map<String, IRubyObject>) args,
+                source
         );
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public AbstractOutputDelegatorExt buildOutput(final RubyString name, SourceWithMetadata source,
-                                                  final IRubyObject args, Map<String, Object> pluginArgs) {
+    public AbstractOutputDelegatorExt buildOutput(final RubyString name,
+                                                  final IRubyObject args,
+                                                  final SourceWithMetadata source) {
         return (AbstractOutputDelegatorExt) plugin(
                 RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.OUTPUT, name.asJavaString(),
-                source, (Map<String, IRubyObject>) args, pluginArgs
+                (Map<String, IRubyObject>) args, source
         );
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public AbstractFilterDelegatorExt buildFilter(final RubyString name, SourceWithMetadata source,
-                                                  final IRubyObject args, Map<String, Object> pluginArgs) {
+    public AbstractFilterDelegatorExt buildFilter(final RubyString name,
+                                                  final IRubyObject args,
+                                                  final SourceWithMetadata source) {
         return (AbstractFilterDelegatorExt) plugin(
                 RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.FILTER, name.asJavaString(),
-                source, (Map<String, IRubyObject>) args, pluginArgs
+                (Map<String, IRubyObject>) args, source
         );
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public IRubyObject buildCodec(final RubyString name, SourceWithMetadata source, final IRubyObject args,
-                                  Map<String, Object> pluginArgs) {
+    public IRubyObject buildCodec(final RubyString name,
+                                  final IRubyObject args,
+                                  final SourceWithMetadata source) {
         return plugin(
-                RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.CODEC,
-                name.asJavaString(), source, (Map<String, IRubyObject>) args, pluginArgs
+                RubyUtil.RUBY.getCurrentContext(),
+                PluginLookup.PluginType.CODEC,
+                name.asJavaString(),
+                (Map<String, IRubyObject>) args,
+                source
         );
     }
 
     @Override
     public Codec buildDefaultCodec(String codecName) {
         return (Codec) JavaUtil.unwrapJavaValue(plugin(
-                RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.CODEC,
-                codecName, null, Collections.emptyMap(), Collections.emptyMap()
+                RubyUtil.RUBY.getCurrentContext(),
+                PluginLookup.PluginType.CODEC,
+                codecName,
+                Collections.emptyMap(),
+                null
         ));
     }
 
     @SuppressWarnings("unchecked")
     @JRubyMethod(required = 3, optional = 1)
     public IRubyObject plugin(final ThreadContext context, final IRubyObject[] args) {
+        final SourceWithMetadata source = args.length > 3 ? (SourceWithMetadata) JavaUtil.unwrapIfJavaObject(args[3]) : null;
+
         return plugin(
                 context,
                 PluginLookup.PluginType.valueOf(args[0].asJavaString().toUpperCase(Locale.ENGLISH)),
                 args[1].asJavaString(),
-                JavaUtil.unwrapIfJavaObject(args[2]),
-                args.length > 3 ? (Map<String, IRubyObject>) args[3] : new HashMap<>(),
-                null
+                (Map<String, IRubyObject>) args[2],
+                source
         );
     }
 
     @SuppressWarnings("unchecked")
-    private IRubyObject plugin(final ThreadContext context, final PluginLookup.PluginType type, final String name,
-                               SourceWithMetadata source, final Map<String, IRubyObject> args,
-                               Map<String, Object> pluginArgs) {
-        final String id = generateOrRetrievePluginId(context, type, name, source);
-        pluginsById.add(id);
+    private IRubyObject plugin(final ThreadContext context,
+                               final PluginLookup.PluginType type,
+                               final String name,
+                               final Map<String, IRubyObject> args,
+                               final SourceWithMetadata source) {
+        final String id = generateOrRetrievePluginId(type, source, args);
+
+        if (id == null) {
+            throw context.runtime.newRaiseException(
+                    RubyUtil.CONFIGURATION_ERROR_CLASS,
+                    String.format(
+                            "Could not determine ID for %s/%s", type.rubyLabel().asJavaString(), name
+                    )
+            );
+        }
+        if (!pluginsById.add(id)) {
+            throw context.runtime.newRaiseException(
+                    RubyUtil.CONFIGURATION_ERROR_CLASS,
+                    String.format("Two plugins have the id '%s', please fix this conflict", id)
+            );
+        }
+
         final AbstractNamespacedMetricExt typeScopedMetric = metrics.create(context, type.rubyLabel());
 
         final PluginLookup.PluginClass pluginClass = pluginResolver.resolve(type, name);
@@ -199,19 +250,18 @@ private IRubyObject plugin(final ThreadContext context, final PluginLookup.Plugi
             } else if (type == PluginLookup.PluginType.FILTER) {
                 return filterDelegator(
                         context, null,
-                        filterClass, klass, rubyArgs, typeScopedMetric, executionCntx);
+                        filterDelegatorClass, klass, rubyArgs, typeScopedMetric, executionCntx);
             } else {
-                final IRubyObject pluginInstance = klass.callMethod(context, "new", rubyArgs);
+                final IRubyObject pluginInstance = PLUGIN_CONTEXTUALIZER_MODULE.callMethod("initialize_plugin", executionCntx, klass, rubyArgs);
                 final AbstractNamespacedMetricExt scopedMetric = typeScopedMetric.namespace(context, RubyUtil.RUBY.newSymbol(id));
                 scopedMetric.gauge(context, MetricKeys.NAME_KEY, pluginInstance.callMethod(context, "config_name"));
                 pluginInstance.callMethod(context, "metric=", scopedMetric);
-                pluginInstance.callMethod(context, "execution_context=", executionCntx);
                 return pluginInstance;
             }
         } else {
-            if (pluginArgs == null) {
-                String err = String.format("Cannot start the Java plugin '%s' in the Ruby execution engine." +
-                        " The Java execution engine is required to run Java plugins.", name);
+            if (engine != Engine.JAVA) {
+                String err = String.format("Cannot start the Java plugin '%s' in the %s execution engine." +
+                        " The Java execution engine is required to run Java plugins.", name, engine);
                 throw new IllegalStateException(err);
             }
 
@@ -221,38 +271,95 @@ private IRubyObject plugin(final ThreadContext context, final PluginLookup.Plugi
             }
 
             Context contextWithMetrics = executionContextFactory.toContext(type, metrics.getRoot(context));
-            return pluginCreator.createDelegator(name, pluginArgs, id, typeScopedMetric, pluginClass, contextWithMetrics);
+            return pluginCreator.createDelegator(name, convertToJavaCoercible(args), id, typeScopedMetric, pluginClass, contextWithMetrics);
         }
     }
 
-    private String generateOrRetrievePluginId(ThreadContext context, PluginLookup.PluginType type, String name,
-                                              SourceWithMetadata source) {
-        final String id;
-        if (type == PluginLookup.PluginType.CODEC) {
-            id = UUID.randomUUID().toString();
+    private Map<String, Object> convertToJavaCoercible(Map<String, IRubyObject> input) {
+        final Map<String, Object> output = new HashMap<>(input);
+
+        // Intercept Codecs
+        for (final Map.Entry<String, IRubyObject> entry : input.entrySet()) {
+            final String key = entry.getKey();
+            final Object value = entry.getValue();
+            final Object unwrapped = JavaUtil.unwrapJavaValue((IRubyObject) value);
+            if (unwrapped instanceof Codec) {
+                output.put(key, unwrapped);
+            }
+        }
+
+        return output;
+    }
+
+    // TODO: caller seems to think that the args is `Map<String, IRubyObject>`, but
+    //       at least any `id` present is actually a `String`.
+    private String generateOrRetrievePluginId(final PluginLookup.PluginType type,
+                                              final SourceWithMetadata source,
+                                              final Map<String, ?> args) {
+        final Optional<String> unprocessedId;
+        if (source == null) {
+            unprocessedId = extractId(() -> extractIdFromArgs(args),
+                                      this::generateUUID);
         } else {
-            String unresolvedId = lir.getGraph().vertices()
-                    .filter(v -> v.getSourceWithMetadata() != null
-                            && v.getSourceWithMetadata().equalsWithoutText(source))
-                    .findFirst()
-                    .map(Vertex::getId).orElse(null);
-            id = (String) configVariables.expand(unresolvedId);
+            unprocessedId = extractId(() -> extractIdFromLIR(source),
+                                      () -> extractIdFromArgs(args),
+                                      () -> generateUUIDForCodecs(type));
         }
-        if (id == null) {
-            throw context.runtime.newRaiseException(
-                    RubyUtil.CONFIGURATION_ERROR_CLASS,
-                    String.format(
-                            "Could not determine ID for %s/%s", type.rubyLabel().asJavaString(), name
-                    )
-            );
+
+        return unprocessedId
+                .map(configVariables::expand)
+                .filter(String.class::isInstance)
+                .map(String.class::cast)
+                .orElse(null);
+    }
+
+    private Optional<String> extractId(final IdExtractor... extractors) {
+        for (IdExtractor extractor : extractors) {
+            final Optional<String> extracted = extractor.extract();
+            if (extracted.isPresent()) {
+                return extracted;
+            }
         }
-        if (pluginsById.contains(id)) {
-            throw context.runtime.newRaiseException(
-                    RubyUtil.CONFIGURATION_ERROR_CLASS,
-                    String.format("Two plugins have the id '%s', please fix this conflict", id)
-            );
+        return Optional.empty();
+    }
+
+    @FunctionalInterface
+    interface IdExtractor {
+        Optional<String> extract();
+    }
+
+    private Optional<String> extractIdFromArgs(final Map<String, ?> args) {
+        if (!args.containsKey("id")) {
+            return Optional.empty();
+        }
+
+        final Object explicitId = args.get("id");
+        if (explicitId instanceof String) {
+            return Optional.of((String) explicitId);
+        } else if (explicitId instanceof RubyString) {
+            return Optional.of(((RubyString) explicitId).asJavaString());
+        } else {
+            return Optional.empty();
         }
-        return id;
+    }
+
+    private Optional<String> generateUUID() {
+        return Optional.of(UUID.randomUUID().toString());
+    }
+
+    private Optional<String> generateUUIDForCodecs(final PluginLookup.PluginType pluginType) {
+        if (pluginType == PluginLookup.PluginType.CODEC) {
+            return generateUUID();
+        }
+        return Optional.empty();
+    }
+
+    private Optional<String> extractIdFromLIR(final SourceWithMetadata source) {
+        return lir.getGraph().vertices()
+                .filter(v -> v.getSourceWithMetadata() != null
+                        && v.getSourceWithMetadata().equalsWithoutText(source))
+                .findFirst()
+                .map(Vertex::getId);
     }
 
     ExecutionContextFactoryExt getExecutionContextFactory() {
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java b/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java
index 0ac7195273f..bf93b73d18a 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java
@@ -54,12 +54,8 @@
 import org.logstash.config.ir.compiler.AbstractOutputDelegatorExt;
 import org.logstash.config.ir.compiler.ComputeStepSyntaxElement;
 import org.logstash.config.ir.compiler.FilterDelegatorExt;
-import org.logstash.config.ir.compiler.PluginFactory;
+import org.logstash.config.ir.compiler.RubyIntegration;
 import org.logstash.ext.JrubyEventExtLibrary;
-import co.elastic.logstash.api.Configuration;
-import co.elastic.logstash.api.Filter;
-import co.elastic.logstash.api.Input;
-import co.elastic.logstash.api.Context;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -494,9 +490,9 @@ private Supplier<Consumer<Collection<JrubyEventExtLibrary.RubyEvent>>> mockOutpu
     }
 
     /**
-     * Configurable Mock {@link PluginFactory}
+     * Configurable Mock {@link RubyIntegration.PluginFactory}
      */
-    static final class MockPluginFactory implements PluginFactory {
+    static final class MockPluginFactory implements RubyIntegration.PluginFactory {
 
         private final Map<String, Supplier<IRubyObject>> inputs;
 
@@ -514,20 +510,20 @@ static final class MockPluginFactory implements PluginFactory {
         }
 
         @Override
-        public IRubyObject buildInput(final RubyString name, SourceWithMetadata source,
-                                      final IRubyObject args, Map<String, Object> pluginArgs) {
+        public IRubyObject buildInput(final RubyString name, final IRubyObject args,
+                                      SourceWithMetadata source) {
             return setupPlugin(name, inputs);
         }
 
         @Override
-        public AbstractOutputDelegatorExt buildOutput(final RubyString name, SourceWithMetadata source,
-                                                      final IRubyObject args, Map<String, Object> pluginArgs) {
+        public AbstractOutputDelegatorExt buildOutput(final RubyString name, final IRubyObject args,
+                                                      SourceWithMetadata source) {
             return PipelineTestUtil.buildOutput(setupPlugin(name, outputs));
         }
 
         @Override
-        public AbstractFilterDelegatorExt buildFilter(final RubyString name, SourceWithMetadata source,
-                                                      final IRubyObject args, Map<String, Object> pluginArgs) {
+        public AbstractFilterDelegatorExt buildFilter(final RubyString name, final IRubyObject args,
+                                                      SourceWithMetadata source) {
             final RubyObject configNameDouble = org.logstash.config.ir.PluginConfigNameMethodDouble.create(name);
             return new FilterDelegatorExt(
                 RubyUtil.RUBY, RubyUtil.FILTER_DELEGATOR_CLASS)
@@ -535,8 +531,7 @@ public AbstractFilterDelegatorExt buildFilter(final RubyString name, SourceWithM
         }
 
         @Override
-        public IRubyObject buildCodec(final RubyString name, SourceWithMetadata source, final IRubyObject args,
-                                      Map<String, Object> pluginArgs) {
+        public IRubyObject buildCodec(final RubyString name, final IRubyObject args, SourceWithMetadata source) {
             throw new IllegalStateException("No codec setup expected in this test.");
         }
 
@@ -555,17 +550,6 @@ private static <T> T setupPlugin(final RubyString name,
             }
             return suppliers.get(name.asJavaString()).get();
         }
-
-        @Override
-        public Input buildInput(final String name, final String id, final Configuration configuration, final Context context) {
-            return null;
-        }
-
-        @Override
-        public Filter buildFilter(final String name, final String id,
-                                  final Configuration configuration, final Context context) {
-            return null;
-        }
     }
 
     @Test
@@ -698,9 +682,9 @@ private String createBigFilterSection(int numFilters) {
     }
 
     /**
-     * Fixed Mock {@link PluginFactory}
+     * Fixed Mock {@link RubyIntegration.PluginFactory}
      * */
-    static final class FixedPluginFactory implements PluginFactory {
+    static final class FixedPluginFactory implements RubyIntegration.PluginFactory {
 
         private Supplier<IRubyObject> input;
         private Supplier<IRubyObject> filter;
@@ -714,27 +698,17 @@ static final class FixedPluginFactory implements PluginFactory {
         }
 
         @Override
-        public Input buildInput(String name, String id, Configuration configuration, Context context) {
-            return null;
-        }
-
-        @Override
-        public Filter buildFilter(String name, String id, Configuration configuration, Context context) {
-            return null;
-        }
-
-        @Override
-        public IRubyObject buildInput(RubyString name, SourceWithMetadata source, IRubyObject args, Map<String, Object> pluginArgs) {
+        public IRubyObject buildInput(RubyString name, IRubyObject args, SourceWithMetadata source) {
             return this.input.get();
         }
 
         @Override
-        public AbstractOutputDelegatorExt buildOutput(RubyString name, SourceWithMetadata source, IRubyObject args, Map<String, Object> pluginArgs) {
+        public AbstractOutputDelegatorExt buildOutput(RubyString name, IRubyObject args, SourceWithMetadata source) {
             return PipelineTestUtil.buildOutput(this.output.get());
         }
 
         @Override
-        public AbstractFilterDelegatorExt buildFilter(RubyString name, SourceWithMetadata source, IRubyObject args, Map<String, Object> pluginArgs) {
+        public AbstractFilterDelegatorExt buildFilter(RubyString name, IRubyObject args, SourceWithMetadata source) {
             final RubyObject configNameDouble = org.logstash.config.ir.PluginConfigNameMethodDouble.create(name);
             return new FilterDelegatorExt(
                     RubyUtil.RUBY, RubyUtil.FILTER_DELEGATOR_CLASS)
@@ -742,7 +716,7 @@ public AbstractFilterDelegatorExt buildFilter(RubyString name, SourceWithMetadat
         }
 
         @Override
-        public IRubyObject buildCodec(RubyString name, SourceWithMetadata source, IRubyObject args, Map<String, Object> pluginArgs) {
+        public IRubyObject buildCodec(RubyString name, IRubyObject args, SourceWithMetadata source) {
             return null;
         }
 
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/compiler/PluginFactoryTest.java b/logstash-core/src/test/java/org/logstash/config/ir/compiler/PluginFactoryTest.java
deleted file mode 100644
index ebc3990690d..00000000000
--- a/logstash-core/src/test/java/org/logstash/config/ir/compiler/PluginFactoryTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Licensed to Elasticsearch B.V. under one or more contributor
- * license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright
- * ownership. Elasticsearch B.V. licenses this file to you under
- * the Apache License, Version 2.0 (the "License"); you may
- * not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *	http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-
-package org.logstash.config.ir.compiler;
-
-import org.junit.Test;
-
-/**
- * Tests for {@link PluginFactory.Default}.
- */
-public final class PluginFactoryTest {
-
-    @Test
-    public void testBuildJavaFilter() throws Exception {
-
-    }
-
-}
diff --git a/logstash-core/src/test/java/org/logstash/plugins/TestPluginFactory.java b/logstash-core/src/test/java/org/logstash/plugins/TestPluginFactory.java
index ca2c2f02c8c..2476b4c0b8e 100644
--- a/logstash-core/src/test/java/org/logstash/plugins/TestPluginFactory.java
+++ b/logstash-core/src/test/java/org/logstash/plugins/TestPluginFactory.java
@@ -30,31 +30,29 @@
 import org.logstash.plugins.codecs.Line;
 
 import java.util.Collections;
-import java.util.Map;
 
 public class TestPluginFactory implements RubyIntegration.PluginFactory {
 
     @Override
-    public IRubyObject buildInput(RubyString name, SourceWithMetadata source,
-                                  IRubyObject args, Map<String, Object> pluginArgs) {
+    public IRubyObject buildInput(RubyString name, IRubyObject args,
+                                  SourceWithMetadata source) {
         return null;
     }
 
     @Override
-    public AbstractOutputDelegatorExt buildOutput(RubyString name, SourceWithMetadata source,
-                                                  IRubyObject args, Map<String, Object> pluginArgs) {
+    public AbstractOutputDelegatorExt buildOutput(RubyString name, IRubyObject args,
+                                                  SourceWithMetadata source) {
         return null;
     }
 
     @Override
-    public AbstractFilterDelegatorExt buildFilter(RubyString name, SourceWithMetadata source,
-                                                  IRubyObject args, Map<String, Object> pluginArgs) {
+    public AbstractFilterDelegatorExt buildFilter(RubyString name, IRubyObject args,
+                                                  SourceWithMetadata source) {
         return null;
     }
 
     @Override
-    public IRubyObject buildCodec(RubyString name, SourceWithMetadata source, IRubyObject args,
-                                  Map<String, Object> pluginArgs) {
+    public IRubyObject buildCodec(RubyString name, IRubyObject args, SourceWithMetadata source) {
         return null;
     }
 
diff --git a/logstash-core/src/test/java/org/logstash/plugins/factory/PluginFactoryExtTest.java b/logstash-core/src/test/java/org/logstash/plugins/factory/PluginFactoryExtTest.java
index ded3049a657..1f621b90b85 100644
--- a/logstash-core/src/test/java/org/logstash/plugins/factory/PluginFactoryExtTest.java
+++ b/logstash-core/src/test/java/org/logstash/plugins/factory/PluginFactoryExtTest.java
@@ -30,6 +30,7 @@
 import org.logstash.config.ir.InvalidIRException;
 import org.logstash.config.ir.PipelineIR;
 import org.logstash.config.ir.RubyEnvTestCase;
+import org.logstash.execution.Engine;
 import org.logstash.instrument.metrics.NamespacedMetricExt;
 import org.logstash.plugins.MetricTestCase;
 import org.logstash.plugins.PluginLookup;
@@ -93,13 +94,12 @@ public void testPluginIdResolvedWithEnvironmentVariables() throws InvalidIRExcep
         envVars.put("CUSTOM", "test");
         PluginFactoryExt sut = new PluginFactoryExt(RubyUtil.RUBY, RubyUtil.PLUGIN_FACTORY_CLASS,
                 mockPluginResolver);
-        sut.init(pipelineIR, metricsFactory, execContextFactory, RubyUtil.FILTER_DELEGATOR_CLASS, envVars::get);
+        sut.init(pipelineIR, metricsFactory, execContextFactory, RubyUtil.FILTER_DELEGATOR_CLASS, envVars::get, Engine.JAVA);
 
         RubyString pluginName = RubyUtil.RUBY.newString("mockinput");
 
         // Exercise
-        IRubyObject pluginInstance = sut.buildInput(pluginName, sourceWithMetadata, RubyHash.newHash(RubyUtil.RUBY),
-                Collections.emptyMap());
+        IRubyObject pluginInstance = sut.buildInput(pluginName, RubyHash.newHash(RubyUtil.RUBY), sourceWithMetadata);
 
         //Verify
         IRubyObject id = pluginInstance.callMethod(RUBY.getCurrentContext(), "id");
