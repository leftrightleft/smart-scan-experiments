diff --git a/.gitignore b/.gitignore
index 2715c52735f..6ffc2014992 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,5 +1,6 @@
 .*.swp
-*.gem
+/*.gem
+logstash*/*.gem
 pkg/*.deb
 pkg/*.rpm
 *.class
diff --git a/Gemfile b/Gemfile
index 21628e82560..0dfd3fe26f2 100644
--- a/Gemfile
+++ b/Gemfile
@@ -6,10 +6,11 @@ gem "logstash-core", :path => "./logstash-core"
 gem "logstash-core-queue-jruby", :path => "./logstash-core-queue-jruby"
 gem "logstash-core-event-java", :path => "./logstash-core-event-java"
 gem "logstash-core-plugin-api", :path => "./logstash-core-plugin-api"
+gem "ruby-progressbar", "~> 1.8.1"
+gem "builder", "~> 3.2.2"
 gem "file-dependencies", "0.1.6"
 gem "ci_reporter_rspec", "1.0.0", :group => :development
 gem "simplecov", :group => :development
-gem "coveralls", :group => :development
 gem "tins", "1.6", :group => :development
 gem "rspec", "~> 3.1.0", :group => :development
 gem "logstash-devutils", "~> 1.1", :group => :development
@@ -115,4 +116,3 @@ gem "logstash-output-stdout"
 gem "logstash-output-tcp"
 gem "logstash-output-udp"
 gem "logstash-output-webhdfs"
-gem "logstash-filter-multiline"
diff --git a/lib/bootstrap/bundler.rb b/lib/bootstrap/bundler.rb
index 13c04b58ab9..c90cd67488a 100644
--- a/lib/bootstrap/bundler.rb
+++ b/lib/bootstrap/bundler.rb
@@ -103,6 +103,7 @@ def invoke!(options = {})
       ::Bundler.settings[:path] = LogStash::Environment::BUNDLE_DIR
       ::Bundler.settings[:gemfile] = LogStash::Environment::GEMFILE_PATH
       ::Bundler.settings[:without] = options[:without].join(":")
+      ::Bundler.settings[:force] = options[:force]
 
       if !debug?
         # Will deal with transient network errors
diff --git a/lib/bootstrap/environment.rb b/lib/bootstrap/environment.rb
index 0411685f19a..79ff4c024df 100644
--- a/lib/bootstrap/environment.rb
+++ b/lib/bootstrap/environment.rb
@@ -5,6 +5,7 @@
 
 require_relative "bundler"
 require_relative "rubygems"
+require "pathname"
 
 module LogStash
   module Environment
@@ -16,7 +17,9 @@ module Environment
     BUNDLE_DIR = ::File.join(LOGSTASH_HOME, "vendor", "bundle")
     GEMFILE_PATH = ::File.join(LOGSTASH_HOME, "Gemfile")
     LOCAL_GEM_PATH = ::File.join(LOGSTASH_HOME, 'vendor', 'local_gems')
-    CACHE_PATH = File.join(LOGSTASH_HOME, "vendor", "cache")
+    CACHE_PATH = ::File.join(LOGSTASH_HOME, "vendor", "cache")
+    LOCKFILE = Pathname.new(::File.join(LOGSTASH_HOME, "Gemfile.jruby-1.9.lock"))
+    GEMFILE = Pathname.new(::File.join(LOGSTASH_HOME, "Gemfile"))
 
     # @return [String] the ruby version string bundler uses to craft its gem path
     def gem_ruby_version
diff --git a/lib/bootstrap/util/compress.rb b/lib/bootstrap/util/compress.rb
index 79bd38461b4..1d9f04b2248 100644
--- a/lib/bootstrap/util/compress.rb
+++ b/lib/bootstrap/util/compress.rb
@@ -18,13 +18,13 @@ module Zip
       # @param source [String] The location of the file to extract
       # @param target [String] Where you do want the file to be extracted
       # @raise [IOError] If the target directory already exist
-      def extract(source, target)
+      def extract(source, target, pattern = nil)
         raise CompressError.new("Directory #{target} exist") if ::File.exist?(target)
         ::Zip::File.open(source) do |zip_file|
           zip_file.each do |file|
             path = ::File.join(target, file.name)
             FileUtils.mkdir_p(::File.dirname(path))
-            zip_file.extract(file, path)
+            zip_file.extract(file, path) if pattern.nil? || pattern =~ file.name
           end
         end
       end
diff --git a/lib/pluginmanager/bundler/logstash_injector.rb b/lib/pluginmanager/bundler/logstash_injector.rb
new file mode 100644
index 00000000000..1ac2e0ebe68
--- /dev/null
+++ b/lib/pluginmanager/bundler/logstash_injector.rb
@@ -0,0 +1,50 @@
+# encoding: utf-8
+require "bootstrap/environment"
+require "bundler"
+require "bundler/definition"
+require "bundler/dependency"
+require "bundler/dsl"
+require "bundler/injector"
+
+# This class cannot be in the logstash namespace, because of the way the DSL
+# class interact with the other libraries
+module Bundler
+  class LogstashInjector < ::Bundler::Injector
+    def self.inject!(new_deps, options = { :gemfile => LogStash::Environment::GEMFILE, :lockfile => LogStash::Environment::LOCKFILE })
+      gemfile = options.delete(:gemfile)
+      lockfile = options.delete(:lockfile)
+
+      bundler_format = Array(new_deps).collect { |plugin|  ::Bundler::Dependency.new(plugin.name, "=#{plugin.version}")}
+
+      injector = new(bundler_format)
+      injector.inject(gemfile, lockfile)
+    end
+
+
+    # This class is pretty similar to what bundler's injector class is doing
+    # but we only accept a local resolution of the dependencies instead of calling rubygems.
+    # so we removed `definition.resolve_remotely!`
+    def inject(gemfile_path, lockfile_path)
+      if Bundler.settings[:frozen]
+        # ensure the lock and Gemfile are synced
+        Bundler.definition.ensure_equivalent_gemfile_and_lockfile(true)
+        # temporarily remove frozen while we inject
+        frozen = Bundler.settings.delete(:frozen)
+      end
+
+      builder = Dsl.new
+      builder.eval_gemfile(gemfile_path)
+
+      @new_deps -= builder.dependencies
+
+      builder.eval_gemfile("injected gems", new_gem_lines) if @new_deps.any?
+      definition = builder.to_definition(lockfile_path, {})
+      append_to(gemfile_path) if @new_deps.any?
+      definition.lock(lockfile_path)
+
+      return @new_deps
+    ensure
+      Bundler.settings[:frozen] = "1" if frozen
+    end
+  end
+end
diff --git a/lib/pluginmanager/bundler/logstash_uninstall.rb b/lib/pluginmanager/bundler/logstash_uninstall.rb
new file mode 100644
index 00000000000..bdaef0dbac6
--- /dev/null
+++ b/lib/pluginmanager/bundler/logstash_uninstall.rb
@@ -0,0 +1,89 @@
+# encoding: utf-8
+require "bootstrap/environment"
+require "bundler"
+require "bundler/definition"
+require "bundler/dependency"
+require "bundler/dsl"
+require "bundler/injector"
+require "pluginmanager/gemfile"
+
+# This class cannot be in the logstash namespace, because of the way the DSL
+# class interact with the other libraries
+module Bundler
+  class LogstashUninstall
+    attr_reader :gemfile_path, :lockfile_path
+
+    def initialize(gemfile_path, lockfile_path)
+      @gemfile_path = gemfile_path
+      @lockfile_path = lockfile_path
+    end
+
+    # To be uninstalled the candidate gems need to be standalone.
+    def dependants_gems(gem_name)
+      builder = Dsl.new
+      builder.eval_gemfile("original gemfile", File.read(gemfile_path))
+      definition = builder.to_definition(lockfile_path, {})
+
+      definition.specs
+        .select { |spec| spec.dependencies.collect(&:name).include?(gem_name) }
+        .collect(&:name).sort.uniq
+    end
+
+    def uninstall!(gem_name)
+      unfreeze_gemfile do
+
+        dependencies_from = dependants_gems(gem_name)
+
+        if dependencies_from.size > 0
+          display_cant_remove_message(gem_name, dependencies_from)
+          false
+        else
+          remove_gem(gem_name)
+          true
+        end
+      end
+    end
+
+    def remove_gem(gem_name)
+      builder = Dsl.new
+      file = File.new(gemfile_path, "r+")
+
+      gemfile = LogStash::Gemfile.new(file).load
+      gemfile.remove(gem_name)
+      builder.eval_gemfile("gemfile to changes", gemfile.generate)
+
+      definition = builder.to_definition(lockfile_path, {})
+      definition.lock(lockfile_path)
+      gemfile.save
+
+      LogStash::PluginManager.ui.info("Successfully removed #{gem_name}")
+    ensure
+      file.close if file
+    end
+
+    def display_cant_remove_message(gem_name, dependencies_from)
+        message =<<-eos
+Failed to remove \"#{gem_name}\" because the following plugins or libraries depend on it:
+
+* #{dependencies_from.join("\n* ")}
+        eos
+        LogStash::PluginManager.ui.info(message)
+    end
+
+    def unfreeze_gemfile
+      if Bundler.settings[:frozen]
+        Bundler.definition.ensure_equivalent_gemfile_and_lockfile(true)
+        frozen = Bundler.settings.delete(:frozen)
+      end
+      yield
+    ensure
+      Bundler.settings[:frozen] = "1" if frozen
+    end
+
+    def self.uninstall!(gem_name, options = { :gemfile => LogStash::Environment::GEMFILE, :lockfile => LogStash::Environment::LOCKFILE })
+      gemfile_path = options[:gemfile]
+      lockfile_path = options[:lockfile]
+      LogstashUninstall.new(gemfile_path, lockfile_path).uninstall!(gem_name)
+    end
+  end
+end
diff --git a/lib/pluginmanager/command.rb b/lib/pluginmanager/command.rb
index 4adc46544c1..1a7c88bedc9 100644
--- a/lib/pluginmanager/command.rb
+++ b/lib/pluginmanager/command.rb
@@ -21,7 +21,6 @@ def display_bundler_output(output)
     end
   end
 
-
   # Each plugin install for a gemfile create a path with a unique id.
   # we must clear what is not currently used in the 
   def remove_unused_locally_installed_gems!
diff --git a/lib/pluginmanager/errors.rb b/lib/pluginmanager/errors.rb
new file mode 100644
index 00000000000..260c5815cbc
--- /dev/null
+++ b/lib/pluginmanager/errors.rb
@@ -0,0 +1,13 @@
+# encoding: utf-8
+module LogStash module PluginManager
+    class PluginManagerError < StandardError; end
+    class FileNotFoundError < PluginManagerError; end
+    class InvalidPackError < PluginManagerError; end
+    class InstallError < PluginManagerError
+      attr_reader :original_exception
+
+      def initialize(original_exception)
+        @original_exception = original_exception
+      end
+    end
+end end
diff --git a/lib/pluginmanager/gem_installer.rb b/lib/pluginmanager/gem_installer.rb
new file mode 100644
index 00000000000..4a1cf020983
--- /dev/null
+++ b/lib/pluginmanager/gem_installer.rb
@@ -0,0 +1,78 @@
+# encoding: utf-8
+require "pluginmanager/ui"
+require "pathname"
+require "rubygems/package"
+
+module LogStash module PluginManager
+  # Install a physical gem package to the appropriate location inside logstash
+  # - Extract the gem
+  # - Generate the specifications
+  # - Copy the data in the right folders
+  class GemInstaller
+    GEM_HOME = Pathname.new(::File.join(LogStash::Environment::BUNDLE_DIR, "jruby", "1.9"))
+    SPECIFICATIONS_DIR = "specifications"
+    GEMS_DIR = "gems"
+
+    attr_reader :gem_home
+
+    def initialize(gem_file, display_post_install_message = false, gem_home = GEM_HOME)
+      @gem = ::Gem::Package.new(gem_file)
+      @gem_home = Pathname.new(gem_home)
+      @display_post_install_message = display_post_install_message
+    end
+
+    def install
+      create_destination_folders
+      extract_files
+      write_specification
+      display_post_install_message
+    end
+
+    def self.install(gem_file, display_post_install_message = false, gem_home = GEM_HOME)
+      self.new(gem_file, display_post_install_message, gem_home).install
+    end
+
+    private
+    def spec
+      @gem.spec
+    end
+
+    def spec_dir
+      gem_home.join(SPECIFICATIONS_DIR)
+    end
+
+    def spec_file
+      spec_dir.join("#{spec.full_name}.gemspec")
+    end
+
+    def gem_dir
+      gem_home.join(GEMS_DIR, spec.full_name)
+    end
+
+    def extract_files
+      @gem.extract_files gem_dir
+    end
+
+    def write_specification
+      ::File.open(spec_file, 'w') do |file|
+        spec.installed_by_version = ::Gem.rubygems_version
+        file.puts spec.to_ruby_for_cache
+        file.fsync rescue nil # Force writing to disk
+      end
+    end
+
+    def display_post_install_message
+      PluginManager.ui.info(spec.post_install_message) if display_post_install_message?
+    end
+
+    def display_post_install_message?
+      @display_post_install_message && !spec.post_install_message.nil?
+    end
+
+    def create_destination_folders
+      FileUtils.mkdir_p(gem_home)
+      FileUtils.mkdir_p(gem_dir)
+      FileUtils.mkdir_p(spec_dir)
+    end
+  end
+end end
diff --git a/lib/pluginmanager/gemfile.rb b/lib/pluginmanager/gemfile.rb
index 68bf88334f1..c0b996dffd7 100644
--- a/lib/pluginmanager/gemfile.rb
+++ b/lib/pluginmanager/gemfile.rb
@@ -15,9 +15,9 @@ def initialize(io)
       @gemset = nil
     end
 
-    def load
+    def load(with_backup = true)
       @gemset ||= DSL.parse(@io.read)
-      backup
+      backup if with_backup
       self
     end
 
@@ -25,11 +25,14 @@ def save
       raise(GemfileError, "a Gemfile must first be loaded") unless @gemset
       @io.truncate(0)
       @io.rewind
-      @io.write(HEADER)
-      @io.write(@gemset.to_s)
+      @io.write(generate)
       @io.flush
     end
 
+    def generate
+      "#{HEADER}#{gemset.to_s}"
+    end
+
     def find(name)
       @gemset.find_gem(name)
     end
diff --git a/lib/pluginmanager/install.rb b/lib/pluginmanager/install.rb
index 0e6383d725b..e7ba94158ce 100644
--- a/lib/pluginmanager/install.rb
+++ b/lib/pluginmanager/install.rb
@@ -1,5 +1,8 @@
 # encoding: utf-8
 require "pluginmanager/command"
+require "pluginmanager/install_strategy_factory"
+require "pluginmanager/ui"
+require "pluginmanager/errors"
 require "jar-dependencies"
 require "jar_install_post_install_hook"
 require "file-dependencies/gem"
@@ -17,6 +20,30 @@ class LogStash::PluginManager::Install < LogStash::PluginManager::Command
   # but the argument parsing does not support it for now so currently if specifying --version only
   # one plugin name can be also specified.
   def execute
+    # This is a special flow for PACK related plugins,
+    # if we dont detect an pack we will just use the normal `Bundle install` Strategy`
+    # this could be refactored into his own strategy
+    begin
+      if strategy = LogStash::PluginManager::InstallStrategyFactory.create(plugins_arg)
+        LogStash::PluginManager.ui.debug("Installing with strategy: #{strategy.class}")
+        strategy.execute
+        return
+      end
+    rescue LogStash::PluginManager::InstallError => e
+      report_exception("An error occured when installing the: #{plugins_args_human}, to have more information about the error add a DEBUG=1 before running the command.", e.original_exception)
+      return
+    rescue LogStash::PluginManager::FileNotFoundError => e
+      report_exception("File not found for: #{plugins_args_human}", e)
+      return
+    rescue LogStash::PluginManager::InvalidPackError => e
+      report_exception("Invalid pack for: #{plugins_args_human}, reason: #{e.message}", e)
+      return
+    rescue => e
+      report_exception("Something went wrong when installing #{plugins_args_human}", e)
+      return
+    end
+
+    # TODO(ph): refactor this into his own strategy
     validate_cli_options!
 
     if local_gems?
@@ -152,4 +179,8 @@ def local_gems?
       signal_usage_error("Mixed source of plugins, you can't mix local `.gem` and remote gems")
     end
   end
+
+  def plugins_args_human
+    plugins_arg.join(", ")
+  end
 end # class Logstash::PluginManager
diff --git a/lib/pluginmanager/install_strategy_factory.rb b/lib/pluginmanager/install_strategy_factory.rb
new file mode 100644
index 00000000000..ac5f9116154
--- /dev/null
+++ b/lib/pluginmanager/install_strategy_factory.rb
@@ -0,0 +1,22 @@
+# encoding: utf-8
+require "pluginmanager/ui"
+require "pluginmanager/pack_fetch_strategy/repository"
+require "pluginmanager/pack_fetch_strategy/uri"
+
+module LogStash module PluginManager
+  class InstallStrategyFactory
+    AVAILABLES_STRATEGIES = [
+      LogStash::PluginManager::PackFetchStrategy::Uri,
+      LogStash::PluginManager::PackFetchStrategy::Repository
+    ]
+
+    def self.create(plugins_arg)
+      AVAILABLES_STRATEGIES.each do |strategy|
+        if installer = strategy.get_installer_for(plugins_arg.first)
+          return installer
+        end
+      end
+      return false
+    end
+  end
+end end
diff --git a/lib/pluginmanager/main.rb b/lib/pluginmanager/main.rb
index 4ccd437a80b..5323f4370a7 100644
--- a/lib/pluginmanager/main.rb
+++ b/lib/pluginmanager/main.rb
@@ -15,7 +15,6 @@ module PluginManager
 require "pluginmanager/util"
 require "pluginmanager/gemfile"
 require "pluginmanager/install"
-require "pluginmanager/uninstall"
 require "pluginmanager/remove"
 require "pluginmanager/list"
 require "pluginmanager/update"
@@ -35,7 +34,7 @@ class Main < Clamp::Command
       subcommand "pack", "Package currently installed plugins", LogStash::PluginManager::Pack
       subcommand "unpack", "Unpack packaged plugins", LogStash::PluginManager::Unpack
       subcommand "generate", "Create the foundation for a new plugin", LogStash::PluginManager::Generate
-      subcommand "uninstall", "Uninstall a plugin. Deprecated: Please use remove instead", LogStash::PluginManager::Uninstall
+      subcommand "uninstall", "Uninstall a plugin. Deprecated: Please use remove instead", LogStash::PluginManager::Remove
     end
   end
 end
diff --git a/lib/pluginmanager/pack_fetch_strategy/repository.rb b/lib/pluginmanager/pack_fetch_strategy/repository.rb
new file mode 100644
index 00000000000..777bd59843a
--- /dev/null
+++ b/lib/pluginmanager/pack_fetch_strategy/repository.rb
@@ -0,0 +1,43 @@
+# encoding: utf-8
+# In the context of the plugin manager no dependencies are currently loaded.
+# So we have to manually require the version file
+require_relative "../../../logstash-core/lib/logstash/version"
+require "pluginmanager/pack_installer/remote"
+require "pluginmanager/utils/http_client"
+require "pluginmanager/ui"
+require "net/http"
+require "uri"
+
+module LogStash module PluginManager module PackFetchStrategy
+  class Repository
+    ELASTIC_PACK_BASE_URI = ENV["LOGSTASH_PACK_URL"] || "https://artifacts.elastic.co/downloads/logstash-plugins"
+    PACK_EXTENSION = "zip"
+
+    class << self
+      def pack_uri(plugin_name)
+        url = "#{ELASTIC_PACK_BASE_URI}/#{plugin_name}/#{plugin_name}-#{LOGSTASH_VERSION}.#{PACK_EXTENSION}"
+        URI.parse(url)
+      end
+
+      def get_installer_for(plugin_name)
+        uri = pack_uri(plugin_name)
+
+        PluginManager.ui.debug("Looking if package named: #{plugin_name} exists at #{uri}")
+
+        if Utils::HttpClient.remote_file_exist?(uri)
+          PluginManager.ui.debug("Found package at: #{uri}")
+          return LogStash::PluginManager::PackInstaller::Remote.new(uri)
+        else
+          PluginManager.ui.debug("Package not found at: #{uri}")
+          return nil
+        end
+      rescue SocketError => e
+        # This probably means there is a firewall in place of the proxy is not correctly configured.
+        # So lets skip this strategy but log a meaningful errors.
+        PluginManager.ui.debug("SocketError, skipping Elastic pack, exception: #{e}")
+
+        return nil
+      end
+    end
+  end
+end end end
diff --git a/lib/pluginmanager/pack_fetch_strategy/uri.rb b/lib/pluginmanager/pack_fetch_strategy/uri.rb
new file mode 100644
index 00000000000..9dfc19828b9
--- /dev/null
+++ b/lib/pluginmanager/pack_fetch_strategy/uri.rb
@@ -0,0 +1,44 @@
+# encoding: utf-8
+require "pluginmanager/utils/http_client"
+require "pluginmanager/pack_installer/local"
+require "pluginmanager/pack_installer/remote"
+require "pluginmanager/ui"
+require "net/http"
+require "uri"
+
+module LogStash module PluginManager module PackFetchStrategy
+  class Uri
+    class << self
+      def get_installer_for(plugin_name)
+        begin
+          uri =  URI.parse(plugin_name)
+
+          if local?(uri)
+            PluginManager.ui.debug("Local file: #{uri.path}")
+            return LogStash::PluginManager::PackInstaller::Local.new(uri.path)
+          elsif http?(uri)
+            PluginManager.ui.debug("Remote file: #{uri}")
+            return LogStash::PluginManager::PackInstaller::Remote.new(uri)
+          else
+            return nil
+          end
+        rescue URI::InvalidURIError,
+          URI::InvalidComponentError,
+          URI::BadURIError => e
+
+          PluginManager.ui.debug("Invalid URI for pack, uri: #{uri}")
+          return nil
+        end
+      end
+
+      private
+      def http?(uri)
+        !uri.scheme.nil? && uri.scheme.match(/^http/)
+      end
+
+      def local?(uri)
+        !uri.scheme.nil? && uri.scheme == "file"
+      end
+    end
+  end
+end end end
diff --git a/lib/pluginmanager/pack_installer/local.rb b/lib/pluginmanager/pack_installer/local.rb
new file mode 100644
index 00000000000..702eb408754
--- /dev/null
+++ b/lib/pluginmanager/pack_installer/local.rb
@@ -0,0 +1,111 @@
+# encoding: utf-8
+require "pluginmanager/ui"
+require "pluginmanager/bundler/logstash_injector"
+require "pluginmanager/gem_installer"
+require "pluginmanager/errors"
+require "pluginmanager/pack_installer/pack"
+require "bootstrap/util/compress"
+require "rubygems/indexer"
+
+module LogStash module PluginManager module PackInstaller
+  class Local
+    PACK_EXTENSION = ".zip"
+    GEMS_DIR = "gems"
+    LOGSTASH_PATTERN_RE = /logstash\/?/
+
+    attr_reader :local_file
+
+    def initialize(local_file)
+      @local_file = local_file
+    end
+
+    def execute
+      raise PluginManager::FileNotFoundError, "Can't file local file #{local_file}" unless ::File.exist?(local_file)
+      raise PluginManager::InvalidPackError, "Invalid format, the pack must be in zip format" unless valid_format?(local_file)
+
+      PluginManager.ui.info("Installing file: #{local_file}")
+      uncompressed_path = uncompress(local_file)
+      PluginManager.ui.debug("Pack uncompressed to #{uncompressed_path}")
+      pack = LogStash::PluginManager::PackInstaller::Pack.new(uncompressed_path)
+      raise PluginManager::InvalidPackError, "The pack must contains at least one plugin" unless pack.valid?
+
+      local_source = move_to_local_source(uncompressed_path)
+      update_in_memory_index(local_source)
+
+      # Try to add the gems to the current gemfile and lock file, if successful
+      # both of them will be updated. This injector is similar to Bundler's own injector class
+      # minus the support for additionals source and doing local resolution only.
+      added = ::Bundler::LogstashInjector.inject!(pack.plugins)
+
+      # When successfull its safe to install the gem and their specifications in the bundle directory
+      pack.gems.each do |packed_gem|
+        PluginManager.ui.debug("Installing, #{packed_gem.name}, version: #{packed_gem.version} file: #{packed_gem.file}")
+        LogStash::PluginManager::GemInstaller::install(packed_gem.file, packed_gem.plugin?)
+      end
+      PluginManager.ui.info("Install successful")
+    rescue ::Bundler::BundlerError => e
+      raise PluginManager::InstallError.new(e), "An error occurent went installing plugins"
+    ensure
+      FileUtils.rm_rf(uncompressed_path) if uncompressed_path && Dir.exist?(uncompressed_path)
+      FileUtils.rm_rf(local_source) if local_source && Dir.exist?(local_source)
+    end
+
+    private
+    def uncompress(source)
+      temporary_directory = Stud::Temporary.pathname
+      LogStash::Util::Zip.extract(source, temporary_directory, LOGSTASH_PATTERN_RE)
+      temporary_directory
+    rescue Zip::Error => e
+      # OK Zip's handling of file is bit weird, if the file exist but is not a valid zip, it will raise
+      # a `Zip::Error` exception with a file not found message...
+      raise InvalidPackError, "Cannot uncompress the zip: #{source}"
+    end
+
+    def valid_format?(local_file)
+      ::File.extname(local_file).downcase == PACK_EXTENSION
+    end
+
+    # Copy the file to a specific format that `Gem::Indexer` can understand
+    # See `#update_in_memory_index`
+    def move_to_local_source(temporary_directory)
+      local_source = Stud::Temporary.pathname
+      local_source_gems = ::File.join(local_source, GEMS_DIR)
+
+      FileUtils.mkdir_p(local_source_gems)
+      PluginManager.ui.debug("Creating the index structure format from #{temporary_directory} to #{local_source}")
+
+      Dir.glob(::File.join(temporary_directory, "**", "*.gem")).each do |file|
+        destination = ::File.join(local_source_gems, ::File.basename(file))
+        FileUtils.cp(file, destination)
+      end
+
+      local_source
+    end
+
+    # This takes a folder with a special structure, will generate an index
+    # similar to what rubygems do and make them available in the local program,
+    # we use this **side effect** to validate theses gems with the current gemfile/lock.
+    # Bundler will assume they are system gems and will use them when doing resolution checks.
+    #
+    #.
+    # ├── gems
+    # │   ├── addressable-2.4.0.gem
+    # │   ├── cabin-0.9.0.gem
+    # │   ├── ffi-1.9.14-java.gem
+    # │   ├── gemoji-1.5.0.gem
+    # │   ├── launchy-2.4.3-java.gem
+    # │   ├── logstash-output-elasticsearch-5.2.0-java.gem
+    # │   ├── logstash-output-secret-0.1.0.gem
+    # │   ├── manticore-0.6.0-java.gem
+    # │   ├── spoon-0.0.6.gem
+    # │   └── stud-0.0.22.gem
+    #
+    # Right now this work fine, but I think we could also use Bundler's SourceList classes to handle the same thing
+    def update_in_memory_index(local_source)
+      PluginManager.ui.debug("Generating indexes in #{local_source}")
+      indexer = ::Gem::Indexer.new(local_source, { :build_modern => true})
+      indexer.ui = ::Gem::SilentUI.new unless ENV["DEBUG"]
+      indexer.generate_index
+    end
+  end
+end end end
diff --git a/lib/pluginmanager/pack_installer/pack.rb b/lib/pluginmanager/pack_installer/pack.rb
new file mode 100644
index 00000000000..7c9b5bbe8e7
--- /dev/null
+++ b/lib/pluginmanager/pack_installer/pack.rb
@@ -0,0 +1,82 @@
+# encoding: utf-8
+require "pluginmanager/errors"
+
+module LogStash module PluginManager module PackInstaller
+  # A object that represent the directory structure
+  # related to the actual gems in the extracted package.
+  #
+  # Example of a valid structure, where `logstash-output-secret` is the actual
+  # plugin to be installed.
+  #.
+  # ├── dependencies
+  # │   ├── addressable-2.4.0.gem
+  # │   ├── cabin-0.9.0.gem
+  # │   ├── ffi-1.9.14-java.gem
+  # │   ├── gemoji-1.5.0.gem
+  # │   ├── launchy-2.4.3-java.gem
+  # │   ├── logstash-output-elasticsearch-5.2.0-java.gem
+  # │   ├── manticore-0.6.0-java.gem
+  # │   ├── spoon-0.0.6.gem
+  # │   └── stud-0.0.22.gem
+  # └── logstash-output-secret-0.1.0.gem
+  class Pack
+    class GemInformation
+      EXTENSION = ".gem"
+      SPLIT_CHAR = "-"
+      JAVA_PLATFORM_RE = /-java/
+      DEPENDENCIES_DIR_RE = /dependencies/
+
+      attr_reader :file, :name, :version, :platform
+
+      def initialize(gem)
+        @file = gem
+        extracts_information
+      end
+
+      def dependency?
+        @dependency
+      end
+
+      def plugin?
+        !dependency?
+      end
+
+      private
+      def extracts_information
+        basename = ::File.basename(file, EXTENSION)
+        parts = basename.split(SPLIT_CHAR)
+
+        @dependency = ::File.dirname(file) =~ DEPENDENCIES_DIR_RE
+
+        if basename.match(JAVA_PLATFORM_RE)
+          @platform = parts.pop
+          @version = parts.pop
+          @name = parts.join(SPLIT_CHAR)
+        else
+          @platform = nil
+          @version = parts.pop
+          @name = parts.join(SPLIT_CHAR)
+        end
+      end
+    end
+
+    attr_reader :gems
+
+    def initialize(source)
+      @gems = Dir.glob(::File.join(source, "**", "*.gem")).collect { |gem| GemInformation.new(gem) }
+    end
+
+    def plugins
+      require "pry"
+      gems.select { |gem| !gem.dependency? }
+    end
+
+    def dependencies
+      gems.select { |gem| gem.dependency? }
+    end
+
+    def valid?
+      plugins.size > 0
+    end
+  end
+end end end
diff --git a/lib/pluginmanager/pack_installer/remote.rb b/lib/pluginmanager/pack_installer/remote.rb
new file mode 100644
index 00000000000..37cb52973b5
--- /dev/null
+++ b/lib/pluginmanager/pack_installer/remote.rb
@@ -0,0 +1,25 @@
+# encoding: utf-8
+require "pluginmanager/pack_installer/local"
+require "pluginmanager/utils/downloader"
+require "fileutils"
+
+module LogStash module PluginManager module PackInstaller
+  class Remote
+    attr_reader :remote_url, :feedback
+
+    def initialize(remote_url, feedback = Utils::Downloader::ProgressbarFeedback)
+      @remote_url = remote_url
+      @feedback = feedback
+    end
+
+    def execute
+      PluginManager.ui.info("Downloading file: #{remote_url}")
+      downloaded_file = Utils::Downloader.fetch(remote_url, feedback)
+      PluginManager.ui.debug("Downloaded package to: #{downloaded_file}")
+
+      PackInstaller::Local.new(downloaded_file).execute
+    ensure
+      FileUtils.rm_rf(downloaded_file) if downloaded_file
+    end
+  end
+end end end
diff --git a/lib/pluginmanager/remove.rb b/lib/pluginmanager/remove.rb
index 530463f64b1..eddd604e1cc 100644
--- a/lib/pluginmanager/remove.rb
+++ b/lib/pluginmanager/remove.rb
@@ -1,8 +1,8 @@
 # encoding: utf-8
+require "pluginmanager/bundler/logstash_uninstall"
 require "pluginmanager/command"
 
 class LogStash::PluginManager::Remove < LogStash::PluginManager::Command
-
   parameter "PLUGIN", "plugin name"
 
   def execute
@@ -19,23 +19,10 @@ def execute
     # it is not possible to uninstall a dependency not listed in the Gemfile, for example a dependent codec
     signal_error("This plugin has not been previously installed, aborting") unless LogStash::PluginManager.installed_plugin?(plugin, gemfile)
 
-    # since we previously did a gemfile.find(plugin) there is no reason why
-    # remove would not work (return nil) here
-    if gemfile.remove(plugin)
-      gemfile.save
-
-      puts("Removing #{plugin}")
-
-      # any errors will be logged to $stderr by invoke!
-      # output, exception = LogStash::Bundler.invoke!(:install => true, :clean => true)
-      output = LogStash::Bundler.invoke!(:install => true, :clean => true)
+    exit(1) unless ::Bundler::LogstashUninstall.uninstall!(plugin)
 
-      remove_unused_locally_installed_gems!
-    end
+    remove_unused_locally_installed_gems!
   rescue => exception
-    gemfile.restore!
-    report_exception("Remove Aborted", exception)
-  ensure
-    display_bundler_output(output)
+    report_exception("Operation aborted, cannot remove plugin.", exception)
   end
 end
diff --git a/lib/pluginmanager/ui.rb b/lib/pluginmanager/ui.rb
new file mode 100644
index 00000000000..1f40265cf3c
--- /dev/null
+++ b/lib/pluginmanager/ui.rb
@@ -0,0 +1,24 @@
+# encoding: utf-8
+module LogStash module PluginManager
+  # The command line commands should be able to report but they shouldn't
+  # require an explicit logger like log4j.
+  class Shell
+    def info(message)
+      puts message
+    end
+    alias_method :error, :info
+    alias_method :warn, :info
+
+    def debug(message)
+      puts message if ENV["DEBUG"]
+    end
+  end
+
+  def self.ui
+    @ui ||= Shell.new
+  end
+
+  def self.ui=(new_ui)
+    @ui = new_ui
+  end
+end end
diff --git a/lib/pluginmanager/uninstall.rb b/lib/pluginmanager/uninstall.rb
deleted file mode 100644
index 2a954e4ea6f..00000000000
--- a/lib/pluginmanager/uninstall.rb
+++ /dev/null
@@ -1,44 +0,0 @@
-# encoding: utf-8
-require "pluginmanager/command"
-
-# TODO: SR: Delete this file in 6.0, as we deprecated uninstall in favar of remove to be consistent with the stack
-
-class LogStash::PluginManager::Uninstall < LogStash::PluginManager::Command
-
-  parameter "PLUGIN", "plugin name"
-
-  def execute
-    puts "uninstall subcommand is deprecated and will be removed in the next major version. Please use logstash-plugin remove instead."
-
-    signal_error("File #{LogStash::Environment::GEMFILE_PATH} does not exist or is not writable, aborting") unless File.writable?(LogStash::Environment::GEMFILE_PATH)
-    ##
-    # Need to setup the bundler status to enable uninstall of plugins
-    # installed as local_gems, otherwise gem:specification is not
-    # finding the plugins
-    ##
-    LogStash::Bundler.setup!({:without => [:build, :development]})
-
-    # make sure this is an installed plugin and present in Gemfile.
-    # it is not possible to uninstall a dependency not listed in the Gemfile, for example a dependent codec
-    signal_error("This plugin has not been previously installed, aborting") unless LogStash::PluginManager.installed_plugin?(plugin, gemfile)
-
-    # since we previously did a gemfile.find(plugin) there is no reason why
-    # remove would not work (return nil) here
-    if gemfile.remove(plugin)
-      gemfile.save
-
-      puts("Uninstalling #{plugin}")
-
-      # any errors will be logged to $stderr by invoke!
-      # output, exception = LogStash::Bundler.invoke!(:install => true, :clean => true)
-      output = LogStash::Bundler.invoke!(:install => true, :clean => true)
-
-      remove_unused_locally_installed_gems!
-    end
-  rescue => exception
-    gemfile.restore!
-    report_exception("Uninstall Aborted", exception)
-  ensure
-    display_bundler_output(output)
-  end
-end
diff --git a/lib/pluginmanager/utils/downloader.rb b/lib/pluginmanager/utils/downloader.rb
new file mode 100644
index 00000000000..7c04dfb1fcf
--- /dev/null
+++ b/lib/pluginmanager/utils/downloader.rb
@@ -0,0 +1,91 @@
+# encoding: utf-8
+require "ruby-progressbar"
+require "pluginmanager/utils/http_client"
+require "pluginmanager/errors"
+require "fileutils"
+
+module LogStash module PluginManager module Utils
+  class Downloader
+    class ProgressbarFeedback
+      FORMAT = "%t [%B] %p%%"
+      TITLE = "Downloading"
+
+      attr_reader :progress_bar
+
+      def initialize(max)
+        @progress_bar = ProgressBar.create(:title => TITLE,
+                                           :starting_at => 0,
+                                           :total => max,
+                                           :format => FORMAT)
+      end
+
+      def update(status)
+        progress_bar.progress += status
+      end
+    end
+
+    class SilentFeedback
+      def initialize(max)
+      end
+
+      def update(status)
+      end
+    end
+
+    attr_reader :download_to, :remote_file_uri, :feedback_strategy
+
+    def initialize(remote_file_uri, feedback = SilentFeedback)
+      @remote_file_uri = URI(remote_file_uri)
+      @download_to = Stud::Temporary.pathname
+      @feedback_strategy = feedback
+    end
+
+    def fetch(redirect_count = 0)
+      # This is defensive programming, but in the real world we do create redirects all the time
+      raise HttpClient::RedirectionLimit, "Too many redirection, tried #{REDIRECTION_LIMIT} times" if redirect_count >= HttpClient::REDIRECTION_LIMIT
+
+      begin
+        FileUtils.mkdir_p(download_to)
+        downloaded_file = ::File.open(::File.join(download_to, ::File.basename(remote_file_uri.path)), "w")
+
+        HttpClient.start(remote_file_uri) do |http|
+          request = Net::HTTP::Get.new(remote_file_uri.path)
+
+          http.request(request) do |response|
+            if response.code == "200"
+              download_chunks(response, downloaded_file)
+            elsif response.code == "302"
+              new_uri = response.headers["location"]
+
+              redirect_count += 1
+              downloader = self.new(new_uri, feedback_strategy)
+              downloader.fetch(redirect_count)
+            else
+              raise LogStash::PluginManager::FileNotFoundError, "Can't download #{remote_file_uri}" if response.code != "200"
+            end
+          end
+          downloaded_file.close
+          downloaded_file.path
+        end
+      rescue => e
+        downloaded_file.close rescue nil
+        FileUtils.rm_rf(download_to)
+        raise e
+      end
+    end
+
+    def self.fetch(remote_file, feedback = SilentFeedback)
+      new(remote_file, feedback).fetch
+    end
+
+    private
+    def download_chunks(response, downloaded_file)
+      feedback = feedback_strategy.new(response.content_length)
+
+      response.read_body do |chunk|
+        feedback.update(chunk.bytesize)
+        downloaded_file.write(chunk)
+      end
+    end
+  end
+end end end
diff --git a/lib/pluginmanager/utils/http_client.rb b/lib/pluginmanager/utils/http_client.rb
new file mode 100644
index 00000000000..7bf48fef3ee
--- /dev/null
+++ b/lib/pluginmanager/utils/http_client.rb
@@ -0,0 +1,40 @@
+# encoding: utf-8
+module LogStash module PluginManager module Utils
+  class HttpClient
+    class RedirectionLimit < RuntimeError; end
+
+    HTTPS_SCHEME = "https"
+    REDIRECTION_LIMIT = 5
+
+    # Proxies should be handled by the library
+    # https://ruby-doc.org/stdlib-2.3.1/libdoc/net/http/rdoc/Net/HTTP.html#class-Net::HTTP-label-Proxies
+    def self.start(uri)
+      uri = URI(uri)
+      Net::HTTP.start(uri.host, uri.port, :use_ssl => uri.scheme == HTTPS_SCHEME) { |http| yield http }
+    end
+
+    # Do a HEAD request on the file to see if it exist before downloading it
+    def self.remote_file_exist?(uri, redirect_count = 0)
+      uri = URI(uri)
+
+      # This is defensive programming, but in the real world we do create redirects all the time
+      raise RedirectionLimit, "Too many redirection, tried #{REDIRECTION_LIMIT} times" if redirect_count >= REDIRECTION_LIMIT
+
+      start(uri) do |http|
+        return false if uri.path.empty?
+
+        request = Net::HTTP::Head.new(uri.path)
+        response = http.request(request)
+
+        if response.code == "302"
+          new_uri = response.headers["location"]
+          remote_file_exist?(new_uri, redirect_count + 1)
+        elsif response.code == "200"
+          true
+        else
+          false
+        end
+      end
+    end
+  end
+end end end
diff --git a/logstash-core/spec/logstash/webserver_spec.rb b/logstash-core/spec/logstash/webserver_spec.rb
index 898a3b8d4d1..a5bd42f0b8c 100644
--- a/logstash-core/spec/logstash/webserver_spec.rb
+++ b/logstash-core/spec/logstash/webserver_spec.rb
@@ -5,6 +5,7 @@
 require "socket"
 require "spec_helper"
 require "open-uri"
+require "webmock/rspec"
 
 def block_ports(range)
   servers = []
@@ -35,6 +36,7 @@ def free_ports(servers)
   before :all do
     @abort = Thread.abort_on_exception
     Thread.abort_on_exception = true
+    WebMock.allow_net_connect!
   end
 
   after :all do
diff --git a/qa/integration/fixtures/remove_spec.yml b/qa/integration/fixtures/remove_spec.yml
new file mode 100644
index 00000000000..cbfc784af81
--- /dev/null
+++ b/qa/integration/fixtures/remove_spec.yml
@@ -0,0 +1,3 @@
+---
+services:
+  - logstash
diff --git a/qa/integration/services/logstash_service.rb b/qa/integration/services/logstash_service.rb
index 4ae85afdbcb..fbf92fa7e73 100644
--- a/qa/integration/services/logstash_service.rb
+++ b/qa/integration/services/logstash_service.rb
@@ -171,4 +171,48 @@ def get_version_yml
   def process_id
     @process.pid
   end
+
+  def plugin_cli
+    PluginCli.new(@logstash_home)
+  end
+
+  class PluginCli
+    class ProcessStatus < Struct.new(:exit_code, :stderr_and_stdout); end
+
+    TIMEOUT_MAXIMUM = 60 * 10 # 10mins.
+    LOGSTASH_PLUGIN = File.join("bin", "logstash-plugin")
+
+    attr_reader :logstash_plugin
+
+    def initialize(logstash_home)
+      @logstash_plugin = File.join(logstash_home, LOGSTASH_PLUGIN)
+    end
+
+    def remove(plugin_name)
+      run("remove #{plugin_name}")
+    end
+
+    def list(plugin_name, verbose = false)
+      run("list #{plugin_name} #{verbose ? "--verbose" : ""}")
+    end
+
+    def install(plugin_name)
+      run("install #{plugin_name}")
+    end
+
+    def run(command)
+      out = Tempfile.new("content")
+      out.sync = true
+      process = ChildProcess.build(logstash_plugin,*command.split(" "))
+      process.io.stdout = process.io.stderr = out
+
+      Bundler.with_clean_env do
+        process.start
+      end
+
+      process.poll_for_exit(TIMEOUT_MAXIMUM)
+      out.rewind
+      ProcessStatus.new(process.exit_code, out.read)
+    end
+  end
 end
diff --git a/qa/integration/specs/cli/remove_spec.rb b/qa/integration/specs/cli/remove_spec.rb
new file mode 100644
index 00000000000..f390b61d00d
--- /dev/null
+++ b/qa/integration/specs/cli/remove_spec.rb
@@ -0,0 +1,44 @@
+# encoding: utf-8
+require_relative '../../framework/fixture'
+require_relative '../../framework/settings'
+require_relative '../../services/logstash_service'
+require_relative '../../framework/helpers'
+require "logstash/devutils/rspec/spec_helper"
+
+describe "Test removal of plugin" do
+  before(:all) do
+    @fixture = Fixture.new(__FILE__)
+    @logstash_plugin = @fixture.get_service("logstash").plugin_cli
+  end
+
+  context "when no other plugins depends on this plugin" do
+    it "successfully remove the plugin" do
+      execute = @logstash_plugin.remove("logstash-input-twitter")
+
+      expect(execute.exit_code).to eq(0)
+      expect(execute.stderr_and_stdout).to match(/Successfully removed logstash-input-twitter/)
+
+      presence_check = @logstash_plugin.list("logstash-input-twitter")
+      expect(presence_check.exit_code).to eq(1)
+      expect(presence_check.stderr_and_stdout).to match(/ERROR: No plugins found/)
+
+      @logstash_plugin.install("logstash-input-twitter")
+    end
+  end
+
+  context "when other plugins depends on this plugin" do
+    it "refuses to remove the plugin and display the plugin that depends on it." do
+      execute = @logstash_plugin.remove("logstash-codec-json")
+
+      expect(execute.exit_code).to eq(1)
+      expect(execute.stderr_and_stdout).to match(/Failed to remove "logstash-codec-json"/)
+      expect(execute.stderr_and_stdout).to match(/logstash-input-beats/) # one of the dependency
+      expect(execute.stderr_and_stdout).to match(/logstash-output-udp/) # one of the dependency
+
+      presence_check = @logstash_plugin.list("logstash-codec-json")
+
+      expect(presence_check.exit_code).to eq(0)
+      expect(presence_check.stderr_and_stdout).to match(/logstash-codec-json/)
+    end
+  end
+end
diff --git a/spec/spec_helper.rb b/spec/spec_helper.rb
index 4e49758160e..44919e332c7 100644
--- a/spec/spec_helper.rb
+++ b/spec/spec_helper.rb
@@ -8,6 +8,9 @@
 
 require "flores/rspec"
 require "flores/random"
+require "pathname"
+
+SUPPORT_DIR = Pathname.new(::File.join(::File.dirname(__FILE__), "support"))
 
 class JSONIOThingy < IO
   def initialize; end
diff --git a/spec/support/pack/empty-pack.zip b/spec/support/pack/empty-pack.zip
new file mode 100644
index 00000000000..f11de003e3f
Binary files /dev/null and b/spec/support/pack/empty-pack.zip differ
diff --git a/spec/support/pack/valid-pack.zip b/spec/support/pack/valid-pack.zip
new file mode 100644
index 00000000000..538bf0d1936
Binary files /dev/null and b/spec/support/pack/valid-pack.zip differ
diff --git a/spec/support/pack/valid-pack/logstash/valid-pack/dependencies/logstash-input-packtestdep-0.0.1.gem b/spec/support/pack/valid-pack/logstash/valid-pack/dependencies/logstash-input-packtestdep-0.0.1.gem
new file mode 100644
index 00000000000..fc51fbf46e6
Binary files /dev/null and b/spec/support/pack/valid-pack/logstash/valid-pack/dependencies/logstash-input-packtestdep-0.0.1.gem differ
diff --git a/spec/support/pack/valid-pack/logstash/valid-pack/dependencies/logstash-input-packtestdep.gemspec b/spec/support/pack/valid-pack/logstash/valid-pack/dependencies/logstash-input-packtestdep.gemspec
new file mode 100644
index 00000000000..c0d175e51e1
--- /dev/null
+++ b/spec/support/pack/valid-pack/logstash/valid-pack/dependencies/logstash-input-packtestdep.gemspec
@@ -0,0 +1,11 @@
+# coding: utf-8
+Gem::Specification.new do |spec|
+  spec.name          = "logstash-input-packtestdep"
+  spec.version       = "0.0.1"
+  spec.authors       = ["Elastic"]
+  spec.email         = ["info@elastic.co"]
+
+  spec.summary       = "a summary"
+  spec.description   = "a description"
+  spec.homepage      = "https://elastic.co"
+end
diff --git a/spec/support/pack/valid-pack/logstash/valid-pack/logstash-input-packtest-0.0.1.gem b/spec/support/pack/valid-pack/logstash/valid-pack/logstash-input-packtest-0.0.1.gem
new file mode 100644
index 00000000000..1a7f8641661
Binary files /dev/null and b/spec/support/pack/valid-pack/logstash/valid-pack/logstash-input-packtest-0.0.1.gem differ
diff --git a/spec/support/pack/valid-pack/logstash/valid-pack/logstash-input-packtest.gemspec b/spec/support/pack/valid-pack/logstash/valid-pack/logstash-input-packtest.gemspec
new file mode 100644
index 00000000000..78a7a1d48b5
--- /dev/null
+++ b/spec/support/pack/valid-pack/logstash/valid-pack/logstash-input-packtest.gemspec
@@ -0,0 +1,13 @@
+# coding: utf-8
+Gem::Specification.new do |spec|
+  spec.name          = "logstash-input-packtest"
+  spec.version       = "0.0.1"
+  spec.authors       = ["Elastic"]
+  spec.email         = ["info@elastic.co"]
+
+  spec.summary       = "a summary"
+  spec.description   = "a description"
+  spec.homepage      = "https://elastic.co"
+
+  spec.add_runtime_dependency "logstash-input-packtestdep"
+end
diff --git a/spec/unit/plugin_manager/gem_installer_spec.rb b/spec/unit/plugin_manager/gem_installer_spec.rb
new file mode 100644
index 00000000000..616f60b7926
--- /dev/null
+++ b/spec/unit/plugin_manager/gem_installer_spec.rb
@@ -0,0 +1,61 @@
+# encoding: utf-8
+require "pluginmanager/gem_installer"
+require "pluginmanager/ui"
+require "stud/temporary"
+require "rubygems/specification"
+require "fileutils"
+require "ostruct"
+
+describe LogStash::PluginManager::GemInstaller do
+  let(:plugin_name) { "logstash-input-packtest-0.0.1" }
+  let(:simple_gem) { ::File.join(::File.dirname(__FILE__), "..", "..", "support", "pack", "valid-pack", "logstash", "valid-pack", "#{plugin_name}.gem") }
+
+  subject { described_class }
+  let(:temporary_gem_home) { p = Stud::Temporary.pathname; FileUtils.mkdir_p(p); p }
+
+  it "install the specifications in the spec dir" do
+    subject.install(simple_gem, false, temporary_gem_home)
+    spec_file = ::File.join(temporary_gem_home, "specifications", "#{plugin_name}.gemspec")
+    expect(::File.exist?(spec_file)).to be_truthy
+    expect(::File.size(spec_file)).to be > 0
+  end
+
+  it "install the gem in the gems dir" do
+    subject.install(simple_gem, false, temporary_gem_home)
+    gem_dir = ::File.join(temporary_gem_home, "gems", plugin_name)
+    expect(Dir.exist?(gem_dir)).to be_truthy
+  end
+
+  context "post_install_message" do
+    let(:message) { "Hello from the friendly pack" }
+
+    context "when present" do
+      before do
+        allow_any_instance_of(::Gem::Specification).to receive(:post_install_message).and_return(message)
+      end
+
+      context "when we want the message" do
+        it "display the message" do
+          expect(LogStash::PluginManager.ui).to receive(:info).with(message)
+          subject.install(simple_gem, true, temporary_gem_home)
+        end
+      end
+
+      context "when we dont want the message" do
+        it "doesn't display the message" do
+          expect(LogStash::PluginManager.ui).not_to receive(:info).with(message)
+          subject.install(simple_gem, false, temporary_gem_home)
+        end
+      end
+    end
+
+    context "when not present" do
+      context "when we want the message" do
+        it "doesn't display the message" do
+          expect(LogStash::PluginManager.ui).not_to receive(:info).with(message)
+          subject.install(simple_gem, true, temporary_gem_home)
+        end
+      end
+    end
+  end
+end
diff --git a/spec/unit/plugin_manager/install_spec.rb b/spec/unit/plugin_manager/install_spec.rb
index 40eb3dfe408..b754811a446 100644
--- a/spec/unit/plugin_manager/install_spec.rb
+++ b/spec/unit/plugin_manager/install_spec.rb
@@ -1,15 +1,20 @@
 # encoding: utf-8
 require 'spec_helper'
 require 'pluginmanager/main'
+require "pluginmanager/pack_fetch_strategy/repository"
 
 describe LogStash::PluginManager::Install do
   let(:cmd) { LogStash::PluginManager::Install.new("install") }
 
-  before(:each) do
-    expect(cmd).to receive(:validate_cli_options!).and_return(nil)
-  end
-
   context "when validating plugins" do
+    before(:each) do
+      expect(cmd).to receive(:validate_cli_options!).and_return(nil)
+    end
+
+    before do
+      expect(LogStash::PluginManager::PackFetchStrategy::Repository).to receive(:get_installer_for).with(anything).and_return(nil)
+    end
+
     let(:sources) { ["https://rubygems.org", "http://localhost:9292"] }
 
     before(:each) do
@@ -25,4 +30,29 @@
       cmd.execute
     end
   end
+
+  context "pack" do
+    let(:cmd) { LogStash::PluginManager::Install.new("install my-super-pack") }
+    before do
+      expect(cmd).to receive(:plugins_arg).and_return(["my-super-pack"]).at_least(:once)
+    end
+
+    it "reports `FileNotFoundError` exception" do
+      expect(LogStash::PluginManager::InstallStrategyFactory).to receive(:create).with(["my-super-pack"]).and_raise(LogStash::PluginManager::FileNotFoundError)
+      expect(cmd).to receive(:report_exception).with(/File not found/, be_kind_of(LogStash::PluginManager::PluginManagerError))
+      cmd.execute
+    end
+
+    it "reports `InvalidPackError` exception" do
+      expect(LogStash::PluginManager::InstallStrategyFactory).to receive(:create).with(["my-super-pack"]).and_raise(LogStash::PluginManager::InvalidPackError)
+      expect(cmd).to receive(:report_exception).with(/Invalid pack for/, be_kind_of(LogStash::PluginManager::PluginManagerError))
+      cmd.execute
+    end
+
+    it "reports any other exceptions" do
+      expect(LogStash::PluginManager::InstallStrategyFactory).to receive(:create).with(["my-super-pack"]).and_raise(StandardError)
+      expect(cmd).to receive(:report_exception).with(/Something went wrong when installing/, be_kind_of(StandardError))
+      cmd.execute
+    end
+  end
 end
diff --git a/spec/unit/plugin_manager/install_strategy_factory_spec.rb b/spec/unit/plugin_manager/install_strategy_factory_spec.rb
new file mode 100644
index 00000000000..6a29ff45e0b
--- /dev/null
+++ b/spec/unit/plugin_manager/install_strategy_factory_spec.rb
@@ -0,0 +1,27 @@
+# encoding: utf-8
+require "pluginmanager/install_strategy_factory"
+
+describe LogStash::PluginManager::InstallStrategyFactory do
+  subject { described_class }
+  let(:plugins_args) { [ "logstash-pack-mega" ] }
+
+  it "returns the first matched strategy" do
+    success = double("urifetch success")
+
+    expect(LogStash::PluginManager::PackFetchStrategy::Uri).to receive(:get_installer_for).with(plugins_args.first).and_return(success)
+    expect(subject.create(plugins_args)).to eq(success)
+  end
+
+  it "returns the matched strategy" do
+    success = double("elastic xpack success")
+
+    expect(LogStash::PluginManager::PackFetchStrategy::Repository).to receive(:get_installer_for).with(plugins_args.first).and_return(success)
+    expect(subject.create(plugins_args)).to eq(success)
+  end
+
+  it "return nil when no strategy matches" do
+    expect(LogStash::PluginManager::PackFetchStrategy::Uri).to receive(:get_installer_for).with(plugins_args.first).and_return(nil)
+    expect(LogStash::PluginManager::PackFetchStrategy::Repository).to receive(:get_installer_for).with(plugins_args.first).and_return(nil)
+    expect(subject.create(plugins_args)).to be_falsey
+  end
+end
diff --git a/spec/unit/plugin_manager/pack_fetch_strategy/repository_spec.rb b/spec/unit/plugin_manager/pack_fetch_strategy/repository_spec.rb
new file mode 100644
index 00000000000..395f1c0b816
--- /dev/null
+++ b/spec/unit/plugin_manager/pack_fetch_strategy/repository_spec.rb
@@ -0,0 +1,42 @@
+# encoding: utf-8
+require "pluginmanager/pack_fetch_strategy/repository"
+require "uri"
+require "webmock/rspec"
+require "spec_helper"
+
+describe LogStash::PluginManager::PackFetchStrategy::Repository do
+  subject { described_class }
+
+  let(:plugin_name) { "hola-pack" }
+
+  context "#plugin_uri" do
+    it "generate an url from a name" do
+      matched = URI.parse("#{subject::ELASTIC_PACK_BASE_URI}/#{plugin_name}/#{plugin_name}-#{LOGSTASH_VERSION}.#{subject::PACK_EXTENSION}")
+      expect(subject.pack_uri(plugin_name)).to eq(matched)
+    end
+  end
+
+  context "when the remote file exist" do
+    it "is return a `RemoteInstaller`" do
+      allow(LogStash::PluginManager::Utils::HttpClient).to receive(:remote_file_exist?).with(subject.pack_uri(plugin_name)).and_return(true)
+      expect(subject.get_installer_for(plugin_name)).to be_kind_of(LogStash::PluginManager::PackInstaller::Remote)
+    end
+  end
+
+  context "when the remote file doesnt exist" do
+    it "returns false" do
+      allow(LogStash::PluginManager::Utils::HttpClient).to receive(:remote_file_exist?).with(subject.pack_uri(plugin_name)).and_return(false)
+      expect(subject.get_installer_for(plugin_name)).to be_falsey
+    end
+  end
+
+  context "when the remote host is unreachable" do
+    it "returns false and yield a debug message" do
+      # To make sure we really try to connect to a failling host we have to let it through webmock
+      host ="#{Time.now.to_i.to_s}-do-not-exist.com"
+      WebMock.disable_net_connect!(:allow => host)
+      stub_const("LogStash::PluginManager::PackFetchStrategy::Repository::ELASTIC_PACK_BASE_URI", "http://#{host}")
+      expect(subject.get_installer_for(plugin_name)).to be_falsey
+    end
+  end
+end
diff --git a/spec/unit/plugin_manager/pack_fetch_strategy/uri_spec.rb b/spec/unit/plugin_manager/pack_fetch_strategy/uri_spec.rb
new file mode 100644
index 00000000000..09effdb909c
--- /dev/null
+++ b/spec/unit/plugin_manager/pack_fetch_strategy/uri_spec.rb
@@ -0,0 +1,52 @@
+# encoding: utf-8
+require "pluginmanager/pack_fetch_strategy/uri"
+require "stud/temporary"
+
+describe LogStash::PluginManager::PackFetchStrategy::Uri do
+  subject { described_class }
+  context "when we dont have URI path" do
+    let(:plugin_path) { "logstash-input-elasticsearch" }
+
+    it "doesnt return an installer" do
+      expect(subject.get_installer_for(plugin_path)).to be_falsey
+    end
+  end
+
+  context "we have another URI scheme than file or http" do
+    let(:plugin_path) { "ftp://localhost:8888/my-pack.zip" }
+
+    it "doesnt return an installer" do
+      expect(subject.get_installer_for(plugin_path)).to be_falsey
+    end
+  end
+
+  context "we have an invalid URI scheme" do
+    let(:plugin_path) { "inv://localhost:8888/my-pack.zip" }
+
+    it "doesnt return an installer" do
+      expect(subject.get_installer_for(plugin_path)).to be_falsey
+    end
+  end
+
+  context "when we have a local path" do
+    let(:temporary_file) do
+      f = Stud::Temporary.file
+      f.write("hola")
+      f.path
+    end
+
+    let(:plugin_path) { "file://#{temporary_file}" }
+
+    it "returns a `LocalInstaller`" do
+      expect(subject.get_installer_for(plugin_path)).to be_kind_of(LogStash::PluginManager::PackInstaller::Local)
+    end
+  end
+
+  context "when we have a remote path" do
+    let(:plugin_path) { "http://localhost:8888/my-pack.zip" }
+
+    it "returns a remote installer" do
+      expect(subject.get_installer_for(plugin_path)).to be_kind_of(LogStash::PluginManager::PackInstaller::Remote)
+    end
+  end
+end
diff --git a/spec/unit/plugin_manager/pack_installer/local_spec.rb b/spec/unit/plugin_manager/pack_installer/local_spec.rb
new file mode 100644
index 00000000000..9fb799cf956
--- /dev/null
+++ b/spec/unit/plugin_manager/pack_installer/local_spec.rb
@@ -0,0 +1,68 @@
+# encoding: utf-8
+require "pluginmanager/pack_installer/local"
+require "stud/temporary"
+require "fileutils"
+
+describe LogStash::PluginManager::PackInstaller::Local do
+  subject { described_class.new(local_file) }
+
+  context "when the local file doesn't exist" do
+    let(:local_file) { ::File.join(Stud::Temporary.pathname, Time.now.to_s.to_s) }
+
+    it "raises an exception" do
+      expect { subject.execute }.to raise_error(LogStash::PluginManager::FileNotFoundError)
+    end
+  end
+
+  context "when the local file exist" do
+    context "when the file has the wrong extension" do
+      let(:local_file) { Stud::Temporary.file.path }
+
+      it "raises a InvalidPackError" do
+        expect { subject.execute }.to raise_error(LogStash::PluginManager::InvalidPackError, /Invalid format/)
+      end
+    end
+
+    context "when there is an error when the zip get uncompressed" do
+      let(:local_file) do
+        directory = Stud::Temporary.pathname
+        FileUtils.mkdir_p(directory)
+        p = ::File.join(directory, "#{Time.now.to_i.to_s}.zip")
+        FileUtils.touch(p)
+        p
+      end
+
+      it "raises a InvalidPackError" do
+        expect { subject.execute }.to raise_error(LogStash::PluginManager::InvalidPackError, /Cannot uncompress the zip/)
+      end
+    end
+
+    context "when the file doesnt have plugins in it" do
+      let(:local_file) { ::File.join(::File.dirname(__FILE__), "..", "..", "..", "support", "pack", "empty-pack.zip") }
+
+      it "raise an Invalid pack" do
+        expect { subject.execute }.to raise_error(LogStash::PluginManager::InvalidPackError, /The pack must contains at least one plugin/)
+      end
+    end
+
+    context "when the pack is valid" do
+      let(:local_file) { ::File.join(::File.dirname(__FILE__), "..", "..", "..", "support", "pack", "valid-pack.zip") }
+
+      it "install the gems" do
+        expect(::Bundler::LogstashInjector).to receive(:inject!).with(be_kind_of(Array)).and_return([])
+
+        expect(::LogStash::PluginManager::GemInstaller).to receive(:install).with(/logstash-input-packtest/, anything)
+        expect(::LogStash::PluginManager::GemInstaller).to receive(:install).with(/logstash-input-packtestdep/, anything)
+
+        # Since the Gem::Indexer have side effect and we have more things loaded
+        # I have to disable it in the tests
+        mock_indexer = double("Gem::Indexer")
+        allow(mock_indexer).to receive(:ui=).with(anything)
+        expect(mock_indexer).to receive(:generate_index)
+        expect(::Gem::Indexer).to receive(:new).with(be_kind_of(String), hash_including(:build_modern => true)).and_return(mock_indexer)
+
+        expect { subject.execute }.not_to raise_error
+      end
+    end
+  end
+end
diff --git a/spec/unit/plugin_manager/pack_installer/pack_spec.rb b/spec/unit/plugin_manager/pack_installer/pack_spec.rb
new file mode 100644
index 00000000000..845f4278f61
--- /dev/null
+++ b/spec/unit/plugin_manager/pack_installer/pack_spec.rb
@@ -0,0 +1,100 @@
+# encoding: utf-8
+require "pluginmanager/pack_installer/pack"
+require "stud/temporary"
+
+describe LogStash::PluginManager::PackInstaller::Pack do
+  let(:extracted_plugin) { ::File.join(::File.dirname(__FILE__), "..", "..", "..", "support", "pack", "valid-pack") }
+
+  subject { described_class.new(extracted_plugin) }
+
+  context "when there is a plugin in the root of the pack" do
+    it "a valid pack" do
+      expect(subject.valid?).to be_truthy
+    end
+
+    it "returns the plugins" do
+      expect(subject.plugins.size).to eq(1)
+      expect(subject.plugins.collect(&:name)).to include("logstash-input-packtest")
+    end
+
+    it "returns the dependencies" do
+      expect(subject.dependencies.size).to eq(1)
+      expect(subject.dependencies.collect(&:name)).to include("logstash-input-packtestdep")
+    end
+
+    it "returns all the gems" do
+      expect(subject.gems.size).to eq(2)
+      expect(subject.gems.collect(&:name)).to include("logstash-input-packtest", "logstash-input-packtestdep")
+    end
+  end
+
+  context "when there is no plugin in the root of the pack " do
+    let(:extracted_plugin) { Stud::Temporary.pathname }
+
+    it "a invalid pack" do
+      expect(subject.valid?).to be_falsey
+    end
+  end
+end
+
+describe LogStash::PluginManager::PackInstaller::Pack::GemInformation do
+  subject { described_class.new(gem) }
+
+  shared_examples "gem information" do
+    it "returns the version" do
+      expect(subject.version).to eq("3.1.8")
+    end
+
+    it "returns the name" do
+      expect(subject.name).to eq("logstash-input-foobar")
+    end
+
+    it "returns the path of the gem" do
+      expect(subject.file).to eq(gem)
+    end
+  end
+
+  context "with a universal gem" do
+    let(:gem) { "/tmp/logstash-input-foobar-3.1.8.gem" }
+
+    include_examples "gem information"
+
+    it "returns nil for the platform" do
+      expect(subject.platform).to be_nil
+    end
+  end
+
+  context "with a java gem" do
+    let(:gem) { "/tmp/logstash-input-foobar-3.1.8-java.gem" }
+
+    include_examples "gem information"
+
+    it "returns nil for the platform" do
+      expect(subject.platform).to eq("java")
+    end
+  end
+
+  context "when its a plugin to be added to the gemfile" do
+    let(:gem) { "/tmp/logstash-input-foobar-3.1.8-java.gem" }
+
+    it "#dependency? return false" do
+      expect(subject.dependency?).to be_falsey
+    end
+
+    it "#plugin? return true" do
+      expect(subject.plugin?).to be_truthy
+    end
+  end
+
+  context "when its a dependency of a plugin" do
+    let(:gem) { "/tmp/dependencies/logstash-input-foobar-3.1.8-java.gem" }
+
+    it "#dependency? return true" do
+      expect(subject.dependency?).to be_truthy
+    end
+
+    it "#plugin? return false" do
+      expect(subject.plugin?).to be_falsey
+    end
+  end
+end
diff --git a/spec/unit/plugin_manager/pack_installer/remote_spec.rb b/spec/unit/plugin_manager/pack_installer/remote_spec.rb
new file mode 100644
index 00000000000..c6daf9ba11e
--- /dev/null
+++ b/spec/unit/plugin_manager/pack_installer/remote_spec.rb
@@ -0,0 +1,40 @@
+# encoding: utf-8
+require "pluginmanager/pack_installer/remote"
+require "webmock/rspec"
+
+describe LogStash::PluginManager::PackInstaller::Remote do
+  let(:url) { "http://localhost:8888/mypackage.zip" }
+
+  subject { described_class.new(url, LogStash::PluginManager::Utils::Downloader::SilentFeedback) }
+
+  context "when the file exist remotely" do
+    let(:content) { "around the world" }
+
+    before do
+      stub_request(:get, url).to_return(
+        { :status => 200,
+          :body => content,
+          :headers => {}}
+      )
+    end
+
+    it "download the file and do a local install" do
+      local_installer = double("LocalInstaller")
+
+      expect(local_installer).to receive(:execute)
+      expect(LogStash::PluginManager::PackInstaller::Local).to receive(:new).with(be_kind_of(String)).and_return(local_installer)
+
+      subject.execute
+    end
+  end
+
+  context "when the file doesn't exist remotely" do
+    before do
+      stub_request(:get, url).to_return({ :status => 404 })
+    end
+
+    it "raises and exception" do
+      expect { subject.execute }.to raise_error(LogStash::PluginManager::FileNotFoundError, /#{url}/)
+    end
+  end
+end
diff --git a/spec/unit/plugin_manager/ui_spec.rb b/spec/unit/plugin_manager/ui_spec.rb
new file mode 100644
index 00000000000..faca7b3a628
--- /dev/null
+++ b/spec/unit/plugin_manager/ui_spec.rb
@@ -0,0 +1,59 @@
+# encoding: utf-8
+require "pluginmanager/ui"
+describe LogStash::PluginManager do
+  it "set the a default ui" do
+    expect(LogStash::PluginManager.ui).to be_kind_of(LogStash::PluginManager::Shell)
+  end
+
+  it "you can override the ui" do
+    klass = Class.new
+    LogStash::PluginManager.ui = klass
+    expect(LogStash::PluginManager.ui).to be(klass)
+    LogStash::PluginManager.ui = LogStash::PluginManager::Shell.new
+  end
+end
+
+describe LogStash::PluginManager::Shell do
+  let(:message) { "hello world" }
+
+  [:info, :error, :warn].each do |level|
+    context "Level: #{level}" do
+      it "display the message to the user" do
+        expect(subject).to receive(:puts).with(message)
+        subject.send(level, message)
+      end
+    end
+  end
+
+  context "Debug" do
+    context "when ENV['DEBUG'] is set" do
+      before do
+        @previous_value = ENV["DEBUG"]
+        ENV["DEBUG"] = "1"
+      end
+
+      it "outputs the message" do
+        expect(subject).to receive(:puts).with(message)
+        subject.debug(message)
+      end
+
+      after do
+        ENV["DEBUG"] = @previous_value
+      end
+    end
+
+    context "when ENV['DEBUG'] is not set" do
+      @previous_value = ENV["DEBUG"]
+      ENV.delete("DEBUG")
+    end
+
+    it "doesn't outputs the message" do
+      expect(subject).not_to receive(:puts).with(message)
+      subject.debug(message)
+    end
+
+    after do
+      ENV["DEBUG"] = @previous_value
+    end
+  end
+end
diff --git a/spec/unit/plugin_manager/utils/downloader_spec.rb b/spec/unit/plugin_manager/utils/downloader_spec.rb
new file mode 100644
index 00000000000..e08e731af01
--- /dev/null
+++ b/spec/unit/plugin_manager/utils/downloader_spec.rb
@@ -0,0 +1,81 @@
+# encoding: utf-8
+require "pluginmanager/utils/downloader"
+require "spec_helper"
+require "webmock/rspec"
+
+describe LogStash::PluginManager::Utils::Downloader::SilentFeedback do
+  let(:max) { 500 }
+  let(:status) { max * 0.5 }
+
+  it "can create an instance" do
+    expect { described_class.new(max) }.not_to raise_error
+  end
+
+  it "can receive `#update` calls" do
+    expect { described_class.new(max).update(status) }.not_to raise_error
+  end
+end
+
+describe LogStash::PluginManager::Utils::Downloader::ProgressbarFeedback do
+  let(:max) { 500 }
+  let(:status) { max * 0.5 }
+
+  it "can create an instance" do
+    expect(ProgressBar).to receive(:create).with(hash_including(:total => max))
+    described_class.new(max)
+  end
+
+  it "can receive multiples `#update` calls" do
+    feedback = described_class.new(max)
+    expect(feedback.progress_bar).to receive(:progress=).with(status).twice
+    feedback.update(status)
+    feedback.update(status)
+  end
+end
+
+describe LogStash::PluginManager::Utils::Downloader do
+  subject { described_class }
+  let(:port) { rand(2000..5000) }
+  let(:url) { "https://localhost:#{port}/my-file.txt"}
+  let(:content) { "its halloween, halloween!" }
+
+  context "when the file exist" do
+    before do
+      stub_request(:get, url).to_return(
+        { :status => 200,
+          :body => content,
+          :headers => {}}
+      )
+    end
+
+    it "download the file to local temporary file" do
+      expect(File.read(subject.fetch(url))).to match(content)
+    end
+
+    context "when an exception occur" do
+      let(:temporary_path) { Stud::Temporary.pathname }
+
+      before do
+        expect_any_instance_of(::File).to receive(:close).at_least(:twice).and_raise("Didn't work")
+        expect(Stud::Temporary).to receive(:pathname).and_return(temporary_path)
+      end
+
+      it "deletes in progress file" do
+        expect { subject.fetch(url) }.to raise_error(RuntimeError, /Didn't work/)
+        expect(Dir.glob(::File.join(temporary_path, "**")).size).to eq(0)
+      end
+    end
+  end
+
+  context "when the file doesn't exist" do
+    before do
+      stub_request(:get, url).to_return(
+        { :status => 404 }
+      )
+    end
+
+    it "raises an exception" do
+      expect { File.read(subject.fetch(url)) }.to raise_error(LogStash::PluginManager::FileNotFoundError)
+    end
+  end
+end
diff --git a/spec/unit/plugin_manager/utils/http_client_spec.rb b/spec/unit/plugin_manager/utils/http_client_spec.rb
new file mode 100644
index 00000000000..7c922486c97
--- /dev/null
+++ b/spec/unit/plugin_manager/utils/http_client_spec.rb
@@ -0,0 +1,101 @@
+# encoding: utf-8
+require "pluginmanager/utils/http_client"
+require "uri"
+
+describe LogStash::PluginManager::Utils::HttpClient do
+  subject  { described_class }
+
+  describe ".start" do
+    context "with ssl" do
+      let(:uri) { URI.parse("https://localhost:8888") }
+
+      it "requires ssl" do
+        expect(Net::HTTP).to receive(:start).with(uri.host, uri.port, hash_including(:use_ssl => true))
+        described_class.start(uri)
+      end
+    end
+
+    context "without ssl" do
+      let(:uri) { URI.parse("http://localhost:8888") }
+
+      it "doesn't requires ssl" do
+        expect(Net::HTTP).to receive(:start).with(uri.host, uri.port, hash_including(:use_ssl => false))
+        described_class.start(uri)
+      end
+    end
+  end
+
+  describe ".remove_file_exist?" do
+    let(:mock_http) { double("Net::HTTP") }
+
+    before do
+      allow(subject).to receive(:start).with(anything).and_yield(mock_http).at_least(:once)
+    end
+
+    context "With URI with a path" do
+      let(:uri) { URI.parse("https://localhost:8080/hola") }
+
+      context "without redirect" do
+        before do
+          expect(mock_http).to receive(:request).with(kind_of(Net::HTTP::Head)).and_return(response)
+        end
+
+        context "file exist" do
+          let(:response) { instance_double("Net::HTTP::Response", :code => "200") }
+
+          it "returns true if the file exist" do
+            expect(subject.remote_file_exist?(uri)).to be_truthy
+          end
+        end
+
+        [404, 400, 401, 500].each do |code|
+          context "when the server return a #{code}" do
+            let(:response) { instance_double("Net::HTTP::Response", :code => code) }
+
+            it "returns false" do
+              expect(subject.remote_file_exist?(uri)).to be_falsey
+            end
+          end
+        end
+      end
+
+      context "with redirects" do
+        let(:redirect_response) { instance_double("Net::HTTP::Response", :code => "302", :headers => { "location" => "https://localhost:8888/new_path" }) }
+        let(:response_ok) { instance_double("Net::HTTP::Response", :code => "200") }
+
+        it "follow 1 level redirect" do
+          expect(mock_http).to receive(:request).with(kind_of(Net::HTTP::Head)).and_return(redirect_response)
+          expect(mock_http).to receive(:request).with(kind_of(Net::HTTP::Head)).and_return(response_ok)
+
+          expect(subject.remote_file_exist?(uri)).to be_truthy
+        end
+
+        it "follow up to the limit of redirect: #{described_class::REDIRECTION_LIMIT - 1}" do
+          (described_class::REDIRECTION_LIMIT - 1).times do
+            expect(mock_http).to receive(:request).with(kind_of(Net::HTTP::Head)).and_return(redirect_response)
+          end
+
+          expect(mock_http).to receive(:request).with(kind_of(Net::HTTP::Head)).and_return(response_ok)
+
+          expect(subject.remote_file_exist?(uri)).to be_truthy
+        end
+
+        it "raises a `RedirectionLimit` when too many redirection occur" do
+          described_class::REDIRECTION_LIMIT.times do
+            expect(mock_http).to receive(:request).with(kind_of(Net::HTTP::Head)).and_return(redirect_response)
+          end
+
+          expect { subject.remote_file_exist?(uri) }.to raise_error(LogStash::PluginManager::Utils::HttpClient::RedirectionLimit)
+        end
+      end
+
+      context "With URI without a path" do
+        let(:uri) { URI.parse("https://localhost:8080") }
+
+        it "return false" do
+          expect(subject.remote_file_exist?(uri)).to be_falsey
+        end
+      end
+    end
+  end
+end
diff --git a/spec/unit/util/compress_spec.rb b/spec/unit/util/compress_spec.rb
index 47bab9e995a..33133c09384 100644
--- a/spec/unit/util/compress_spec.rb
+++ b/spec/unit/util/compress_spec.rb
@@ -2,6 +2,40 @@
 require "spec_helper"
 require 'ostruct'
 require "bootstrap/util/compress"
+require "stud/temporary"
+require "fileutils"
+
+def build_zip_file(structure)
+  source = Stud::Temporary.pathname
+  FileUtils.mkdir_p(source)
+
+  structure.each do |p|
+    file = ::File.basename(p)
+    path = ::File.join(source, ::File.dirname(p))
+    full_path = ::File.join(path, file)
+
+    FileUtils.mkdir_p(path)
+    ::File.open(full_path, "a") do |f|
+      f.write("Hello - #{Time.now.to_i.to_s}")
+    end
+  end
+
+  target = Stud::Temporary.pathname
+  FileUtils.mkdir_p(target)
+  target_file = ::File.join(target, "mystructure.zip")
+
+  LogStash::Util::Zip.compress(source, target_file)
+  target_file
+rescue => e
+  FileUtils.rm_rf(target) if target
+  raise e
+ensure
+  FileUtils.rm_rf(source)
+end
+
+def list_files(target)
+  Dir.glob(::File.join(target, "**", "*")).select { |f| ::File.file?(f) }.size
+end
 
 describe LogStash::Util::Zip do
 
@@ -30,10 +64,53 @@
       expect(zip_file).to receive(:extract).exactly(3).times
       subject.extract(source, target)
     end
+
+    context "patterns" do
+      # Theses tests sound duplicated but they are actually better than the other one
+      # since they do not involve any mocks.
+      subject { described_class }
+
+      let(:zip_structure) {
+        [
+          "logstash/logstash-output-secret/logstash-output-monitoring.gem",
+          "logstash/logs/more/log.log",
+          "kibana/package.json",
+          "elasticsearch/jars.jar",
+          "elasticsearch/README.md"
+        ]
+      }
+
+      let(:zip_file) { build_zip_file(zip_structure) }
+      let(:target) { Stud::Temporary.pathname }
+
+      context "when no matching pattern is supplied" do
+        it "extracts all the file" do
+          subject.extract(zip_file, target)
+
+          expect(list_files(target)).to eq(zip_structure.size)
+
+          zip_structure.each do |full_path|
+            expect(::File.exist?(::File.join(target, full_path))).to be_truthy
+          end
+        end
+      end
+
+      context "when a matching pattern is supplied" do
+        it "extracts only the relevant files" do
+          subject.extract(zip_file, target, /logstash\/?/)
+
+          expect(list_files(target)).to eq(2)
+
+          ["logstash/logstash-output-secret/logstash-output-monitoring.gem",
+           "logstash/logs/more/log.log"].each do |full_path|
+            expect(::File.exist?(::File.join(target, full_path))).to be_truthy
+          end
+        end
+      end
+    end
   end
 
   context "#compression" do
-
     let(:target) { File.join(File.expand_path("."), "target_file.zip") }
     let(:source) { File.expand_path("source_dir") }
 
@@ -62,7 +139,6 @@
   subject { Class.new { extend LogStash::Util::Tar } }
 
   context "#extraction" do
-
     let(:source) { File.join(File.expand_path("."), "source_file.tar.gz") }
     let(:target) { File.expand_path("target_dir") }
 
