diff --git a/CHANGELOG b/CHANGELOG
index 917bf91c761..cc4b34cfc0e 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -11,6 +11,8 @@
   - improvement: twitter: supports http proxying now (#276, patch by Richard
     Pijnenburg)
   - improvement: tcp: ssl now supported! (#318, patch by Matthew Richardson)
+  - feature: redis: now supports 'batch_count' option for doing bulk
+    fetches from redis lists. Requires Redis 2.6.0 or higher.
 
   ## filters
   - deprecation: the --grok-patterns-path flag is deprecated and will now
diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index 99a13530597..f3e7c5eff2d 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -1,11 +1,9 @@
 The following is a list of people who have contributed ideas, code, bug
 reports, or in general have helped logstash along its way.
 
-Project Owners
+Contributors:
 * Jordan Sissel (jordansissel)
 * Pete Fritchman (fetep)
-
-Contributors:
 * Brice Figureau (masterzen)
 * Vladimir Vuksan (vvuksan)
 * Alexandre Dulaunoy (adulau)
@@ -68,4 +66,4 @@ Contributors:
 Note: If you've sent me patches, bug reports, or otherwise contributed to
 logstash, and you aren't on the list above and want to be, please let me know
 and I'll make sure you're here. Contributions from folks like you are what make
-open source the bomb.
+open source awesome.
diff --git a/Makefile b/Makefile
index d50b0370d4e..9e5fc3ca76d 100644
--- a/Makefile
+++ b/Makefile
@@ -305,4 +305,27 @@ sync-jira-components: $(addprefix create/jiracomponent/,$(subst lib/logstash/,,$
 	$(QUIET)rm tmp_jira_action_list
 
 create/jiracomponent/%: 
-	$(QUIET)echo "--action addComponent --project LOGSTASH --name $(subst create/jiracomponent/,,$@)" >> tmp_jira_action_list
\ No newline at end of file
+	$(QUIET)echo "--action addComponent --project LOGSTASH --name $(subst create/jiracomponent/,,$@)" >> tmp_jira_action_list
+
+## Release note section (up to you if/how/when to integrate in docs)
+# Collect the details of:
+#  - merged pull request from GitHub since last release
+#  - issues for FixVersion from JIRA
+
+# Note on used Github logic
+# We parse the commit between the last tag (should be the last release) and HEAD 
+# to extract all the notice about merged pull requests.
+
+# Note on used JIRA release note URL
+# The JIRA Release note list all issues (even open ones) 
+# with Fix Version assigned to target version
+# So one must verify manually that there is no open issue left (TODO use JIRACLI)
+
+# This is the ID for a version item in jira, can be obtained by CLI 
+# or through the Version URL https://logstash.jira.com/browse/LOGSTASH/fixforversion/xxx
+JIRA_VERSION_ID=10820
+
+releaseNote: 
+	-$(QUIET)rm releaseNote.html
+	$(QUIET)curl -si "https://logstash.jira.com/secure/ReleaseNote.jspa?version=$(JIRA_VERSION_ID)&projectId=10020" | sed -n '/<textarea.*>/,/<\/textarea>/p' | grep textarea -v >> releaseNote.html
+	$(QUIET)ruby pull_release_note.rb
\ No newline at end of file
diff --git a/README.md b/README.md
index 594495e5ac9..ff5310f0a12 100755
--- a/README.md
+++ b/README.md
@@ -24,8 +24,8 @@ You can also find documentation on the <http://logstash.net> site.
 To work on the code without building a jar, install rvm and run the following:
 
     # Install JRuby with rvm
-    rvm install jruby-1.7.1
-    rvm use jruby-1.7.1
+    rvm install jruby-1.7.2
+    rvm use jruby-1.7.2
 
     # Install logstash dependencies
     ruby gembag.rb logstash.gemspec
diff --git a/bin/logstash b/bin/logstash
index b129d6327c4..3f5c7968047 100755
--- a/bin/logstash
+++ b/bin/logstash
@@ -7,4 +7,13 @@ if [ -d "$basedir/.git" ] ; then
 fi
 
 export RUBYLIB="$basedir/lib"
-ruby "$basedir/lib/logstash/runner.rb" "$@"
+
+which ruby > /dev/null 2>&1
+if [ "$?" -eq 0 -a -z "$USE_JRUBY" ] ; then
+  ruby "$basedir/lib/logstash/runner.rb" "$@"
+else
+  # No ruby found, fetch JRuby and run.
+  jruby="vendor/jar/jruby-complete-1.7.2.jar"
+  [ ! -f "$jruby" ] && make build-jruby
+  java -jar "$jruby" "$basedir/lib/logstash/runner.rb" "$@"
+fi
diff --git a/bot/check_pull_changelog.rb b/bot/check_pull_changelog.rb
new file mode 100644
index 00000000000..7e8ac7e1f21
--- /dev/null
+++ b/bot/check_pull_changelog.rb
@@ -0,0 +1,89 @@
+require "octokit"
+##
+# This script will validate that any pull request submitted against a github 
+# repository will contains changes to CHANGELOG file.
+#
+# If not the case, an helpful text will be commented on the pull request
+# If ok, a thanksful message will be commented also containing a @mention to 
+# acts as a trigger for review notification by a human.
+## 
+
+
+@bot="" # Put here your bot github username
+@password="" # Put here your bot github password
+
+@repository="logstash/logstash"
+@mention="@jordansissel"
+
+@missing_changelog_message = <<MISSING_CHANGELOG
+Hello, I'm #{@bot}, I'm here to help you accomplish your pull request submission quest
+
+You still need to accomplish these tasks:
+
+* Please add a changelog information
+
+Also note that your pull request name will appears in the details section 
+of the release notes, so please make it clear
+MISSING_CHANGELOG
+
+@ok_changelog_message = <<OK_CHANGELOG
+You successfully completed the pre-requisite quest (aka updating CHANGELOG)
+
+Also note that your pull request name will appears in the details section 
+of the release notes, so please make it clear, if not already done.
+
+#{@mention} Dear master, would you please have a look to this humble request
+OK_CHANGELOG
+
+#Connect to Github
+@client=Octokit::Client.new(:login => @bot, :password => @password)
+
+
+#For each open pull
+Octokit.pull_requests(@repository).each do |pull|
+  #Get botComment
+  botComment = nil
+  @client.issue_comments(@repository, pull.number, {
+    :sort => "created",
+    :direction => "desc"
+  }).each do |comment|
+    if comment.user.login == @bot
+      botComment = comment
+      break
+    end
+  end
+
+  if !botComment.nil? and botComment.body.start_with?("[BOT-OK]")
+    #Pull already validated by bot, nothing to do
+    puts "Pull request #{pull.number}, already ok for bot"
+  else
+    #Firt encounter, or previous [BOT-WARN] status
+    #Check for changelog
+    warnOnMissingChangeLog = true
+    @client.pull_request_files(@repository, pull.number).each do |changedFile|
+      if changedFile.filename  == "CHANGELOG"
+        if changedFile.additions.to_i > 0
+          #Changelog looks good
+          warnOnMissingChangeLog = false
+        else
+          #No additions, means crazy deletion
+          warnOnMissingChangeLog = true
+        end
+      end
+    end
+    if warnOnMissingChangeLog
+      if botComment.nil?
+        puts "Pull request #{pull.number}, adding bot warning"
+        @client.add_comment(@repository, pull.number, "[BOT-WARN] #{@missing_changelog_message}")
+      else
+        puts "Pull request #{pull.number}, already warned, no changes yet"
+      end
+    else
+      if !botComment.nil?
+        @client.delete_comment(@repository,botComment.id)
+      end
+      puts "Pull request #{pull.number}, adding bot ok"
+      @client.add_comment(@repository, pull.number, "[BOT-OK] #{@ok_changelog_message}")
+    end
+  end
+end
diff --git a/debian/debian/dirs b/debian/debian/dirs
index cff5bcc39a1..e12bf97994c 100644
--- a/debian/debian/dirs
+++ b/debian/debian/dirs
@@ -14,3 +14,6 @@ var/log/logstash
 
 # Cache directory for the unpacked logstash.jar file.
 var/cache/logstash
+
+# Temp dir for java
+var/logstash/
diff --git a/debian/debian/logstash.init b/debian/debian/logstash.init
index 02b407930f7..abcd09f6c44 100644
--- a/debian/debian/logstash.init
+++ b/debian/debian/logstash.init
@@ -42,7 +42,7 @@ JAVA=/usr/bin/java
 LS_HOME=/var/lib/logstash
 
 # Additional Java OPTS
-#LS_HOME/bin/java/JAVA/g_OPTS=
+LS_JAVA_OPTS=" -Djava.io.tmpdir=/var/logstash/"
 
 # logstash log directory
 LOG_DIR=/var/log/logstash
@@ -57,7 +57,6 @@ LOG_FILE=$LOG_DIR/$NAME.log
 OPEN_FILES=2048
 
 
-LS_JAVA_OPTS=" -Djava.io.tmpdir=/var/logstash/"
 
 # Nice level
 NICE=19
diff --git a/docs/configuration.md b/docs/configuration.md
index b3af28c608d..5f98a0c6abc 100644
--- a/docs/configuration.md
+++ b/docs/configuration.md
@@ -40,7 +40,7 @@ Comments are as in ruby, perl, and python. Starts with a '#' character. Example:
 The documentation for a plugin may say that a config field has a certain type.
 Examples include boolean, string, array, number, hash, etc.
 
-### Boolean
+### <a name="boolean"></a>Boolean
 
 A boolean must be either true or false.
 
@@ -48,7 +48,7 @@ Examples:
 
     debug => true
 
-### String
+### <a name="string"></a>String
 
 A string must be a single value.
 
@@ -58,7 +58,7 @@ Example:
 
 Single, unquoted words are valid as strings, too, but you should use quotes.
 
-### Number
+### <a name="number"></a>Number
 
 Numbers must be valid numerics (floating point or integer are OK)
 
@@ -66,7 +66,7 @@ Example:
 
     port => 33
 
-### Array
+### <a name="array"></a>Array
 
 An 'array' can be a single string value or multiple. If you specify the same
 field multiple times, it appends to the array.
@@ -78,7 +78,7 @@ Examples:
 
 The above makes 'path' a 3-element array including all 3 strings.
 
-### Hash
+### <a name="hash"></a>Hash
 
 A 'hash' is currently represented using the same syntax as an array (see above).
 The 'key' and 'value' are simply pairs, such as:
diff --git a/docs/learn.md b/docs/learn.md
index 8c0ead078e2..b2034f16bbc 100644
--- a/docs/learn.md
+++ b/docs/learn.md
@@ -22,7 +22,7 @@ parsing tools, etc. Video also below:
 The slides are available online here: [slides](http://goo.gl/68c62). The slides
 include speaker notes (click 'actions' then 'speaker notes').
 -->
-<iframe width="480" height="296" src="http://www.youtube.com/embed/RuUFnog29M4" frameborder="0" allowfullscreen></iframe>
+<iframe width="480" height="296" src="http://www.youtube.com/embed/RuUFnog29M4" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
 
 The slides are available online here: [slides](http://semicomplete.com/presentations/logstash-puppetconf-2012/).
 
diff --git a/docs/plugin-doc.html.erb b/docs/plugin-doc.html.erb
index 244dfa3d447..263e46a31d9 100644
--- a/docs/plugin-doc.html.erb
+++ b/docs/plugin-doc.html.erb
@@ -83,9 +83,9 @@ This is what it might look like in your config file:
   <li> The configuration attribute name here is anything that matches the above regular expression. </li>
 <% end -%>
 <% if config[:validate].is_a?(Symbol) -%>
-  <li> Value type is <%= config[:validate] %> </li>
+  <li> Value type is <a href="../configuration#<%= config[:validate] %>"><%= config[:validate] %></a> </li>
 <% elsif config[:validate].nil? -%>
-  <li> Value type is string </li>
+  <li> Value type is <a href="../configuration#string">string</a> </li>
 <% elsif config[:validate].is_a?(Array) -%>
   <li> Value can be any of: <%= config[:validate].map(&:inspect).join(", ") %> </li>
 <% end -%>
diff --git a/lib/logstash/agent.rb b/lib/logstash/agent.rb
index 711578bfa1e..bf3d27c6dfd 100644
--- a/lib/logstash/agent.rb
+++ b/lib/logstash/agent.rb
@@ -29,6 +29,7 @@ class LogStash::Agent
   attr_reader :config_path
   attr_reader :logfile
   attr_reader :verbose
+  attr_reader :configtest
 
   public
   def initialize
@@ -45,6 +46,7 @@ def initialize
     @verbose = 0
     @filterworker_count = 1
     @watchdog_timeout = 10
+    @configtest = false
 
     @plugins = {}
     @plugins_mutex = Mutex.new
@@ -104,6 +106,10 @@ def options(opts)
       @logfile = path
     end
 
+    opts.on("-t", "--configtest", "Test configuration and exit.") do |arg|
+        @configtest = true
+    end
+
     opts.on("-v", "Increase verbosity") do
       @verbose += 1
     end
@@ -397,7 +403,7 @@ def run_with_config(config)
 
       # If we are given a config string (run usually with 'agent -e "some config string"')
       # then set up some defaults.
-      if @config_string
+      if @config_string or @configtest
         require "logstash/inputs/stdin"
         require "logstash/outputs/stdout"
 
@@ -409,10 +415,10 @@ def run_with_config(config)
         end
 
         # If no inputs are specified, use stdin by default.
-        @inputs = [LogStash::Inputs::Stdin.new("type" => [ "stdin" ])] if @inputs.length == 0
+        @inputs = [LogStash::Inputs::Stdin.new("type" => [ "stdin" ])] if (@inputs.length == 0 or @configtest)
 
         # If no outputs are specified, use stdout in debug mode.
-        @outputs = [LogStash::Outputs::Stdout.new("debug" => [ "true" ])] if @outputs.length == 0
+        @outputs = [LogStash::Outputs::Stdout.new("debug" => [ "true" ])] if (@outputs.length == 0 or @configtest)
       end
 
       if @inputs.length == 0 or @outputs.length == 0
@@ -487,6 +493,13 @@ def run_with_config(config)
       @logger.info("All plugins are started and registered.")
     end # synchronize
 
+    # exit if configtest
+    if @configtest
+      puts "Config test passed.  Exiting..."
+      shutdown
+      exit (0)
+    end
+
     # yield to a block in case someone's waiting for us to be done setting up
     # like tests, etc.
     yield if block_given?
diff --git a/lib/logstash/config/mixin.rb b/lib/logstash/config/mixin.rb
index 25038f91cda..1bebe6e0a67 100644
--- a/lib/logstash/config/mixin.rb
+++ b/lib/logstash/config/mixin.rb
@@ -350,7 +350,7 @@ def validate_value(value, validator)
             if value.size > 1 # only one value wanted
               return false, "Expected number, got #{value.inspect}"
             end
-            if value.first.to_s.to_i.to_s != value.first.to_s
+            if value.first.to_s.to_f.to_s != value.first.to_s
               return false, "Expected number, got #{value.first.inspect}"
             end
             result = value.first.to_i
diff --git a/lib/logstash/event_v0.rb b/lib/logstash/event_v0.rb
index 37a01c63ddb..d33422bfc8e 100644
--- a/lib/logstash/event_v0.rb
+++ b/lib/logstash/event_v0.rb
@@ -4,7 +4,6 @@
 require "logstash/time_addon"
 require "logstash/namespace"
 require "uri"
-require "msgpack"
 
 # General event type. 
 # Basically a light wrapper on top of a hash.
diff --git a/lib/logstash/event_v1.rb b/lib/logstash/event_v1.rb
index 39a826b304f..047caf64923 100644
--- a/lib/logstash/event_v1.rb
+++ b/lib/logstash/event_v1.rb
@@ -4,7 +4,6 @@
 require "logstash/time_addon"
 require "logstash/namespace"
 require "uri"
-require "msgpack"
 
 # the logstash event object.
 #
diff --git a/lib/logstash/filters/csv.rb b/lib/logstash/filters/csv.rb
index a17926f7704..db27437a49e 100644
--- a/lib/logstash/filters/csv.rb
+++ b/lib/logstash/filters/csv.rb
@@ -25,7 +25,7 @@ class LogStash::Filters::CSV < LogStash::Filters::Base
 
   # The CSV data in the value of the source field will be expanded into a
   # datastructure.
-  # This deprecates the regexp '[A-Za-z0-9_-]' variable.
+  # This deprecates the regexp `[A-Za-z0-9_-]` variable.
   config :source, :validate => :string
 
   # Define a list of column names (in the order they appear in the CSV,
diff --git a/lib/logstash/filters/date.rb b/lib/logstash/filters/date.rb
index e62fa4fa540..9e87886bf95 100644
--- a/lib/logstash/filters/date.rb
+++ b/lib/logstash/filters/date.rb
@@ -43,8 +43,8 @@ class LogStash::Filters::Date < LogStash::Filters::Base
   #
   # [joda.time.format.DateTimeFormat](http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html)
   #
-  # An array with field name first, and format patterns following, [ field,
-  # formats... ]
+  # An array with field name first, and format patterns following, `[ field,
+  # formats... ]`
   #
   # If your time field has multiple possible formats, you can do this:
   #
diff --git a/lib/logstash/filters/geoip.rb b/lib/logstash/filters/geoip.rb
index 52e4c72fbf0..ee9a2b428a0 100644
--- a/lib/logstash/filters/geoip.rb
+++ b/lib/logstash/filters/geoip.rb
@@ -24,7 +24,18 @@ class LogStash::Filters::GeoIP < LogStash::Filters::Base
 
   # The field containing IP address, hostname is also OK. If this field is an
   # array, only the first value will be used.
-  config :field, :validate => :string, :required => true
+  config :field, :validate => :string, :deprecated => true
+
+  # The field containing IP address, hostname is also OK. If this field is an
+  # array, only the first value will be used.
+  config :source, :validate => :string
+
+  # Array of fields that we want to be included in our event
+  # Default it will include all fields.
+  # Possible fields depend on the database type
+  # For the built in GeoLiteCity database:
+  # city_name, continent_code, country_code2, country_code3, country_name, dma_code, ip, latitude, longitude, postal_code, region_name, timezone
+  config :fields, :validate => :array
 
   public
   def register
@@ -64,6 +75,15 @@ def register
     else
       raise RuntimeException.new "This GeoIP database is not currently supported"
     end
+
+    #TODO(electrical): Remove this when removing the field variable
+    if @field
+      if @source
+        logger.error("'field' and 'source' are the same setting, but 'field' is deprecated. Please use only 'source'")
+      end
+      @source = @field
+    end
+
   end # def register
 
   public
@@ -71,7 +91,7 @@ def filter(event)
     return unless filter?(event)
     geo_data = nil
     begin
-      ip = event[@field]
+      ip = event[@source]
       ip = ip.first if ip.is_a? Array
       geo_data = @geoip.send(@geoip_type, ip)
     rescue SocketError => e
@@ -84,8 +104,17 @@ def filter(event)
       geo_data_hash.delete(:request)
       event["geoip"] = {} if event["geoip"].nil?
       geo_data_hash.each do |key, value|
-        # convert key to string (normally a Symbol)
-        event["geoip"][key.to_s] = value
+        # Check if we have an array for specific fields
+        if !fields.empty?
+          # Check if the key is in our fields array
+          if fields.include?(key.to_s)
+            # convert key to string (normally a Symbol)
+            event["geoip"][key.to_s] = value
+          end
+        else
+          # convert key to string (normally a Symbol)
+          event["geoip"][key.to_s] = value
+        end
       end
       filter_matched(event)
     end
diff --git a/lib/logstash/filters/metrics.rb b/lib/logstash/filters/metrics.rb
index e2c9f975864..7d4132af0bf 100644
--- a/lib/logstash/filters/metrics.rb
+++ b/lib/logstash/filters/metrics.rb
@@ -95,10 +95,10 @@ class LogStash::Filters::Metrics < LogStash::Filters::Base
   config_name "metrics"
   plugin_status "experimental"
 
-  # syntax: meter => [ "name of metric", "name of metric" ]
+  # syntax: `meter => [ "name of metric", "name of metric" ]`
   config :meter, :validate => :array, :default => []
 
-  # syntax: timer => [ "name of metric", "%{time_value}" ]
+  # syntax: `timer => [ "name of metric", "%{time_value}" ]`
   config :timer, :validate => :hash, :default => {}
 
   # Don't track events that have @timestamp older than some number of seconds. 
diff --git a/lib/logstash/filters/range.rb b/lib/logstash/filters/range.rb
new file mode 100644
index 00000000000..88a628c2c87
--- /dev/null
+++ b/lib/logstash/filters/range.rb
@@ -0,0 +1,141 @@
+require "logstash/filters/base"
+require "logstash/namespace"
+
+# This filter is used to check that certain fields are within expected size/length ranges.
+# Supported types are numbers and strings.
+# Numbers are checked to be within numeric value range.
+# Strings are checked to be within string length range.
+# More than one range can be specified for same fieldname, actions will be applied incrementally.
+# Then field value is with in a specified range and action will be taken
+# supported actions are drop event add tag or add field with specified value.
+#
+# Example usecases are for histogram like tagging of events
+# or for finding anomaly values in fields or too big events that should be dropped.
+
+class LogStash::Filters::Range < LogStash::Filters::Base
+  config_name "range"
+  plugin_status "experimental"
+
+  # An array of field, min, max ,action tuples.
+  # Example:
+  #
+  #     filter {
+  #       %PLUGIN% {
+  #         ranges => [ "@message", 0, 10, "tag:short",
+  #                     "@message", 11, 100, "tag:medium",
+  #                     "@message", 101, 1000, "tag:long",
+  #                     "@message", 1001, 1e1000, "drop",
+  #                     "duration", 0, 100, "field:latency:fast",
+  #                     "duration", 101, 200, "field:latency:normal",
+  #                     "duration", 201, 1000, "field:latency:slow",
+  #                     "duration", 1001, 1e1000, "field:latency:outlier" 
+  #                     "requests", 0, 10, "tag:to_few_%{@host_source}_requests" ]
+  #       }
+  #     }
+  #
+  # Supported actions are drop tag or field with specified value.
+  # Added tag names and field names and field values can have %{dynamic} values.
+  #
+  # TODO(piavlo): The action syntax is ugly at the moment due to logstash grammar limitations - arrays grammar should support
+  # TODO(piavlo): simple not nested hashses as values in addition to numaric and string values to prettify the syntax.
+  config :ranges, :validate => :array, :default => []
+
+  # Negate the range match logic, events should be outsize of the specificed range to match.
+  config :negate, :validate => :boolean, :default => false
+
+  public
+  def register
+    if @ranges.length % 4 != 0
+      raise "#{self.class.name}: ranges array should consist of 4 field tuples (field,min,max,action)"
+    end
+  
+    @range_tuples = {}
+
+    while !@ranges.empty?
+      fieldname, min, max, action = @ranges.shift(4)
+      
+      raise "#{self.class.name}: range field name value should be a string" if !fieldname.is_a?(String)
+      raise "#{self.class.name}: range min value should be a number" if !min.is_a?(Integer) and !min.is_a?(Float)
+      raise "#{self.class.name}: range min value should be a number" if !max.is_a?(Integer) and !max.is_a?(Float)
+      raise "#{self.class.name}: range action value should be a string" if !action.is_a?(String)
+      
+      action = action.split(':')
+      
+      case action.first
+      when "drop"
+        raise "#{self.class.name}: drop action does not accept any parameters" unless action.length == 1
+        action = { :name => :drop }
+      when "tag"
+        raise "#{self.class.name}: tag action accepts exactly one arg which is a tag name" unless action.length == 2
+        action = { :name => :add_tag, :tag => action.last }
+      when "field"
+        raise "#{self.class.name}: field action accepts exactly 2 args which are a field name and field value" unless action.length == 3
+        if action.last == action.last.to_i.to_s
+          value = action.last.to_i
+        elsif action.last == action.last.to_f.to_s
+          value = action.last.to_f
+        else
+          value = action.last
+        end
+        action = { :name => :add_field, :field => action[1], :value => value }
+      else
+        raise "#{self.class.name}: unsupported action #{action}"
+      end
+      
+      @range_tuples[fieldname] ||= []
+      @range_tuples[fieldname] << { :min => min, :max => max, :action => action }
+    end
+  end # def register
+
+ 
+  public
+  def filter(event)
+    return unless filter?(event)
+
+    @range_tuples.each_key do |fieldname|
+      if event.include?(fieldname)
+        @range_tuples[fieldname].each do |range|
+          matched = false
+        
+          field = event[fieldname]
+          case field
+          when Integer
+            matched = field.between?(range[:min], range[:max])
+          when Float
+            matched = field.between?(range[:min], range[:max])
+          when String
+            matched = field.length.between?(range[:min], range[:max])
+          else
+            @logger.warn("#{self.class.name}: action field value has unsupported type")
+          end
+
+          matched = !matched if @negate
+          next unless matched
+        
+          case range[:action][:name]
+          when :drop
+            @logger.debug? and @logger.debug("#{self.class.name}: dropping event due to range match", :event => event)
+            event.cancel
+            return
+          when :add_tag
+            @logger.debug? and @logger.debug("#{self.class.name}: adding tag due to range match",
+                                             :event => event, :tag => range[:action][:tag] )
+            event.tags << event.sprintf(range[:action][:tag])
+          when :add_field
+            @logger.debug? and @logger.debug("#{self.class.name}: adding field due to range match",
+                                              :event => event, :field => range[:action][:field], :value => range[:action][:value])
+            new_field = event.sprintf(range[:action][:field])
+            if event[new_field]
+              event[new_field] = [event[new_field]] if !event[new_field].is_a?(Array)
+              event[new_field] << event.sprintf(range[:action][:value])
+            else
+              event[new_field] = range[:action][:value].is_a?(String) ? event.sprintf(range[:action][:value]) : range[:action][:value]
+            end
+          end
+        end
+      end
+    end
+    
+    filter_matched(event)
+  end # def filter
+end # class LogStash::Filters::Range
diff --git a/lib/logstash/filters/translate.rb b/lib/logstash/filters/translate.rb
index 5edd7a4aee5..fa101f1473d 100644
--- a/lib/logstash/filters/translate.rb
+++ b/lib/logstash/filters/translate.rb
@@ -3,69 +3,114 @@
 
 # Originally written to translate HTTP response codes 
 # but turned into a general translation tool which uses
-# .yaml files as a dictionary.
+# configured has or/and .yaml files as a dictionary.
 # response codes in default dictionary were scraped from 
 # 'gem install cheat; cheat status_codes'
+#
+# Alternatively for simple string search and replacements for just a few values
+# use the gsub function of the mutate filter.
 
 class LogStash::Filters::Translate < LogStash::Filters::Base
   config_name "translate"
   plugin_status "experimental"
 
-
   # The field containing a response code If this field is an
   # array, only the first value will be used.
   config :field, :validate => :string, :required => true
 
+  # In case dstination field already exists should we skip translation(default) or override it with new translation
+  config :override, :validate => :boolean, :default => false
+
+  # Dictionary to use for translation.
+  # Example:
+  #
+  #     filter {
+  #       %PLUGIN% {
+  #         dictionary => [ "100", "Continue",
+  #                         "101", "Switching Protocols",
+  #                         "200", "OK",
+  #                         "201", "Created",
+  #                         "202", "Accepted" ]
+  #       }
+  #     }
+  config :dictionary, :validate => :hash,  :default => {}
+
   # name with full path of external dictionary file.    
-  # format of the table should be a YAML file. 
+  # format of the table should be a YAML file which will be merged with the @dictionary.
   # make sure you encase any integer based keys in quotes.
-  # For simple string search and replacements for just a few values
-  # use the gsub function of the mutate filter.
-  config :dictionary_path, :validate => :path, :required => true
+  config :dictionary_path, :validate => :path
 
-  # The destination you wish to populate with the response code.    
-  # default is http_response_code.  set to the same value as source
-  # if you want to do a substitution.
+  # The destination field you wish to populate with the translation code.
+  # default is "translation".
+  # Set to the same value as source if you want to do a substitution, in this case filter will allways succeed.
   config :destination, :validate => :string, :default => "translation"
 
-  # set to false if you want to match multiple terms.   
+  # set to false if you want to match multiple terms
   # a large dictionary could get expensive if set to false.
   config :exact, :validate => :boolean, :default => true
 
+  # treat dictionary keys as regular expressions to match against, used only then @exact enabled.
+  config :regex, :validate => :boolean, :default => false
 
+  # Incase no translation was made add default translation string
+  config :fallback, :validate => :string
 
   public
   def register
-    if File.exists?(@dictionary_path)
+    if @dictionary_path
+      raise "#{self.class.name}: dictionary file #{@dictionary_path} does not exists" unless File.exists?(@dictionary_path)
       begin
-        @dictionary = YAML.load_file(@dictionary_path)
+        @dictionary.merge!(YAML.load_file(@dictionary_path))
       rescue Exception => e
-        raise "Bad Syntax in dictionary file" 
+        raise "#{self.class.name}: Bad Syntax in dictionary file #{@dictionary_path}"
       end
-    end # if File.exists?
-    @logger.info("Dictionary - ", :dictionary => @dictionary)
+    end
+    
+    @logger.debug? and @logger.debug("#{self.class.name}: Dictionary - ", :dictionary => @dictionary)
     if @exact
-      @logger.info("Dictionary translation method - Exact")
-    else 
-      @logger.info("Dictionary translation method - Fuzzy")
-    end # if @exact
+      @logger.debug? and @logger.debug("#{self.class.name}: Dictionary translation method - Exact")
+    else
+      @logger.debug? and @logger.debug("#{self.class.name}: Dictionary translation method - Fuzzy")
+    end
   end # def register
 
   public
   def filter(event)
     return unless filter?(event)
-      begin
-        source = event[@field]
-        source = source.first if source.is_a? Array # if array,  just use first value 
-        source = source.to_s # make sure its a string.  Is this really needed?
-        if @exact
-          translation = @dictionary[source] if @dictionary.include?(source)
-        else 
-          translation = source.gsub(Regexp.union(@dictionary.keys), @dictionary)
-        end # if @exact
-      rescue Exception => e
-          @logger.error("Something went wrong when attempting to translate from dictionary", :exception => e, :field => @field, :event => event)
+
+    return unless event.include?(@field) # Skip translation in case event does not have @event field.
+    return if event.include?(@destination) and not @override # Skip translation in case @destination field already exists and @override is disabled.
+
+    begin
+      #If source field is array use first value and make sure source value is string
+      source = event[@field].is_a?(Array) ? event[@field].first.to_s : event[@field].to_s
+      matched = false
+      if @exact
+        if @regex
+          key = @dictionary.keys.detect{|k| source.match(Regexp.new(k))}
+          if key
+            event[@destination] = @dictionary[key]
+            matched = true
+          end
+        elsif @dictionary.include?(source)
+          event[@destination] = @dictionary[source]
+          matched = true
+        end
+      else 
+        translation = source.gsub(Regexp.union(@dictionary.keys), @dictionary)
+        if source != translation
+          event[@destination] = translation
+          matched = true
+        end
+      end
+
+      if not matched and @fallback
+        event[@destination] = @fallback
+        matched = true
       end
-      event[@destination] = translation
+      filter_matched(event) if matched or @field == @destination
+    rescue Exception => e
+      @logger.error("Something went wrong when attempting to translate from dictionary", :exception => e, :field => @field, :event => event)
+    end
   end # def filter
 end # class LogStash::Filters::Translate
diff --git a/lib/logstash/inputs/eventlog.rb b/lib/logstash/inputs/eventlog.rb
index 464ef4d4854..ceb2785a689 100644
--- a/lib/logstash/inputs/eventlog.rb
+++ b/lib/logstash/inputs/eventlog.rb
@@ -50,7 +50,12 @@ def register
 
     @hostname = Socket.gethostname
     @logger.info("Registering input eventlog://#{@hostname}/#{@logfile}")
-    require "win32ole" # rubygem 'win32ole' ('jruby-win32ole' on JRuby)
+
+    if RUBY_PLATFORM == "java"
+      require "jruby-win32ole"
+    else
+      require "win32ole"
+    end
   end # def register
 
   public
diff --git a/lib/logstash/inputs/file.rb b/lib/logstash/inputs/file.rb
index b1c7cabeaf0..4a0492621a3 100644
--- a/lib/logstash/inputs/file.rb
+++ b/lib/logstash/inputs/file.rb
@@ -16,7 +16,7 @@ class LogStash::Inputs::File < LogStash::Inputs::Base
   plugin_status "beta"
 
   # The path to the file to use as an input.
-  # You can use globs here, such as "/var/log/*.log"
+  # You can use globs here, such as `/var/log/*.log`
   # Paths must be absolute and cannot be relative.
   config :path, :validate => :array, :required => true
 
diff --git a/lib/logstash/inputs/irc.rb b/lib/logstash/inputs/irc.rb
index b5d5cfe20d5..ce2071effa3 100644
--- a/lib/logstash/inputs/irc.rb
+++ b/lib/logstash/inputs/irc.rb
@@ -56,7 +56,7 @@ def register
       c.realname = @real
       c.user = @user
       c.channels = @channels
-      c.password = @password
+      c.password = @password.value rescue nil
       c.ssl.use = @secure
     end
     queue = @irc_queue
diff --git a/lib/logstash/inputs/rabbitmq.rb b/lib/logstash/inputs/rabbitmq.rb
index ade38c47424..ec916568741 100644
--- a/lib/logstash/inputs/rabbitmq.rb
+++ b/lib/logstash/inputs/rabbitmq.rb
@@ -82,6 +82,9 @@ class LogStash::Inputs::RabbitMQ < LogStash::Inputs::Threadable
   # Maximum permissible size of a frame (in bytes) to negotiate with clients
   config :frame_max, :validate => :number, :default => 131072
 
+  # Array of headers (in messages' metadata) to add to fields in the event
+  config :headers_fields, :validate => :array, :default => {}
+  
   public
   def initialize(params)
     super
@@ -135,12 +138,24 @@ def run(queue)
       @bunnyqueue = @bunny.queue(@queue, {:durable => @durable, :auto_delete => @auto_delete, :exclusive => @exclusive, :arguments => @arguments_hash })
       @bunnyqueue.bind(@exchange, :key => @key)
 
-      @bunnyqueue.subscribe({:ack => @ack}) do |data|
-        e = to_event(data[:payload], @rabbitmq_url)
-        if e
+      # need to get metadata from data
+      @bunnyqueue.subscribe({:ack => @ack, :block => true}) do |delivery_info, metadata, data|
+        
+        e = to_event(data, @rabbitmq_url)
+        if e          
+          if !@headers_fields.empty?
+            # constructing the hash array of headers to add
+            # select headers from properties if they are in the array @headers_fields
+            headers_add = metadata.headers.select {|k, v| @headers_fields.include?(k)}          
+            @logger.debug("Headers to insert in fields : ", :headers => headers_add)
+             
+            headers_add.each do |added_field, added_value|
+              e[added_field] = added_value              
+            end # headers_add.each do
+          end # if !@headers_fields.empty?
           queue << e
-        end
-      end # @bunnyqueue.subscribe
+        end # if e
+      end # @bunnyqueue.subscribe do
 
     rescue *[Bunny::ConnectionError, Bunny::ServerDownError] => e
       @logger.error("RabbitMQ connection error, will reconnect: #{e}")
diff --git a/lib/logstash/inputs/redis.rb b/lib/logstash/inputs/redis.rb
index 44fe1de6799..83aa92f3674 100644
--- a/lib/logstash/inputs/redis.rb
+++ b/lib/logstash/inputs/redis.rb
@@ -6,8 +6,12 @@
 # (using BLPOP)
 #
 # For more information about redis, see <http://redis.io/>
+#
+# ## `batch_count` note
+#
+# If you use the 'batch_count' setting, you *must* use a redis version 2.6.0 or
+# newer. Anything older does not support the operations used by batching.
 class LogStash::Inputs::Redis < LogStash::Inputs::Threadable
-
   config_name "redis"
   plugin_status "beta"
 
diff --git a/lib/logstash/inputs/snmptrap.rb b/lib/logstash/inputs/snmptrap.rb
index 4c8399cbbe1..34c13aaf7f4 100644
--- a/lib/logstash/inputs/snmptrap.rb
+++ b/lib/logstash/inputs/snmptrap.rb
@@ -9,8 +9,6 @@
 #   @enterprise=[1.2.3.4.5.6], @source_ip="127.0.0.1", @agent_addr=#<SNMP::IpAddress:0x29a4833e @value="\xC0\xC1\xC2\xC3">, 
 #   @specific_trap=99>
 #
-# TODO : work out how to break it down into field.keys.   looks like varbind_list can have multiple entries which might 
-#        mean multiple events per trap ?
 
 class LogStash::Inputs::Snmptrap < LogStash::Inputs::Base
   config_name "snmptrap"
@@ -57,6 +55,9 @@ def snmptrap_listener(output_queue)
     @snmptrap.on_trap_default do |trap|
       begin
         event = to_event(trap.inspect, trap.source_ip)
+        trap.each_varbind do |vb|
+          event[vb.name.to_s] = vb.value.to_s
+        end
         @logger.debug("SNMP Trap received: ", :trap_object => trap.inspect)
         output_queue << event if event
       rescue => event
diff --git a/lib/logstash/inputs/tcp.rb b/lib/logstash/inputs/tcp.rb
index 3f18c46a55a..d6b458f7028 100644
--- a/lib/logstash/inputs/tcp.rb
+++ b/lib/logstash/inputs/tcp.rb
@@ -34,7 +34,7 @@ class Interrupted < StandardError; end
   # `client` connects to a server.
   config :mode, :validate => ["server", "client"], :default => "server"
 
-  # Enable ssl (must be set for other `ssl_` options to take effect_
+  # Enable ssl (must be set for other `ssl_` options to take effect)
   config :ssl_enable, :validate => :boolean, :default => false
 
   # Verify the identity of the other end of the ssl connection against the CA
diff --git a/lib/logstash/outputs/file.rb b/lib/logstash/outputs/file.rb
index 6c7985bad3b..3aa92b20e89 100644
--- a/lib/logstash/outputs/file.rb
+++ b/lib/logstash/outputs/file.rb
@@ -58,12 +58,13 @@ def receive(event)
     # TODO(sissel): Check if we should rotate the file.
 
     if @message_format
-      output = event.sprintf(@message_format) + "\n"
+      output = event.sprintf(@message_format)
     else
       output = event.to_json
     end
 
-    fd.puts(output)
+    fd.write(output)
+    fd.write("\n")
 
     flush(fd)
     close_stale_files
diff --git a/lib/logstash/outputs/ganglia.rb b/lib/logstash/outputs/ganglia.rb
index cb39817b5ad..8d1c80bf2aa 100644
--- a/lib/logstash/outputs/ganglia.rb
+++ b/lib/logstash/outputs/ganglia.rb
@@ -13,10 +13,10 @@ class LogStash::Outputs::Ganglia < LogStash::Outputs::Base
   # The port to connect on your ganglia server.
   config :port, :validate => :number, :default => 8649
 
-  # The metric to use. This supports dynamic strings like %{@source_host}
+  # The metric to use. This supports dynamic strings like `%{@source_host}`
   config :metric, :validate => :string, :required => true
 
-  # The value to use. This supports dynamic strings like %{bytes}
+  # The value to use. This supports dynamic strings like `%{bytes}`
   # It will be coerced to a floating point value. Values which cannot be
   # coerced will zero (0)
   config :value, :validate => :string, :required => true
diff --git a/lib/logstash/outputs/irc.rb b/lib/logstash/outputs/irc.rb
index 14b16aa1dca..f3a7d0b9f38 100644
--- a/lib/logstash/outputs/irc.rb
+++ b/lib/logstash/outputs/irc.rb
@@ -51,7 +51,7 @@ def register
       c.user = @user
       c.realname = @real
       c.channels = @channels
-      c.password = @password
+      c.password = @password.value rescue nil
     end
     Thread.new(@bot) do |bot|
       bot.start
diff --git a/lib/logstash/outputs/rabbitmq.rb b/lib/logstash/outputs/rabbitmq.rb
index 9c0355f77f3..c45aab6c72d 100644
--- a/lib/logstash/outputs/rabbitmq.rb
+++ b/lib/logstash/outputs/rabbitmq.rb
@@ -59,6 +59,9 @@ class LogStash::Outputs::RabbitMQ < LogStash::Outputs::Base
   # Maximum permissible size of a frame (in bytes) to negotiate with clients
   config :frame_max, :validate => :number, :default => 131072
 
+  # Array of fields to add to headers in messages' metadata
+  config :fields_headers, :validate => :array, :default => {}
+  
   public
   def register
     require "bunny"
@@ -112,6 +115,24 @@ def receive(event)
     @logger.debug("Sending event", :destination => to_s, :event => event,
                   :key => key)
     key = event.sprintf(@key) if @key
+    
+   
+    # Adding headers from fields' attribute
+    @headers_add = event.fields.select {|k, v| @fields_headers.include?(k)}
+    @logger.debug("Adding headers from Fields attributes : #{@headers_add.inspect}")
+            
+    # Adding headers from "original" attributes 
+    # Iteration on each field name specified in fields_headers
+    @fields_headers.each do |added_field|
+      # Verify if added_field is in the list of tags     
+      if event.include?(added_field)
+        @headers_add[added_field] = event[added_field]
+        @logger.debug("Adding native field #{added_field} to headers")
+      else
+        @logger.debug("Not Adding tag #{added_field} to headers because missing")
+      end # if event.include?(added_field)
+    end # :fields_headers.each do |added_field|
+    
     begin
       receive_raw(event.to_json, key)
     rescue JSON::GeneratorError => e
@@ -125,22 +146,30 @@ def receive(event)
   def receive_raw(message, key=@key)
     begin
       if @bunnyexchange
-        @logger.debug(["Publishing message", { :destination => to_s, :message => message, :key => key }])
-        @bunnyexchange.publish(message, :persistent => @persistent, :key => key)
+        if @headers_add.empty?
+          #tags2headers is empty, so we send the message normally
+          @logger.debug(["Publishing message", { :destination => to_s, :message => message, :key => key }])
+          @bunnyexchange.publish(message, :persistent => @persistent, :key => key)
+        else
+          #publishing messages WITH headers, that are stored in "headers_add"
+          @logger.debug(["Publishing message", { :destination => to_s, :message => message, :key => key , :headers => @headers_add.inspect}])
+          @bunnyexchange.publish(message, :persistent => @persistent, :key => key, :headers => @headers_add)
+          
+        end # if @headers2headers.empty?
       else
         @logger.warn("Tried to send message, but not connected to rabbitmq yet.")
-      end
+      end  # if @bunnyexchange
     rescue *[Bunny::ServerDownError, Errno::ECONNRESET] => e
       @logger.error("RabbitMQ connection error (during publish), will reconnect: #{e}")
       connect
       retry
-    end
-  end
+    end # begin
+  end # def receive_raw
 
   public
   def to_s
     return "amqp://#{@user}@#{@host}:#{@port}#{@vhost}/#{@exchange_type}/#{@exchange}\##{@key}"
-  end
+  end # def to_s
 
   public
   def teardown
diff --git a/logstash.gemspec b/logstash.gemspec
index 7df9b48a474..5bae1386816 100644
--- a/logstash.gemspec
+++ b/logstash.gemspec
@@ -17,78 +17,80 @@ Gem::Specification.new do |gem|
   gem.version       = LOGSTASH_VERSION
 
   # Core dependencies
-  gem.add_runtime_dependency "cabin", ["0.5.0"]
-  gem.add_runtime_dependency "json"
-  gem.add_runtime_dependency "minitest" # for running the tests from the jar
-  gem.add_runtime_dependency "pry"
-  gem.add_runtime_dependency "stud"
-  gem.add_runtime_dependency "sys-uname" # for platform detection
-  gem.add_runtime_dependency "clamp" # for command line args/flags
-  gem.add_runtime_dependency "i18n"
+  gem.add_runtime_dependency "cabin", ["0.5.0"]   #(Apache 2.0 license)
+  gem.add_runtime_dependency "json"               #(ruby license)
+  gem.add_runtime_dependency "minitest"           # for running the tests from the jar, (MIT license)
+  gem.add_runtime_dependency "pry"                #(ruby license)
+  gem.add_runtime_dependency "stud"               #(Apache 2.0 license)
+  gem.add_runtime_dependency "sys-uname"          # for platform detection (Artistic 2.0 license)
+  gem.add_runtime_dependency "clamp"              # for command line args/flags (MIT license)
+  gem.add_runtime_dependency "i18n"               #(MIT license)
 
   # Web dependencies
-  gem.add_runtime_dependency "ftw", ["~> 0.0.26"]
-  gem.add_runtime_dependency "haml"
-  gem.add_runtime_dependency "rack"
-  gem.add_runtime_dependency "sass"
-  gem.add_runtime_dependency "sinatra"
+  gem.add_runtime_dependency "ftw", ["~> 0.0.27"] #(Apache 2.0 license)
+  gem.add_runtime_dependency "haml"               #(MIT license)
+  gem.add_runtime_dependency "rack"               #(MIT license)
+  gem.add_runtime_dependency "sass"               #(MIT license)
+  gem.add_runtime_dependency "sinatra"            #(MIT license)
 
   # Input/Output/Filter dependencies
   #TODO Can these be optional?
-  gem.add_runtime_dependency "aws-sdk"
-  gem.add_runtime_dependency "heroku"
-  gem.add_runtime_dependency "addressable", ["~> 2.2.6"]
-  gem.add_runtime_dependency "bunny", [">= 0.9.0.pre6"]
-  gem.add_runtime_dependency "ffi"
-  gem.add_runtime_dependency "ffi-rzmq", ["0.9.3"]
-  gem.add_runtime_dependency "filewatch", ["0.5.1"]
-  gem.add_runtime_dependency "gelfd", ["0.2.0"]
-  gem.add_runtime_dependency "gelf", ["1.3.2"]
-  gem.add_runtime_dependency "gmetric", ["0.1.3"]
-  gem.add_runtime_dependency "jls-grok", ["0.10.10"]
-  gem.add_runtime_dependency "mail"
-  gem.add_runtime_dependency "mongo"
-  gem.add_runtime_dependency "metriks"
-  gem.add_runtime_dependency "onstomp"
-  gem.add_runtime_dependency "redis"
-  gem.add_runtime_dependency "riak-client", ["1.0.3"]
-  gem.add_runtime_dependency "riemann-client", ["0.0.6"]
-  gem.add_runtime_dependency "statsd-ruby", ["0.3.0"]
-  gem.add_runtime_dependency "uuidtools" # For generating amqp queue names
-  gem.add_runtime_dependency "xml-simple"
-  gem.add_runtime_dependency "xmpp4r", ["0.5"]
-  gem.add_runtime_dependency "jls-lumberjack", [">0"]
-  gem.add_runtime_dependency "geoip", [">= 1.1.0"]
-  gem.add_runtime_dependency "beefcake", "0.3.7"
-  gem.add_runtime_dependency "php-serialize" # For input drupal_dblog
-  gem.add_runtime_dependency "murmurhash3"
-  gem.add_runtime_dependency "rufus-scheduler"
-  gem.add_runtime_dependency "user_agent_parser", [">= 2.0.0"]
-  gem.add_runtime_dependency "snmp"
+  gem.add_runtime_dependency "awesome_print"                    #(MIT license)
+  gem.add_runtime_dependency "aws-sdk"                          #{Apache 2.0 license}
+  gem.add_runtime_dependency "heroku"                           #(MIT license)
+  gem.add_runtime_dependency "addressable", ["~> 2.2.6"]        #(Apache 2.0 license)
+  gem.add_runtime_dependency "bunny", [">= 0.9.0.pre6"]         #(MIT license)
+  gem.add_runtime_dependency "ffi"                              #(LGPL-3 license)
+  gem.add_runtime_dependency "ffi-rzmq", ["0.9.3"]              #(MIT license)
+  gem.add_runtime_dependency "filewatch", ["0.5.1"]             #(BSD license)
+  gem.add_runtime_dependency "gelfd", ["0.2.0"]                 #(Apache 2.0 license)
+  gem.add_runtime_dependency "gelf", ["1.3.2"]                  #(MIT license)
+  gem.add_runtime_dependency "gmetric", ["0.1.3"]               #(MIT license)
+  gem.add_runtime_dependency "jls-grok", ["0.10.10"]            #(BSD license)
+  gem.add_runtime_dependency "mail"                             #(MIT license)
+  gem.add_runtime_dependency "mongo"                            #(Apache 2.0 license)
+  gem.add_runtime_dependency "metriks"                          #(MIT license)
+  gem.add_runtime_dependency "onstomp"                          #(Apache 2.0 license)
+  gem.add_runtime_dependency "redis"                            #(MIT license)
+  gem.add_runtime_dependency "riak-client", ["1.0.3"]           #(Apache 2.0 license)
+  gem.add_runtime_dependency "riemann-client", ["0.0.6"]        #(MIT license)
+  gem.add_runtime_dependency "statsd-ruby", ["0.3.0"]           #(MIT license)
+  gem.add_runtime_dependency "uuidtools"                        # For generating amqp queue names (Apache 2.0 license)
+  gem.add_runtime_dependency "xml-simple"                       #(ruby license?)
+  gem.add_runtime_dependency "xmpp4r", ["0.5"]                  #(ruby license)
+  gem.add_runtime_dependency "jls-lumberjack", [">0"]           #(Apache 2.0 license)
+  gem.add_runtime_dependency "geoip", [">= 1.1.0"]              #(GPL license)
+  gem.add_runtime_dependency "beefcake", "0.3.7"                #(MIT license)
+  gem.add_runtime_dependency "php-serialize"                    # For input drupal_dblog (MIT license)
+  gem.add_runtime_dependency "murmurhash3"                      #(MIT license)
+  gem.add_runtime_dependency "rufus-scheduler"                  #(MIT license)
+  gem.add_runtime_dependency "user_agent_parser", [">= 2.0.0"]  #(MIT license)
+  gem.add_runtime_dependency "snmp"                             #(ruby license)
 
   if RUBY_PLATFORM == 'java'
     gem.platform = RUBY_PLATFORM
-    gem.add_runtime_dependency "jruby-elasticsearch", ["0.0.14"]
-    gem.add_runtime_dependency "jruby-httpclient"
-    gem.add_runtime_dependency "jruby-openssl"
-    gem.add_runtime_dependency "jruby-win32ole"
-    gem.add_runtime_dependency "jdbc-mysql" # For input drupal_dblog
-    gem.add_runtime_dependency "msgpack-jruby"
+    gem.add_runtime_dependency "jruby-elasticsearch", ["0.0.14"]  #(BSD license)
+    gem.add_runtime_dependency "jruby-httpclient"                 #(Apache 2.0 license)
+    gem.add_runtime_dependency "bouncy-castle-java", "1.5.0146.1" #(MIT license)
+    gem.add_runtime_dependency "jruby-openssl", "0.8.2"           #(CPL/GPL/LGPL license)
+    gem.add_runtime_dependency "jruby-win32ole"                   #(unknown license)
+    gem.add_runtime_dependency "jdbc-mysql"                       # For input drupal_dblog (BSD license)
+    gem.add_runtime_dependency "msgpack-jruby"                    #(Apache 2.0 license)
   else
-    gem.add_runtime_dependency "excon"
-    gem.add_runtime_dependency "mysql2" # For input drupal_dblog
-    gem.add_runtime_dependency "msgpack"
+    gem.add_runtime_dependency "excon"    #(MIT license)
+    gem.add_runtime_dependency "mysql2"   # For input drupal_dblog (MIT license)
+    gem.add_runtime_dependency "msgpack"  #(Apache 2.0 license)
   end
 
   if RUBY_VERSION >= '1.9.1'
-    gem.add_runtime_dependency "cinch" # cinch requires 1.9.1+
+    gem.add_runtime_dependency "cinch" # cinch requires 1.9.1+ #(MIT license)
   end
 
   # These are runtime-deps so you can do 'java -jar logstash.jar rspec <test>'
-  gem.add_runtime_dependency "spoon"
-  gem.add_runtime_dependency "mocha"
-  gem.add_runtime_dependency "shoulda"
-  gem.add_runtime_dependency "rspec"
-  gem.add_runtime_dependency "insist", "0.0.8"
-  gem.add_runtime_dependency "rumbster" # For faking smtp in email tests
+  gem.add_runtime_dependency "spoon"            #(Apache 2.0 license)
+  gem.add_runtime_dependency "mocha"            #(MIT license)
+  gem.add_runtime_dependency "shoulda"          #(MIT license)
+  gem.add_runtime_dependency "rspec"            #(MIT license)
+  gem.add_runtime_dependency "insist", "0.0.8"  #(Apache 2.0 license)
+  gem.add_runtime_dependency "rumbster"         # For faking smtp in email tests (Apache 2.0 license)
 end
diff --git a/patterns/grok-patterns b/patterns/grok-patterns
index baf6a5809c5..6f4556015c9 100755
--- a/patterns/grok-patterns
+++ b/patterns/grok-patterns
@@ -1,4 +1,4 @@
-USERNAME [a-zA-Z0-9_-]+
+USERNAME [a-zA-Z0-9._-]+
 USER %{USERNAME}
 INT (?:[+-]?(?:[0-9]+))
 BASE10NUM (?<![0-9.+-])(?>[+-]?(?:(?:[0-9]+(?:\.[0-9]+)?)|(?:\.[0-9]+)))
diff --git a/patterns/linux-syslog b/patterns/linux-syslog
index a4ae0bbaaa5..3db302a8a31 100644
--- a/patterns/linux-syslog
+++ b/patterns/linux-syslog
@@ -5,3 +5,9 @@ CRON_ACTION [A-Z ]+
 CRONLOG %{SYSLOGBASE} \(%{USER:user}\) %{CRON_ACTION:action} \(%{DATA:message}\)
 
 SYSLOGLINE %{SYSLOGBASE2} %{GREEDYDATA:message}
+
+# IETF 5424 syslog(8) format (see http://www.rfc-editor.org/info/rfc5424)
+SYSLOG5424PRI (?:\<%{NONNEGINT}\>)
+SYSLOG5424SD (?:\[%{DATA}\]+|-)
+
+SYSLOG5424LINE %{SYSLOG5424PRI:syslog5424_pri}%{NONNEGINT:syslog5424_ver} (%{TIMESTAMP_ISO8601:syslog5424_ts}|-) (%{HOSTNAME:syslog5424_host}|-) (%{WORD:syslog5424_app}|-) (%{WORD:syslog5424_proc}|-) (%{WORD:syslog5424_msgid}|-) %{SYSLOG5424SD:syslog5424_sd} %{GREEDYDATA:syslog5424_msg}
diff --git a/pull_release_note.rb b/pull_release_note.rb
new file mode 100644
index 00000000000..6ccdba92e5f
--- /dev/null
+++ b/pull_release_note.rb
@@ -0,0 +1,25 @@
+require "octokit"
+
+
+@repository= "logstash/logstash"
+@releaseNote= "releaseNote.html"
+
+#Last release  == last tag
+lastReleaseSha = Octokit.tags(@repository).first.commit.sha
+
+currentReleaseSha ="HEAD"
+
+#Collect PR Merge in a file
+File.open(@releaseNote, "a") do |f|
+  f.puts "<h2>Merged pull request</h2>"
+  f.puts "<ul>"
+  Octokit.compare(@repository, lastReleaseSha, currentReleaseSha).commits.each do |commit|
+    if commit.commit.message.start_with?("Merge pull")
+      scan_re = Regexp.new(/^Merge pull request #(\d+) from ([^\/]+)\/.*\n\n(.*)/)
+      commit.commit.message.scan(scan_re) do |pullNumber, user, summary|
+        f.puts "<li><a href='https://github.com/logstash/logstash/pull/#{pullNumber}'>Pull ##{pullNumber}<a> by #{user}: #{summary}</li>"
+      end
+    end
+  end
+  f.puts "</ul>"
+end
\ No newline at end of file
diff --git a/spec/filters/grok.rb b/spec/filters/grok.rb
index 5215b7b87e5..3ab07c19dd7 100644
--- a/spec/filters/grok.rb
+++ b/spec/filters/grok.rb
@@ -1,7 +1,7 @@
 require "test_utils"
 require "logstash/filters/grok"
 
-describe LogStash::Filters::Grok do 
+describe LogStash::Filters::Grok do
   extend LogStash::RSpec
 
   describe "simple syslog line" do
@@ -26,7 +26,33 @@
     end
   end
 
-  describe "parsing an event with multiple messages (array of strings)" do 
+  describe "ietf 5424 syslog line" do
+    # The logstash config goes here.
+    # At this time, only filters are supported.
+    config <<-CONFIG
+      filter {
+        grok {
+          pattern => "%{SYSLOG5424LINE}"
+          singles => true
+        }
+      }
+    CONFIG
+
+    sample "<191>1 2009-06-30T18:30:00+02:00 paxton.local grokdebug 4123 - [id1 foo="bar"][id2 baz="something"] Hello, syslog." do
+      reject { subject["@tags"] }.include?("_grokparsefailure")
+      insist { subject["syslog5424_pri"] } == "<191>"
+      insist { subject["syslog5424_ver"] } == "1"
+      insist { subject["syslog5424_ts"] } == "2009-06-30T18:30:00+02:00"
+      insist { subject["syslog5424_host"] } == "paxton.local"
+      insist { subject["syslog5424_app"] } == "grokdebug"
+      insist { subject["syslog5424_proc"] } == "4123"
+      insist { subject["syslog5424_msgid"] } == nil
+      insist { subject["syslog5424_sd"] } == "[id1 foo=\"bar\"][id2 baz=\"something\"]"
+      insist { subject["syslog5424_msg"] } == "Hello, syslog."
+    end
+  end
+
+  describe "parsing an event with multiple messages (array of strings)" do
     config <<-CONFIG
       filter {
         grok {
@@ -37,7 +63,7 @@
     CONFIG
 
     sample({ "@message" => [ "hello 12345", "world 23456" ] }) do
-      insist { subject["NUMBER"] } == [ "12345", "23456" ] 
+      insist { subject["NUMBER"] } == [ "12345", "23456" ]
     end
   end
 
diff --git a/spec/filters/grok/timeout2.rb b/spec/filters/grok/timeout2.rb
index 83243b94e7a..7af93a5f222 100644
--- a/spec/filters/grok/timeout2.rb
+++ b/spec/filters/grok/timeout2.rb
@@ -22,6 +22,35 @@
       insist { duration } < 0.03
     end
   end
+
+  describe "user reported timeout" do
+    config <<-'CONFIG'
+      filter {
+        grok { 
+          pattern => [
+            "%{DATA:http_host} %{IPORHOST:clientip} %{USER:ident} %{USER:http_auth} \[%{HTTPDATE:http_timestamp}\] \"%{WORD:http_method} %{DATA:http_request} HTTP/%{NUMBER:http_version}\" %{NUMBER:http_response_code} (?:%{NUMBER:bytes}|-) \"(?:%{URI:http_referrer}|-)\" %{QS:http_user_agent} %{QS:http_x_forwarded_for} %{USER:ssl_chiper} %{NUMBER:request_time} (?:%{DATA:gzip_ratio}|-) (?:%{DATA:upstream}|-) (?:%{NUMBER:upstream_time}|-) (?:%{WORD:geoip_country}|-)",
+            "%{DATA:http_host} %{IPORHOST:clientip} %{USER:ident} %{USER:http_auth} \[%{HTTPDATE:http_timestamp}\] \"%{WORD:http_method} %{DATA:http_request} HTTP/%{NUMBER:http_version}\" %{NUMBER:http_response_code} (?:%{NUMBER:bytes}|-) \"(?:%{URI:http_referrer}|-)\" %{QS:http_user_agent} %{QS:http_x_forwarded_for} %{USER:ssl_chiper} %{NUMBER:request_time} (?:%{DATA:gzip_ratio}|-) (?:%{DATA:upstream}|-) (?:%{NUMBER:upstream_time}|-)"
+          ]
+        }
+      }
+    CONFIG
+
+    start = Time.now
+    sample 'www.example.com 10.6.10.13 - - [09/Aug/2012:16:19:39 +0200] "GET /index.php HTTP/1.1" 403 211 "-" "Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.8.1.12) Gecko/20080201 Firefox/2.0.0.12" "-" - 0.019 - 10.6.10.12:81 0.002 US' do
+      duration = Time.now - start
+      insist { duration } < 1
+      reject { subject.tags }.include?("_grokparsefailure")
+      insist { subject["geoip_country"] } == ["US"]
+    end
+
+
+    sample 'www.example.com 10.6.10.13 - - [09/Aug/2012:16:19:39 +0200] "GET /index.php HTTP/1.1" 403 211 "-" "Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.8.1.12) Gecko/20080201 Firefox/2.0.0.12" "-" - 0.019 - 10.6.10.12:81 0.002 -' do
+      duration = Time.now - start
+      insist { duration } < 1
+      reject { subject.tags }.include?("_grokparsefailure")
+      insist { subject["geoip_country"].nil? } == true
+    end
+  end
 end
 
 __END__
diff --git a/spec/filters/range.rb b/spec/filters/range.rb
new file mode 100644
index 00000000000..ca23e7afc78
--- /dev/null
+++ b/spec/filters/range.rb
@@ -0,0 +1,191 @@
+require "test_utils"
+require "logstash/filters/range"
+
+describe LogStash::Filters::Range do
+  extend LogStash::RSpec
+
+  describe "range match integer field on tag action" do
+    config <<-CONFIG
+      filter {
+        range {
+          ranges => [ "duration", 10, 100, "tag:cool",
+                      "duration", 1, 1, "tag:boring" ]
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "duration" => 50
+    } do
+      insist { subject["@tags"] }.include?("cool")
+      reject { subject["@tags"] }.include?("boring")
+    end
+  end
+
+  describe "range match float field on tag action" do
+    config <<-CONFIG
+      filter {
+        range {
+          ranges => [ "duration", 0, 100, "tag:cool",
+                      "duration", 0, 1, "tag:boring" ]
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "duration" => 50.0
+    } do
+      insist { subject["@tags"] }.include?("cool")
+      reject { subject["@tags"] }.include?("boring")
+    end
+  end
+
+  describe "range match string field on tag action" do
+    config <<-CONFIG
+      filter {
+        range {
+          ranges => [ "length", 0, 10, "tag:cool",
+                      "length", 0, 1, "tag:boring" ]
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "length" => "123456789"
+    } do
+      insist { subject["@tags"] }.include?("cool")
+      reject { subject["@tags"] }.include?("boring")
+    end
+  end
+
+  describe "range match with negation" do
+    config <<-CONFIG
+      filter {
+        range {
+          ranges => [ "length", 0, 10, "tag:cool",
+                      "length", 0, 1, "tag:boring" ]
+          negate => true
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "length" => "123456789"
+    } do
+      reject { subject["@tags"] }.include?("cool")
+      insist { subject["@tags"] }.include?("boring")
+    end
+  end
+
+  describe "range match on drop action" do
+    config <<-CONFIG
+      filter {
+        range {
+          ranges => [ "length", 0, 10, "drop" ]
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "length" => "123456789"
+    } do
+      insist { subject }.nil?
+    end
+  end
+
+  describe "range match on field action with string value" do
+    config <<-CONFIG
+      filter {
+        range {
+          ranges => [ "duration", 10, 100, "field:cool:foo",
+                      "duration", 1, 1, "field:boring:foo" ]
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "duration" => 50
+    } do
+      insist { subject["@fields"] }.include?("cool")
+      insist { subject["@fields"]["cool"] } == "foo"
+      reject { subject["@fields"] }.include?("boring")
+    end
+  end
+
+  describe "range match on field action with integer value" do
+    config <<-CONFIG
+      filter {
+        range {
+          ranges => [ "duration", 10, 100, "field:cool:666",
+                      "duration", 1, 1, "field:boring:666" ]
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "duration" => 50
+    } do
+      insist { subject["@fields"] }.include?("cool")
+      insist { subject["@fields"]["cool"] } == 666
+      reject { subject["@fields"] }.include?("boring")
+    end
+  end
+
+  describe "range match on field action with float value" do
+    config <<-CONFIG
+      filter {
+        range {
+          ranges => [ "duration", 10, 100, "field:cool:3.14",
+                      "duration", 1, 1, "field:boring:3.14" ]
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "duration" => 50
+    } do
+      insist { subject["@fields"] }.include?("cool")
+      insist { subject["@fields"]["cool"] } == 3.14
+      reject { subject["@fields"] }.include?("boring")
+    end
+  end
+
+  describe "range match on tag action with dynamic string value" do
+    config <<-CONFIG
+      filter {
+        range {
+          ranges => [ "duration", 10, 100, "tag:cool_%{dynamic}_dynamic",
+                      "duration", 1, 1, "tag:boring_%{dynamic}_dynamic" ]
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "duration" => 50,
+      "dynamic" => "and"
+    } do
+      insist { subject["@tags"] }.include?("cool_and_dynamic")
+      reject { subject["@tags"] }.include?("boring_and_dynamic")
+    end
+  end
+
+  describe "range match on field action with dynamic string field and value" do
+    config <<-CONFIG
+      filter {
+        range {
+          ranges => [ "duration", 10, 100, "field:cool_%{dynamic}_dynamic:foo_%{dynamic}_bar",
+                      "duration", 1, 1, "field:boring_%{dynamic}_dynamic:foo_%{dynamic}_bar" ]
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "duration" => 50,
+      "dynamic" => "and"
+    } do
+      insist { subject["@fields"] }.include?("cool_and_dynamic")
+      insist { subject["@fields"]["cool_and_dynamic"] } == "foo_and_bar"
+      reject { subject["@fields"] }.include?("boring_and_dynamic")
+    end
+  end
+end
\ No newline at end of file
diff --git a/spec/filters/translate.rb b/spec/filters/translate.rb
new file mode 100644
index 00000000000..6aaaa8bfbbd
--- /dev/null
+++ b/spec/filters/translate.rb
@@ -0,0 +1,76 @@
+require "test_utils"
+require "logstash/filters/translate"
+
+describe LogStash::Filters::Translate do
+  extend LogStash::RSpec
+
+  describe "exact translation" do
+    config <<-CONFIG
+      filter {
+        translate {
+          field       => "status"
+          destination => "translation"
+          dictionary  => [ "200", "OK",
+                           "300", "Redirect",
+                           "400", "Client Error",
+                           "500", "Server Error" ]
+          exact       => true
+          regex       => false
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "status" => 200
+    } do
+      insist { subject["translation"] } == "OK"
+    end
+  end
+
+  describe "multi translation" do
+    config <<-CONFIG
+      filter {
+        translate {
+          field       => "status"
+          destination => "translation"
+          dictionary  => [ "200", "OK",
+                           "300", "Redirect",
+                           "400", "Client Error",
+                          "500", "Server Error" ]
+          exact       => false
+          regex       => false
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+     "status" => "200 & 500"
+    } do
+      insist { subject["translation"] } == "OK & Server Error"
+    end
+  end
+
+  describe "regex translation" do
+    config <<-CONFIG
+      filter {
+        translate {
+          field       => "status"
+          destination => "translation"
+          dictionary  => [ "^2[0-9][0-9]$", "OK",
+                           "^3[0-9][0-9]$", "Redirect",
+                           "^4[0-9][0-9]$", "Client Error",
+                           "^5[0-9][0-9]$", "Server Error" ]
+          exact       => true
+          regex       => true
+        }
+      }
+    CONFIG
+
+    sample "@fields" => {
+      "status" => "200"
+    } do
+      insist { subject["translation"] } == "OK"
+    end
+  end
+
+end
\ No newline at end of file
diff --git a/spec/inputs/redis.rb b/spec/inputs/redis.rb
index 3a00625b17a..6a145ef84e0 100644
--- a/spec/inputs/redis.rb
+++ b/spec/inputs/redis.rb
@@ -1,13 +1,35 @@
 require "test_utils"
 require "redis"
 
+def populate(key, event_count)
+  require "logstash/event"
+  redis = Redis.new(:host => "localhost")
+  event_count.times do |value|
+    event = LogStash::Event.new("@fields" => { "sequence" => value })
+    Stud::try(10.times) do
+      redis.rpush(key, event.to_json)
+    end
+  end
+end
+
+def process(plugins, event_count)
+  sequence = 0
+  redis = plugins.first
+  output = Shiftback.new do |event|
+    insist { event["sequence"] } == sequence
+    sequence += 1
+    redis.teardown if sequence == event_count
+  end
+  redis.register
+  redis.run(output)
+end # process
+
 describe "inputs/redis" do
   extend LogStash::RSpec
 
   describe "read events from a list" do
     key = 10.times.collect { rand(10).to_s }.join("")
     event_count = 1000 + rand(50)
-
     config <<-CONFIG
       input {
         redis {
@@ -19,28 +41,26 @@
       }
     CONFIG
 
-    # populate the redis list
-    before :each do
-      require "logstash/event"
-      redis = Redis.new(:host => "localhost")
-      event_count.times do |value|
-        event = LogStash::Event.new("@fields" => { "sequence" => value })
-        Stud::try(10.times) do
-          redis.rpush(key, event.to_json)
-        end
-      end
-    end
+    before(:each) { populate(key, event_count) }
+    input { |plugins| process(plugins, event_count) }
+  end
+
+  describe "read events from a list with batch_count=5" do
+    key = 10.times.collect { rand(10).to_s }.join("")
+    event_count = 1000 + rand(50)
+    config <<-CONFIG
+      input {
+        redis {
+          type => "blah"
+          key => "#{key}"
+          data_type => "list"
+          batch_count => #{rand(20)+1}
+          format => json_event
+        }
+      }
+    CONFIG
 
-    input do |plugins|
-      sequence = 0
-      redis = plugins.first
-      output = Shiftback.new do |event|
-        insist { event["sequence"] } == sequence
-        sequence += 1
-        redis.teardown if sequence == event_count
-      end
-      redis.register
-      redis.run(output)
-    end # input
+    before(:each) { populate(key, event_count) }
+    input { |plugins| process(plugins, event_count) }
   end
 end
