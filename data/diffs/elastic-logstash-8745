diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStore.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStore.java
index 8c9d10a3b3b..44e3a1e722d 100644
--- a/logstash-core/src/main/java/org/logstash/secret/store/SecretStore.java
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStore.java
@@ -12,6 +12,30 @@
  */
 public interface SecretStore {
 
+    /**
+     * Creates a new secret store
+     *
+     * @param secureConfig the configuration necessary to create the store
+     * @return the newly created secret store.
+     */
+    SecretStore create(SecureConfig secureConfig);
+
+    /**
+     * Delete secret store
+     *
+     * @param secureConfig the configuration necessary to delete the store
+     */
+    void delete(SecureConfig secureConfig);
+
+    /**
+     * Queries if a secret store matching this configuration exists
+     *
+     * @param secureConfig the configuration necessary to determine if the secret store exists
+     * @return true if the secret store exists, false other wise. Note - this does not provide any validity of the keystore, merely it's existence or not. It is recommended to
+     * use the {@link SecretStoreFactory#LOGSTASH_MARKER} to test validity.
+     */
+    boolean exists(SecureConfig secureConfig);
+
     /**
      * Gets all of the known {@link SecretIdentifier}
      *
@@ -19,6 +43,14 @@ public interface SecretStore {
      */
     Collection<SecretIdentifier> list();
 
+    /**
+     * Loads an existing secret store
+     *
+     * @param secureConfig the configuration necessary to load the store
+     * @return the loaded secret store.
+     */
+    SecretStore load(SecureConfig secureConfig);
+
     /**
      * Persist a secret to the store. Implementations should overwrite existing secrets with same identifier without error unless explicitly documented otherwise.
      *
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java
index 0576a1714eb..708e67cff7e 100644
--- a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java
@@ -15,17 +15,7 @@ private SecretStoreException(String message) {
         super(message);
     }
 
-    static public class NotLogstashKeyStore extends SecretStoreException {
-        public NotLogstashKeyStore(String message) {
-            super(message);
-        }
-
-        public NotLogstashKeyStore(String message, Throwable cause) {
-            super(message, cause);
-        }
-    }
-
-    static public class RetrievalException extends SecretStoreException {
+      static public class RetrievalException extends SecretStoreException {
         public RetrievalException(SecretIdentifier secretIdentifier, Throwable cause) {
             super(String.format("Error while trying to retrieve secret %s", secretIdentifier.toExternalForm()), cause);
         }
@@ -50,6 +40,10 @@ static public class LoadException extends SecretStoreException {
         public LoadException(String message, Throwable cause) {
             super(message, cause);
         }
+
+        public LoadException(String message) {
+            super(message);
+        }
     }
 
     static public class PersistException extends SecretStoreException {
@@ -86,5 +80,18 @@ public AccessException(String message) {
         }
     }
 
+    static public class AlreadyExistsException extends SecretStoreException {
+        public AlreadyExistsException(String message) {
+            super(message);
+        }
+    }
+
+    static public class InvalidConfigurationException extends SecretStoreException {
+        public InvalidConfigurationException(String message) {
+            super(message);
+        }
+    }
+
+
 
 }
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreFactory.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreFactory.java
index c1ffdbb0c55..2a2bc1c8a67 100644
--- a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreFactory.java
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreFactory.java
@@ -4,20 +4,18 @@
 import org.apache.logging.log4j.Logger;
 import org.logstash.secret.SecretIdentifier;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-
 /**
- * <p>A factory to load the implementation of a {@link SecretStore}. Where the implementation requires a constructor that accepts a {@link SecureConfig} as it's only parameter.
+ * <p>A factory to load the implementation of a {@link SecretStore}. Implementation may be defined via the {@link SecureConfig} via with a key of "keystore.classname" and
+ * value equal to the fqn of the class that implements {@link SecretStore}
  * </p>
  */
 public class SecretStoreFactory {
 
     public static final String KEYSTORE_ACCESS_KEY = "keystore.pass";
     //secret stores should create a secret with this as the key and value to identify a logstash secret
-    public final static SecretIdentifier LOGSTASH_MARKER = new SecretIdentifier("logstash-secret-store");
+    public final static SecretIdentifier LOGSTASH_MARKER = new SecretIdentifier("keystore.seed");
 
-    public final static String ENVIRONMENT_PASS_KEY = "LOGSTASH_SECRET_STORE_PASS";
+    public final static String ENVIRONMENT_PASS_KEY = "LOGSTASH_KEYSTORE_PASS";
 
     /**
      * Private constructor
@@ -27,29 +25,73 @@ private SecretStoreFactory() {
 
     private static final Logger LOGGER = LogManager.getLogger(SecretStoreFactory.class);
 
+    private enum MODE {LOAD, CREATE, EXISTS, DELETE}
+
+    /**
+     * Determine if this secret store currently exists
+     */
+    public static boolean exists(SecureConfig secureConfig) {
+        return doIt(MODE.EXISTS, secureConfig).exists(secureConfig);
+    }
+
+    /**
+     * Creates a new {@link SecretStore} based on the provided configuration
+     *
+     * @param secureConfig The configuration to pass to the implementation
+     * @return the newly created SecretStore
+     * @throws {@link SecretStoreException} if errors occur while loading, or if store already exists
+     */
+    static public SecretStore create(SecureConfig secureConfig) {
+        return doIt(MODE.CREATE, secureConfig);
+    }
+
     /**
-     * Creates a {@link SecretStore} based on the provided configuration
+     * Deletes a {@link SecretStore} based on the provided configuration
      *
      * @param secureConfig The configuration to pass to the implementation
-     * @return
+     * @throws {@link SecretStoreException} if errors occur
      */
+    static public void delete(SecureConfig secureConfig) {
+        doIt(MODE.DELETE, secureConfig);
+    }
+
+    /**
+     * Loads an existing {@link SecretStore} based on the provided configuration
+     *
+     * @param secureConfig The configuration to pass to the implementation
+     * @return the loaded SecretStore
+     * @throws {@link SecretStoreException} if errors occur while loading, or if store does not exist
+     */
+    static public SecretStore load(SecureConfig secureConfig) {
+        return doIt(MODE.LOAD, secureConfig);
+    }
+
     @SuppressWarnings({"unchecked", "JavaReflectionMemberAccess"})
-    static public SecretStore loadSecretStore(SecureConfig secureConfig) {
-        //cheap SPI, if we ever support more then one implementation we should expose it as a setting and push the class name here via the secureConfig
-        String className = System.getProperty("org.logstash.secret.store.SecretStore", "org.logstash.secret.store.backend.JavaKeyStore");
+    private static SecretStore doIt(MODE mode, SecureConfig secureConfig) {
+        char[] configuredClassName = secureConfig.getPlainText("keystore.classname");
+        String className = configuredClassName != null ? new String(configuredClassName) : "org.logstash.secret.store.backend.JavaKeyStore";
         try {
-            LOGGER.debug("Attempting to loadSecretStore secret store with implementation: {}", className);
+            LOGGER.debug("Attempting to {} or secret store with implementation: {}", mode.name().toLowerCase(), className);
             Class<? extends SecretStore> implementation = (Class<? extends SecretStore>) Class.forName(className);
-            Constructor<? extends SecretStore> constructor = implementation.getConstructor(SecureConfig.class);
+
             addSecretStoreAccess(secureConfig);
-            return constructor.newInstance(secureConfig);
-        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException | NoSuchMethodException e) {
+
+            if (MODE.LOAD.equals(mode)) {
+                return implementation.newInstance().load(secureConfig);
+            } else if (MODE.CREATE.equals(mode)) {
+                return implementation.newInstance().create(secureConfig);
+            } else if (MODE.DELETE.equals(mode)) {
+                implementation.newInstance().delete(secureConfig);
+                return null;
+            } else if (MODE.EXISTS.equals(mode)) {
+                return implementation.newInstance();
+            } else {
+                throw new IllegalStateException("missing mode. This is bug in Logstash.");
+            }
+        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
             throw new SecretStoreException.ImplementationNotFoundException(
-                    String.format("Could not loadSecretStore class %s, please ensure it is on the Java classpath, implements org.logstash.secret.store.SecretStore, and has a 1 " +
-                            "argument constructor that accepts a org.logstash.secret.store.SecureConfig", className), e);
-        } catch (InvocationTargetException ite) {
-            //this is thrown if an exception is thrown from the constructor
-            throw new SecretStoreException.LoadException("Unable to load Logstash secret store", ite);
+                    String.format("Could not %s class %s, please ensure it is on the Java classpath, implements org.logstash.secret.store.SecretStore, and has a zero " +
+                            "argument constructor", mode.name().toLowerCase(), className), e);
         }
     }
 
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecureConfig.java b/logstash-core/src/main/java/org/logstash/secret/store/SecureConfig.java
index df5984d7186..81f3cfdeb6b 100644
--- a/logstash-core/src/main/java/org/logstash/secret/store/SecureConfig.java
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecureConfig.java
@@ -1,7 +1,6 @@
 package org.logstash.secret.store;
 
 import java.nio.CharBuffer;
-import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java b/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java
index a032b5efc47..bde6b3db8a5 100644
--- a/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java
+++ b/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java
@@ -38,101 +38,116 @@
  * <p>This class is threadsafe.</p>
  */
 public final class JavaKeyStore implements SecretStore {
-    private static final Logger LOGGER = LogManager.getLogger(JavaKeyStore.class);
     private static final String KEYSTORE_TYPE = "pkcs12";
+    private static final Logger LOGGER = LogManager.getLogger(JavaKeyStore.class);
+    private static final String PATH_KEY = "keystore.file";
     private static final CharsetEncoder asciiEncoder = StandardCharsets.US_ASCII.newEncoder();
-
+    private KeyStore keyStore;
     private char[] keyStorePass;
     private Path keyStorePath;
-    private final ProtectionParameter protectionParameter;
-    private final Lock readLock;
-    private final Lock writeLock;
-    private KeyStore keyStore;
-    private final SecureConfig config;
+    private ProtectionParameter protectionParameter;
+    private Lock readLock;
+    private boolean useDefaultPass = false;
+    private Lock writeLock;
+    //package private for testing
+    static String filePermissions = "rw-rw----";
 
     /**
-     * Constructor - will create the keystore if it does not exist.
+     * {@inheritDoc}
      *
-     * @param config The configuration for this keystore <p>Requires "keystore.pass" and "keystore.path" in the configuration</p><p>WARNING! this constructor clears all values
+     * @param config The configuration for this keystore <p>Requires "keystore.file" in the configuration,</p><p>WARNING! this method clears all values
      *               from this configuration, meaning this config is NOT reusable after passed in here.</p>
-     * @throws SecretStoreException if errors occur while trying to create or access the keystore
+     * @throws SecretStoreException.CreateException if the store can not be created
+     * @throws SecretStoreException                 (of other sub types) if contributing factors prevent the creation
      */
-    public JavaKeyStore(SecureConfig config) {
-        this.config = config;
+    @Override
+    public JavaKeyStore create(SecureConfig config) {
+        if (exists(config)) {
+            throw new SecretStoreException.AlreadyExistsException(String.format("Logstash keystore at %s already exists.",
+                    new String(config.getPlainText(PATH_KEY))));
+        }
         try {
-            char[] path = config.getPlainText("keystore.path");
-            if (path == null) {
-                throw new IllegalArgumentException("Logstash keystore path must be defined");
+            init(config);
+            writeLock.lock();
+            LOGGER.debug("Creating new keystore at {}.", keyStorePath.toAbsolutePath());
+            String keyStorePermissions = filePermissions;
+            //create the keystore on disk with a default entry to identify this as a logstash keystore
+            Files.createFile(keyStorePath, PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(keyStorePermissions)));
+            try {
+                keyStore = KeyStore.Builder.newInstance(KEYSTORE_TYPE, null, protectionParameter).getKeyStore();
+                SecretKeyFactory factory = SecretKeyFactory.getInstance("PBE");
+                byte[] base64 = SecretStoreUtil.base64Encode(LOGSTASH_MARKER.getKey().getBytes(StandardCharsets.UTF_8));
+                SecretKey secretKey = factory.generateSecret(new PBEKeySpec(SecretStoreUtil.asciiBytesToChar(base64)));
+                keyStore.setEntry(LOGSTASH_MARKER.toExternalForm(), new KeyStore.SecretKeyEntry(secretKey), protectionParameter);
+                saveKeyStore();
+                PosixFileAttributeView attrs = Files.getFileAttributeView(keyStorePath, PosixFileAttributeView.class);
+                if (attrs != null) {
+                    //the directory umask applies when creating the file, so re-apply permissions here
+                    attrs.setPermissions(PosixFilePermissions.fromString(keyStorePermissions));
+                }
+                LOGGER.info("Created Logstash keystore at {}", keyStorePath.toAbsolutePath());
+                return this;
+            } catch (Exception e) {
+                throw new SecretStoreException.CreateException("Failed to create Logstash keystore.", e);
             }
-            this.keyStorePath = Paths.get(new String(path));
-            this.keyStorePass = getKeyStorePassword(keyStorePath.toFile().exists());
-            this.keyStore = KeyStore.getInstance(KEYSTORE_TYPE);
-
-            ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
-            readLock = readWriteLock.readLock();
-            writeLock = readWriteLock.writeLock();
-            this.protectionParameter = new PasswordProtection(this.keyStorePass);
+        } catch (SecretStoreException sse) {
+            throw sse;
+        } catch (Exception e) { //should never happen
+            throw new SecretStoreException.UnknownException("Error while trying to create the Logstash keystore", e);
+        } finally {
+            releaseLock(writeLock);
+            config.clearValues();
+        }
+    }
 
-            try (final InputStream is = Files.newInputStream(keyStorePath)) {
-                try {
-                    keyStore.load(is, this.keyStorePass);
-                } catch (IOException ioe) {
-                    if (ioe.getCause() instanceof UnrecoverableKeyException) {
-                        throw new SecretStoreException.AccessException(
-                                String.format("Can not access Java keystore at %s. Please verify correct file permissions and keystore password.",
-                                        keyStorePath.toAbsolutePath()), ioe);
-                    } else {
-                        throw new SecretStoreException.NotLogstashKeyStore(String.format("Found a file at %s, but it is not a valid Logstash keystore.",
-                                keyStorePath.toAbsolutePath().toString()), ioe);
-                    }
-                }
-                byte[] marker = retrieveSecret(LOGSTASH_MARKER);
-                if (marker == null) {
-                    throw new SecretStoreException.NotLogstashKeyStore(String.format("Found a keystore at %s, but it is not a Logstash keystore.",
-                            keyStorePath.toAbsolutePath().toString()));
-                }
-                LOGGER.debug("Using existing keystore at {}", keyStorePath.toAbsolutePath());
-            } catch (NoSuchFileException noSuchFileException) {
-                LOGGER.info("Keystore not found at {}. Creating new keystore.", keyStorePath.toAbsolutePath());
-                //wrapped in a system property mostly for testing, but could be used for more restrictive defaults
-                String keyStorePermissions = System.getProperty("logstash.keystore.file.perms", "rw-rw----");
-                //create the keystore on disk with a default entry to identify this as a logstash keystore
-                Files.createFile(keyStorePath, PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(keyStorePermissions)));
-                try {
-                    keyStore = KeyStore.Builder.newInstance(KEYSTORE_TYPE, null, protectionParameter).getKeyStore();
-                    SecretKeyFactory factory = SecretKeyFactory.getInstance("PBE");
-                    byte[] base64 = SecretStoreUtil.base64Encode(LOGSTASH_MARKER.getKey().getBytes(StandardCharsets.UTF_8));
-                    SecretKey secretKey = factory.generateSecret(new PBEKeySpec(SecretStoreUtil.asciiBytesToChar(base64)));
-                    keyStore.setEntry(LOGSTASH_MARKER.toExternalForm(), new KeyStore.SecretKeyEntry(secretKey), protectionParameter);
-                    saveKeyStore();
-                    PosixFileAttributeView attrs = Files.getFileAttributeView(keyStorePath, PosixFileAttributeView.class);
-                    if (attrs != null) {
-                        //the directory umask applies when creating the file, so re-apply permissions here
-                        attrs.setPermissions(PosixFilePermissions.fromString(keyStorePermissions));
-                    }
-                    LOGGER.info("Keystore created at {}", keyStorePath.toAbsolutePath());
-                } catch (Exception e) {
-                    throw new SecretStoreException.CreateException("Failed to create Logstash keystore.", e);
-                }
+    @Override
+    public void delete(SecureConfig config) {
+        try {
+            initLocks();
+            writeLock.lock();
+            if (exists(config)) {
+                Files.delete(Paths.get(new String(config.getPlainText(PATH_KEY))));
             }
         } catch (SecretStoreException sse) {
             throw sse;
         } catch (Exception e) { //should never happen
-            throw new SecretStoreException.UnknownException("Error while trying to create or load the Logstash keystore", e);
+            throw new SecretStoreException.UnknownException("Error while trying to delete the Logstash keystore", e);
         } finally {
+            releaseLock(writeLock);
             config.clearValues();
         }
     }
 
+    /**
+     * {@inheritDoc}
+     *
+     * @param config The configuration for this keystore <p>Requires "keystore.file" in the configuration</p>
+     * @throws SecretStoreException.InvalidConfigurationException if "keystore.file" is not defined in the config
+     */
+    @Override
+    public boolean exists(SecureConfig config) {
+        char[] path = config.getPlainText(PATH_KEY);
+        if (!valid(path)) {
+            throw new SecretStoreException.InvalidConfigurationException("Logstash keystore path (keystore.file) must be defined");
+        }
+        return new File(new String(path)).exists();
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        SecretStoreUtil.clearChars(keyStorePass);
+    }
+
     /**
      * Obtains the keystore password depending on if the password is explicitly defined and/or if this is a new keystore.
      *
-     * @param existing true if the keystore file already exists
+     * @param config the configuration
      * @return the char[] of the keystore password
      * @throws IOException on io errors
      */
-    private char[] getKeyStorePassword(boolean existing) throws IOException {
+    private char[] getKeyStorePassword(SecureConfig config) throws IOException {
         char[] plainText = config.getPlainText(SecretStoreFactory.KEYSTORE_ACCESS_KEY);
+        boolean existing = exists(config);
 
         //ensure if a password is configured, that we don't allow empty passwords
         if (config.has(SecretStoreFactory.KEYSTORE_ACCESS_KEY) && (plainText == null || plainText.length == 0)) {
@@ -145,7 +160,9 @@ private char[] getKeyStorePassword(boolean existing) throws IOException {
             }
         }
 
-        if (plainText == null) {
+        useDefaultPass = !config.has(SecretStoreFactory.KEYSTORE_ACCESS_KEY);
+
+        if (useDefaultPass) {
             if (existing) {
                 //read the pass
                 SeekableByteChannel byteChannel = Files.newByteChannel(keyStorePath, StandardOpenOption.READ);
@@ -168,6 +185,7 @@ private char[] getKeyStorePassword(boolean existing) throws IOException {
                 return SecretStoreUtil.base64EncodeToChars(randomBytes);
             }
         } else {
+            //explicit user defined pass
             //keystore passwords require ascii encoding, only base64 encode if necessary
             return asciiEncoder.canEncode(CharBuffer.wrap(plainText)) ? plainText : SecretStoreUtil.base64Encode(plainText);
         }
@@ -175,6 +193,24 @@ private char[] getKeyStorePassword(boolean existing) throws IOException {
                 String.format("Could not determine keystore password. Please ensure the file at %s is a valid Logstash keystore", keyStorePath.toAbsolutePath()));
     }
 
+    private void init(SecureConfig config) throws IOException, KeyStoreException {
+        char[] path = config.getPlainText(PATH_KEY);
+        if (!valid(path)) {
+            throw new IllegalArgumentException("Logstash keystore path must be defined");
+        }
+        this.keyStorePath = Paths.get(new String(path));
+        this.keyStorePass = getKeyStorePassword(config);
+        this.keyStore = KeyStore.getInstance(KEYSTORE_TYPE);
+        this.protectionParameter = new PasswordProtection(this.keyStorePass);
+        initLocks();
+    }
+
+    private void initLocks(){
+        ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
+        readLock = readWriteLock.readLock();
+        writeLock = readWriteLock.writeLock();
+    }
+
     @Override
     public Collection<SecretIdentifier> list() {
         Set<SecretIdentifier> identifiers = new HashSet<>();
@@ -189,11 +225,69 @@ public Collection<SecretIdentifier> list() {
         } catch (Exception e) {
             throw new SecretStoreException.ListException(e);
         } finally {
-            readLock.unlock();
+            releaseLock(readLock);
         }
         return identifiers;
     }
 
+    /**
+     * {@inheritDoc}
+     *
+     * @param config The configuration for this keystore <p>Requires "keystore.file" in the configuration</p><p>WARNING! this method clears all values
+     *               from this configuration, meaning this config is NOT reusable after passed in here.</p>
+     * @throws SecretStoreException.CreateException if the store can not be created
+     * @throws SecretStoreException                 (of other sub types) if contributing factors prevent the creation
+     */
+    @Override
+    public JavaKeyStore load(SecureConfig config) {
+        if (!exists(config)) {
+            throw new SecretStoreException.LoadException(
+                    String.format("Can not find Logstash keystore at %s. Please verify this file exists and is a valid Logstash keystore.",
+                            new String(config.getPlainText("keystore.file"))));
+        }
+        try {
+            init(config);
+            readLock.lock();
+            try (final InputStream is = Files.newInputStream(keyStorePath)) {
+                try {
+                    keyStore.load(is, this.keyStorePass);
+                } catch (IOException ioe) {
+                    if (ioe.getCause() instanceof UnrecoverableKeyException) {
+                        throw new SecretStoreException.AccessException(
+                                String.format("Can not access Logstash keystore at %s. Please verify correct file permissions and keystore password.",
+                                        keyStorePath.toAbsolutePath()), ioe);
+                    } else {
+                        throw new SecretStoreException.LoadException(String.format("Found a file at %s, but it is not a valid Logstash keystore.",
+                                keyStorePath.toAbsolutePath().toString()), ioe);
+                    }
+                }
+                byte[] marker = retrieveSecret(LOGSTASH_MARKER);
+                if (marker == null) {
+                    throw new SecretStoreException.LoadException(String.format("Found a keystore at %s, but it is not a Logstash keystore.",
+                            keyStorePath.toAbsolutePath().toString()));
+                }
+                LOGGER.debug("Using existing keystore at {}", keyStorePath.toAbsolutePath());
+                return this;
+            }
+        } catch (SecretStoreException sse) {
+            throw sse;
+        } catch (Exception e) { //should never happen
+            throw new SecretStoreException.UnknownException("Error while trying to load the Logstash keystore", e);
+        } finally {
+            releaseLock(readLock);
+            config.clearValues();
+        }
+    }
+
+    /**
+     * Need to load the keystore before any operations in case an external (or different JVM) has modified the keystore on disk.
+     */
+    private void loadKeyStore() throws CertificateException, NoSuchAlgorithmException, IOException {
+        try (final InputStream is = Files.newInputStream(keyStorePath)) {
+            keyStore.load(is, keyStorePass);
+        }
+    }
+
     @Override
     public void persistSecret(SecretIdentifier identifier, byte[] secret) {
         try {
@@ -215,7 +309,7 @@ public void persistSecret(SecretIdentifier identifier, byte[] secret) {
         } catch (Exception e) {
             throw new SecretStoreException.PersistException(identifier, e);
         } finally {
-            writeLock.unlock();
+            releaseLock(writeLock);
         }
     }
 
@@ -230,7 +324,13 @@ public void purgeSecret(SecretIdentifier identifier) {
         } catch (Exception e) {
             throw new SecretStoreException.PurgeException(identifier, e);
         } finally {
-            writeLock.unlock();
+            releaseLock(writeLock);
+        }
+    }
+
+    private void releaseLock(Lock lock) {
+        if (lock != null) {
+            lock.unlock();
         }
     }
 
@@ -244,7 +344,7 @@ public byte[] retrieveSecret(SecretIdentifier identifier) {
                 KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore.getEntry(identifier.toExternalForm(), protectionParameter);
                 //not found
                 if (secretKeyEntry == null) {
-                    LOGGER.warn("requested secret {} not found", identifier.toExternalForm());
+                    LOGGER.debug("requested secret {} not found", identifier.toExternalForm());
                     return null;
                 }
                 PBEKeySpec passwordBasedKeySpec = (PBEKeySpec) factory.getKeySpec(secretKeyEntry.getSecretKey(), PBEKeySpec.class);
@@ -257,26 +357,17 @@ public byte[] retrieveSecret(SecretIdentifier identifier) {
             } catch (Exception e) {
                 throw new SecretStoreException.RetrievalException(identifier, e);
             } finally {
-                readLock.unlock();
+                releaseLock(readLock);
             }
         }
         return null;
     }
 
-    /**
-     * Need to reload the keystore before any operations in case an external (or different JVM)  has modified the keystore on disk.
-     */
-    private void loadKeyStore() throws CertificateException, NoSuchAlgorithmException, IOException {
-        try (final InputStream is = Files.newInputStream(keyStorePath)) {
-            keyStore.load(is, keyStorePass);
-        }
-    }
-
     /**
      * Saves the keystore with some extra meta data if needed. Note - need two output streams here to allow checking the with the append flag, and the other without an append.
      */
     private void saveKeyStore() throws IOException, CertificateException, NoSuchAlgorithmException, KeyStoreException {
-        FileLock fileLock = null;
+        FileLock fileLock;
         try (final FileOutputStream appendOs = new FileOutputStream(keyStorePath.toFile(), true)) {
             fileLock = appendOs.getChannel().tryLock();
             if (fileLock == null) {
@@ -284,7 +375,7 @@ private void saveKeyStore() throws IOException, CertificateException, NoSuchAlgo
             }
             try (final OutputStream os = Files.newOutputStream(keyStorePath, StandardOpenOption.WRITE)) {
                 keyStore.store(os, keyStorePass);
-                if (!config.has(SecretStoreFactory.KEYSTORE_ACCESS_KEY)) {
+                if (useDefaultPass) {
                     byte[] obfuscatedPass = SecretStoreUtil.asciiCharToBytes(SecretStoreUtil.obfuscate(keyStorePass.clone()));
                     DataOutputStream dataOutputStream = new DataOutputStream(os);
                     os.write(obfuscatedPass);
@@ -298,9 +389,12 @@ private void saveKeyStore() throws IOException, CertificateException, NoSuchAlgo
         }
     }
 
-    @Override
-    protected void finalize() throws Throwable {
-        SecretStoreUtil.clearChars(keyStorePass);
+    /**
+     * @param chars char[] to check for null or empty
+     * @return true if not null, and not empty, false otherwise
+     */
+    private boolean valid(char[] chars) {
+        return !(chars == null || chars.length == 0);
     }
 }
 
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreFactoryTest.java b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreFactoryTest.java
index 249cc6163b2..746d84b459c 100644
--- a/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreFactoryTest.java
+++ b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreFactoryTest.java
@@ -58,46 +58,45 @@ private static void setEnv(Map<String, String> newenv) throws Exception {
     }
 
     @Test
-    public void testAlternativeImplementation(){
-        String beforeSystem = System.getProperty(SecretStore.class.getCanonicalName());
-        try {
-            System.setProperty(SecretStore.class.getCanonicalName(), "org.logstash.secret.store.SecretStoreFactoryTest$MemoryStore");
-            SecretStore secretStore = SecretStoreFactory.loadSecretStore(new SecureConfig());
-            assertThat(secretStore).isInstanceOf(MemoryStore.class);
-            validateMarker(secretStore);
-        } finally {
-            if (beforeSystem == null) {
-                System.clearProperty(SecretStore.class.getCanonicalName());
-            } else {
-                System.setProperty(SecretStore.class.getCanonicalName(), beforeSystem);
-            }
-        }
+    public void testAlternativeImplementation() {
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.classname", "org.logstash.secret.store.SecretStoreFactoryTest$MemoryStore".toCharArray());
+        SecretStore secretStore = SecretStoreFactory.load(secureConfig);
+        assertThat(secretStore).isInstanceOf(MemoryStore.class);
+        validateMarker(secretStore);
     }
 
     @Test
-    public void testAlternativeImplementationInvalid(){
+    public void testAlternativeImplementationInvalid() {
         thrown.expect(SecretStoreException.ImplementationNotFoundException.class);
-        String beforeSystem = System.getProperty(SecretStore.class.getCanonicalName());
-        try {
-            System.setProperty(SecretStore.class.getCanonicalName(), "junk");
-            SecretStoreFactory.loadSecretStore(new SecureConfig());
-        } finally {
-            if (beforeSystem == null) {
-                System.clearProperty(SecretStore.class.getCanonicalName());
-            } else {
-                System.setProperty(SecretStore.class.getCanonicalName(), beforeSystem);
-            }
-        }
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.classname", "junk".toCharArray());
+        SecretStore secretStore = SecretStoreFactory.load(secureConfig);
+        assertThat(secretStore).isInstanceOf(MemoryStore.class);
+        validateMarker(secretStore);
     }
 
     @Test
-    public void testDefaultLoad() throws IOException {
+    public void testCreateLoad() throws IOException {
+        SecretIdentifier id = new SecretIdentifier(UUID.randomUUID().toString());
+        String value = UUID.randomUUID().toString();
         SecureConfig secureConfig = new SecureConfig();
-        secureConfig.add("keystore.path", folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray());
-        SecretStore secretStore = SecretStoreFactory.loadSecretStore(secureConfig);
+        secureConfig.add("keystore.file", folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray());
+        SecretStore secretStore = SecretStoreFactory.create(secureConfig.clone());
 
         byte[] marker = secretStore.retrieveSecret(LOGSTASH_MARKER);
         assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+        secretStore.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        byte[] retrievedValue = secretStore.retrieveSecret(id);
+        assertThat(new String(retrievedValue, StandardCharsets.UTF_8)).isEqualTo(value);
+
+
+        secretStore = SecretStoreFactory.load(secureConfig);
+        marker = secretStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+        secretStore.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        retrievedValue = secretStore.retrieveSecret(id);
+        assertThat(new String(retrievedValue, StandardCharsets.UTF_8)).isEqualTo(value);
     }
 
     @Test
@@ -112,19 +111,19 @@ public void testDefaultLoadWithEnvPass() throws Exception {
 
             //Each usage of the secure config requires it's own instance since implementations can/should clear all the values once used.
             SecureConfig secureConfig1 = new SecureConfig();
-            secureConfig1.add("keystore.path", folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray());
+            secureConfig1.add("keystore.file", folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray());
             SecureConfig secureConfig2 = secureConfig1.clone();
             SecureConfig secureConfig3 = secureConfig1.clone();
             SecureConfig secureConfig4 = secureConfig1.clone();
 
             //ensure that with only the environment we can retrieve the marker from the store
-            SecretStore secretStore = SecretStoreFactory.loadSecretStore(secureConfig1);
+            SecretStore secretStore = SecretStoreFactory.create(secureConfig1);
             validateMarker(secretStore);
 
             //ensure that aren't simply using the defaults
             boolean expectedException = false;
             try {
-                new JavaKeyStore(secureConfig2);
+                new JavaKeyStore().create(secureConfig2);
             } catch (SecretStoreException e) {
                 expectedException = true;
             }
@@ -132,11 +131,11 @@ public void testDefaultLoadWithEnvPass() throws Exception {
 
             //ensure that direct key access using the system key wil work
             secureConfig3.add(KEYSTORE_ACCESS_KEY, pass.toCharArray());
-            secretStore = new JavaKeyStore(secureConfig3);
+            secretStore = new JavaKeyStore().load(secureConfig3);
             validateMarker(secretStore);
 
             //ensure that pass will work again
-            secretStore = SecretStoreFactory.loadSecretStore(secureConfig4);
+            secretStore = SecretStoreFactory.load(secureConfig4);
             validateMarker(secretStore);
 
         } finally {
@@ -149,9 +148,9 @@ public void testDefaultLoadWithEnvPass() throws Exception {
      */
     @Test
     public void testErrorLoading() {
-        thrown.expect(SecretStoreException.LoadException.class);
+        thrown.expect(SecretStoreException.InvalidConfigurationException.class);
         //default implementation requires a path
-        SecretStoreFactory.loadSecretStore(new SecureConfig());
+        SecretStoreFactory.load(new SecureConfig());
     }
 
     private void validateMarker(SecretStore secretStore) {
@@ -166,10 +165,30 @@ static class MemoryStore implements SecretStore {
 
         Map<SecretIdentifier, ByteBuffer> secrets = new HashMap(1);
 
-        public MemoryStore(SecureConfig secureConfig){
+        public MemoryStore() {
             persistSecret(LOGSTASH_MARKER, LOGSTASH_MARKER.getKey().getBytes(StandardCharsets.UTF_8));
         }
 
+        @Override
+        public SecretStore create(SecureConfig secureConfig) {
+            return this;
+        }
+
+        @Override
+        public void delete(SecureConfig secureConfig) {
+            secrets.clear();
+        }
+
+        @Override
+        public SecretStore load(SecureConfig secureConfig) {
+            return this;
+        }
+
+        @Override
+        public boolean exists(SecureConfig secureConfig) {
+            return true;
+        }
+
         @Override
         public Collection<SecretIdentifier> list() {
             return secrets.keySet();
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java b/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java
index 339bfe7d6b7..3effd794c02 100644
--- a/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java
+++ b/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java
@@ -7,6 +7,7 @@
 import org.junit.rules.ExpectedException;
 import org.junit.rules.TemporaryFolder;
 import org.logstash.secret.SecretIdentifier;
+import org.logstash.secret.store.SecretStore;
 import org.logstash.secret.store.SecretStoreException;
 import org.logstash.secret.store.SecretStoreFactory;
 import org.logstash.secret.store.SecureConfig;
@@ -88,8 +89,8 @@ public static void main(String... args) throws IOException, InterruptedException
         } else if (EXTERNAL_TEST_WRITE.equals(args[0])) {
             Path keyStoreFile = Paths.get(args[2]);
             SecureConfig config = new SecureConfig();
-            config.add("keystore.path", keyStoreFile.toAbsolutePath().toString().toCharArray());
-            JavaKeyStore keyStore = new JavaKeyStore(config);
+            config.add("keystore.file", keyStoreFile.toAbsolutePath().toString().toCharArray());
+            JavaKeyStore keyStore = new JavaKeyStore().create(config);
             writeAtoZ(keyStore);
             validateAtoZ(keyStore);
             //write the magic file to let the other process know the test is ready
@@ -123,16 +124,16 @@ private static void writeAtoZ(JavaKeyStore keyStore) {
     public void _setup() throws Exception {
         keyStorePath = folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray();
         SecureConfig secureConfig = new SecureConfig();
-        secureConfig.add("keystore.path", keyStorePath.clone());
-        keyStore = new JavaKeyStore(secureConfig);
+        secureConfig.add("keystore.file", keyStorePath.clone());
+        keyStore = new JavaKeyStore().create(secureConfig);
 
         withDefinedPassConfig = new SecureConfig();
         withDefinedPassConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "mypassword".toCharArray());
-        withDefinedPassConfig.add("keystore.path",
+        withDefinedPassConfig.add("keystore.file",
                 Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore.with.defined.pass").toURI()).toString().toCharArray());
 
         withDefaultPassConfig = new SecureConfig();
-        withDefaultPassConfig.add("keystore.path",
+        withDefaultPassConfig.add("keystore.file",
                 Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore.with.default.pass").toURI()).toString().toCharArray());
     }
 
@@ -166,7 +167,7 @@ public void isLogstashKeystore() throws Exception {
         assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
 
         //exiting
-        JavaKeyStore existingKeyStore = new JavaKeyStore(withDefinedPassConfig);
+        JavaKeyStore existingKeyStore = new JavaKeyStore().load(withDefinedPassConfig);
         marker = existingKeyStore.retrieveSecret(LOGSTASH_MARKER);
         assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
     }
@@ -178,7 +179,7 @@ public void isLogstashKeystore() throws Exception {
      */
     @Test
     public void notLogstashKeystore() throws Exception {
-        thrown.expect(SecretStoreException.NotLogstashKeyStore.class);
+        thrown.expect(SecretStoreException.LoadException.class);
         SecureConfig altConfig = new SecureConfig();
         Path altPath = folder.newFolder().toPath().resolve("alt.not.a.logstash.keystore");
         try (OutputStream out = Files.newOutputStream(altPath)) {
@@ -186,8 +187,8 @@ public void notLogstashKeystore() throws Exception {
             new Random().nextBytes(randomBytes);
             out.write(randomBytes);
         }
-        altConfig.add("keystore.path", altPath.toString().toCharArray());
-        new JavaKeyStore(altConfig);
+        altConfig.add("keystore.file", altPath.toString().toCharArray());
+        new JavaKeyStore().load(altConfig);
     }
 
     /**
@@ -197,9 +198,9 @@ public void notLogstashKeystore() throws Exception {
      */
     @Test
     public void notLogstashKeystoreNoMarker() throws Exception {
-        thrown.expect(SecretStoreException.NotLogstashKeyStore.class);
-        withDefinedPassConfig.add("keystore.path", Paths.get(this.getClass().getClassLoader().getResource("not.a.logstash.keystore").toURI()).toString().toCharArray().clone());
-        new JavaKeyStore(withDefinedPassConfig);
+        thrown.expect(SecretStoreException.LoadException.class);
+        withDefinedPassConfig.add("keystore.file", Paths.get(this.getClass().getClassLoader().getResource("not.a.logstash.keystore").toURI()).toString().toCharArray().clone());
+        new JavaKeyStore().load(withDefinedPassConfig);
     }
 
     /**
@@ -237,28 +238,22 @@ public void purgeMissingSecret() {
     @Test
     public void readExisting() throws Exception {
         //uses an explicit password
-        validateAtoZ(new JavaKeyStore(this.withDefinedPassConfig));
+        validateAtoZ(new JavaKeyStore().load(this.withDefinedPassConfig));
 
         //uses an implicit password
-        validateAtoZ(new JavaKeyStore(this.withDefaultPassConfig));
+        validateAtoZ(new JavaKeyStore().load(this.withDefaultPassConfig));
     }
 
     /**
      * Comprehensive tests that uses a freshly created keystore to write 26 entries, list them, read them, and delete them.
      */
     @Test
-    public void readWriteListDelete() throws InterruptedException {
-
-
+    public void readWriteListDelete() {
         writeAtoZ(keyStore);
         Collection<SecretIdentifier> foundIds = keyStore.list();
         assertThat(keyStore.list().size()).isEqualTo(26 + 1);
-
         validateAtoZ(keyStore);
-
-
         foundIds.stream().filter(id -> !id.equals(LOGSTASH_MARKER)).forEach(id -> keyStore.purgeSecret(id));
-
         assertThat(keyStore.list().size()).isEqualTo(1);
         assertThat(keyStore.list().stream().findFirst().get()).isEqualTo(LOGSTASH_MARKER);
     }
@@ -287,7 +282,7 @@ public void retrieveWithInvalidInput() {
      */
     @Test
     public void tamperedKeystore() throws Exception {
-        thrown.expect(SecretStoreException.class);
+        thrown.expect(SecretStoreException.AccessException.class);
         byte[] keyStoreAsBytes = Files.readAllBytes(Paths.get(new String(keyStorePath)));
         //bump the middle byte by 1
         int tamperLocation = keyStoreAsBytes.length / 2;
@@ -295,9 +290,21 @@ public void tamperedKeystore() throws Exception {
         Path tamperedPath = folder.newFolder().toPath().resolve("tampered.logstash.keystore");
         Files.write(tamperedPath, keyStoreAsBytes);
         SecureConfig sc = new SecureConfig();
-        sc.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "mypassword".toCharArray());
-        sc.add("keystore.path", tamperedPath.toUri().toString().toCharArray());
-        new JavaKeyStore(sc);
+        sc.add("keystore.file", tamperedPath.toString().toCharArray());
+        new JavaKeyStore().load(sc);
+    }
+
+    /**
+     * Ensures correct error when trying to re-create a pre-existing store
+     *
+     * @throws IOException when it goes boom.
+     */
+    @Test
+    public void testAlreadyCreated() throws IOException {
+        thrown.expect(SecretStoreException.AlreadyExistsException.class);
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.file", keyStorePath.clone());
+        new JavaKeyStore().create(secureConfig);
     }
 
     /**
@@ -322,6 +329,22 @@ public void testDefaultPermissions() throws Exception {
         }
     }
 
+    @Test
+    public void testDelete() throws IOException {
+        thrown.expect(SecretStoreException.LoadException.class);
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig altConfig = new SecureConfig();
+        altConfig.add("keystore.file", altPath.toString().toCharArray());
+        SecretStore secretStore = new JavaKeyStore().create(altConfig.clone());
+        assertThat(secretStore.exists(altConfig.clone())).isTrue();
+        byte[] marker = keyStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+        secretStore.delete(altConfig.clone());
+        assertThat(secretStore.exists(altConfig.clone())).isFalse();
+       new JavaKeyStore().load(altConfig.clone());
+
+    }
+
     /**
      * Empty passwords are not allowed
      *
@@ -332,9 +355,9 @@ public void testEmptyNotAllowedOnCreate() throws IOException {
         thrown.expect(SecretStoreException.CreateException.class);
         Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
         SecureConfig altConfig = new SecureConfig();
-        altConfig.add("keystore.path", altPath.toString().toCharArray());
+        altConfig.add("keystore.file", altPath.toString().toCharArray());
         altConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "".toCharArray());
-        new JavaKeyStore(altConfig);
+        new JavaKeyStore().create(altConfig);
     }
 
     /**
@@ -347,12 +370,12 @@ public void testEmptyNotAllowedOnExisting() throws Exception {
         thrown.expect(SecretStoreException.AccessException.class);
         Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
         SecureConfig altConfig = new SecureConfig();
-        altConfig.add("keystore.path", altPath.toString().toCharArray());
+        altConfig.add("keystore.file", altPath.toString().toCharArray());
         SecureConfig altConfig2 = altConfig.clone();
-        altConfig2.add("keystore.path", altPath.toString().toCharArray());
+        altConfig2.add("keystore.file", altPath.toString().toCharArray());
         altConfig2.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "".toCharArray());
-        new JavaKeyStore(altConfig);
-        new JavaKeyStore(altConfig2);
+        new JavaKeyStore().create(altConfig);
+        new JavaKeyStore().load(altConfig2);
     }
 
     /**
@@ -364,9 +387,9 @@ public void testEmptyNotAllowedOnExisting() throws Exception {
     public void testExternalUpdateList() throws IOException {
         Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
         SecureConfig secureConfig = new SecureConfig();
-        secureConfig.add("keystore.path", altPath.toString().toCharArray());
-        JavaKeyStore keyStore1 = new JavaKeyStore(secureConfig.clone());
-        JavaKeyStore keyStore2 = new JavaKeyStore(secureConfig);
+        secureConfig.add("keystore.file", altPath.toString().toCharArray());
+        JavaKeyStore keyStore1 = new JavaKeyStore().create(secureConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore().load(secureConfig);
         String value = UUID.randomUUID().toString();
         SecretIdentifier id = new SecretIdentifier(value);
         //jvm1 persist, jvm2 list
@@ -387,9 +410,9 @@ public void testExternalUpdateList() throws IOException {
     public void testExternalUpdatePersist() throws IOException {
         Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
         SecureConfig secureConfig = new SecureConfig();
-        secureConfig.add("keystore.path", altPath.toString().toCharArray());
-        JavaKeyStore keyStore1 = new JavaKeyStore(secureConfig.clone());
-        JavaKeyStore keyStore2 = new JavaKeyStore(secureConfig);
+        secureConfig.add("keystore.file", altPath.toString().toCharArray());
+        JavaKeyStore keyStore1 = new JavaKeyStore().create(secureConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore().load(secureConfig);
         String value1 = UUID.randomUUID().toString();
         String value2 = UUID.randomUUID().toString();
         SecretIdentifier id1 = new SecretIdentifier(value1);
@@ -420,10 +443,10 @@ public void testExternalUpdatePersist() throws IOException {
     public void testExternalUpdateRead() throws IOException {
         Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
         SecureConfig secureConfig = new SecureConfig();
-        secureConfig.add("keystore.path", altPath.toString().toCharArray());
+        secureConfig.add("keystore.file", altPath.toString().toCharArray());
         secureConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "mypass".toCharArray());
-        JavaKeyStore keyStore1 = new JavaKeyStore(secureConfig.clone());
-        JavaKeyStore keyStore2 = new JavaKeyStore(secureConfig);
+        JavaKeyStore keyStore1 = new JavaKeyStore().create(secureConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore().load(secureConfig);
         String value = UUID.randomUUID().toString();
         SecretIdentifier id = new SecretIdentifier(value);
         //jvm1 persist, jvm2 read
@@ -489,10 +512,10 @@ public void testFileLock() throws Exception {
     public void testGeneratedSecret() throws IOException {
         Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
         SecureConfig altConfig = new SecureConfig();
-        altConfig.add("keystore.path", altPath.toString().toCharArray());
+        altConfig.add("keystore.file", altPath.toString().toCharArray());
         //note - no password given here.
-        JavaKeyStore keyStore1 = new JavaKeyStore(altConfig.clone());
-        JavaKeyStore keyStore2 = new JavaKeyStore(altConfig);
+        JavaKeyStore keyStore1 = new JavaKeyStore().create(altConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore().load(altConfig);
         String value = UUID.randomUUID().toString();
         SecretIdentifier id = new SecretIdentifier(value);
         //jvm1 persist, jvm2 read
@@ -524,11 +547,19 @@ public void testLargeKeysAndValues() {
         keyStore.purgeSecret(id);
     }
 
+    @Test
+    public void testLoadNotCreated() throws IOException {
+        thrown.expect(SecretStoreException.LoadException.class);
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.file", altPath.toString().toCharArray());
+        new JavaKeyStore().load(secureConfig.clone());
+    }
+
     @Test
     public void testNoPathDefined() {
-        thrown.expect(SecretStoreException.class);
-        thrown.expectCause(isA(IllegalArgumentException.class));
-        new JavaKeyStore(new SecureConfig());
+        thrown.expect(SecretStoreException.InvalidConfigurationException.class);
+        new JavaKeyStore().load(new SecureConfig());
     }
 
     /**
@@ -543,8 +574,8 @@ public void testNonAscii() throws Exception {
 
         SecureConfig sc = new SecureConfig();
         sc.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, nonAscii.toCharArray());
-        sc.add("keystore.path", (new String(keyStorePath) + ".nonAscii").toCharArray());
-        JavaKeyStore nonAsciiKeyStore = new JavaKeyStore(sc);
+        sc.add("keystore.file", (new String(keyStorePath) + ".nonAscii").toCharArray());
+        JavaKeyStore nonAsciiKeyStore = new JavaKeyStore().create(sc);
 
         SecretIdentifier id = new SecretIdentifier(nonAscii);
         nonAsciiKeyStore.persistSecret(id, nonAscii.getBytes(StandardCharsets.UTF_8));
@@ -558,14 +589,14 @@ public void testNonAscii() throws Exception {
      */
     @Test
     public void testRestrictivePermissions() throws Exception {
-        String beforeTest = System.getProperty("logstash.keystore.file.perms");
+        String beforeTest = JavaKeyStore.filePermissions;
+        JavaKeyStore.filePermissions = "rw-------";
         try {
-            System.setProperty("logstash.keystore.file.perms", "rw-------");
             Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
             SecureConfig secureConfig = new SecureConfig();
-            secureConfig.add("keystore.path", altPath.toString().toCharArray());
+            secureConfig.add("keystore.file", altPath.toString().toCharArray());
 
-            keyStore = new JavaKeyStore(secureConfig);
+            keyStore = new JavaKeyStore().create(secureConfig);
             assertThat(altPath.toFile().exists()).isTrue();
             PosixFileAttributeView attrs = Files.getFileAttributeView(altPath, PosixFileAttributeView.class);
 
@@ -581,11 +612,7 @@ public void testRestrictivePermissions() throws Exception {
                 assertThat(permissions.toArray()).containsExactlyInAnyOrder(expected.toArray());
             }
         } finally {
-            if (beforeTest == null) {
-                System.clearProperty("logstash.keystore.file.perms");
-            } else {
-                System.setProperty("logstash.keystore.file.perms", beforeTest);
-            }
+            JavaKeyStore.filePermissions = beforeTest;
         }
     }
 
@@ -613,8 +640,8 @@ public void testWithRealSecondJvm() throws Exception {
             }
         }
         SecureConfig config = new SecureConfig();
-        config.add("keystore.path", altPath.toAbsolutePath().toString().toCharArray());
-        JavaKeyStore keyStore = new JavaKeyStore(config);
+        config.add("keystore.file", altPath.toAbsolutePath().toString().toCharArray());
+        JavaKeyStore keyStore = new JavaKeyStore().load(config);
         validateAtoZ(keyStore);
     }
 
@@ -627,8 +654,6 @@ public void testWithRealSecondJvm() throws Exception {
     public void wrongPassword() throws Exception {
         thrown.expect(SecretStoreException.AccessException.class);
         withDefinedPassConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "wrongpassword".toCharArray());
-        new JavaKeyStore(withDefinedPassConfig);
+        new JavaKeyStore().load(withDefinedPassConfig);
     }
-
-
 }
\ No newline at end of file
diff --git a/logstash-core/src/test/resources/logstash.keystore.with.default.pass b/logstash-core/src/test/resources/logstash.keystore.with.default.pass
index b1064058956..db1419c373d 100644
Binary files a/logstash-core/src/test/resources/logstash.keystore.with.default.pass and b/logstash-core/src/test/resources/logstash.keystore.with.default.pass differ
diff --git a/logstash-core/src/test/resources/logstash.keystore.with.defined.pass b/logstash-core/src/test/resources/logstash.keystore.with.defined.pass
index a4b418be80f..a21d9a88270 100644
Binary files a/logstash-core/src/test/resources/logstash.keystore.with.defined.pass and b/logstash-core/src/test/resources/logstash.keystore.with.defined.pass differ
