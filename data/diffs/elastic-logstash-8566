diff --git a/logstash-core/src/main/java/org/logstash/secret/SecretIdentifier.java b/logstash-core/src/main/java/org/logstash/secret/SecretIdentifier.java
new file mode 100644
index 00000000000..b28d4549646
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/SecretIdentifier.java
@@ -0,0 +1,101 @@
+package org.logstash.secret;
+
+import java.util.Locale;
+import java.util.regex.Pattern;
+
+/**
+ * <p>A URN based identifier for a given secret. The URN is constructed as such: {@code urn:logstash:secret:v1:<key>}</p>
+ * <p><em>Note - v1 is the version of the URN (not the key). This allows for passive changes to the URN for anything to the right of v1</em></p>
+ */
+public class SecretIdentifier {
+
+    private final static Pattern colonPattern = Pattern.compile(":");
+    private final static String VERSION = "v1";
+    private final static Pattern urnPattern = Pattern.compile("urn:logstash:secret:"+ VERSION + ":.*$");
+    private final String key;
+
+    /**
+     * Constructor
+     *
+     * @param key The unique part of the identifier. This is the key to reference the secret, and the key itself should not be sensitive. For example: {@code db.pass}
+     */
+    public SecretIdentifier(String key) {
+        this.key = validateWithTransform(key, "key");
+    }
+
+    /**
+     * Converts an external URN format to a {@link SecretIdentifier} object.
+     *
+     * @param urn The {@link String} formatted identifier obtained originally from {@link SecretIdentifier#toExternalForm()}
+     * @return The {@link SecretIdentifier} object used to identify secrets, null if not valid external form.
+     */
+    public static SecretIdentifier fromExternalForm(String urn) {
+        if (urn == null || !urnPattern.matcher(urn).matches()) {
+            throw new IllegalArgumentException("Invalid external form " + urn);
+        }
+        String[] parts = colonPattern.split(urn, 5);
+        return new SecretIdentifier(validateWithTransform(parts[4], "key"));
+    }
+
+    /**
+     * Minor validation and downcases the parts
+     *
+     * @param part     The part of the URN to validate
+     * @param partName The name of the part used for logging.
+     * @return The validated and transformed part.
+     */
+    private static String validateWithTransform(String part, String partName) {
+        if (part == null || part.isEmpty()) {
+            throw new IllegalArgumentException(String.format("%s may not be null or empty", partName));
+        }
+        return part.toLowerCase(Locale.US);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        SecretIdentifier that = (SecretIdentifier) o;
+
+        if (key != null ? !key.equals(that.key) : that.key != null) return false;
+        return VERSION != null ? VERSION.equals(that.VERSION) : that.VERSION == null;
+    }
+
+    /**
+     * Get the key (unique part) of the identifier
+     *
+     * @return the unique part of the identifier
+     */
+    public String getKey() {
+        return key;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = key != null ? key.hashCode() : 0;
+        result = 31 * result + (VERSION != null ? VERSION.hashCode() : 0);
+        return result;
+    }
+
+    /**
+     * Converts this object to a format acceptable external {@link String} format. Note - no gauruntees are made with respect to encoding or safe use. For example, the external
+     * format may not be URL safely encoded.
+     *
+     * @return the externally formatted {@link String}
+     */
+    public String toExternalForm() {
+        StringBuilder sb = new StringBuilder(100);
+        sb.append("urn").append(":");
+        sb.append("logstash").append(":");
+        sb.append("secret").append(":");
+        sb.append(VERSION).append(":");
+        sb.append(this.key);
+        return sb.toString();
+    }
+
+    @Override
+    public String toString() {
+        return toExternalForm();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStore.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStore.java
new file mode 100644
index 00000000000..8c9d10a3b3b
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStore.java
@@ -0,0 +1,45 @@
+package org.logstash.secret.store;
+
+
+import org.logstash.secret.SecretIdentifier;
+
+import java.util.Collection;
+
+/**
+ * <p>Contract with a store that can persist, retrieve, and purge sensitive data.</p>
+ * <p>Implementations <strong>MUST</strong> ensure proper security for the storage of the secrets.</p>
+ * <p>Implementations should throw a {@link SecretStoreException} if and only if errors are encountered while performing the action. </p>
+ */
+public interface SecretStore {
+
+    /**
+     * Gets all of the known {@link SecretIdentifier}
+     *
+     * @return a Collection of {@link SecretIdentifier}
+     */
+    Collection<SecretIdentifier> list();
+
+    /**
+     * Persist a secret to the store. Implementations should overwrite existing secrets with same identifier without error unless explicitly documented otherwise.
+     *
+     * @param id     The {@link SecretIdentifier} to identify the secret to persist
+     * @param secret The byte[] representation of the secret. Implementations should zero out this byte[] once it has been persisted.
+     */
+    void persistSecret(SecretIdentifier id, byte[] secret);
+
+    /**
+     * Purges the secret from the store.
+     *
+     * @param id The {@link SecretIdentifier} to identify the secret to purge
+     */
+    void purgeSecret(SecretIdentifier id);
+
+    /**
+     * Retrieves a secret.
+     *
+     * @param id The {@link SecretIdentifier} to identify the secret to retrieve
+     * @return the byte[] of the secret, null if no secret is found.
+     */
+    byte[] retrieveSecret(SecretIdentifier id);
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java
new file mode 100644
index 00000000000..b211d294c6f
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java
@@ -0,0 +1,63 @@
+package org.logstash.secret.store;
+
+import org.logstash.secret.SecretIdentifier;
+
+/**
+ * Exceptions when working a {@link SecretStore}
+ */
+public class SecretStoreException extends RuntimeException {
+
+    public SecretStoreException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public SecretStoreException(String message) {
+        super(message);
+    }
+
+    static public class NotLogstashKeyStore extends SecretStoreException {
+        public NotLogstashKeyStore(String message) {
+            super(message);
+        }
+
+        public NotLogstashKeyStore(String message, Throwable cause) {
+            super(message, cause);
+        }
+    }
+
+    static public class RetrievalException extends SecretStoreException {
+        public RetrievalException(SecretIdentifier secretIdentifier, Throwable cause) {
+            super(String.format("Error while trying to retrieve secret %s", secretIdentifier.toExternalForm()), cause);
+        }
+    }
+
+    static public class ListException extends SecretStoreException {
+        public ListException(Throwable cause) {
+            super("Error while trying to list keys in secret store", cause);
+        }
+    }
+
+    static public class CreateException extends SecretStoreException {
+        public CreateException(String message, Throwable cause) {
+            super(message, cause);
+        }
+    }
+
+    static public class PersistException extends SecretStoreException {
+        public PersistException(SecretIdentifier secretIdentifier, Throwable cause) {
+            super(String.format("Error while trying to store secret %s", secretIdentifier.toExternalForm()), cause);
+        }
+    }
+
+    static public class PurgeException extends SecretStoreException {
+        public PurgeException(SecretIdentifier secretIdentifier, Throwable cause) {
+            super(String.format("Error while trying to purge secret %s", secretIdentifier.toExternalForm()), cause);
+        }
+    }
+
+    static public class AccessException extends SecretStoreException {
+        public AccessException(String message, Throwable throwable) {
+            super(message, throwable);
+        }
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreUtil.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreUtil.java
new file mode 100644
index 00000000000..9a8acc938b7
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreUtil.java
@@ -0,0 +1,99 @@
+package org.logstash.secret.store;
+
+import java.util.Arrays;
+import java.util.Base64;
+
+/**
+ * Conversion utility between String, bytes, and chars. All methods attempt to keep sensitive data out of memory. Sensitive data should avoid using Java {@link String}'s.
+ */
+final public class SecretStoreUtil {
+
+    /**
+     * Private constructor. Utility class.
+     */
+    private SecretStoreUtil() {
+    }
+
+    /**
+     * Converts bytes from ascii encoded text to a char[] and zero outs the original byte[]
+     *
+     * @param bytes the bytes from an ascii encoded text (note - no validation is done to ensure ascii encoding)
+     * @return the corresponding char[]
+     */
+    public static char[] asciiBytesToChar(byte[] bytes) {
+        char[] chars = new char[bytes.length];
+        for (int i = 0; i < bytes.length; i++) {
+            chars[i] = (char) bytes[i];
+            bytes[i] = '\0';
+        }
+        return chars;
+    }
+
+    /**
+     * Converts characters from ascii encoded text to a byte[] and zero outs the original char[]
+     *
+     * @param chars the chars from an ascii encoded text (note - no validation is done to ensure ascii encoding)
+     * @return the corresponding byte[]
+     */
+    public static byte[] asciiCharToBytes(char[] chars) {
+        byte[] bytes = new byte[chars.length];
+        for (int i = 0; i < chars.length; i++) {
+            bytes[i] = (byte) chars[i];
+            chars[i] = '\0';
+        }
+        return bytes;
+    }
+
+    /**
+     * Base64 encode the given byte[], then zero the original byte[]
+     *
+     * @param b the byte[] to base64 encode
+     * @return the base64 encoded bytes
+     */
+    public static byte[] base64Encode(byte[] b) {
+        byte[] bytes = Base64.getEncoder().encode(b);
+        clearBytes(b);
+        return bytes;
+    }
+
+    /**
+     * Base64 encode the given char[], then zero out the original char[]
+     *
+     * @param chars the char[] to base64 encode
+     * @return the char[] representation of the base64 encoding
+     */
+    public static char[] base64Encode(char[] chars) {
+        return asciiBytesToChar(base64Encode(asciiCharToBytes(chars)));
+    }
+
+    /**
+     * Decodes a Base64 encoded byte[], then zero out the original byte[]
+     *
+     * @param b the base64 bytes
+     * @return the non-base64 encoded bytes
+     */
+    public static byte[] base64Decode(byte[] b) {
+        byte[] bytes = Base64.getDecoder().decode(b);
+        clearBytes(b);
+        return bytes;
+    }
+
+    /**
+     * Decodes a Base64 encoded char[], then zero out the original char[]
+     *
+     * @param chars the base64 chars
+     * @return the non-base64 encoded chars
+     */
+    public static byte[] base64Decode(char[] chars) {
+        return base64Decode(asciiCharToBytes(chars));
+    }
+
+    /**
+     * Attempt to keep data out of the heap.
+     *
+     * @param bytes the bytes to zero out
+     */
+    public static void clearBytes(byte[] bytes) {
+        Arrays.fill(bytes, (byte) '\0');
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java b/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java
new file mode 100644
index 00000000000..82e6a9daf58
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java
@@ -0,0 +1,218 @@
+package org.logstash.secret.store.backend;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.logstash.secret.SecretIdentifier;
+import org.logstash.secret.store.SecretStore;
+import org.logstash.secret.store.SecretStoreException;
+import org.logstash.secret.store.SecretStoreUtil;
+
+import javax.crypto.SecretKey;
+import javax.crypto.SecretKeyFactory;
+import javax.crypto.spec.PBEKeySpec;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.NoSuchFileException;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
+import java.nio.file.attribute.PosixFileAttributeView;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.security.KeyStore;
+import java.security.KeyStore.PasswordProtection;
+import java.security.KeyStore.ProtectionParameter;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.CertificateException;
+import java.util.*;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * <p>Java Key Store implementation for the {@link SecretStore}.</p>
+ * <p>Note this implementation should not be used for high volume or large datasets.</p>
+ * <p>This class is threadsafe.</p>
+ */
+public final class JavaKeyStore implements SecretStore {
+    public static final String LOGSTASH_MARKER = "logstash-key-store";
+    private static final Logger LOGGER = LogManager.getLogger(JavaKeyStore.class);
+    private static final String KEYSTORE_TYPE = "pkcs12";
+
+    private final char[] keyStorePass;
+    private final Path keyStorePath;
+    private final ProtectionParameter protectionParameter;
+    private final Lock readLock;
+    private final Lock writeLock;
+    private KeyStore keyStore;
+
+    /**
+     * Constructor - will create the keystore if it does not exist
+     *
+     * @param keyStorePath The full path to the java keystore
+     * @param keyStorePass The password to the keystore
+     * @throws SecretStoreException if errors occur while trying to create or access the keystore
+     */
+    public JavaKeyStore(Path keyStorePath, char[] keyStorePass) {
+        try {
+            this.keyStorePath = keyStorePath;
+            this.keyStore = KeyStore.getInstance(KEYSTORE_TYPE);
+            this.keyStorePass = SecretStoreUtil.base64Encode(keyStorePass);
+            ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
+            readLock = readWriteLock.readLock();
+            writeLock = readWriteLock.writeLock();
+            this.protectionParameter = new PasswordProtection(this.keyStorePass);
+            SecretIdentifier logstashMarker = new SecretIdentifier(LOGSTASH_MARKER);
+
+            try (final InputStream is = Files.newInputStream(keyStorePath)) {
+                try {
+                    keyStore.load(is, this.keyStorePass);
+                } catch (IOException ioe) {
+                    if (ioe.getCause() instanceof UnrecoverableKeyException) {
+                        throw new SecretStoreException.AccessException(
+                                String.format("Can not access Java keystore at %s. Please verify correct file permissions and keystore password.",
+                                        keyStorePath.toAbsolutePath()), ioe);
+                    } else {
+                        throw new SecretStoreException.NotLogstashKeyStore(String.format("Found a file at %s, but it is not a valid Logstash keystore.",
+                                keyStorePath.toAbsolutePath().toString()), ioe);
+                    }
+                }
+                byte[] marker = retrieveSecret(logstashMarker);
+                if (marker == null) {
+                    throw new SecretStoreException.NotLogstashKeyStore(String.format("Found a keystore at %s, but it is not a Logstash keystore.",
+                            keyStorePath.toAbsolutePath().toString()));
+                }
+                LOGGER.debug("Using existing keystore at {}", keyStorePath.toAbsolutePath());
+            } catch (NoSuchFileException noSuchFileException) {
+                LOGGER.info("Keystore not found at {}. Creating new keystore.", keyStorePath.toAbsolutePath());
+                //wrapped in a system property mostly for testing, but could be used for more restrictive defaults
+                String keyStorePermissions = System.getProperty("logstash.keystore.file.perms", "rw-rw----");
+                //create the keystore on disk with a default entry to identify this as a logstash keystore
+                Files.createFile(keyStorePath, PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(keyStorePermissions)));
+                try (final OutputStream os = Files.newOutputStream(keyStorePath, StandardOpenOption.WRITE)) {
+                    keyStore = KeyStore.Builder.newInstance(KEYSTORE_TYPE, null, protectionParameter).getKeyStore();
+                    SecretKeyFactory factory = SecretKeyFactory.getInstance("PBE");
+                    byte[] base64 = SecretStoreUtil.base64Encode(LOGSTASH_MARKER.getBytes(StandardCharsets.UTF_8));
+                    SecretKey secretKey = factory.generateSecret(new PBEKeySpec(SecretStoreUtil.asciiBytesToChar(base64)));
+                    keyStore.setEntry(logstashMarker.toExternalForm(), new KeyStore.SecretKeyEntry(secretKey), protectionParameter);
+                    keyStore.store(os, this.keyStorePass);
+                    PosixFileAttributeView attrs = Files.getFileAttributeView(keyStorePath, PosixFileAttributeView.class);
+                    if (attrs != null) {
+                        //the directory umask applies when creating the file, so re-apply permissions here
+                        attrs.setPermissions(PosixFilePermissions.fromString(keyStorePermissions));
+                    }
+                    LOGGER.info("Keystore created at {}", keyStorePath.toAbsolutePath());
+                } catch (Exception e) {
+                    throw new SecretStoreException.CreateException("Failed to create Logstash keystore.", e);
+                }
+            }
+        } catch (SecretStoreException sse) {
+            throw sse;
+        } catch (Exception e) { //should never happen
+            throw new SecretStoreException("Error while trying to create or load the Logstash keystore", e);
+        }
+    }
+
+    @Override
+    public Collection<SecretIdentifier> list() {
+        Set<SecretIdentifier> identifiers = new HashSet<>();
+        try {
+            readLock.lock();
+            reloadKeyStore();
+            Enumeration<String> aliases = keyStore.aliases();
+            while (aliases.hasMoreElements()) {
+                String alias = aliases.nextElement();
+                identifiers.add(SecretIdentifier.fromExternalForm(alias));
+            }
+        } catch (Exception e) {
+            throw new SecretStoreException.ListException(e);
+        } finally {
+            readLock.unlock();
+        }
+        return identifiers;
+    }
+
+    @Override
+    public void persistSecret(SecretIdentifier identifier, byte[] secret) {
+        try {
+            writeLock.lock();
+            reloadKeyStore();
+            SecretKeyFactory factory = SecretKeyFactory.getInstance("PBE");
+            //PBEKey requires an ascii password, so base64 encode it
+            byte[] base64 = SecretStoreUtil.base64Encode(secret);
+            PBEKeySpec passwordBasedKeySpec = new PBEKeySpec(SecretStoreUtil.asciiBytesToChar(base64));
+            SecretKey secretKey = factory.generateSecret(passwordBasedKeySpec);
+            keyStore.setEntry(identifier.toExternalForm(), new KeyStore.SecretKeyEntry(secretKey), protectionParameter);
+            try (final OutputStream os = Files.newOutputStream(keyStorePath)) {
+                keyStore.store(os, keyStorePass);
+            } finally {
+                passwordBasedKeySpec.clearPassword();
+                SecretStoreUtil.clearBytes(secret);
+            }
+            LOGGER.debug("persisted secret {}", identifier.toExternalForm());
+        } catch (Exception e) {
+            throw new SecretStoreException.PersistException(identifier, e);
+        } finally {
+            writeLock.unlock();
+        }
+    }
+
+    @Override
+    public void purgeSecret(SecretIdentifier identifier) {
+        try {
+            writeLock.lock();
+            reloadKeyStore();
+            keyStore.deleteEntry(identifier.toExternalForm());
+            try (final OutputStream os = Files.newOutputStream(keyStorePath)) {
+                keyStore.store(os, keyStorePass);
+            }
+            LOGGER.debug("purged secret {}", identifier.toExternalForm());
+        } catch (Exception e) {
+            throw new SecretStoreException.PurgeException(identifier, e);
+        } finally {
+            writeLock.unlock();
+        }
+    }
+
+    @Override
+    public byte[] retrieveSecret(SecretIdentifier identifier) {
+        if (identifier != null && identifier.getKey() != null && !identifier.getKey().isEmpty()) {
+            try {
+                readLock.lock();
+                reloadKeyStore();
+                SecretKeyFactory factory = SecretKeyFactory.getInstance("PBE");
+                KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore.getEntry(identifier.toExternalForm(), protectionParameter);
+                //not found
+                if (secretKeyEntry == null) {
+                    LOGGER.warn("requested secret {} not found", identifier.toExternalForm());
+                    return null;
+                }
+                PBEKeySpec passwordBasedKeySpec = (PBEKeySpec) factory.getKeySpec(secretKeyEntry.getSecretKey(), PBEKeySpec.class);
+                //base64 encoded char[]
+                char[] base64secret = passwordBasedKeySpec.getPassword();
+                byte[] secret = SecretStoreUtil.base64Decode(base64secret);
+                passwordBasedKeySpec.clearPassword();
+                LOGGER.debug("retrieved secret {}", identifier.toExternalForm());
+                return secret;
+            } catch (Exception e) {
+                throw new SecretStoreException.RetrievalException(identifier, e);
+            } finally {
+                readLock.unlock();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Need to reload the keystore before any operations in case an external (or different JVM)  has modified the keystore on disk.
+     */
+    private void reloadKeyStore() throws CertificateException, NoSuchAlgorithmException, IOException {
+        try (final InputStream is = Files.newInputStream(keyStorePath)) {
+            keyStore.load(is, keyStorePass);
+        }
+    }
+}
+
diff --git a/logstash-core/src/test/java/org/logstash/secret/SecretIdentifierTest.java b/logstash-core/src/test/java/org/logstash/secret/SecretIdentifierTest.java
new file mode 100644
index 00000000000..1f537c518b2
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/SecretIdentifierTest.java
@@ -0,0 +1,70 @@
+package org.logstash.secret;
+
+
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Unit tests for {@link SecretIdentifier}
+ */
+public class SecretIdentifierTest {
+
+    /**
+     * Example usage
+     */
+    @Test
+    public void testBasic() {
+        SecretIdentifier id = new SecretIdentifier("foo");
+        assertThat(id.toExternalForm()).isEqualTo("urn:logstash:secret:v1:foo");
+        assertThat(id.getKey()).isEqualTo("foo");
+    }
+
+    /**
+     * identifiers are case insensitive
+     */
+    @Test
+    public void testCase() {
+        SecretIdentifier id = new SecretIdentifier("FOO");
+        assertThat(id.toExternalForm()).isEqualTo("urn:logstash:secret:v1:foo");
+        SecretIdentifier id2 = new SecretIdentifier("foo");
+        assertThat(id).isEqualTo(id2);
+        assertThat(id.getKey()).isEqualTo(id2.getKey());
+        assertThat(id.toExternalForm()).isEqualTo(id.toExternalForm()).isEqualTo(id.toString()).isEqualTo(id2.toString());
+    }
+
+    /**
+     * Colon in the key don't cause issues with parsing the colon separated URN
+     */
+    @Test
+    public void testColon() {
+        SecretIdentifier id = new SecretIdentifier("foo:bar");
+        assertThat(id.toExternalForm()).isEqualTo("urn:logstash:secret:v1:foo:bar");
+        assertThat(id.getKey()).isEqualTo("foo:bar");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testEmptyKey() {
+        new SecretIdentifier("");
+    }
+
+    /**
+     * valid urns should be able to be constructed from the urn
+     */
+    @Test
+    public void testFromExternal() {
+        assertThat(SecretIdentifier.fromExternalForm("urn:logstash:secret:v1:foo")).isEqualTo(new SecretIdentifier("foo"));
+        assertThat(SecretIdentifier.fromExternalForm("urn:logstash:secret:v1:foo:bar")).isEqualTo(new SecretIdentifier("foo:bar"));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testFromExternalInvalid() {
+        SecretIdentifier.fromExternalForm("urn:logstash:secret:invalid:foo");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testNullKey() {
+        new SecretIdentifier(null);
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreUtilTest.java b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreUtilTest.java
new file mode 100644
index 00000000000..964f249e803
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreUtilTest.java
@@ -0,0 +1,57 @@
+package org.logstash.secret.store;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.nio.charset.StandardCharsets;
+import java.util.UUID;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Unit tests for {@link SecretStoreUtil}
+ */
+public class SecretStoreUtilTest {
+
+    private String asciiString;
+    @Before
+    public void setup(){
+        asciiString = UUID.randomUUID().toString();
+    }
+
+    @Test
+    public void testAsciiBytesToChar() {
+        byte[] asciiBytes = asciiString.getBytes(StandardCharsets.US_ASCII);
+        char[] asciiChars = SecretStoreUtil.asciiBytesToChar(asciiBytes);
+        assertThat(asciiChars).isEqualTo(asciiString.toCharArray());
+        assertThat(asciiBytes).containsOnly('\0');
+    }
+
+    @Test
+    public void testAsciiCharToBytes(){
+        char[] asciiChars = asciiString.toCharArray();
+        byte[] asciiBytes = SecretStoreUtil.asciiCharToBytes(asciiChars);
+        assertThat(asciiBytes).isEqualTo(asciiString.getBytes(StandardCharsets.US_ASCII));
+        assertThat(asciiChars).contains('\0');
+    }
+
+    @Test
+    public void testBase64EncodeBytes(){
+        byte[] asciiBytes = asciiString.getBytes(StandardCharsets.US_ASCII);
+        byte[] base64Bytes = SecretStoreUtil.base64Encode(asciiBytes);
+        assertThat(asciiBytes).containsOnly('\0');
+        asciiBytes = SecretStoreUtil.base64Decode(base64Bytes);
+        assertThat(base64Bytes).containsOnly('\0');
+        assertThat(asciiBytes).isEqualTo(asciiString.getBytes(StandardCharsets.US_ASCII));
+    }
+
+    @Test
+    public void testBase64EncodeChars(){
+        char[] asciiChars = asciiString.toCharArray();
+        char[] base64Chars = SecretStoreUtil.base64Encode(asciiChars);
+        assertThat(asciiChars).containsOnly('\0');
+        byte[] asciiBytes = SecretStoreUtil.base64Decode(base64Chars);
+        assertThat(base64Chars).containsOnly('\0');
+        assertThat(asciiBytes).isEqualTo(asciiString.getBytes(StandardCharsets.US_ASCII));
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java b/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java
new file mode 100644
index 00000000000..315e02cf89e
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java
@@ -0,0 +1,377 @@
+package org.logstash.secret.store.backend;
+
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TemporaryFolder;
+import org.logstash.secret.SecretIdentifier;
+import org.logstash.secret.store.SecretStoreException;
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.PosixFileAttributeView;
+import java.nio.file.attribute.PosixFilePermission;
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+
+import static java.nio.file.attribute.PosixFilePermission.*;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Fail.fail;
+import static org.hamcrest.CoreMatchers.instanceOf;
+
+/**
+ * Unit tests for the {@link JavaKeyStore}
+ */
+public class JavaKeyStoreTest {
+
+    @Rule
+    public TemporaryFolder folder = new TemporaryFolder();
+
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+    private JavaKeyStore keyStore;
+    private char[] keyStorePass;
+    private Path keyStorePath;
+
+    /**
+     * Simple example usage.
+     */
+    @Test
+    public void basicTest() {
+        String password = "pAssW3rd!";
+        //persist
+        keyStore.persistSecret(new SecretIdentifier("mysql.password"), password.getBytes(StandardCharsets.UTF_8));
+        //retrieve
+        byte[] secret = keyStore.retrieveSecret(new SecretIdentifier("mysql.password"));
+        assertThat(new String(secret, StandardCharsets.UTF_8)).isEqualTo(password);
+        //purge
+        keyStore.purgeSecret(new SecretIdentifier("mysql.password"));
+        secret = keyStore.retrieveSecret(new SecretIdentifier("mysql.password"));
+        assertThat(secret).isNull();
+    }
+
+    /**
+     * Tests that the magic marker that identifies this a logstash keystore is present.  This marker helps to ensure that we are only dealing with our keystore, we do not want
+     * to support arbitrary keystores.
+     *
+     * @throws Exception when ever it wants to.
+     */
+    @Test
+    public void isLogstashKeystore() throws Exception {
+        //newly created
+        byte[] marker = keyStore.retrieveSecret(new SecretIdentifier(JavaKeyStore.LOGSTASH_MARKER));
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(JavaKeyStore.LOGSTASH_MARKER);
+
+        //exiting
+        JavaKeyStore existingKeyStore = new JavaKeyStore(Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore").toURI()), "mypassword".toCharArray());
+        marker = existingKeyStore.retrieveSecret(new SecretIdentifier(JavaKeyStore.LOGSTASH_MARKER));
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(JavaKeyStore.LOGSTASH_MARKER);
+    }
+
+    /**
+     * Tests that when the magic marker that identifies this a logstash keystore is not present the correct exception is thrown.
+     *
+     * @throws Exception when ever it wants to.
+     */
+    @Test
+    public void notLogstashKeystore() throws Exception {
+        thrown.expect(SecretStoreException.NotLogstashKeyStore.class);
+        new JavaKeyStore(Paths.get(this.getClass().getClassLoader().getResource("not.a.logstash.keystore").toURI()), "mypassword".toCharArray());
+    }
+
+    /**
+     * Overwrite should be no-error overwrite
+     */
+    @Test
+    public void overwriteExisting() {
+        SecretIdentifier id = new SecretIdentifier("myId");
+        int originalSize = keyStore.list().size();
+
+        keyStore.persistSecret(id, "password1".getBytes(StandardCharsets.UTF_8));
+        assertThat(keyStore.list().size()).isEqualTo(originalSize + 1);
+        assertThat(new String(keyStore.retrieveSecret(id), StandardCharsets.UTF_8)).isEqualTo("password1");
+
+        keyStore.persistSecret(id, "password2".getBytes(StandardCharsets.UTF_8));
+        assertThat(keyStore.list().size()).isEqualTo(originalSize + 1);
+        assertThat(new String(keyStore.retrieveSecret(id), StandardCharsets.UTF_8)).isEqualTo("password2");
+    }
+
+    /**
+     * Purging missing secrets should be no-error no-op
+     */
+    @Test
+    public void purgeMissingSecret() {
+        Collection<SecretIdentifier> original = keyStore.list();
+        keyStore.purgeSecret(new SecretIdentifier("does-not-exist"));
+        assertThat(keyStore.list().toArray()).containsExactlyInAnyOrder(original.toArray());
+    }
+
+    /**
+     * Tests that we can read a pre-existing keystore from disk.
+     *
+     * @throws Exception when ever it wants to.
+     */
+    @Test
+    public void readExisting() throws Exception {
+        JavaKeyStore existingKeyStore = new JavaKeyStore(Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore").toURI()), "mypassword".toCharArray());
+        //contents of the existing is a-z for both the key and value
+        for (int i = 65; i <= 90; i++) {
+            byte[] expected = new byte[]{(byte) i};
+            SecretIdentifier id = new SecretIdentifier(new String(expected, StandardCharsets.UTF_8));
+            assertThat(existingKeyStore.retrieveSecret(id)).isEqualTo(expected);
+        }
+    }
+
+    /**
+     * Comprehensive tests that uses a freshly created keystore to write 26 entries, list them, read them, and delete them.
+     */
+    @Test
+    public void readWriteListDelete() {
+        Set<String> values = new HashSet<>(27);
+        Set<SecretIdentifier> keys = new HashSet<>(27);
+        SecretIdentifier markerId = new SecretIdentifier(JavaKeyStore.LOGSTASH_MARKER);
+        //add the marker
+        keys.add(markerId);
+        values.add(JavaKeyStore.LOGSTASH_MARKER);
+        //a-z key and value
+        for (int i = 65; i <= 90; i++) {
+            byte[] expected = new byte[]{(byte) i};
+            values.add(new String(expected, StandardCharsets.UTF_8));
+            SecretIdentifier id = new SecretIdentifier(new String(expected, StandardCharsets.UTF_8));
+            keyStore.persistSecret(id, expected);
+            keys.add(id);
+        }
+        Collection<SecretIdentifier> foundIds = keyStore.list();
+        assertThat(keyStore.list().size()).isEqualTo(26 + 1);
+        assertThat(values.size()).isEqualTo(26 + 1);
+        assertThat(keys.size()).isEqualTo(26 + 1);
+
+        foundIds.stream().forEach(id -> assertThat(keys).contains(id));
+        foundIds.stream().forEach(id -> assertThat(values).contains(new String(keyStore.retrieveSecret(id), StandardCharsets.UTF_8)));
+
+        foundIds.stream().filter(id -> !id.equals(markerId)).forEach(id -> keyStore.purgeSecret(id));
+
+        assertThat(keyStore.list().size()).isEqualTo(1);
+        assertThat(keyStore.list().stream().findFirst().get()).isEqualTo(markerId);
+    }
+
+    /**
+     * Retrieving missing should be no-error, null result
+     */
+    @Test
+    public void retrieveMissingSecret() {
+        assertThat(keyStore.retrieveSecret(new SecretIdentifier("does-not-exist"))).isNull();
+    }
+
+    /**
+     * Invalid input should be no-error, null result
+     */
+    @Test
+    public void retrieveWithInvalidInput() {
+        assertThat(keyStore.retrieveSecret(null)).isNull();
+    }
+
+    @Before
+    public void setup() throws Exception {
+        keyStorePath = folder.newFolder().toPath().resolve("logstash.keystore");
+        keyStorePass = UUID.randomUUID().toString().toCharArray();
+        keyStore = new JavaKeyStore(keyStorePath, keyStorePass);
+    }
+
+    /**
+     * Test to ensure that keystore is tamper proof.  This really ends up testing the Java's KeyStore implementation, not the code here....but an important attribute to ensure
+     * for any type of secret store.
+     *
+     * @throws Exception when ever it wants to
+     */
+    @Test
+    public void tamperedKeystore() throws Exception {
+
+        thrown.expect(SecretStoreException.NotLogstashKeyStore.class);
+        byte[] keyStoreAsBytes = Files.readAllBytes(keyStorePath);
+        //bump the middle byte by 1
+        int tamperLocation = keyStoreAsBytes.length / 2;
+        keyStoreAsBytes[tamperLocation] = (byte) (keyStoreAsBytes[tamperLocation] + 1);
+        Path tamperedPath = folder.newFolder().toPath().resolve("tampered.logstash.keystore");
+        Files.write(tamperedPath, keyStoreAsBytes);
+        new JavaKeyStore(tamperedPath, keyStorePass);
+    }
+
+    /**
+     * Test upper sane bounds.
+     */
+    @Test
+    public void testLargeKeysAndValues() {
+        int keySize = 1000;
+        int valueSize = 100000;
+        StringBuilder keyBuilder = new StringBuilder(keySize);
+        IntStream.range(0, keySize).forEach(i -> keyBuilder.append('k'));
+        String key = keyBuilder.toString();
+
+        StringBuilder valueBuilder = new StringBuilder(valueSize);
+        IntStream.range(0, valueSize).forEach(i -> valueBuilder.append('v'));
+        String value = valueBuilder.toString();
+
+        SecretIdentifier id = new SecretIdentifier(key);
+        keyStore.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+
+        byte[] secret = keyStore.retrieveSecret(id);
+        assertThat(new String(secret, StandardCharsets.UTF_8)).isEqualTo(value);
+
+        keyStore.purgeSecret(id);
+    }
+
+    /**
+     * Ensure that non-ascii keys and values are properly handled.
+     *
+     * @throws Exception when the clowns cry
+     */
+    @Test
+    public void testNonAscii() throws Exception {
+        int[] codepoints = {0xD83E, 0xDD21, 0xD83E, 0xDD84};
+        String nonAscii = new String(codepoints, 0, codepoints.length);
+        SecretIdentifier id = new SecretIdentifier(nonAscii);
+        keyStore.persistSecret(id, nonAscii.getBytes(StandardCharsets.UTF_8));
+        assertThat(new String(keyStore.retrieveSecret(id), StandardCharsets.UTF_8)).isEqualTo(nonAscii);
+    }
+
+    /**
+     * The default permissions should be restrictive for Posix filesystems.
+     *
+     * @throws Exception when it goes boom.
+     */
+    @Test
+    public void testDefaultPermissions() throws Exception {
+        PosixFileAttributeView attrs = Files.getFileAttributeView(keyStorePath, PosixFileAttributeView.class);
+        boolean isWindows = System.getProperty("os.name").startsWith("Windows");
+        //not all Windows FS are Posix
+        if (!isWindows && attrs == null) {
+            fail("Can not determine POSIX file permissions for " + keyStore + " this is likely an error in the test");
+        }
+        // if we got attributes, lets assert them.
+        if (attrs != null) {
+            Set<PosixFilePermission> permissions = attrs.readAttributes().permissions();
+            EnumSet<PosixFilePermission> expected = EnumSet.of(OWNER_READ, OWNER_WRITE, GROUP_READ, GROUP_WRITE);
+            assertThat(permissions.toArray()).containsExactlyInAnyOrder(expected.toArray());
+        }
+    }
+
+    /**
+     * Ensure the permissions can be set to be set more restrictive then default
+     *
+     * @throws Exception when it goes boom.
+     */
+    @Test
+    public void testRestrictivePermissions() throws Exception {
+        String beforeTest = System.getProperty("logstash.keystore.file.perms");
+        try {
+            System.setProperty("logstash.keystore.file.perms", "rw-------");
+            Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+            keyStore = new JavaKeyStore(altPath, keyStorePass);
+            assertThat(altPath.toFile().exists()).isTrue();
+            PosixFileAttributeView attrs = Files.getFileAttributeView(altPath, PosixFileAttributeView.class);
+
+            boolean isWindows = System.getProperty("os.name").startsWith("Windows");
+            //not all Windows FS are Posix
+            if (!isWindows && attrs == null) {
+                fail("Can not determine POSIX file permissions for " + keyStore + " this is likely an error in the test");
+            }
+            // if we got attributes, lets assert them.
+            if (attrs != null) {
+                Set<PosixFilePermission> permissions = attrs.readAttributes().permissions();
+                EnumSet<PosixFilePermission> expected = EnumSet.of(OWNER_READ, OWNER_WRITE);
+                assertThat(permissions.toArray()).containsExactlyInAnyOrder(expected.toArray());
+            }
+        } finally {
+            if (beforeTest == null) {
+                System.clearProperty("logstash.keystore.file.perms");
+            } else {
+                System.setProperty("logstash.keystore.file.perms", beforeTest);
+            }
+        }
+    }
+
+    /**
+     * Simulates a different JVM modifying the keystore and ensure a consistent read view
+     */
+    @Test
+    public void testExternalUpdateRead() throws IOException {
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        JavaKeyStore keyStore1 = new JavaKeyStore(altPath, "mypass".toCharArray());
+        JavaKeyStore keyStore2 = new JavaKeyStore(altPath, "mypass".toCharArray());
+        String value = UUID.randomUUID().toString();
+        SecretIdentifier id = new SecretIdentifier(value);
+        //jvm1 persist, jvm2 read
+        keyStore1.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        assertThat(new String(keyStore2.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
+        //purge from jvm2
+        assertThat(new String(keyStore1.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
+        keyStore2.purgeSecret(id);
+        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value))).isNull();
+    }
+
+    /**
+     * Simulates a different JVM modifying the keystore and ensure a consistent list view
+     */
+    @Test
+    public void testExternalUpdateList() throws IOException {
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        JavaKeyStore keyStore1 = new JavaKeyStore(altPath, "mypass".toCharArray());
+        JavaKeyStore keyStore2 = new JavaKeyStore(altPath, "mypass".toCharArray());
+        String value = UUID.randomUUID().toString();
+        SecretIdentifier id = new SecretIdentifier(value);
+        //jvm1 persist, jvm2 list
+        keyStore1.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        assertThat(keyStore2.list().stream().map(k -> keyStore2.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8)).collect(Collectors.toSet())).contains(value);
+        //purge from jvm1
+        assertThat(new String(keyStore2.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
+        keyStore1.purgeSecret(id);
+        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value))).isNull();
+    }
+
+    /**
+     * Simulates a different JVMs modifying the keystore and ensure a consistent view
+     */
+    @Test
+    public void testExternalUpdatePersist() throws IOException {
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        JavaKeyStore keyStore1 = new JavaKeyStore(altPath, "mypass".toCharArray());
+        JavaKeyStore keyStore2 = new JavaKeyStore(altPath, "mypass".toCharArray());
+        String value1 = UUID.randomUUID().toString();
+        String value2 = UUID.randomUUID().toString();
+        SecretIdentifier id1 = new SecretIdentifier(value1);
+        SecretIdentifier id2 = new SecretIdentifier(value2);
+        //jvm1 persist id1, jvm2 persist id2
+        keyStore1.persistSecret(id1, value1.getBytes(StandardCharsets.UTF_8));
+        keyStore2.persistSecret(id2, value2.getBytes(StandardCharsets.UTF_8));
+        //both keystores should contain both values
+        assertThat(keyStore1.list().stream().map(k -> keyStore1.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8))
+                .collect(Collectors.toSet())).contains(value1,  value2);
+        assertThat(keyStore2.list().stream().map(k -> keyStore2.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8))
+                .collect(Collectors.toSet())).contains(value1,  value2);
+        //purge from jvm1
+        keyStore1.purgeSecret(id1);
+        keyStore1.purgeSecret(id2);
+        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value1))).isNull();
+        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value2))).isNull();
+        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value1))).isNull();
+        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value2))).isNull();
+    }
+
+    /**
+     * Ensure that the when the wrong password is presented the corrected exception is thrown.
+     *
+     * @throws Exception when ever it wants to
+     */
+    @Test
+    public void wrongPassword() throws Exception {
+        thrown.expect(SecretStoreException.AccessException.class);
+        new JavaKeyStore(Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore").toURI()), "wrongpassword".toCharArray());
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/resources/logstash.keystore b/logstash-core/src/test/resources/logstash.keystore
new file mode 100644
index 00000000000..ecf06032af1
Binary files /dev/null and b/logstash-core/src/test/resources/logstash.keystore differ
diff --git a/logstash-core/src/test/resources/not.a.logstash.keystore b/logstash-core/src/test/resources/not.a.logstash.keystore
new file mode 100644
index 00000000000..195e18d7948
Binary files /dev/null and b/logstash-core/src/test/resources/not.a.logstash.keystore differ
