diff --git a/logstash-core/lib/logstash/inputs/metrics.rb b/logstash-core/lib/logstash/inputs/metrics.rb
index 7b261c5c52e..9570454ab97 100644
--- a/logstash-core/lib/logstash/inputs/metrics.rb
+++ b/logstash-core/lib/logstash/inputs/metrics.rb
@@ -4,6 +4,11 @@
 require "logstash/instrument/collector"
 
 module LogStash module Inputs
+  # The Metrics inputs is responable of registring itself to the collector.
+  # The collector class will periodically emits new snapshot of the system,
+  # The metrics need to take that information and transform it into
+  # a `Logstash::Event`, which can be consumed by the shipper and send to
+  # Elasticsearch
   class Metrics < LogStash::Inputs::Base
     config_name "metrics"
 
@@ -27,8 +32,8 @@ def stop
       LogStash::Instrument::Collector.instance.delete_observer(self)
     end
 
-    def update(time, snapshot)
-      @logger.debug("Metrics input: received a new snapshot", :snapshot => snapshot, :event => snapshot.to_event) if @logger.debug?
+    def update(snapshot)
+      @logger.debug("Metrics input: received a new snapshot", :created_at => snapshot.created_at, :snapshot => snapshot, :event => snapshot.metric_store.to_event) if @logger.debug?
 
       # TODO: (ph)
       # - Obviously the format here is wrong and we need to
@@ -39,7 +44,10 @@ def update(time, snapshot)
       #   - We can use a synchronization mechanism between the called thread (update method)
       #   and the plugin thread (run method)
       #   - How we handle back pressure here?
-      @queue << snapshot.to_event
+      #   - one snashot should be only one event
+      snapshot.metric_store.to_events.each do |event|
+        @queue << event
+      end
     end
   end
 end;end
diff --git a/logstash-core/lib/logstash/instrument/collector.rb b/logstash-core/lib/logstash/instrument/collector.rb
index c606a4ffe0a..7ba7c7fd7ac 100644
--- a/logstash-core/lib/logstash/instrument/collector.rb
+++ b/logstash-core/lib/logstash/instrument/collector.rb
@@ -1,79 +1,101 @@
 # encoding: utf-8
 require "logstash/instrument/snapshot"
+require "logstash/instrument/metric_store"
 require "logstash/util/loggable"
-require "concurrent/map"
+require "concurrent/timer_task"
 require "observer"
 require "singleton"
 require "thread"
 
 module LogStash module Instrument
+  # The Collector singleton is the single point of reference for all
+  # the metrics collection inside logstash, the metrics library will make
+  # direct calls to this class.
+  #
+  # This class is an observable responsable of periodically emitting view of the system
+  # to other components like the internal metrics pipelines.
   class Collector
-    # TODO: move to a timer based  API with concurrent ruby timer class
-    # Allow to accept an external flush
-    # When the flush is done we should not record any new metric
     include LogStash::Util::Loggable
     include Observable
     include Singleton
 
-    SNAPSHOT_ROTATION_TIME = 1 #seconds
+    SNAPSHOT_ROTATION_TIME_SECS = 1 # seconds
+    SNAPSHOT_ROTATION_TIMEOUT_INTERVAL_SECS = 10 * 60 # seconds
 
     def initialize
-      @snapshot_rotation_mutex = Mutex.new
-      rotate_snapshot
+      @metric_store = MetricStore.new
+
+      start_periodic_snapshotting
     end
 
-    # This part of the code is called from multiple threads
-    # TODO: rename to record?
+    # The metric library will call this unique interface
+    # its the job of the collector to update the store with new metric
+    # of update the metric
+    #
+    # If there is a problem with the key or the type of metric we will record an error 
+    # but we wont stop processing events, theses errors are not considered fatal.
+    # 
     def push(*args)
-      snapshot.push(*args)
-    end
+      namespaces_path, key, type, metric_type_params = args
 
-    def self.snapshot_rotation_time=(time)
-      @snapsho_rotation_time = ime
+      begin
+        metric = @metric_store.fetch_or_store(namespaces_path, key) do
+          LogStash::Instrument::MetricType.create(type, namespaces_path, key)
+        end
+        metric.execute(*metric_type_params)
+        changed # we had changes coming in so we can notify the observers
+      rescue MetricStore::NamespacesExpectedError => e
+        logger.error("Collector: Cannot record metric", :exception => e)
+      rescue NameError => e
+        logger.error("Collector: Cannot create concrete class for this metric type",
+                     :type => type,
+                     :namespaces_path => namespaces_path,
+                     :key => key,
+                     :stacktrace => e.backtrace)
+      end
     end
 
-    def self.snapshot_rotation_time
-      @snapshot_rotation_time || SNAPSHOT_ROTATION_TIME
+    # Monitor the `Concurrent::TimerTask` this update is triggered on every successful or not
+    # run of the task, TimerTask implement Observable and the collector acts as
+    # the observer and will keep track if something went wrong in the execution.
+    #
+    # @param [Time] Time of execution
+    # @param [result] Result of the execution
+    # @param [Exception] Exception
+    def update(time_of_execution, result, exception)
+      return true if exception.nil?
+      logger.error("Collector: Something went wrong went sending data to the observers", 
+                   :execution_time => time_of_execution,
+                   :result => result,
+                   :exception => exception)
     end
 
-    private
-    def roll_over?
-      Concurrent.monotonic_time - @last_rotation >= self.class.snapshot_rotation_time
+    # Snapshot the current Metric Store and return it immediately,
+    # This is useful if you want to get access to the current metric store without
+    # waiting for a periodic call.
+    # 
+    # @return [LogStash::Instrument::MetricStore]
+    def snapshot_metric
+      Snapshot.new(@metric_store)
     end
 
-    def snapshot
-      # TODO: We currently sent delta to the observers.
-      # Should we keep the whole picture and send the updated state instead?
-      if roll_over? && @snapshot_rotation_mutex.try_lock 
-        # fair rotation of the snapshot done by the winning thread
-        # metric could be written in the previous snapshot.
-        # Since the snapshot isn't written right away
-        # the view of the snapshot should be consistent at the time of
-        # writing, if we don't receive any events for 5 secs we wont send it.
-        # This might be a problem, for time correlation.
-        logger.debug("Collector: Rotating snapshot", :last_rotation => @last_rotation) if logger.debug?
-
-        publish_snapshot
-        rotate_snapshot
-
-        @snapshot_rotation_mutex.unlock
-      end
-
-      @current_snapshot
-    end
-
-    def rotate_snapshot
-      @current_snapshot = Snapshot.new
-      update_last_rotation
+    # Configure and start the periodic task for snapshotting the `MetricStore`
+    def start_periodic_snapshotting
+      @snapshot_task = Concurrent::TimerTask.new { publish_snapshot }
+      @snapshot_task.execution_interval = SNAPSHOT_ROTATION_TIME_SECS
+      @snapshot_task.timeout_interval = SNAPSHOT_ROTATION_TIMEOUT_INTERVAL_SECS
+      @snapshot_task.add_observer(self)
+      @snapshot_task.execute
     end
 
+    # Create a snapshot of the MetricStore and send it to to the registered observers
+    # The observer will receive the following signature in the update methode.
+    #
+    # `#update(created_at, metric_store)`
     def publish_snapshot
-      changed
-      notify_observers(Concurrent.monotonic_time, @current_snapshot) 
-    end
-
-    def update_last_rotation
-      @last_rotation = Concurrent.monotonic_time
+      created_at = Time.now
+      logger.debug("Collector: Sending snapshot to observers", :created_at => created_at) if logger.debug?
+      notify_observers(snapshot_metric)
     end
   end
 end; end
diff --git a/logstash-core/lib/logstash/instrument/metric.rb b/logstash-core/lib/logstash/instrument/metric.rb
index 6090f79f192..b51007c5440 100644
--- a/logstash-core/lib/logstash/instrument/metric.rb
+++ b/logstash-core/lib/logstash/instrument/metric.rb
@@ -4,40 +4,42 @@
 require "concurrent"
 
 module LogStash module Instrument
-  class MetricNoKeyProvided < Exception; end
-  class MetricNoBlockProvided < Exception; end
+  class MetricException < Exception; end
+  class MetricNoKeyProvided < MetricException; end
+  class MetricNoBlockProvided < MetricException; end
+  class MetricNoNamespaceProvided < MetricException; end
 
   class Metric
-    attr_reader :collector, :base_key
+    attr_reader :collector, :namespace_information
 
-    def initialize(collector, base_key = nil)
+    public
+    def initialize(collector, namespace = nil)
       @collector = collector
-      @base_key = base_key
+      @namespace_information = Array(namespace).map(&:to_sym)
     end
 
     def increment(key, value = 1)
-      collector.push(:counter, merge_keys(key), :increment, Concurrent.monotonic_time, value)
+      validate_key!(key)
+      collector.push(namespace_information, key, :counter, :increment, value)
     end
 
     def decrement(key, value = 1)
-      collector.push(:counter, merge_keys(key), :decrement, Concurrent.monotonic_time, value)
+      validate_key!(key)
+      collector.push(namespace_information, key, :counter, :decrement, value)
     end
 
     # might be worth to create a block interface for time based gauge
     def gauge(key, value)
-      collector.push(:gauge, merge_keys(key), Concurrent.monotonic_time, value)
+      validate_key!(key)
+      collector.push(namespace_information, key, :gauge, value)
     end
 
-    def namespace(key)
-      Metric.new(collector, merge_keys(key.to_sym))
-    end
-
-    # I think this should have his own values.
     def time(key, &block)
+      validate_key!(key)
       if block_given?
-        start_time = Concurrent.monotonic_time
+        start_time = Time.now
         content = block.call
-        duration = Concurrent.monotonic_time - start_time
+        duration = Time.now - start_time
         gauge(key, duration)
         return content
       else
@@ -45,20 +47,23 @@ def time(key, &block)
       end
     end
 
-    # TODO
-    def self.create(name, collector = LogStash::Instrument::Collector.instance)
+    def namespace(sub_namespace)
+      raise MetricNoNamespaceProvided if sub_namespace.nil? || sub_namespace.empty?
+
+      new_namespace = namespace_information.clone
+      new_namespace << sub_namespace
+
+      Metric.new(collector, new_namespace)
+    end
+
+    def self.create(namespace, collector = LogStash::Instrument::Collector.instance)
       reporter = LogStash::Instrument::Reporter::Stdout.new(collector)
-      Metric.new(collector, name)
+      Metric.new(collector, namespace)
     end
 
     private
-    def merge_keys(key)
-      valid_key!(key)
-      [@base_key, key.to_sym]
-    end
-    
-    def valid_key!(key)
-      raise MetricNoKeyProvided if key.nil? || key == ""
+    def validate_key!(key)
+      raise MetricNoKeyProvided if key.nil? || key.empty?
     end
   end
 end; end
diff --git a/logstash-core/lib/logstash/instrument/metric_store.rb b/logstash-core/lib/logstash/instrument/metric_store.rb
new file mode 100644
index 00000000000..2023993cba6
--- /dev/null
+++ b/logstash-core/lib/logstash/instrument/metric_store.rb
@@ -0,0 +1,110 @@
+# encoding: utf-8
+require "concurrent"
+require "logstash/event"
+require "logstash/instrument/metric_type"
+
+module LogStash module Instrument
+  # The Metric store the data structure that make sure the data is
+  # saved in a retrievable way, this is a wrapper around multiples ConcurrentHashMap
+  # acting as a tree like structure.
+  class MetricStore
+    class NamespacesExpectedError < Exception; end
+
+    def initialize
+      @store = Concurrent::Map.new
+    end
+
+    # This method use the namespace and key to search the corresponding value of
+    # the hash, if it doesn't exist it will create the appropriate namespaces
+    # path in the hash and return `new_value`
+    #
+    # @param [Array] The path where the values should be located
+    # @param [Object] The default object if the value is not found in the path
+    # @return [Object] Return the new_value of the retrieve object in the tree
+    def fetch_or_store(namespaces, key, default_value = nil)
+      fetch_or_store_namespaces(namespaces).fetch_or_store(key, block_given? ? yield(key) : default_value)
+    end
+    
+    # This method allow to retrieve values for a specific path,
+    #
+    #
+    # @param [Array] The path where values should be located
+    # @return nil if the values are not found
+    def get(*key_paths)
+      get_recursively(key_paths, @store)
+    end
+
+    # Take all the individuals `MetricType` and convert them to `Logstash::Event`
+    #
+    # @return [Array] An array of all metric transformed in `Logstash::Event`
+    def to_events
+      to_events_recursively(@store).flatten
+    end
+
+    private
+    def get_recursively(key_paths, map)
+      key_candidate = key_paths.shift
+
+      if key_paths.empty?
+        return map[key_candidate]
+      else 
+        next_map = map[key_candidate]
+
+        if next_map.is_a?(Concurrent::Map)
+          return get_recursively(key_paths, next_map)
+        else
+          return nil
+        end
+      end
+    end
+
+    def to_events_recursively(values)
+      events = []
+      values.each_value do |value|
+        if value.is_a?(Concurrent::Map)
+          events << to_events_recursively(value) 
+        else
+          events << value.to_event
+        end
+      end
+      return events
+    end
+
+    # This method iterate through the namespace path and try to find the corresponding 
+    # value for the path, if the any part of the path is not found it will 
+    # create it.
+    #
+    # @param [Array] The path where values should be located
+    # @raise [ConcurrentMapExpected] Raise if the retrieved object isn't a `Concurrent::Map`
+    # @return [Concurrent::Map] Map where the metrics should be saved
+    def fetch_or_store_namespaces(namespaces_path)
+      path_map = fetch_or_store_namespace_recursively(@store, namespaces_path)
+      
+      # This mean one of the namespace and key are colliding
+      # and we have to deal it upstream.
+      unless path_map.is_a?(Concurrent::Map)
+        raise NamespacesExpectedError, "Expecting a `Namespaces` but found class:  #{path_map.class.name} for namespaces_path: #{namespaces_path}"
+      end
+
+      return path_map
+    end
+
+    # Recursively fetch or create the namespace paths through the `MetricStove`
+    # This algorithm use an index to known which keys to search in the map.
+    # This doesn't cloning the array if we want to give a better feedback to the user
+    #
+    # @param [Concurrent::Map] Map to search for the key
+    # @param [Array] List of path to create
+    # @param [Fixnum] Which part from the list to create
+    #
+    def fetch_or_store_namespace_recursively(map, namespaces_path, idx = 0)
+      current = namespaces_path[idx]
+      
+      # we are at the end of the namespace path, break out of the recursion
+      return map if current.nil?
+
+      new_map = map.fetch_or_store(current) { Concurrent::Map.new }
+      return fetch_or_store_namespace_recursively(new_map, namespaces_path, idx + 1)
+    end
+  end
+end; end
diff --git a/logstash-core/lib/logstash/instrument/metric_type.rb b/logstash-core/lib/logstash/instrument/metric_type.rb
new file mode 100644
index 00000000000..e26799b51a9
--- /dev/null
+++ b/logstash-core/lib/logstash/instrument/metric_type.rb
@@ -0,0 +1,22 @@
+# encoding: utf-8
+require "logstash/instrument/metric_type/counter"
+require "logstash/instrument/metric_type/mean"
+
+module LogStash module Instrument
+  module MetricType
+    METRIC_TYPE_LIST = {
+      :counter => LogStash::Instrument::MetricType::Counter,
+      :mean => LogStash::Instrument::MetricType::Mean
+    }.freeze
+
+    # Use the string to generate a concrete class for this metrics
+    # 
+    # @param [String] The name of the class
+    # @param [Array] Namespaces list
+    # @param [String] The metric key
+    # @raise [NameError] If the class is not found
+    def self.create(type, namespaces, key)
+      METRIC_TYPE_LIST[type].new(namespaces, key)
+    end
+  end
+end; end
diff --git a/logstash-core/lib/logstash/instrument/metric_type/base.rb b/logstash-core/lib/logstash/instrument/metric_type/base.rb
new file mode 100644
index 00000000000..ea868332bb9
--- /dev/null
+++ b/logstash-core/lib/logstash/instrument/metric_type/base.rb
@@ -0,0 +1,17 @@
+# encoding: utf-8
+require "logstash/instrument/metric_type/counter"
+require "logstash/util"
+
+module LogStash module Instrument module MetricType
+  class Base
+    def initialize(namespaces, key)
+      @namespaces = namespaces
+      @key = key
+    end
+
+    private
+    def type
+      @type ||= LogStash::Util.class_name(self).downcase
+    end
+  end
+end; end; end
diff --git a/logstash-core/lib/logstash/instrument/metric_type/counter.rb b/logstash-core/lib/logstash/instrument/metric_type/counter.rb
index 64cf4940bb3..19fc6663b63 100644
--- a/logstash-core/lib/logstash/instrument/metric_type/counter.rb
+++ b/logstash-core/lib/logstash/instrument/metric_type/counter.rb
@@ -1,11 +1,13 @@
 # encoding: utf-8
+require "logstash/instrument/metric_type/base"
 require "concurrent"
+
 module LogStash module Instrument module MetricType
-  class Counter
-    attr_reader :key
-    def initialize(key, value = 0)
-      @key = key
+  class Counter < Base
+    def initialize(namespaces, key, value = 0)
+      super(namespaces, key)
 
+      # TODO
       # This should be a `LongAdder`,
       # will have to create a rubyext for it and support jdk7
       # look at the elasticsearch source code.
@@ -22,12 +24,29 @@ def decrement(value = 1)
       @counter.decrement(value)
     end
 
-    def execute(type, key, action, time, value)
+    def execute(action, value = 1)
       @counter.send(action, value)
     end
 
+    def value
+      @counter.value
+    end
+
+    def to_hash
+      { 
+        "namespaces" => @namespaces,
+        "key" => @key,
+        "type" => type,
+        "value" => value 
+      }
+    end
+    
+    def to_event(created_at = Time.now)
+      LogStash::Event.new(to_hash.merge({ "@timestamp" => created_at }))
+    end
+
     def inspect
-      "#{self.class.name} - key: #{key} value: #{@counter.value}"
+      "#{self.class.name} - namespaces: #{namespaces} key: #{@key} value: #{value}"
     end
   end
 end; end; end
diff --git a/logstash-core/lib/logstash/instrument/metric_type/mean.rb b/logstash-core/lib/logstash/instrument/metric_type/mean.rb
new file mode 100644
index 00000000000..f465fddd00b
--- /dev/null
+++ b/logstash-core/lib/logstash/instrument/metric_type/mean.rb
@@ -0,0 +1,41 @@
+# encoding: utf-8
+require "logstash/instrument/metric_type/base"
+require "concurrent"
+
+module LogStash module Instrument module MetricType
+  class Mean < LogStash::Instrument::MetricType::Base
+    def initialize(namespaces, key)
+      super(namespaces, key)
+
+      @counter = Concurrent::AtomicFixnum.new
+      @sum = Concurrent::AtomicFixnum.new
+    end
+
+    def increment(value = 1)
+      @counter.increment
+      @sum.increment(value = 1)
+    end
+
+    def decrement(value = 1)
+      @counter.decrement
+      @sum.decrement(value)
+    end
+
+    def mean
+      @sum.value / @counter.value
+    end
+
+    def to_hash
+      { 
+        "namespaces" => @namespaces,
+        "key" => @key,
+        "type" => type,
+        "value" => mean
+      }
+    end
+
+    def inspect
+      "#{self.class.name} - namespaces: #{@namespaces} key: #{@key} value: #{value}"
+    end
+  end
+end; end; end
diff --git a/logstash-core/lib/logstash/instrument/null_metric.rb b/logstash-core/lib/logstash/instrument/null_metric.rb
index e65511b4c32..7ec33cc4c14 100644
--- a/logstash-core/lib/logstash/instrument/null_metric.rb
+++ b/logstash-core/lib/logstash/instrument/null_metric.rb
@@ -1,7 +1,7 @@
 # encoding: utf-8
 module LogStash module Instrument
  class NullMetric
-   attr_reader :collector, :base_key
+   attr_reader :collector, :namespace_information
    def initialize
    end
 
diff --git a/logstash-core/lib/logstash/instrument/periodic_poller/abstract_poller.rb b/logstash-core/lib/logstash/instrument/periodic_poller/base.rb
similarity index 98%
rename from logstash-core/lib/logstash/instrument/periodic_poller/abstract_poller.rb
rename to logstash-core/lib/logstash/instrument/periodic_poller/base.rb
index af4de7f572a..32bfd931a9a 100644
--- a/logstash-core/lib/logstash/instrument/periodic_poller/abstract_poller.rb
+++ b/logstash-core/lib/logstash/instrument/periodic_poller/base.rb
@@ -4,7 +4,7 @@
 require "concurrent"
 
 module LogStash module Instrument module PeriodicPoller
-  class AbstractPoller
+  class Base
     include LogStash::Util::Loggable
 
     DEFAULT_OPTIONS = {
diff --git a/logstash-core/lib/logstash/instrument/periodic_poller/jvm.rb b/logstash-core/lib/logstash/instrument/periodic_poller/jvm.rb
index 344fc9d1e83..031b11b1033 100644
--- a/logstash-core/lib/logstash/instrument/periodic_poller/jvm.rb
+++ b/logstash-core/lib/logstash/instrument/periodic_poller/jvm.rb
@@ -1,8 +1,8 @@
 # encoding: utf-8
-require "logstash/instrument/periodic_poller/abstract_poller"
+require "logstash/instrument/periodic_poller/base"
 
 module LogStash module Instrument module PeriodicPoller
-  class JVM < AbstractPoller
+  class JVM < Base
     def initialize(metric, options = {})
       super(metric, options)
     end
diff --git a/logstash-core/lib/logstash/instrument/periodic_poller/os.rb b/logstash-core/lib/logstash/instrument/periodic_poller/os.rb
index 4a9f31a5c92..8ad09dfc7d7 100644
--- a/logstash-core/lib/logstash/instrument/periodic_poller/os.rb
+++ b/logstash-core/lib/logstash/instrument/periodic_poller/os.rb
@@ -1,8 +1,8 @@
 # encoding: utf-8
-require "logstash/instrument/periodic_poller/abstract_poller"
+require "logstash/instrument/periodic_poller/base"
 
 module LogStash module Instrument module PeriodicPoller
-  class Os < AbstractPoller
+  class Os < Base
     def initialize(metric, options = {})
       super(metric, options)
     end
diff --git a/logstash-core/lib/logstash/instrument/probe/os.rb b/logstash-core/lib/logstash/instrument/probe/os.rb
deleted file mode 100644
index 059bd03481f..00000000000
--- a/logstash-core/lib/logstash/instrument/probe/os.rb
+++ /dev/null
@@ -1,100 +0,0 @@
-# encoding: utf-8
-java_import "java.lang.management.ManagementFactory"
-java_import "java.lang.management.OperatingSystemMXBean"
-
-# Thin layer to handle the communication between ruby
-# and the Java Management api.
-module LogStash module Instrument module Probe
-  class Jvm
-  end
-
-  class Os
-    attr_reader :os_mxbean
-
-    def initialize
-      @os_mxbean = ManagementFactory.getOperatingSystemMXBean();
-    end
-
-    def available_processors
-    end
-
-    def arch
-    end
-
-    def system_load_average
-      load_average = os_mxbean.getSystemLoadAverage
-      return (load_average == -1) ? nil : load_average
-    end
-
-    def call(method)
-    end
-
-    ######################################
-    ######################################
-    ######################################
-    
-    def fs
-      Fs.new(os_mxbean)
-    end
-
-    def memory
-      Memory.new(self)
-    end
-    
-    ######################################
-    ######################################
-    ######################################
-    # File handle, limit?
-    # File descriptor
-    class Fs
-      METHODS = %w(getFreePhysicalMemorySize
-      getTotalPhysicalMemorySize
-      getFreeSwapSpaceSize
-      getTotalSwapSpaceSize)
-
-      # Convert from a CamelCase method to an underscore version
-      def self.underscore(str)
-        str.gsub!(/^get/, '')
-        str.gsub!(/([A-Z\d]+)([A-Z][a-z])/,'\1_\2')
-        str.gsub!(/([a-z\d])([A-Z])/,'\1_\2')
-        str.tr!("-", "_")
-        str.downcase!
-        puts str
-        str
-      end
-
-      METHODS.each do |method|
-        define_method underscore(method) do
-          call(method)
-        end
-      end
-
-      def initialize(os_mxbean)
-        @os_mxbean = os_mxbean
-      end
-
-      # We wrap all the methods call to the underlying MxBean, for
-      # two reasons:
-      #
-      # 1. Not all the methods are implemented by all the OS beans.
-      # 2. The Java Security manager could block some of the call and raise and exception.
-      #
-      # I think for #2, JRuby doesn't currently support the security manager but things might
-      # change in the future.
-      def call(method)
-        if @os_mxbean.respond_to?(method)
-          result = @os_mxbean.send(method)
-          return result == -1 ? nil : result
-        end
-        return nil
-      rescue
-        return nil
-      end
-    end
-
-    class Memory
-      def initialize(os)
-      end
-    end
-  end
-end; end; end
diff --git a/logstash-core/lib/logstash/instrument/reporter/stdout.rb b/logstash-core/lib/logstash/instrument/reporter/stdout.rb
index 168f77c96f1..22a2457034f 100644
--- a/logstash-core/lib/logstash/instrument/reporter/stdout.rb
+++ b/logstash-core/lib/logstash/instrument/reporter/stdout.rb
@@ -9,8 +9,8 @@ def initialize(collector)
       collector.add_observer(self)
     end
 
-    def update(time, snapshot)
-      logger.error("Reporter Stdout", :time => time, :snapshot_size => snapshot.size, :snapshot => snapshot.inspect)
+    def update(snapshot)
+      logger.error("Reporter Stdout", :time => snapshot.created_at, :snapshot => snapshot.inspect)
     end
   end
 end; end; end
diff --git a/logstash-core/lib/logstash/instrument/snapshot.rb b/logstash-core/lib/logstash/instrument/snapshot.rb
index 45de3fbd8e1..f46068439ad 100644
--- a/logstash-core/lib/logstash/instrument/snapshot.rb
+++ b/logstash-core/lib/logstash/instrument/snapshot.rb
@@ -1,42 +1,16 @@
 # encoding: utf-8
-require "logstash/instrument/metric_type/counter"
 require "logstash/util/loggable"
 require "logstash/event"
 
 module LogStash module Instrument
   class Snapshot
     include LogStash::Util::Loggable
-   
-    def initialize
-      # The Map doesn't respect the order of insertion
-      # we have to track the time another way
-      @metrics = Concurrent::Map.new
-    end
-
-    def push(*args)
-      type, key, _ = args
-      metric = @metrics.fetch_or_store(key, concrete_class(type, key))
-      metric.execute(*args)
-    end
-
-    def concrete_class(type, key)
-      # TODO, benchmark, I think this is faster than using constantize
-      case type
-      when :counter then MetricType::Counter.new(key)
-      end
-    end
-
-    def size
-      @metrics.size
-    end
 
-    def to_event
-      LogStash::Event.new({ "message" => "HELLO MEtrics",
-                            "size" => @metrics.size })
-    end
+    attr_reader :metric_store, :created_at
 
-    def inspect
-      "#{self.class.name} - metrics: #{@metrics.values.map(&:inspect)}"
+    def initialize(metric_store, created_at = Time.now)
+      @metric_store = metric_store
+      @created_at = created_at
     end
   end
 end; end
diff --git a/logstash-core/lib/logstash/util.rb b/logstash-core/lib/logstash/util.rb
index d3c5fe6ff41..9f07384c189 100644
--- a/logstash-core/lib/logstash/util.rb
+++ b/logstash-core/lib/logstash/util.rb
@@ -183,4 +183,13 @@ def self.stringify_symbols(o)
       o
     end
   end
+
+  # Take a instance reference and return the name of the class
+  # stripping all the modules.
+  #
+  # @param [Object] The object to return the class)
+  # @return [String] The name of the class
+  def self.class_name(instance)
+    instance.class.name.split("::").last
+  end
 end # module LogStash::Util
diff --git a/logstash-core/spec/logstash/inputs/metrics_spec.rb b/logstash-core/spec/logstash/inputs/metrics_spec.rb
new file mode 100644
index 00000000000..5e2f1607878
--- /dev/null
+++ b/logstash-core/spec/logstash/inputs/metrics_spec.rb
@@ -0,0 +1,32 @@
+# encoding: utf-8
+require "logstash/inputs/metrics"
+require "spec_helper"
+
+describe LogStash::Inputs::Metrics do
+  let(:queue) { [] }
+
+  describe "#run" do
+    it "should register itself to the collector observer" do
+      expect(LogStash::Instrument::Collector.instance).to receive(:add_observer).with(subject)
+      t = Thread.new { subject.run(queue) }
+      sleep(0.1) # give a bit of time to the thread to start
+      subject.stop
+    end
+  end
+
+  describe "#stop" do
+    it "should remove itself from the the collector observer" do
+      expect(LogStash::Instrument::Collector.instance).to receive(:delete_observer).with(subject)
+      t = Thread.new { subject.run(queue) }
+      sleep(0.1) # give a bit of time to the thread to start
+      subject.stop
+    end
+
+    it "should unblock the input" do
+      t = Thread.new { subject.run(queue) }
+      sleep(0.1) # give a bit of time to the thread to start
+      subject.do_stop
+      wait_for { t.status }.to be_falsey
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/instrument/collector_spec.rb b/logstash-core/spec/logstash/instrument/collector_spec.rb
new file mode 100644
index 00000000000..b96be4a5ede
--- /dev/null
+++ b/logstash-core/spec/logstash/instrument/collector_spec.rb
@@ -0,0 +1,49 @@
+# encoding: utf-8
+require "logstash/instrument/collector"
+require "spec_helper"
+
+describe LogStash::Instrument::Collector do
+  subject { LogStash::Instrument::Collector.instance }
+  describe "#push" do
+    let(:namespaces_path) { [:root, :pipelines, :pipelines01] }
+    let(:key) { :my_key }
+
+    context "when the `MetricType` exist" do
+      it "store the metric of type `counter`" do
+        subject.push(namespaces_path, key, :counter, :increment)
+      end
+    end
+
+    context "when the `MetricType` doesn't exist" do
+      let(:wrong_type) { :donotexist }
+
+      it "logs an error but dont crash" do
+        expect(subject.logger).to receive(:error)
+          .with("Collector: Cannot create concrete class for this metric type",
+        hash_including({ :type => wrong_type, :namespaces_path => namespaces_path }))
+
+          subject.push(namespaces_path, key, wrong_type, :increment)
+      end
+    end
+
+    context "when there is a conflict with the metric key" do
+      let(:conflicting_namespaces) { [namespaces_path, key].flatten }
+
+      it "logs an error but dont crash" do
+        subject.push(namespaces_path, key, :counter, :increment)
+
+        expect(subject.logger).to receive(:error)
+          .with("Collector: Cannot record metric",
+          hash_including({ :exception => instance_of(LogStash::Instrument::MetricStore::NamespacesExpectedError) }))
+
+          subject.push(conflicting_namespaces, :random_key, :counter, :increment)
+      end
+    end
+  end
+
+  describe "#snapshot_metric" do
+    it "return a `LogStash::Instrument::MetricStore`" do
+      expect(subject.snapshot_metric).to be_kind_of(LogStash::Instrument::Snapshot)
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/instrument/metric_spec.rb b/logstash-core/spec/logstash/instrument/metric_spec.rb
index 266caae5eba..0013152a66b 100644
--- a/logstash-core/spec/logstash/instrument/metric_spec.rb
+++ b/logstash-core/spec/logstash/instrument/metric_spec.rb
@@ -3,21 +3,21 @@
 require "logstash/instrument/collector"
 require "spec_helper"
 
-xdescribe LogStash::Instrument::Metric do
+describe LogStash::Instrument::Metric do
   let(:collector) { [] }
-  let(:base_key) { :root }
+  let(:namespace) { :root }
 
-  subject { LogStash::Instrument::Metric.new(collector, base_key) }
+  subject { LogStash::Instrument::Metric.new(collector, namespace) }
 
   context "#increment" do
     it "a counter by 1" do
       metric = subject.increment(:error_rate)
-      expect(collector.pop).to be_a_metric_event(:counter_increment, [:root, :error_rate], 1)
+      expect(collector).to be_a_metric_event([:root, :error_rate], :counter, :increment, 1)
     end
 
     it "a counter by a provided value" do
       metric = subject.increment(:error_rate, 20)
-      expect(metric.pop).to be_a_metric_event(:counter_increment, [:root, :error_rate], 20)
+      expect(collector).to be_a_metric_event([:root, :error_rate], :counter, :increment, 20)
     end
 
     it "raises an exception if the key is an empty string" do
@@ -32,12 +32,12 @@
   context "#decrement" do
     it "a counter by 1" do
       metric = subject.decrement(:error_rate)
-      expect(collector.pop).to be_a_metric_event(:counter_decrement, [:root, :error_rate], 1)
+      expect(collector).to be_a_metric_event([:root, :error_rate], :counter, :decrement, 1)
     end
 
     it "a counter by a provided value" do
       metric = subject.decrement(:error_rate, 20)
-      expect(metric.pop).to be_a_metric_event(:counter_decrement, [:root, :error_rate], 20)
+      expect(collector).to be_a_metric_event([:root, :error_rate], :counter, :decrement, 20)
     end
 
     it "raises an exception if the key is an empty string" do
@@ -52,7 +52,7 @@
   context "#gauge" do
     it "set the value of a key" do
       metric = subject.gauge(:size_queue, 20)
-      expect(metric.pop).to be_a_metric_event(:gauge, [:root, :size_queue], 20)
+      expect(collector).to be_a_metric_event([:root, :size_queue], :gauge, 20)
     end
 
     it "raises an exception if the key is an empty string" do
@@ -68,7 +68,7 @@
     let(:sub_key) { :my_sub_key }
 
     it "creates a new metric object and append the `sub_key` to the `base_key`" do
-      expect(subject.namespace(sub_key).base_key).to eq([base_key, sub_key])
+      expect(subject.namespace(sub_key).namespace_information).to eq([namespace, sub_key])
     end
 
     it "uses the same collector as the creator class" do
diff --git a/logstash-core/spec/logstash/instrument/metric_store_spec.rb b/logstash-core/spec/logstash/instrument/metric_store_spec.rb
new file mode 100644
index 00000000000..1f48eb7a6b8
--- /dev/null
+++ b/logstash-core/spec/logstash/instrument/metric_store_spec.rb
@@ -0,0 +1,94 @@
+# encoding: utf-8
+require "logstash/instrument/metric_store"
+require "logstash/instrument/metric_type/base"
+
+describe LogStash::Instrument::MetricStore do
+  let(:namespaces) { [ :root, :pipelines, :pipeline_01 ] } 
+  let(:key) { :events_in }
+  let(:counter) { LogStash::Instrument::MetricType::Counter.new(namespaces, key) }
+
+  context "when the metric object doesn't exist" do
+    it "store the object" do
+      expect(subject.fetch_or_store(namespaces, key, counter)).to eq(counter)
+    end
+
+    it "support a block as argument" do
+      expect(subject.fetch_or_store(namespaces, key) { counter }).to eq(counter)
+    end
+  end
+
+  context "when the metric object exist in the namespace"  do
+    let(:new_counter) { LogStash::Instrument::MetricType::Counter.new(namespaces, key) }
+
+    it "return the object" do
+      subject.fetch_or_store(namespaces, key, counter)
+      expect(subject.fetch_or_store(namespaces, key, new_counter)).to eq(counter)
+    end
+  end
+
+  context "when the namespace end node isn't a map" do
+    let(:conflicting_namespaces) { [:root, :pipelines, :pipeline_01, :events_in] }
+
+    it "raise an exception" do
+      subject.fetch_or_store(namespaces, key, counter)
+      expect { subject.fetch_or_store(conflicting_namespaces, :new_key, counter) }.to raise_error(LogStash::Instrument::MetricStore::NamespacesExpectedError)
+    end
+  end
+
+  describe "#get" do
+    let(:metric_events) {
+      [
+        [[:node, :sashimi, :pipelines, :pipeline01, :plugins, :"logstash-output-elasticsearch"], :event_in, :increment],
+        [[:node, :sashimi, :pipelines, :pipeline01], :processed_events_in, :increment],
+        [[:node, :sashimi, :pipelines, :pipeline01], :processed_events_out, :increment],
+      ]
+    }
+
+    before :each do
+      # Lets add a few metrics in the store before trying to find them
+      metric_events.each do |namespaces, metric_key, action|
+        metric = subject.fetch_or_store(namespaces, metric_key, LogStash::Instrument::MetricType::Counter.new(namespaces, key))
+        metric.execute(action)
+      end
+    end
+
+    it "retrieves end of of a branch" do
+      metrics = subject.get(:node, :sashimi, :pipelines, :pipeline01, :plugins, :"logstash-output-elasticsearch")
+      expect(metrics).to be_kind_of(Concurrent::Map)
+    end
+
+    it "retrieves branch" do
+      metrics = subject.get(:node, :sashimi, :pipelines, :pipeline01)
+      expect(metrics).to be_kind_of(Concurrent::Map)
+    end
+
+    it "allow to retrieve a specific metrics" do
+      metrics = subject.get(:node, :sashimi, :pipelines, :pipeline01, :plugins, :"logstash-output-elasticsearch", :event_in)
+      expect(metrics).to be_kind_of(LogStash::Instrument::MetricType::Base)
+    end
+  end
+
+  describe "#to_event" do
+    let(:metric_events) {
+      [
+        [[:node, :sashimi, :pipelines, :pipeline01, :plugins, :"logstash-output-elasticsearch"], :event_in, :increment],
+        [[:node, :sashimi, :pipelines, :pipeline01], :processed_events, :increment],
+      ]
+    }
+
+    before do
+      # Lets add a few metrics in the store before trying to convert them
+      metric_events.each do |namespaces, metric_key, action|
+        metric = subject.fetch_or_store(namespaces, metric_key, LogStash::Instrument::MetricType::Counter.new(namespaces, key))
+        metric.execute(action)
+      end
+    end
+
+    it "converts all metric to `Logstash::Event`" do
+      events = subject.to_events
+      events.each do |event|
+        expect(event).to be_kind_of(LogStash::Event)
+      end
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb b/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb
new file mode 100644
index 00000000000..30e08ac8651
--- /dev/null
+++ b/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb
@@ -0,0 +1,31 @@
+# encoding: utf-8
+require "logstash/instrument/metric_type/counter"
+require "spec_helper"
+
+describe LogStash::Instrument::MetricType::Counter do
+  let(:namespaces) { [:root, :pipelines, :pipeline_01] }
+  let(:key) { :mykey }
+
+  subject { LogStash::Instrument::MetricType::Counter.new(namespaces, key) }
+
+  describe "#increment" do
+    it "increment the counter" do
+      expect{ subject.increment }.to change { subject.value }.by(1)
+    end
+  end
+
+  describe "#decrement" do
+    it "decrement the counter" do
+      expect{ subject.decrement }.to change { subject.value }.by(-1)
+    end
+  end
+
+  describe "#to_hash" do
+    it "return the details of the counter" do
+      expect(subject.to_hash).to include({ "namespaces" => namespaces,
+                                           "key" => key,
+                                           "value" => 0,
+                                           "type" => "counter" })
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/output_delegator_spec.rb b/logstash-core/spec/logstash/output_delegator_spec.rb
index f938611d2d7..77d8f8166c8 100644
--- a/logstash-core/spec/logstash/output_delegator_spec.rb
+++ b/logstash-core/spec/logstash/output_delegator_spec.rb
@@ -1,8 +1,6 @@
 # encoding: utf-8
 require "logstash/output_delegator"
 require 'spec_helper'
-
-
 describe LogStash::OutputDelegator do
   let(:logger) { double("logger") }
   let(:out_klass) { double("output klass") }
diff --git a/logstash-core/spec/logstash/util_spec.rb b/logstash-core/spec/logstash/util_spec.rb
index 82e75092675..04007a284f3 100644
--- a/logstash-core/spec/logstash/util_spec.rb
+++ b/logstash-core/spec/logstash/util_spec.rb
@@ -3,7 +3,17 @@
 
 require "logstash/util"
 
+
+class ClassNameTest
+end
+
+module TestingClassName
+  class TestKlass
+  end
+end
+
 describe LogStash::Util do
+  subject { described_class }
 
   context "stringify_keys" do
     it "should convert hash symbol keys to strings" do
@@ -32,4 +42,22 @@
       expect(LogStash::Util.stringify_symbols([:a, [1, :b]])).to eq(["a", [1, "b"]])
     end
   end
+
+  describe ".class_name" do
+    context "when the class is a top level class" do
+      let(:klass) { ClassNameTest.new }
+
+      it "returns the name of the class" do
+        expect(subject.class_name(klass)).to eq("ClassNameTest")
+      end
+    end
+
+    context "when the class is nested inside modules" do
+      let(:klass) { TestingClassName::TestKlass.new }
+
+      it "returns the name of the class" do
+        expect(subject.class_name(klass)).to eq("TestKlass")
+      end
+    end
+  end
 end
diff --git a/logstash-core/spec/support/matchers.rb b/logstash-core/spec/support/matchers.rb
index 31540efa28b..263ac7b3a43 100644
--- a/logstash-core/spec/support/matchers.rb
+++ b/logstash-core/spec/support/matchers.rb
@@ -2,15 +2,15 @@
 require "rspec"
 require "rspec/expectations"
 
-RSpec::Matchers.define :be_a_metric_event do |type, key, value|
+RSpec::Matchers.define :be_a_metric_event do |namespace, type, *args|
   match do
-    actual.first == type &&
-      actual[1].kind_of?(Time) &&
-      actual[2] == key &&
-      actual.last == value
+    namespace == actual[0] << actual[1] && 
+      type == actual[2] &&
+      args == actual[3..-1]
   end
 end
 
+# Match to test `NullObject` pattern
 RSpec::Matchers.define :implement_interface_of do |type, key, value|
   match do |actual|
     all_instance_methods_implemented?
