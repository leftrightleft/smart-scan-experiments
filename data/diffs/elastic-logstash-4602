diff --git a/logstash-core/lib/logstash/agent.rb b/logstash-core/lib/logstash/agent.rb
index 3a2cb779814..519f37c3298 100644
--- a/logstash-core/lib/logstash/agent.rb
+++ b/logstash-core/lib/logstash/agent.rb
@@ -22,7 +22,7 @@ class LogStash::Agent
 
   def initialize(options = {})
     @pipelines = {}
-     
+
     @node_name = options[:node_name] || Socket.gethostname
     @collect_metric = options.fetch(:collect_metric, false)
     @logger = options[:logger]
@@ -59,7 +59,7 @@ def execute
 
   def add_pipeline(pipeline_id, config_str, settings = {})
     settings.merge!(:pipeline_id => pipeline_id,
-                    :metric => metric.namespace(pipeline_id))
+                    :metric => metric)
 
     @pipelines[pipeline_id] = LogStash::Pipeline.new(config_str, settings)
   end
@@ -69,7 +69,7 @@ def node_uuid
   end
 
   # Calculate the Logstash uptime in milliseconds
-  # 
+  #
   # @return [Fixnum] Uptime in milliseconds
   def uptime
     ((Time.now.to_f - started_at.to_f) * 1000.0).to_i
@@ -92,7 +92,7 @@ def stop_webserver
   def start_background_services
     if collect_metric?
       @logger.debug("Agent: Starting metric periodic pollers")
-      @periodic_pollers.start 
+      @periodic_pollers.start
     end
   end
 
@@ -106,7 +106,7 @@ def stop_background_services
   def configure_metric
     if collect_metric?
       @logger.debug("Agent: Configuring metric collection")
-      @metric = LogStash::Instrument::Metric.create(:root)
+      @metric = LogStash::Instrument::Metric.create
       add_metric_pipeline
     else
       @metric = LogStash::Instrument::NullMetric.new
@@ -131,7 +131,7 @@ def add_metric_pipeline
       }
       output {
         elasticsearch {
-          flush_size => 10
+          flush_size => 1
           hosts => "127.0.0.1"
           index => "metrics-%{+YYYY.MM.dd}"
         }
diff --git a/logstash-core/lib/logstash/filter_delegator.rb b/logstash-core/lib/logstash/filter_delegator.rb
index ab6c3afa0bd..ce2c71d6644 100644
--- a/logstash-core/lib/logstash/filter_delegator.rb
+++ b/logstash-core/lib/logstash/filter_delegator.rb
@@ -20,9 +20,12 @@ def initialize(logger, klass, metric, *args)
       @filter = klass.new(options)
 
       # Scope the metrics to the plugin
-      @metric = metric.namespace(@filter.id.to_sym)
-      @filter.metric = @metric
+      namespaced_metric = metric.namespace(@filter.id.to_sym)
+      @filter.metric = metric
 
+      @metric_events = namespaced_metric.namespace(:events)
+
+      # Not all the filters will do bufferings
       define_flush_method if @filter.respond_to?(:flush)
     end
 
@@ -31,18 +34,29 @@ def config_name
     end
 
     def multi_filter(events)
-      @metric.increment(:events_in, events.size)
+      @metric_events.increment(:in, events.size)
 
       new_events = @filter.multi_filter(events)
 
-      @metric.increment(:events_out, new_events.size)
+      # There is no garantee in the context of filter
+      # that EVENTS_INT == EVENTS_OUT, see the aggregates and
+      # the split filter
+      @metric_events.increment(:out, new_events.size) unless new_events.nil?
+
       return new_events
     end
 
     private
     def define_flush_method
       define_singleton_method(:flush) do |options = {}|
-        @filter.flush(options)
+        # we also need to trace the number of events
+        # coming from a specific filters.
+        new_events = @filter.flush(options)
+
+        # Filter plugins that does buffering or spooling of events like the
+        # `Logstash-filter-aggregates` can return `NIL` and will flush on the next flush ticks.
+        @metric_events.increment(:out, new_events.size) unless new_events.nil?
+        new_events
       end
     end
   end
diff --git a/logstash-core/lib/logstash/inputs/metrics.rb b/logstash-core/lib/logstash/inputs/metrics.rb
index 62c83497b9d..8a8ce92dcf0 100644
--- a/logstash-core/lib/logstash/inputs/metrics.rb
+++ b/logstash-core/lib/logstash/inputs/metrics.rb
@@ -11,6 +11,7 @@ module LogStash module Inputs
   # Elasticsearch
   class Metrics < LogStash::Inputs::Base
     config_name "metrics"
+    milestone 3
 
     def register
     end
@@ -35,16 +36,9 @@ def stop
     def update(snapshot)
       @logger.debug("Metrics input: received a new snapshot", :created_at => snapshot.created_at, :snapshot => snapshot, :event => snapshot.metric_store.to_event) if @logger.debug?
 
-      # TODO: (ph)
-      # - Obviously the format here is wrong and we need to
-      # transform it from Snapshot to an event
-      # - There is another problem, if the queue is full this could block the snapshot thread.
-      # There is a few possible solution for this problem:
-      #   - We can use a future
-      #   - We can use a synchronization mechanism between the called thread (update method)
-      #   and the plugin thread (run method)
-      #   - How we handle back pressure here?
-      #   - one snashot should be only one event ?
+      # The back pressure is handled in the collector's
+      # scheduled task (running into his own thread) if something append to one of the listener it will
+      # will timeout. In a sane pipeline, with a low traffic of events it shouldn't be a problems.
       snapshot.metric_store.each do |metric|
         @queue << LogStash::Event.new({ "@timestamp" => snapshot.created_at }.merge(metric.to_hash))
       end
diff --git a/logstash-core/lib/logstash/instrument/collector.rb b/logstash-core/lib/logstash/instrument/collector.rb
index 81b69cb5a3c..a27146b791a 100644
--- a/logstash-core/lib/logstash/instrument/collector.rb
+++ b/logstash-core/lib/logstash/instrument/collector.rb
@@ -19,7 +19,7 @@ class Collector
     include Observable
     include Singleton
 
-    SNAPSHOT_ROTATION_TIME_SECS = 10 # seconds
+    SNAPSHOT_ROTATION_TIME_SECS = 1 # seconds
     SNAPSHOT_ROTATION_TIMEOUT_INTERVAL_SECS = 10 * 60 # seconds
 
     def initialize
@@ -34,9 +34,9 @@ def initialize
     # its the job of the collector to update the store with new metric
     # of update the metric
     #
-    # If there is a problem with the key or the type of metric we will record an error 
+    # If there is a problem with the key or the type of metric we will record an error
     # but we wont stop processing events, theses errors are not considered fatal.
-    # 
+    #
     def push(namespaces_path, key, type, *metric_type_params)
       begin
         metric = @metric_store.fetch_or_store(namespaces_path, key) do
@@ -69,7 +69,7 @@ def push(namespaces_path, key, type, *metric_type_params)
     # @param [Exception] Exception
     def update(time_of_execution, result, exception)
       return true if exception.nil?
-      logger.error("Collector: Something went wrong went sending data to the observers", 
+      logger.error("Collector: Something went wrong went sending data to the observers",
                    :execution_time => time_of_execution,
                    :result => result,
                    :exception => exception)
@@ -78,7 +78,7 @@ def update(time_of_execution, result, exception)
     # Snapshot the current Metric Store and return it immediately,
     # This is useful if you want to get access to the current metric store without
     # waiting for a periodic call.
-    # 
+    #
     # @return [LogStash::Instrument::MetricStore]
     def snapshot_metric
       Snapshot.new(@metric_store)
diff --git a/logstash-core/lib/logstash/instrument/metric.rb b/logstash-core/lib/logstash/instrument/metric.rb
index 0877d9faf03..ace6061e8ce 100644
--- a/logstash-core/lib/logstash/instrument/metric.rb
+++ b/logstash-core/lib/logstash/instrument/metric.rb
@@ -8,87 +8,102 @@ class MetricNoKeyProvided < MetricException; end
   class MetricNoBlockProvided < MetricException; end
   class MetricNoNamespaceProvided < MetricException; end
 
+  # This class provide the interface between the code, the collector and the format
+  # of the recorded metric.
   class Metric
-    class TimedExecution
-      MILLISECONDS = 1_000_000.0.freeze
-
-      def initialize(metric, key)
-        @metric = metric
-        @key = key
-        start
-      end
-
-      def start
-        @start_time = current_time
-      end
-
-      def stop
-        @metric.report_time(@key, (MILLISECONDS * (current_time - @start_time)).to_i)
-      end
-
-      private
-      def current_time
-        Time.now
-      end
-    end
-
-    attr_reader :collector, :namespace_information
+    attr_reader :collector
 
-    public
-    def initialize(collector, namespace = nil)
+    def initialize(collector)
       @collector = collector
-      @namespace_information = Array(namespace).map(&:to_sym)
     end
 
-    def increment(key, value = 1)
+    def increment(namespace, key, value = 1)
       validate_key!(key)
-      collector.push(namespace_information, key, :counter, :increment, value)
+      collector.push(namespace, key, :counter, :increment, value)
     end
 
-    def decrement(key, value = 1)
+    def decrement(namespace, key, value = 1)
       validate_key!(key)
-      collector.push(namespace_information, key, :counter, :decrement, value)
+      collector.push(namespace, key, :counter, :decrement, value)
     end
 
-    # might be worth to create a block interface for time based gauge
-    def gauge(key, value)
+    def gauge(namespace, key, value)
       validate_key!(key)
-      collector.push(namespace_information, key, :gauge, :set, value)
+      collector.push(namespace, key, :gauge, :set, value)
     end
 
-    def time(key)
+    def time(namespace, key)
       validate_key!(key)
 
       if block_given?
-        timer = TimedExecution.new(self, key)
+        timer = TimedExecution.new(self, namespace, key)
         content = yield
         timer.stop
         return content
       else
-        TimedExecution.new(self, key)
+        TimedExecution.new(self, namespace, key)
       end
     end
 
-    def report_time(key, duration)
-      collector.push(namespace_information, key, :mean, :increment, duration)
+    def report_time(namespace, key, duration)
+      collector.push(namespace, key, :mean, :increment, duration)
     end
 
-    def namespace(sub_namespace)
-      raise MetricNoNamespaceProvided if sub_namespace.nil? || sub_namespace.empty?
-
-      new_namespace = namespace_information.clone
-      new_namespace << sub_namespace
-
-      Metric.new(collector, new_namespace)
+    # This method return a metric instance tied to a specific namespace
+    # so instead of specifying the namespace on every call.
+    #
+    # Example:
+    #   metric.increment(:namespace, :mykey, 200)
+    #   metric.increment(:namespace, :mykey_2, 200)
+    #
+    #   namespaced_metric = metric.namespace(:namespace)
+    #   namespaced_metric.increment(:mykey, 200)
+    #   namespaced_metric.increment(:mykey_2, 200)
+    # ```
+    #
+    # @param name [Array<String>] Name of the namespace
+    # @param name [String] Name of the namespace
+    def namespace(name)
+      raise MetricNoNamespaceProvided if name.nil? || name.empty?
+
+      NamespacedMetric.new(self, name)
     end
 
-    def self.create(namespace, collector = LogStash::Instrument::Collector.instance)
-      Metric.new(collector, namespace)
+    # Create a Metric instrance using the default Collector singleton reference
+    #
+    #
+    def self.create(collector = LogStash::Instrument::Collector.instance)
+      Metric.new(collector)
     end
 
     private
     def validate_key!(key)
       raise MetricNoKeyProvided if key.nil? || key.empty?
     end
+
+    # Allow to calculate the execution of a block of code.
+    # This class support 2 differents syntax a block or the return of
+    # the object itself, but in the later case the metric wont be recorded
+    # Until we call `#stop`.
+    #
+    # @see LogStash::Instrument::Metric#time
+    class TimedExecution
+      MILLISECONDS = 1_000_000.0.freeze
+
+      def initialize(metric, namespace, key)
+        @metric = metric
+        @namespace = namespace
+        @key = key
+        start
+      end
+
+      def start
+        @start_time = Time.now
+      end
+
+      def stop
+        @metric.report_time(@namespace, @key, (MILLISECONDS * (Time.now - @start_time)).to_i)
+      end
+    end
   end
 end; end
diff --git a/logstash-core/lib/logstash/instrument/metric_store.rb b/logstash-core/lib/logstash/instrument/metric_store.rb
index 332ad35c7f6..85371059408 100644
--- a/logstash-core/lib/logstash/instrument/metric_store.rb
+++ b/logstash-core/lib/logstash/instrument/metric_store.rb
@@ -8,7 +8,14 @@ module LogStash module Instrument
   # saved in a retrievable way, this is a wrapper around multiples ConcurrentHashMap
   # acting as a tree like structure.
   class MetricStore
-    class NamespacesExpectedError < Exception; end
+    class NamespacesExpectedError < StandardError; end
+    class MetricNotFound < StandardError; end
+
+    KEY_PATH_SEPARATOR = "/".freeze
+
+    # Lets me a bit flexible on the coma usage in the path
+    # definition
+    FILTER_KEYS_SEPARATOR = /\s?*,\s*/.freeze
 
     def initialize
       # We keep the structured cache to allow
@@ -28,49 +35,107 @@ def fetch_or_store(namespaces, key, default_value = nil)
     end
 
     # This method allow to retrieve values for a specific path,
+    # This method support the following queries
+    #
+    # stats/pipelines/pipeline_X
+    # stats/pipelines/pipeline_X,pipeline_2
+    # stats/os,jvm
     #
+    # If you use the `,` on a key the metric store will return the both values at that level
+    #
+    # The returned hash will keep the same structure as it had in the `Concurrent::Map`
+    # but will be a normal ruby hash. This will allow the api to easily seriliaze the content
+    # of the map
     #
     # @param [Array] The path where values should be located
     # @return nil if the values are not found
+    def get_with_path(path)
+      key_paths = path.gsub(/^#{KEY_PATH_SEPARATOR}+/, "").split(KEY_PATH_SEPARATOR)
+      get(*key_paths)
+    end
+
+    # Use an array of symbols instead of path
     def get(*key_paths)
-      get_recursively(key_paths, @store)
+      # Normalize the symbols access
+      key_paths.map(&:to_sym)
+      new_hash = Hash.new
+
+      get_recursively(key_paths, @store, new_hash)
+
+      new_hash
     end
 
-    # Return all the individuals Metric
-    #
-    # @return [Array] An array of all metric transformed in `Logstash::Event`, or in case of passing a block it yields
-    # the expected value as other Enumerable implementations.
-    def each(&block)
-      data = each_recursively(@store).flatten
-      if block_given?
-        data.each(&block)
+    # Return all the individuals Metric,
+    # This call mimic a Enum's each if a block is provided
+    def each(path = nil, &block)
+      metrics = if path.nil?
+        get_all
       else
-        return data
+        transform_to_array(get_with_path(path))
       end
+
+      block_given? ? metrics.each(&block) : metrics
     end
+    alias_method :all, :each
 
     private
-    def get_recursively(key_paths, map)
-      key_candidate = key_paths.shift
+    def get_all
+      each_recursively(@store).flatten
+    end
+
+    def get_recursively(key_paths, map, new_hash)
+      key_candidates = extract_filter_keys(key_paths.shift)
 
-      if key_paths.empty?
-        return map[key_candidate]
-      else 
-        next_map = map[key_candidate]
+      key_candidates.each do |key_candidate|
+        raise MetricNotFound, "For path: #{key_candidate}" if map[key_candidate].nil?
 
-        if next_map.is_a?(Concurrent::Map)
-          return get_recursively(key_paths, next_map)
+        if key_paths.empty? # End of the user requested path
+          if map[key_candidate].is_a?(Concurrent::Map)
+            new_hash[key_candidate] = transform_to_hash(map[key_candidate])
+          else
+            new_hash[key_candidate] = map[key_candidate]
+          end
         else
-          return nil
+          if map[key_candidate].is_a?(Concurrent::Map)
+            new_hash[key_candidate] = get_recursively(key_paths, map[key_candidate], {})
+          else
+            new_hash[key_candidate] = map[key_candidate]
+          end
         end
       end
+      return new_hash
     end
 
+    def extract_filter_keys(key)
+      key.to_s.strip.split(FILTER_KEYS_SEPARATOR).map(&:to_sym)
+    end
+
+    def transform_to_array(map)
+      map.values.collect do |value|
+        value.is_a?(Hash) ? transform_to_array(value) : value
+      end.flatten
+    end
+
+    def transform_to_hash(map, new_hash = Hash.new)
+      map.each_pair do |key, value|
+        if value.is_a?(Concurrent::Map)
+          new_hash[key] = {}
+          transform_to_hash(value, new_hash[key])
+        else
+          new_hash[key] = value
+        end
+      end
+
+      return new_hash
+    end
+
+    # Recursively fetch only the leaf node that should be an instance
+    # of the `MetricType`
     def each_recursively(values)
       events = []
       values.each_value do |value|
         if value.is_a?(Concurrent::Map)
-          events << each_recursively(value) 
+          events << each_recursively(value)
         else
           events << value
         end
@@ -78,8 +143,8 @@ def each_recursively(values)
       return events
     end
 
-    # This method iterate through the namespace path and try to find the corresponding 
-    # value for the path, if the any part of the path is not found it will 
+    # This method iterate through the namespace path and try to find the corresponding
+    # value for the path, if any part of the path is not found it will
     # create it.
     #
     # @param [Array] The path where values should be located
@@ -107,7 +172,7 @@ def fetch_or_store_namespaces(namespaces_path)
     #
     def fetch_or_store_namespace_recursively(map, namespaces_path, idx = 0)
       current = namespaces_path[idx]
-      
+
       # we are at the end of the namespace path, break out of the recursion
       return map if current.nil?
 
diff --git a/logstash-core/lib/logstash/instrument/metric_type.rb b/logstash-core/lib/logstash/instrument/metric_type.rb
index 6245bd157dd..127d43ce3b0 100644
--- a/logstash-core/lib/logstash/instrument/metric_type.rb
+++ b/logstash-core/lib/logstash/instrument/metric_type.rb
@@ -12,7 +12,7 @@ module MetricType
     }.freeze
 
     # Use the string to generate a concrete class for this metrics
-    # 
+    #
     # @param [String] The name of the class
     # @param [Array] Namespaces list
     # @param [String] The metric key
diff --git a/logstash-core/lib/logstash/instrument/metric_type/base.rb b/logstash-core/lib/logstash/instrument/metric_type/base.rb
index 2557a57f7ad..5711c3f83b6 100644
--- a/logstash-core/lib/logstash/instrument/metric_type/base.rb
+++ b/logstash-core/lib/logstash/instrument/metric_type/base.rb
@@ -1,24 +1,33 @@
 # encoding: utf-8
-require "logstash/instrument/metric_type/counter"
 require "logstash/event"
 require "logstash/util"
 
 module LogStash module Instrument module MetricType
   class Base
+    attr_reader :namespaces, :key
+
     def initialize(namespaces, key)
       @namespaces = namespaces
       @key = key
     end
 
-    def to_event(created_at = Time.now)
-      LogStash::Event.new(to_hash.merge({ "@timestamp" => created_at }))
+    def inspect
+      "#{self.class.name} - namespaces: #{namespaces} key: #{key} value: #{value}"
     end
 
-    def inspect
-      "#{self.class.name} - namespaces: #{@namespaces} key: #{@key} value: #{value}"
+    def to_hash
+      {
+        "namespaces" => namespaces,
+        "key" => key,
+        "type" => type,
+        "value" => value
+      }
+    end
+
+    def to_json_data
+      value
     end
 
-    protected
     def type
       @type ||= LogStash::Util.class_name(self).downcase
     end
diff --git a/logstash-core/lib/logstash/instrument/metric_type/counter.rb b/logstash-core/lib/logstash/instrument/metric_type/counter.rb
index a7f89f248d6..e99bca57939 100644
--- a/logstash-core/lib/logstash/instrument/metric_type/counter.rb
+++ b/logstash-core/lib/logstash/instrument/metric_type/counter.rb
@@ -25,14 +25,5 @@ def execute(action, value = 1)
     def value
       @counter.value
     end
-
-    def to_hash
-      { 
-        "namespaces" => @namespaces,
-        "key" => @key,
-        "type" => type,
-        "value" => value 
-      }
-    end
   end
 end; end; end
diff --git a/logstash-core/lib/logstash/instrument/metric_type/gauge.rb b/logstash-core/lib/logstash/instrument/metric_type/gauge.rb
index d913a079c3f..7981bc877a5 100644
--- a/logstash-core/lib/logstash/instrument/metric_type/gauge.rb
+++ b/logstash-core/lib/logstash/instrument/metric_type/gauge.rb
@@ -1,6 +1,7 @@
 # encoding: utf-8
 require "logstash/instrument/metric_type/base"
 require "concurrent/atomic_reference/mutex_atomic"
+require "logstash/json"
 
 module LogStash module Instrument module MetricType
   class Gauge < Base
@@ -17,14 +18,5 @@ def execute(action, value = nil)
     def value
       @gauge.get
     end
-
-    def to_hash
-      { 
-        "namespaces" => @namespaces,
-        "key" => @key,
-        "type" => type,
-        "value" => value 
-      }
-    end
   end
 end; end; end
diff --git a/logstash-core/lib/logstash/instrument/metric_type/mean.rb b/logstash-core/lib/logstash/instrument/metric_type/mean.rb
index 96e534bd68b..f2cf7c5bc46 100644
--- a/logstash-core/lib/logstash/instrument/metric_type/mean.rb
+++ b/logstash-core/lib/logstash/instrument/metric_type/mean.rb
@@ -22,20 +22,12 @@ def decrement(value = 1)
     end
 
     def mean
-      if @counter > 0 
+      if @counter > 0
         @sum.value / @counter.value
       else
         0
       end
     end
-
-    def to_hash
-      { 
-        "namespaces" => @namespaces,
-        "key" => @key,
-        "type" => type,
-        "value" => mean
-      }
-    end
+    alias_method :value, :mean
   end
 end; end; end
diff --git a/logstash-core/lib/logstash/instrument/namespaced_metric.rb b/logstash-core/lib/logstash/instrument/namespaced_metric.rb
new file mode 100644
index 00000000000..6b0ad020e60
--- /dev/null
+++ b/logstash-core/lib/logstash/instrument/namespaced_metric.rb
@@ -0,0 +1,54 @@
+# encoding: utf-8
+require "logstash/instrument/metric"
+
+module LogStash module Instrument
+  # This class acts a a proxy between the metric library and the user calls.
+  #
+  # This is the class that plugins authors will use to interact with the `MetricStore`
+  # It has the same public interface as `Metric` class but doesnt require to send
+  # the namespace on every call.
+  #
+  # @see Logstash::Instrument::Metric
+  class NamespacedMetric
+    attr_reader :namespace_name
+    # Create metric with a specific namespace
+    #
+    # @param metric [LogStash::Instrument::Metric] The metric instance to proxy
+    # @param namespace [Array] The namespace to use
+    def initialize(metric, namespace_name)
+      @metric = metric
+      @namespace_name = Array(namespace_name)
+    end
+
+    def increment(key, value = 1)
+      @metric.increment(namespace_name, key, value)
+    end
+
+    def decrement(namespace, key, value = 1)
+      @metric.decrement(namespace_name, key, value)
+    end
+
+    def gauge(key, value)
+      @metric.gauge(namespace_name, key, value)
+    end
+
+    def report_time(key, duration)
+      @metric.report_time(namespace_name, key, duration)
+    end
+
+    def time(key, &block)
+      @metric.time(namespace_name, key, &block)
+    end
+
+    def collector
+      @metric.collector
+    end
+
+    def namespace(name)
+      NamespacedMetric.new(metric, namespace_name.concat(Array(name)))
+    end
+
+    private
+    attr_reader :metric
+  end
+end; end
diff --git a/logstash-core/lib/logstash/instrument/null_metric.rb b/logstash-core/lib/logstash/instrument/null_metric.rb
index f842cc1a6cf..947b8a13ecf 100644
--- a/logstash-core/lib/logstash/instrument/null_metric.rb
+++ b/logstash-core/lib/logstash/instrument/null_metric.rb
@@ -2,42 +2,45 @@
 require "logstash/instrument/metric"
 
 module LogStash module Instrument
+ # This class is used in the context when we disable the metric collection
+ # for specific plugin to replace the `NamespacedMetric` class with this one
+ # which doesn't produce any metric to the collector.
  class NullMetric
-   class NullTimedExecution
-     def self.stop
-     end
-   end
-
-   # Allow to reuse the same variable when creating subnamespace
-   NULL_METRIC_INSTANCE = NullMetric.new
-
-   attr_reader :collector, :namespace_information
-   def initialize
-   end
+   attr_reader :namespace_name, :collector
 
    def increment(key, value = 1)
    end
 
-   def decrement(key, value = 1)
+   def decrement(namespace, key, value = 1)
    end
 
-   # might be worth to create a block interface for time based gauge
    def gauge(key, value)
    end
 
-   def namespace(key)
-     NULL_METRIC_INSTANCE
-   end
-
    def report_time(key, duration)
    end
 
+   # We have to manually redefine this method since it can return an
+   # object this object also has to be implemented as a NullObject
    def time(key)
      if block_given?
-       yield 
+       yield
      else
        NullTimedExecution
      end
    end
+
+   def namespace(key)
+      self.class.new
+   end
+
+   private
+   # Null implementation of the internal timer class
+   #
+   # @see LogStash::Instrument::TimedExecution`
+   class NullTimedExecution
+     def self.stop
+     end
+   end
  end
 end; end
diff --git a/logstash-core/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
index 60643de5c16..45d2dca1965 100644
--- a/logstash-core/lib/logstash/pipeline.rb
+++ b/logstash-core/lib/logstash/pipeline.rb
@@ -15,6 +15,7 @@
 require "logstash/util/wrapped_synchronous_queue"
 require "logstash/pipeline_reporter"
 require "logstash/instrument/metric"
+require "logstash/instrument/namespaced_metric"
 require "logstash/instrument/null_metric"
 require "logstash/instrument/collector"
 require "logstash/output_delegator"
@@ -54,11 +55,11 @@ def initialize(config_str, settings = {})
     @outputs = nil
 
     @worker_threads = []
-    
+
     # Metric object should be passed upstream, multiple pipeline share the same metric
     # and collector only the namespace will changes.
     # If no metric is given, we use a `NullMetric` for all internal calls.
-    # We also do this to make the changes backward compatible with previous testing of the 
+    # We also do this to make the changes backward compatible with previous testing of the
     # pipeline.
     #
     # This need to be configured before we evaluate the code to make
@@ -181,7 +182,7 @@ def start_workers
     begin
       start_inputs
       @outputs.each {|o| o.register }
-      @filters.each {|f| f.register}
+      @filters.each {|f| f.register }
 
       pipeline_workers = safe_pipeline_worker_count
       batch_size = @settings[:pipeline_batch_size]
@@ -211,17 +212,22 @@ def start_workers
   end
 
   # Main body of what a worker thread does
-  # Repeatedly takes batches off the queu, filters, then outputs them
+  # Repeatedly takes batches off the queue, filters, then outputs them
   def worker_loop(batch_size, batch_delay)
     running = true
 
+    namespace_events = metric.namespace([:stats, :events])
+    namespace_pipeline = metric.namespace([:stats, :pipelines, pipeline_id.to_s.to_sym, :events])
+
     while running
       # To understand the purpose behind this synchronize please read the body of take_batch
       input_batch, signal = @input_queue_pop_mutex.synchronize { take_batch(batch_size, batch_delay) }
       running = false if signal == LogStash::SHUTDOWN
 
       @events_consumed.increment(input_batch.size)
-      metric.increment(:events_in, input_batch.size)
+
+      namespace_events.increment(:in, input_batch.size)
+      namespace_pipeline.increment(:in, input_batch.size)
 
       filtered_batch = filter_batch(input_batch)
 
@@ -231,10 +237,15 @@ def worker_loop(batch_size, batch_delay)
       end
 
       @events_filtered.increment(filtered_batch.size)
-      metric.increment(:events_filtered, filtered_batch.size)
+
+      namespace_events.increment(:filtered, filtered_batch.size)
+      namespace_pipeline.increment(:filtered, filtered_batch.size)
 
       output_batch(filtered_batch)
 
+      namespace_events.increment(:out, filtered_batch.size)
+      namespace_pipeline.increment(:out, filtered_batch.size)
+
       inflight_batches_synchronize { set_current_thread_inflight_batch(nil) }
     end
   end
@@ -412,12 +423,14 @@ def shutdown_workers
   def plugin(plugin_type, name, *args)
     args << {} if args.empty?
 
+    pipeline_scoped_metric = metric.namespace([:stats, :pipelines, pipeline_id.to_s.to_sym, :plugins])
+
     klass = LogStash::Plugin.lookup(plugin_type, name)
 
     if plugin_type == "output"
-      LogStash::OutputDelegator.new(@logger, klass, default_output_workers, metric, *args)
+      LogStash::OutputDelegator.new(@logger, klass, default_output_workers, pipeline_scoped_metric.namespace(:outputs), *args)
     elsif plugin_type == "filter"
-      LogStash::FilterDelegator.new(@logger, klass, metric, *args)
+      LogStash::FilterDelegator.new(@logger, klass, pipeline_scoped_metric.namespace(:filters), *args)
     else
       klass.new(*args)
     end
@@ -467,7 +480,7 @@ def flush
   end
 
   # Calculate the uptime in milliseconds
-  # 
+  #
   # @return [Fixnum] Uptime in milliseconds, 0 if the pipeline is not started
   def uptime
     return 0 if started_at.nil?
diff --git a/logstash-core/lib/logstash/plugin.rb b/logstash-core/lib/logstash/plugin.rb
index de8634b6c2a..1e32056fcbc 100644
--- a/logstash-core/lib/logstash/plugin.rb
+++ b/logstash-core/lib/logstash/plugin.rb
@@ -92,7 +92,7 @@ def debug_info
   end
 
   def metric=(new_metric)
-    @metric = new_metric.namespace(@id)
+    @metric = new_metric
   end
 
   def metric
diff --git a/logstash-core/spec/logstash/instrument/metric_spec.rb b/logstash-core/spec/logstash/instrument/metric_spec.rb
index e025f71c17f..0a8a65d4338 100644
--- a/logstash-core/spec/logstash/instrument/metric_spec.rb
+++ b/logstash-core/spec/logstash/instrument/metric_spec.rb
@@ -8,87 +8,87 @@
   let(:collector) { [] }
   let(:namespace) { :root }
 
-  subject { LogStash::Instrument::Metric.new(collector, namespace) }
+  subject { LogStash::Instrument::Metric.new(collector) }
 
   context "#increment" do
     it "a counter by 1" do
-      metric = subject.increment(:error_rate)
+      metric = subject.increment(:root, :error_rate)
       expect(collector).to be_a_metric_event([:root, :error_rate], :counter, :increment, 1)
     end
 
     it "a counter by a provided value" do
-      metric = subject.increment(:error_rate, 20)
+      metric = subject.increment(:root, :error_rate, 20)
       expect(collector).to be_a_metric_event([:root, :error_rate], :counter, :increment, 20)
     end
 
     it "raises an exception if the key is an empty string" do
-      expect { subject.increment("", 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
+      expect { subject.increment(:root, "", 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
     end
 
     it "raise an exception if the key is nil" do
-      expect { subject.increment(nil, 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
+      expect { subject.increment(:root, nil, 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
     end
   end
 
   context "#decrement" do
     it "a counter by 1" do
-      metric = subject.decrement(:error_rate)
+      metric = subject.decrement(:root, :error_rate)
       expect(collector).to be_a_metric_event([:root, :error_rate], :counter, :decrement, 1)
     end
 
     it "a counter by a provided value" do
-      metric = subject.decrement(:error_rate, 20)
+      metric = subject.decrement(:root, :error_rate, 20)
       expect(collector).to be_a_metric_event([:root, :error_rate], :counter, :decrement, 20)
     end
 
     it "raises an exception if the key is an empty string" do
-      expect { subject.decrement("", 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
+      expect { subject.decrement(:root, "", 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
     end
 
     it "raise an exception if the key is nil" do
-      expect { subject.decrement(nil, 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
+      expect { subject.decrement(:root, nil, 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
     end
   end
 
   context "#gauge" do
     it "set the value of a key" do
-      metric = subject.gauge(:size_queue, 20)
+      metric = subject.gauge(:root, :size_queue, 20)
       expect(collector).to be_a_metric_event([:root, :size_queue], :gauge, :set, 20)
     end
 
     it "raises an exception if the key is an empty string" do
-      expect { subject.gauge("", 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
+      expect { subject.gauge(:root, "", 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
     end
 
     it "raise an exception if the key is nil" do
-      expect { subject.gauge(nil, 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
+      expect { subject.gauge(:root, nil, 20) }.to raise_error(LogStash::Instrument::MetricNoKeyProvided)
     end
   end
 
   context "#time" do
     let(:sleep_time) { 2 }
     let(:sleep_time_ms) { sleep_time * 1_000_000 }
-      
+
     it "records the duration" do
-      subject.time(:duration_ms) { sleep(sleep_time) }
+      subject.time(:root, :duration_ms) { sleep(sleep_time) }
 
       expect(collector.last).to be_within(sleep_time_ms).of(sleep_time_ms + 5000)
-      expect(collector[0]).to match([:root])
+      expect(collector[0]).to match(:root)
       expect(collector[1]).to be(:duration_ms)
       expect(collector[2]).to be(:mean)
     end
 
     it "returns the value of the executed block" do
-      expect(subject.time(:testing) { "hello" }).to eq("hello")
+      expect(subject.time(:root, :testing) { "hello" }).to eq("hello")
     end
 
     it "return a TimedExecution" do
-      execution = subject.time(:duration_ms)
+      execution = subject.time(:root, :duration_ms)
       sleep(sleep_time)
       execution.stop
 
       expect(collector.last).to be_within(sleep_time_ms).of(sleep_time_ms + 0.1)
-      expect(collector[0]).to match([:root])
+      expect(collector[0]).to match(:root)
       expect(collector[1]).to be(:duration_ms)
       expect(collector[2]).to be(:mean)
     end
@@ -98,12 +98,13 @@
     let(:sub_key) { :my_sub_key }
 
     it "creates a new metric object and append the `sub_key` to the `base_key`" do
-      expect(subject.namespace(sub_key).namespace_information).to eq([namespace, sub_key])
+      expect(subject.namespace(sub_key).namespace_name).to eq([sub_key])
     end
 
     it "uses the same collector as the creator class" do
       child = subject.namespace(sub_key)
-      expect(subject.collector).to eq(child.collector)
+      metric = child.increment(:error_rate)
+      expect(collector).to be_a_metric_event([sub_key, :error_rate], :counter, :increment, 1)
     end
   end
 end
diff --git a/logstash-core/spec/logstash/instrument/metric_store_spec.rb b/logstash-core/spec/logstash/instrument/metric_store_spec.rb
index b5d9204aa9a..4371977355b 100644
--- a/logstash-core/spec/logstash/instrument/metric_store_spec.rb
+++ b/logstash-core/spec/logstash/instrument/metric_store_spec.rb
@@ -3,7 +3,7 @@
 require "logstash/instrument/metric_type/base"
 
 describe LogStash::Instrument::MetricStore do
-  let(:namespaces) { [ :root, :pipelines, :pipeline_01 ] } 
+  let(:namespaces) { [ :root, :pipelines, :pipeline_01 ] }
   let(:key) { :events_in }
   let(:counter) { LogStash::Instrument::MetricType::Counter.new(namespaces, key) }
 
@@ -35,36 +35,129 @@
     end
   end
 
-  describe "#get" do
+  context "retrieving events" do
     let(:metric_events) {
       [
         [[:node, :sashimi, :pipelines, :pipeline01, :plugins, :"logstash-output-elasticsearch"], :event_in, :increment],
         [[:node, :sashimi, :pipelines, :pipeline01], :processed_events_in, :increment],
         [[:node, :sashimi, :pipelines, :pipeline01], :processed_events_out, :increment],
+        [[:node, :sashimi, :pipelines, :pipeline02], :processed_events_out, :increment],
       ]
     }
 
     before :each do
       # Lets add a few metrics in the store before trying to find them
       metric_events.each do |namespaces, metric_key, action|
-        metric = subject.fetch_or_store(namespaces, metric_key, LogStash::Instrument::MetricType::Counter.new(namespaces, key))
+        metric = subject.fetch_or_store(namespaces, metric_key, LogStash::Instrument::MetricType::Counter.new(namespaces, metric_key))
         metric.execute(action)
       end
     end
 
-    it "retrieves end of of a branch" do
-      metrics = subject.get(:node, :sashimi, :pipelines, :pipeline01, :plugins, :"logstash-output-elasticsearch")
-      expect(metrics).to be_kind_of(Concurrent::Map)
-    end
+    describe "#get" do
+      context "when the path exist" do
+        it "retrieves end of of a branch" do
+          metrics = subject.get(:node, :sashimi, :pipelines, :pipeline01, :plugins, :"logstash-output-elasticsearch")
+          expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => a_hash_including(:plugins => a_hash_including(:"logstash-output-elasticsearch" => anything)))))))
+        end
+
+        it "retrieves branch" do
+          metrics = subject.get(:node, :sashimi, :pipelines, :pipeline01)
+          expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => anything)))))
+        end
+
+        it "allow to retrieve a specific metrics" do
+          metrics = subject.get(:node, :sashimi, :pipelines, :pipeline01, :plugins, :"logstash-output-elasticsearch", :event_in)
+          expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => a_hash_including(:plugins => a_hash_including(:"logstash-output-elasticsearch" => a_hash_including(:event_in => be_kind_of(LogStash::Instrument::MetricType::Base)))))))))
+        end
+
+        context "with filtered keys" do
+          it "allows to retrieve multiple keys on the same level" do
+            metrics = subject.get(:node, :sashimi, :pipelines, :"pipeline01,pipeline02")
+            expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => anything, :pipeline02 => anything)))))
+          end
+
+          it "supports space in the keys" do
+            metrics = subject.get(:node, :sashimi, :pipelines, :"pipeline01, pipeline02 ")
+            expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => anything, :pipeline02 => anything)))))
+          end
+
+          it "retrieves only the requested keys" do
+            metrics = subject.get(:node, :sashimi, :pipelines, :"pipeline01,pipeline02", :processed_events_in)
+            expect(metrics[:node][:sashimi][:pipelines].keys).to include(:pipeline01, :pipeline02)
+          end
+        end
+
+        context "when the path doesnt exist" do
+          it "raise an exception" do
+            expect { subject.get(:node, :sashimi, :dontexist) }.to raise_error(LogStash::Instrument::MetricStore::MetricNotFound, /dontexist/)
+          end
+        end
+      end
+
+      describe "#get_with_path" do
+        context "when the path exist" do
+          it "removes the first `/`" do
+            metrics = subject.get_with_path("/node/sashimi/")
+            expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => anything)))
+          end
+
+          it "retrieves end of of a branch" do
+            metrics = subject.get_with_path("node/sashimi/pipelines/pipeline01/plugins/logstash-output-elasticsearch")
+            expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => a_hash_including(:plugins => a_hash_including(:"logstash-output-elasticsearch" => anything)))))))
+          end
+
+          it "retrieves branch" do
+            metrics = subject.get_with_path("node/sashimi/pipelines/pipeline01")
+            expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => anything)))))
+          end
 
-    it "retrieves branch" do
-      metrics = subject.get(:node, :sashimi, :pipelines, :pipeline01)
-      expect(metrics).to be_kind_of(Concurrent::Map)
+          it "allow to retrieve a specific metrics" do
+            metrics = subject.get_with_path("node/sashimi/pipelines/pipeline01/plugins/logstash-output-elasticsearch/event_in")
+            expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => a_hash_including(:plugins => a_hash_including(:"logstash-output-elasticsearch" => a_hash_including(:event_in => be_kind_of(LogStash::Instrument::MetricType::Base)))))))))
+          end
+
+          context "with filtered keys" do
+            it "allows to retrieve multiple keys on the same level" do
+              metrics = subject.get_with_path("node/sashimi/pipelines/pipeline01,pipeline02/plugins/logstash-output-elasticsearch/event_in")
+              expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => anything, :pipeline02 => anything)))))
+            end
+
+            it "supports space in the keys" do
+              metrics = subject.get_with_path("node/sashimi/pipelines/pipeline01, pipeline02 /plugins/logstash-output-elasticsearch/event_in")
+              expect(metrics).to match(a_hash_including(:node => a_hash_including(:sashimi => a_hash_including(:pipelines  => a_hash_including(:pipeline01 => anything, :pipeline02 => anything)))))
+            end
+
+            it "retrieves only the requested keys" do
+              metrics = subject.get(:node, :sashimi, :pipelines, :"pipeline01,pipeline02", :processed_events_in)
+              expect(metrics[:node][:sashimi][:pipelines].keys).to include(:pipeline01, :pipeline02)
+            end
+          end
+        end
+      end
+
+      context "when the path doesnt exist" do
+        it "raise an exception" do
+          expect { subject.get_with_path("node/sashimi/dontexist, pipeline02 /plugins/logstash-output-elasticsearch/event_in") }.to raise_error(LogStash::Instrument::MetricStore::MetricNotFound, /dontexist/)
+        end
+      end
     end
 
-    it "allow to retrieve a specific metrics" do
-      metrics = subject.get(:node, :sashimi, :pipelines, :pipeline01, :plugins, :"logstash-output-elasticsearch", :event_in)
-      expect(metrics).to be_kind_of(LogStash::Instrument::MetricType::Base)
+    describe "#each" do
+      it "retrieves all the metric" do
+        expect(subject.each.size).to eq(metric_events.size)
+      end
+
+      it "returns metric types" do
+        metrics = []
+        subject.each { |i| metrics << i }
+        expect(metrics.size).to eq(metric_events.size)
+      end
+
+      it "retrieves all the metrics from a specific branch" do
+        metrics = []
+        subject.each("node/sashimi/pipelines/pipeline01") { |i| metrics << i }
+        expect(metrics.size).to eq(3)
+      end
     end
   end
 end
diff --git a/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb b/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb
index 30e08ac8651..b51aebc792d 100644
--- a/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb
+++ b/logstash-core/spec/logstash/instrument/metric_type/counter_spec.rb
@@ -20,12 +20,21 @@
     end
   end
 
-  describe "#to_hash" do
-    it "return the details of the counter" do
-      expect(subject.to_hash).to include({ "namespaces" => namespaces,
-                                           "key" => key,
-                                           "value" => 0,
-                                           "type" => "counter" })
+  context "When serializing to JSON" do
+    it "serializes the value" do
+      expect(LogStash::Json.dump(subject)).to eq("0")
+    end
+  end
+
+  context "When creating a hash " do
+    it "creates the hash from all the values" do
+      metric_hash = {
+        "key" => key,
+        "namespaces" => namespaces,
+        "value" => 0,
+        "type" => "counter"
+      }
+      expect(subject.to_hash).to match(metric_hash)
     end
   end
 end
diff --git a/logstash-core/spec/logstash/instrument/metric_type/gauge_spec.rb b/logstash-core/spec/logstash/instrument/metric_type/gauge_spec.rb
index ea5d86bd5e8..0481f6d283b 100644
--- a/logstash-core/spec/logstash/instrument/metric_type/gauge_spec.rb
+++ b/logstash-core/spec/logstash/instrument/metric_type/gauge_spec.rb
@@ -1,5 +1,6 @@
 # encoding: utf-8
 require "logstash/instrument/metric_type/gauge"
+require "logstash/json"
 require "spec_helper"
 
 describe LogStash::Instrument::MetricType::Gauge do
@@ -19,13 +20,21 @@
     end
   end
 
-  describe "#to_hash" do
+  context "When serializing to JSON" do
+    it "serializes the value" do
+      expect(LogStash::Json.dump(subject)).to eq("\"#{value}\"")
+    end
+  end
 
-    it "return the details of the gauge" do
-      expect(subject.to_hash).to include({ "namespaces" => namespaces,
-                                           "key" => key,
-                                           "value" => value,
-                                           "type" => "gauge" })
+  context "When creating a hash " do
+    it "creates the hash from all the values" do
+      metric_hash = {
+        "key" => key,
+        "namespaces" => namespaces,
+        "value" => value,
+        "type" => "gauge"
+      }
+      expect(subject.to_hash).to match(metric_hash)
     end
   end
 end
diff --git a/logstash-core/spec/logstash/instrument/namespaced_metric_spec.rb b/logstash-core/spec/logstash/instrument/namespaced_metric_spec.rb
new file mode 100644
index 00000000000..6ba84168df9
--- /dev/null
+++ b/logstash-core/spec/logstash/instrument/namespaced_metric_spec.rb
@@ -0,0 +1,25 @@
+# encoding: utf-8
+require "logstash/instrument/namespaced_metric"
+require "logstash/instrument/metric"
+require_relative "../../support/matchers"
+require "spec_helper"
+
+describe LogStash::Instrument::NamespacedMetric do
+  let(:namespace) { :stats }
+  let(:collector) { [] }
+  let(:metric) { LogStash::Instrument::Metric.new(collector) }
+
+  subject { described_class.new(metric, namespace) }
+
+  it "defines the same interface as `Metric`" do
+    expect(described_class).to implement_interface_of(LogStash::Instrument::Metric)
+  end
+
+  it "returns a TimedException when we call without a block" do
+    expect(subject.time(:duration_ms)).to be_kind_of(LogStash::Instrument::Metric::TimedExecution)
+  end
+
+  it "returns the value of the block" do
+    expect(subject.time(:duration_ms) { "hello" }).to eq("hello")
+  end
+end
diff --git a/logstash-core/spec/logstash/instrument/null_metric_spec.rb b/logstash-core/spec/logstash/instrument/null_metric_spec.rb
index 58944e297c8..ec55d341be4 100644
--- a/logstash-core/spec/logstash/instrument/null_metric_spec.rb
+++ b/logstash-core/spec/logstash/instrument/null_metric_spec.rb
@@ -1,11 +1,11 @@
 # encoding: utf-8
 require "logstash/instrument/null_metric"
-require "logstash/instrument/metric"
+require "logstash/instrument/namespaced_metric"
 require_relative "../../support/matchers"
 
 describe LogStash::Instrument::NullMetric do
   it "defines the same interface as `Metric`" do
-    expect(described_class).to implement_interface_of(LogStash::Instrument::Metric) 
+    expect(described_class).to implement_interface_of(LogStash::Instrument::NamespacedMetric)
   end
 
   describe "#time" do
diff --git a/logstash-core/spec/support/matchers.rb b/logstash-core/spec/support/matchers.rb
index 263ac7b3a43..88ea508b02d 100644
--- a/logstash-core/spec/support/matchers.rb
+++ b/logstash-core/spec/support/matchers.rb
@@ -4,7 +4,7 @@
 
 RSpec::Matchers.define :be_a_metric_event do |namespace, type, *args|
   match do
-    namespace == actual[0] << actual[1] && 
+    namespace == Array(actual[0]).concat(Array(actual[1])) &&
       type == actual[2] &&
       args == actual[3..-1]
   end
@@ -17,11 +17,11 @@
   end
 
   def missing_methods
-    expected.instance_methods - actual.instance_methods 
+    expected.instance_methods.select { |method| !actual.instance_methods.include?(method) }
   end
 
   def all_instance_methods_implemented?
-    missing_methods.empty?
+    expected.instance_methods.all? { |method| actual.instance_methods.include?(method) }
   end
 
   failure_message do
