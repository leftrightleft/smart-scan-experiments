diff --git a/logstash-core/lib/logstash/instrument/metric_type.rb b/logstash-core/lib/logstash/instrument/metric_type.rb
index 1915e59a375..32862b360ad 100644
--- a/logstash-core/lib/logstash/instrument/metric_type.rb
+++ b/logstash-core/lib/logstash/instrument/metric_type.rb
@@ -17,6 +17,7 @@
 
 require "logstash/instrument/metric_type/counter"
 require "logstash/instrument/metric_type/gauge"
+require "logstash/instrument/metric_type/timer"
 require "logstash/instrument/metric_type/uptime"
 
 module LogStash module Instrument
@@ -25,6 +26,7 @@ module MetricType
       :counter => LogStash::Instrument::MetricType::Counter,
       :gauge => LogStash::Instrument::MetricType::Gauge,
       :uptime => LogStash::Instrument::MetricType::Uptime,
+      :timer => LogStash::Instrument::MetricType::Timer,
     }.freeze
 
     # Use the string to generate a concrete class for this metrics
diff --git a/logstash-core/lib/logstash/instrument/metric_type/timer.rb b/logstash-core/lib/logstash/instrument/metric_type/timer.rb
new file mode 100644
index 00000000000..cb4c23a9da6
--- /dev/null
+++ b/logstash-core/lib/logstash/instrument/metric_type/timer.rb
@@ -0,0 +1,31 @@
+# Licensed to Elasticsearch B.V. under one or more contributor
+# license agreements. See the NOTICE file distributed with
+# this work for additional information regarding copyright
+# ownership. Elasticsearch B.V. licenses this file to you under
+# the Apache License, Version 2.0 (the "License"); you may
+# not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#  http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+java_import org.logstash.instrument.metrics.timer.ExecutionMillisTimer
+
+module LogStash module Instrument module MetricType
+  class Timer < ExecutionMillisTimer
+
+    def initialize(namespaces, key)
+      super(key.to_s)
+    end
+
+    def execute(action, value = nil)
+      send(action, value)
+    end
+  end
+end; end; end
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/NamespacedMetric.java b/logstash-core/src/main/java/co/elastic/logstash/api/NamespacedMetric.java
index e0c01d53191..553aa97c400 100644
--- a/logstash-core/src/main/java/co/elastic/logstash/api/NamespacedMetric.java
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/NamespacedMetric.java
@@ -20,6 +20,8 @@
 
 package co.elastic.logstash.api;
 
+import org.logstash.instrument.metrics.timer.ExecutionMillisTimer;
+
 import java.util.function.Supplier;
 
 /**
@@ -43,6 +45,14 @@ public interface NamespacedMetric extends Metric {
      */
     CounterMetric counter(String metric);
 
+    /**
+     * Creates a timer with the name {@code metric}.
+     *
+     * @param metric name of the timer
+     * @return an instance tracking a timer metric allowing easy execution timing
+     */
+    TimerMetric timer(String metric);
+
     /**
      * Increment the {@code metric} metric by 1.
      *
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/TimerMetric.java b/logstash-core/src/main/java/co/elastic/logstash/api/TimerMetric.java
new file mode 100644
index 00000000000..512a26e5270
--- /dev/null
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/TimerMetric.java
@@ -0,0 +1,41 @@
+package co.elastic.logstash.api;
+
+import java.util.function.Supplier;
+
+/**
+ * A timer metric that tracks a single timer.
+ *
+ * You can retrieve an instance of this class using {@link NamespacedMetric#timer(String)}.
+ */
+public interface TimerMetric {
+    /**
+     * Execute the provided {@link Supplier}, timing its execution.
+     * @param supplier a block for execution
+     * @return the value of executing the {@code supplier} without modification
+     * @param <R> this method returns an object of the same type as the one supplied by {@code supplier}
+     */
+    <R> R time(Supplier<R> supplier);
+
+    /**
+     * For cases where it is NOT practical to use {@link TimerMetric#time(Supplier)},
+     * but IS practical to guarantee we can commit execution after completion with {@link Committer#commit()}.
+     *
+     * @return a {@link Committer}, which is used for stopping the timer.
+     *         when using {@link TimerMetric#begin()}, you <em>MUST</em> also send {@link Committer#commit()}.
+     */
+    Committer begin();
+
+    /**
+     * Report a number of milliseconds elapsed <em>without</em> tracking execution itself.
+     * This is significantly safer than {@link TimerMetric#begin()}+{@link Committer#commit()}.
+     * @param millisecondsElapsed
+     */
+    void reportUntracked(final long millisecondsElapsed);
+
+    interface Committer {
+        /**
+         * @return the number of milliseconds since instantiation
+         */
+        long commit();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractFilterDelegatorExt.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractFilterDelegatorExt.java
index c5629a00df2..af727926ef1 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractFilterDelegatorExt.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractFilterDelegatorExt.java
@@ -20,6 +20,7 @@
 
 package org.logstash.config.ir.compiler;
 
+import co.elastic.logstash.api.TimerMetric;
 import org.jruby.Ruby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
@@ -35,6 +36,7 @@
 import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
 import org.logstash.instrument.metrics.MetricKeys;
 import org.logstash.instrument.metrics.counter.LongCounter;
+import org.logstash.instrument.metrics.timer.ExecutionMillisTimer;
 
 import java.util.Collection;
 import java.util.concurrent.TimeUnit;
@@ -52,7 +54,7 @@ public abstract class AbstractFilterDelegatorExt extends RubyObject {
 
     protected transient LongCounter eventMetricIn;
 
-    protected transient LongCounter eventMetricTime;
+    protected transient TimerMetric eventMetricTime;
 
     public AbstractFilterDelegatorExt(final Ruby runtime, final RubyClass metaClass) {
         super(runtime, metaClass);
@@ -65,7 +67,7 @@ protected void initMetrics(final String id, final AbstractNamespacedMetricExt na
             metricEvents = namespacedMetric.namespace(context, MetricKeys.EVENTS_KEY);
             eventMetricOut = LongCounter.fromRubyBase(metricEvents, MetricKeys.OUT_KEY);
             eventMetricIn = LongCounter.fromRubyBase(metricEvents, MetricKeys.IN_KEY);
-            eventMetricTime = LongCounter.fromRubyBase(metricEvents, MetricKeys.DURATION_IN_MILLIS_KEY);
+            eventMetricTime = ExecutionMillisTimer.fromRubyBase(metricEvents, MetricKeys.DURATION_IN_MILLIS_KEY);
             namespacedMetric.gauge(context, MetricKeys.NAME_KEY, configName(context));
         }
     }
@@ -130,9 +132,7 @@ public IRubyObject getId() {
     public RubyArray multiFilter(final IRubyObject input) {
         RubyArray batch = (RubyArray) input;
         eventMetricIn.increment((long) batch.size());
-        final long start = System.nanoTime();
-        final RubyArray result = doMultiFilter(batch);
-        eventMetricTime.increment(TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));
+        final RubyArray result = eventMetricTime.time(() -> doMultiFilter(batch));
         int count = 0;
         for (final JrubyEventExtLibrary.RubyEvent event : (Collection<JrubyEventExtLibrary.RubyEvent>) result) {
             if (!event.getEvent().isCancelled()) {
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractOutputDelegatorExt.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractOutputDelegatorExt.java
index 0c3ae8bd33c..bd34701d1a6 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractOutputDelegatorExt.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractOutputDelegatorExt.java
@@ -22,6 +22,8 @@
 
 import java.util.Collection;
 import java.util.concurrent.TimeUnit;
+
+import co.elastic.logstash.api.TimerMetric;
 import org.jruby.Ruby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
@@ -37,6 +39,7 @@
 import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
 import org.logstash.instrument.metrics.MetricKeys;
 import org.logstash.instrument.metrics.counter.LongCounter;
+import org.logstash.instrument.metrics.timer.ExecutionMillisTimer;
 
 @JRubyClass(name = "AbstractOutputDelegator")
 public abstract class AbstractOutputDelegatorExt extends RubyObject {
@@ -57,7 +60,7 @@ public abstract class AbstractOutputDelegatorExt extends RubyObject {
 
     private transient LongCounter eventMetricIn;
 
-    private transient LongCounter eventMetricTime;
+    private transient TimerMetric eventMetricTime;
 
     public AbstractOutputDelegatorExt(final Ruby runtime, final RubyClass metaClass) {
         super(runtime, metaClass);
@@ -117,9 +120,7 @@ public IRubyObject multiReceive(final IRubyObject events) {
         final RubyArray batch = (RubyArray) events;
         final int count = batch.size();
         eventMetricIn.increment((long) count);
-        final long start = System.nanoTime();
-        doOutput(batch);
-        eventMetricTime.increment(TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));
+        eventMetricTime.<Void>time(() -> { doOutput(batch); return null; });
         eventMetricOut.increment((long) count);
         return this;
     }
@@ -134,7 +135,7 @@ protected void initMetrics(final String id, final AbstractMetricExt metric) {
             namespacedMetric.gauge(context, MetricKeys.NAME_KEY, configName(context));
             eventMetricOut = LongCounter.fromRubyBase(metricEvents, MetricKeys.OUT_KEY);
             eventMetricIn = LongCounter.fromRubyBase(metricEvents, MetricKeys.IN_KEY);
-            eventMetricTime = LongCounter.fromRubyBase(metricEvents, MetricKeys.DURATION_IN_MILLIS_KEY);
+            eventMetricTime = ExecutionMillisTimer.fromRubyBase(metricEvents, MetricKeys.DURATION_IN_MILLIS_KEY);
         }
     }
 
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/FilterDelegatorExt.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/FilterDelegatorExt.java
index 66806255845..62a6d391057 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/FilterDelegatorExt.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/FilterDelegatorExt.java
@@ -34,6 +34,7 @@
 import org.jruby.runtime.builtin.IRubyObject;
 import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
 import org.logstash.instrument.metrics.counter.LongCounter;
+import org.logstash.instrument.metrics.timer.ExecutionMillisTimer;
 
 import java.util.UUID;
 
@@ -70,7 +71,7 @@ public IRubyObject initialize(final ThreadContext context, final IRubyObject fil
     public FilterDelegatorExt initForTesting(final IRubyObject filter, RubyObject configNameDouble) {
         eventMetricOut = LongCounter.DUMMY_COUNTER;
         eventMetricIn = LongCounter.DUMMY_COUNTER;
-        eventMetricTime = LongCounter.DUMMY_COUNTER;
+        eventMetricTime = ExecutionMillisTimer.nullTimer();
         this.filter = filter;
         filterMethod = filter.getMetaClass().searchMethod(FILTER_METHOD_NAME);
         flushes = filter.respondsTo("flush");
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaCodecDelegator.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaCodecDelegator.java
index ea3b9f72a3c..c29f8f390da 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaCodecDelegator.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaCodecDelegator.java
@@ -24,22 +24,16 @@
 import co.elastic.logstash.api.Context;
 import co.elastic.logstash.api.CounterMetric;
 import co.elastic.logstash.api.Event;
-import co.elastic.logstash.api.Metric;
 import co.elastic.logstash.api.NamespacedMetric;
 import co.elastic.logstash.api.PluginConfigSpec;
-import org.jruby.RubySymbol;
-import org.jruby.runtime.ThreadContext;
-import org.logstash.RubyUtil;
-import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
+import co.elastic.logstash.api.TimerMetric;
 import org.logstash.instrument.metrics.MetricKeys;
-import org.logstash.instrument.metrics.counter.LongCounter;
 
 import java.io.IOException;
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.util.Collection;
 import java.util.Map;
-import java.util.concurrent.TimeUnit;
 import java.util.function.Consumer;
 
 public class JavaCodecDelegator implements Codec {
@@ -52,13 +46,13 @@ public class JavaCodecDelegator implements Codec {
 
     protected final CounterMetric encodeMetricIn;
 
-    protected final CounterMetric encodeMetricTime;
+    protected final TimerMetric encodeMetricTime;
 
     protected final CounterMetric decodeMetricIn;
 
     protected final CounterMetric decodeMetricOut;
 
-    protected final CounterMetric decodeMetricTime;
+    protected final TimerMetric decodeMetricTime;
 
 
     public JavaCodecDelegator(final Context context, final Codec codec) {
@@ -71,12 +65,12 @@ public JavaCodecDelegator(final Context context, final Codec codec) {
 
             final NamespacedMetric encodeMetric = metric.namespace(ENCODE_KEY);
             encodeMetricIn = encodeMetric.counter(IN_KEY);
-            encodeMetricTime = encodeMetric.counter(MetricKeys.DURATION_IN_MILLIS_KEY.asJavaString());
+            encodeMetricTime = encodeMetric.timer(MetricKeys.DURATION_IN_MILLIS_KEY.asJavaString());
 
             final NamespacedMetric decodeMetric = metric.namespace(DECODE_KEY);
             decodeMetricIn = decodeMetric.counter(IN_KEY);
             decodeMetricOut = decodeMetric.counter(MetricKeys.OUT_KEY.asJavaString());
-            decodeMetricTime = decodeMetric.counter(MetricKeys.DURATION_IN_MILLIS_KEY.asJavaString());
+            decodeMetricTime = decodeMetric.timer(MetricKeys.DURATION_IN_MILLIS_KEY.asJavaString());
         }
     }
 
@@ -84,39 +78,41 @@ public JavaCodecDelegator(final Context context, final Codec codec) {
     public void decode(final ByteBuffer buffer, final Consumer<Map<String, Object>> eventConsumer) {
         decodeMetricIn.increment();
 
-        final long start = System.nanoTime();
-
-        codec.decode(buffer, (event) -> {
-            decodeMetricOut.increment();
-            eventConsumer.accept(event);
+        decodeMetricTime.time(() -> {
+            codec.decode(buffer, (event) -> {
+                decodeMetricOut.increment();
+                eventConsumer.accept(event);
+            });
+            return null;
         });
-
-        decodeMetricTime.increment(TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));
     }
 
     @Override
     public void flush(final ByteBuffer buffer, final Consumer<Map<String, Object>> eventConsumer) {
         decodeMetricIn.increment();
 
-        final long start = System.nanoTime();
-
-        codec.flush(buffer, (event) -> {
-            decodeMetricOut.increment();
-            eventConsumer.accept(event);
+        decodeMetricTime.time(() -> {
+            codec.flush(buffer, (event) -> {
+                decodeMetricOut.increment();
+                eventConsumer.accept(event);
+            });
+            return null;
         });
-
-        decodeMetricTime.increment(TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));
     }
 
     @Override
     public void encode(final Event event, final OutputStream out) throws IOException {
         encodeMetricIn.increment();
 
-        final long start = System.nanoTime();
-
-        codec.encode(event, out);
-
-        decodeMetricTime.increment(TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));
+        decodeMetricTime.time(() -> {
+            try {
+                codec.encode(event, out);
+            } catch (IOException e) {
+                // TODO: make TimerMetric#time handle/propagate checked exceptions
+                throw new RuntimeException(e);
+            }
+            return null;
+        });
     }
 
     @Override
diff --git a/logstash-core/src/main/java/org/logstash/execution/AbstractPipelineExt.java b/logstash-core/src/main/java/org/logstash/execution/AbstractPipelineExt.java
index b8debf753ef..76f678bef36 100644
--- a/logstash-core/src/main/java/org/logstash/execution/AbstractPipelineExt.java
+++ b/logstash-core/src/main/java/org/logstash/execution/AbstractPipelineExt.java
@@ -37,6 +37,7 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import co.elastic.logstash.api.TimerMetric;
 import com.google.common.annotations.VisibleForTesting;
 import org.apache.commons.codec.binary.Hex;
 import org.apache.logging.log4j.LogManager;
@@ -76,6 +77,7 @@
 import org.logstash.instrument.metrics.NullMetricExt;
 import org.logstash.instrument.metrics.UptimeMetric;
 import org.logstash.instrument.metrics.counter.LongCounter;
+import org.logstash.instrument.metrics.timer.ExecutionMillisTimer;
 import org.logstash.plugins.ConfigVariableExpander;
 import org.logstash.secret.store.SecretStore;
 import org.logstash.secret.store.SecretStoreExt;
@@ -451,6 +453,7 @@ public final IRubyObject collectStats(final ThreadContext context) throws IOExce
             dataMetrics.gauge(context, PATH, dirPath);
             pipelineMetric.gauge(context, MetricKeys.EVENTS_KEY, inner.ruby_unread_count(context));
         }
+
         return context.nil;
     }
 
@@ -479,13 +482,13 @@ public final IRubyObject initializeFlowMetrics(final ThreadContext context) {
         this.flowMetrics.add(outputThroughput);
         storeMetric(context, flowNamespace, outputThroughput);
 
-        final LongCounter queuePushWaitInMillis = initOrGetCounterMetric(context, eventsNamespace, JRubyWrappedWriteClientExt.PUSH_DURATION_KEY);
-        final FlowMetric backpressureFlow = new FlowMetric("backpressure", queuePushWaitInMillis, uptimeInMillis);
+        final ExecutionMillisTimer queuePushWaitInMillis = initOrGetTimerMetric(context, eventsNamespace, JRubyWrappedWriteClientExt.PUSH_DURATION_KEY);
+        final FlowMetric backpressureFlow = new FlowMetric("queue_backpressure", queuePushWaitInMillis, uptimeInMillis);
         this.flowMetrics.add(backpressureFlow);
         storeMetric(context, flowNamespace, backpressureFlow);
 
-        final LongCounter durationInMillis = initOrGetCounterMetric(context, eventsNamespace, MetricKeys.DURATION_IN_MILLIS_KEY);
-        final FlowMetric concurrencyFlow = new FlowMetric("concurrency", durationInMillis, uptimeInMillis);
+        final ExecutionMillisTimer durationInMillis = initOrGetTimerMetric(context, eventsNamespace, MetricKeys.DURATION_IN_MILLIS_KEY);
+        final FlowMetric concurrencyFlow = new FlowMetric("worker_concurrency", durationInMillis, uptimeInMillis);
         this.flowMetrics.add(concurrencyFlow);
         storeMetric(context, flowNamespace, concurrencyFlow);
 
@@ -518,6 +521,16 @@ UptimeMetric initOrGetUptimeMetric(final ThreadContext context,
         return retrievedMetric.toJava(UptimeMetric.class);
     }
 
+    ExecutionMillisTimer initOrGetTimerMetric(final ThreadContext context,
+                                     final RubySymbol[] subPipelineNamespacePath,
+                                     final RubySymbol uptimeMetricName) {
+        final IRubyObject collector = this.metric.collector(context);
+        final IRubyObject fullNamespace = RubyArray.newArray(context.runtime, fullNamespacePath(subPipelineNamespacePath));
+
+        final IRubyObject retrievedMetric = collector.callMethod(context, "get", new IRubyObject[]{fullNamespace, uptimeMetricName, context.runtime.newSymbol("timer")});
+        return retrievedMetric.toJava(ExecutionMillisTimer.class);
+    }
+
 
     <T> void storeMetric(final ThreadContext context,
                          final RubySymbol[] subPipelineNamespacePath,
diff --git a/logstash-core/src/main/java/org/logstash/execution/QueueReadClientBase.java b/logstash-core/src/main/java/org/logstash/execution/QueueReadClientBase.java
index 6e4163e025d..3d0ed555621 100644
--- a/logstash-core/src/main/java/org/logstash/execution/QueueReadClientBase.java
+++ b/logstash-core/src/main/java/org/logstash/execution/QueueReadClientBase.java
@@ -20,6 +20,7 @@
 
 package org.logstash.execution;
 
+import co.elastic.logstash.api.TimerMetric;
 import org.jruby.Ruby;
 import org.jruby.RubyClass;
 import org.jruby.RubyHash;
@@ -34,10 +35,13 @@
 import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
 import org.logstash.instrument.metrics.MetricKeys;
 import org.logstash.instrument.metrics.counter.LongCounter;
+import org.logstash.instrument.metrics.timer.CombinedMillisTimer;
+import org.logstash.instrument.metrics.timer.ExecutionMillisTimer;
 
 import java.io.IOException;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 
 /**
  * Common code shared by Persistent and In-Memory queues clients implementation
@@ -52,14 +56,16 @@ public abstract class QueueReadClientBase extends RubyObject implements QueueRea
     protected long waitForMillis = 50;
 
     private final ConcurrentHashMap<Long, QueueBatch> inflightBatches = new ConcurrentHashMap<>();
-    private final ConcurrentHashMap<Long, Long> inflightClocks = new ConcurrentHashMap<>();
+    private final ConcurrentHashMap<Long, TimerMetric.Committer> inflightTimerCommitters = new ConcurrentHashMap<>();
 
     private transient LongCounter eventMetricOut;
     private transient LongCounter eventMetricFiltered;
-    private transient LongCounter eventMetricTime;
+    private transient TimerMetric eventMetricTime;
     private transient LongCounter pipelineMetricOut;
     private transient LongCounter pipelineMetricFiltered;
-    private transient LongCounter pipelineMetricTime;
+    private transient TimerMetric pipelineMetricTime;
+
+    private transient AtomicReference<TimerMetric> combinedMetricTime = new AtomicReference<>(ExecutionMillisTimer.nullTimer());
 
     protected QueueReadClientBase(final Ruby runtime, final RubyClass metaClass) {
         super(runtime, metaClass);
@@ -78,7 +84,8 @@ public IRubyObject setEventsMetric(final IRubyObject metric) {
         synchronized(namespacedMetric.getMetric()) {
             eventMetricOut = LongCounter.fromRubyBase(namespacedMetric, MetricKeys.OUT_KEY);
             eventMetricFiltered = LongCounter.fromRubyBase(namespacedMetric, MetricKeys.FILTERED_KEY);
-            eventMetricTime = LongCounter.fromRubyBase(namespacedMetric, MetricKeys.DURATION_IN_MILLIS_KEY);
+            eventMetricTime = ExecutionMillisTimer.fromRubyBase(namespacedMetric, MetricKeys.DURATION_IN_MILLIS_KEY);
+            combinedMetricTime.updateAndGet(existing -> CombinedMillisTimer.combine(existing, eventMetricTime));
         }
         return this;
     }
@@ -89,7 +96,8 @@ public IRubyObject setPipelineMetric(final IRubyObject metric) {
         synchronized(namespacedMetric.getMetric()) {
             pipelineMetricOut = LongCounter.fromRubyBase(namespacedMetric, MetricKeys.OUT_KEY);
             pipelineMetricFiltered = LongCounter.fromRubyBase(namespacedMetric, MetricKeys.FILTERED_KEY);
-            pipelineMetricTime = LongCounter.fromRubyBase(namespacedMetric, MetricKeys.DURATION_IN_MILLIS_KEY);
+            pipelineMetricTime = ExecutionMillisTimer.fromRubyBase(namespacedMetric, MetricKeys.DURATION_IN_MILLIS_KEY);
+            combinedMetricTime.updateAndGet(existing -> CombinedMillisTimer.combine(existing, pipelineMetricTime));
         }
         return this;
     }
@@ -131,12 +139,14 @@ public IRubyObject rubyReadBatch(final ThreadContext context) throws Interrupted
     public void closeBatch(QueueBatch batch) throws IOException {
         batch.close();
         inflightBatches.remove(Thread.currentThread().getId());
-        Long startTime = inflightClocks.remove(Thread.currentThread().getId());
-        if (startTime != null && batch.filteredSize() > 0) {
-            // stop timer and record metrics iff the batch is non-empty.
-            long elapsedTimeMillis = (System.nanoTime() - startTime) / 1_000_000;
-            eventMetricTime.increment(elapsedTimeMillis);
-            pipelineMetricTime.increment(elapsedTimeMillis);
+        TimerMetric.Committer committer = inflightTimerCommitters.remove(Thread.currentThread().getId());
+        if (committer != null) {
+            final long executionTimeInMillis = committer.commit();
+            if (batch.filteredSize() <= 0) {
+//                System.err.format("OVER-REPORTING: %sms\n", executionTimeInMillis);
+                // TODO: abort tracking? undo?
+                // previous implementation late-reported execution time after execution was complete IFF there were events in the batch.
+            }
         }
     }
 
@@ -196,7 +206,8 @@ public void rubyAddOutputMetrics(final IRubyObject size) {
     public void startMetrics(QueueBatch batch) {
         long threadId = Thread.currentThread().getId();
         inflightBatches.put(threadId, batch);
-        inflightClocks.put(threadId, System.nanoTime());
+        final TimerMetric selectedMetricTime = batch.filteredSize() > 0 ? combinedMetricTime.getPlain() : ExecutionMillisTimer.nullTimer();
+        inflightTimerCommitters.computeIfAbsent(threadId, (k) -> selectedMetricTime.begin());
     }
 
     @Override
diff --git a/logstash-core/src/main/java/org/logstash/execution/WorkerLoop.java b/logstash-core/src/main/java/org/logstash/execution/WorkerLoop.java
index b60080671eb..aa591d61e6a 100644
--- a/logstash-core/src/main/java/org/logstash/execution/WorkerLoop.java
+++ b/logstash-core/src/main/java/org/logstash/execution/WorkerLoop.java
@@ -21,9 +21,13 @@
 
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.LongAdder;
+import java.util.function.Supplier;
+
+import co.elastic.logstash.api.TimerMetric;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.logstash.config.ir.CompiledPipeline;
+import org.logstash.instrument.metrics.timer.CombinedMillisTimer;
 
 /**
  * Pipeline execution worker, it's responsible to execute filters and output plugins for each {@link QueueBatch} that
diff --git a/logstash-core/src/main/java/org/logstash/ext/JRubyWrappedWriteClientExt.java b/logstash-core/src/main/java/org/logstash/ext/JRubyWrappedWriteClientExt.java
index ad3e684624a..73cea25a8f5 100644
--- a/logstash-core/src/main/java/org/logstash/ext/JRubyWrappedWriteClientExt.java
+++ b/logstash-core/src/main/java/org/logstash/ext/JRubyWrappedWriteClientExt.java
@@ -21,8 +21,14 @@
 package org.logstash.ext;
 
 import java.util.Collection;
+import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+
+import co.elastic.logstash.api.TimerMetric;
 import org.jruby.Ruby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
@@ -38,6 +44,7 @@
 import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
 import org.logstash.instrument.metrics.MetricKeys;
 import org.logstash.instrument.metrics.counter.LongCounter;
+import org.logstash.instrument.metrics.timer.ExecutionMillisTimer;
 
 @JRubyClass(name = "WrappedWriteClient")
 public final class JRubyWrappedWriteClientExt extends RubyObject implements QueueWriter {
@@ -50,13 +57,13 @@ public final class JRubyWrappedWriteClientExt extends RubyObject implements Queu
     private JRubyAbstractQueueWriteClientExt writeClient;
 
     private transient LongCounter eventsMetricsCounter;
-    private transient LongCounter eventsMetricsTime;
+    private transient TimerMetric eventsMetricsTime;
 
     private transient LongCounter pipelineMetricsCounter;
-    private transient LongCounter pipelineMetricsTime;
+    private transient TimerMetric pipelineMetricsTime;
 
     private transient LongCounter pluginMetricsCounter;
-    private transient LongCounter pluginMetricsTime;
+    private transient TimerMetric pluginMetricsTime;
 
     public JRubyWrappedWriteClientExt(final Ruby runtime, final RubyClass metaClass) {
         super(runtime, metaClass);
@@ -78,18 +85,18 @@ public JRubyWrappedWriteClientExt initialize(
             final AbstractNamespacedMetricExt eventsMetrics =
                 getMetric(metric, "stats", "events");
             eventsMetricsCounter = LongCounter.fromRubyBase(eventsMetrics, MetricKeys.IN_KEY);
-            eventsMetricsTime = LongCounter.fromRubyBase(eventsMetrics, PUSH_DURATION_KEY);
+            eventsMetricsTime = ExecutionMillisTimer.fromRubyBase(eventsMetrics, PUSH_DURATION_KEY);
             final AbstractNamespacedMetricExt pipelineMetrics =
                 getMetric(metric, "stats", "pipelines", pipelineId, "events");
             pipelineMetricsCounter = LongCounter.fromRubyBase(pipelineMetrics, MetricKeys.IN_KEY);
-            pipelineMetricsTime = LongCounter.fromRubyBase(pipelineMetrics, PUSH_DURATION_KEY);
+            pipelineMetricsTime = ExecutionMillisTimer.fromRubyBase(pipelineMetrics, PUSH_DURATION_KEY);
             final AbstractNamespacedMetricExt pluginMetrics = getMetric(
                 metric, "stats", "pipelines", pipelineId, "plugins", "inputs",
                 pluginId.asJavaString(), "events"
             );
             pluginMetricsCounter =
                 LongCounter.fromRubyBase(pluginMetrics, MetricKeys.OUT_KEY);
-            pluginMetricsTime = LongCounter.fromRubyBase(pluginMetrics, PUSH_DURATION_KEY);
+            pluginMetricsTime = ExecutionMillisTimer.fromRubyBase(pluginMetrics, PUSH_DURATION_KEY);
         }
         return this;
     }
@@ -97,24 +104,22 @@ public JRubyWrappedWriteClientExt initialize(
     @JRubyMethod(name = {"push", "<<"}, required = 1)
     public IRubyObject push(final ThreadContext context, final IRubyObject event)
         throws InterruptedException {
-        final long start = System.nanoTime();
-        incrementCounters(1L);
-        final IRubyObject res = writeClient.doPush(context, (JrubyEventExtLibrary.RubyEvent) event);
-        incrementTimers(start);
-        return res;
+        return executeWithTimers(() -> {
+            incrementCounters(1L);
+            return writeClient.doPush(context, (JrubyEventExtLibrary.RubyEvent) event);
+        });
     }
 
     @SuppressWarnings("unchecked")
     @JRubyMethod(name = "push_batch", required = 1)
     public IRubyObject pushBatch(final ThreadContext context, final IRubyObject batch)
         throws InterruptedException {
-        final long start = System.nanoTime();
-        incrementCounters((long) ((Collection<IRubyObject>) batch).size());
-        final IRubyObject res = writeClient.doPushBatch(
-            context, (Collection<JrubyEventExtLibrary.RubyEvent>) batch
-        );
-        incrementTimers(start);
-        return res;
+        return executeWithTimers(() -> {
+            incrementCounters((long) ((Collection<IRubyObject>) batch).size());
+            return writeClient.doPushBatch(
+                    context, (Collection<JrubyEventExtLibrary.RubyEvent>) batch
+            );
+        });
     }
 
     /**
@@ -135,13 +140,33 @@ private void incrementCounters(final long count) {
         pluginMetricsCounter.increment(count);
     }
 
+    @Deprecated
+    /**
+     * @param start the execution's starting System.nanotime
+     * @deprecated use {@link JRubyWrappedWriteClientExt.executeWithTimers}
+     */
     private void incrementTimers(final long start) {
         final long increment = TimeUnit.MILLISECONDS.convert(
             System.nanoTime() - start, TimeUnit.NANOSECONDS
         );
-        eventsMetricsTime.increment(increment);
-        pipelineMetricsTime.increment(increment);
-        pluginMetricsTime.increment(increment);
+        eventsMetricsTime.reportUntracked(increment);
+        pipelineMetricsTime.reportUntracked(increment);
+        pluginMetricsTime.reportUntracked(increment);
+    }
+
+    private <V,E extends Exception> V executeWithTimers(final ExceptionalSupplier<V,E> supplier) throws E {
+        final List<TimerMetric> timers = List.of(eventsMetricsTime, pipelineMetricsTime, pluginMetricsTime);
+        final List<TimerMetric.Committer> committers = timers.stream().map(TimerMetric::begin).collect(Collectors.toList());
+        try {
+            return supplier.get();
+        } finally {
+            committers.forEach(TimerMetric.Committer::commit);
+        }
+    }
+
+    @FunctionalInterface
+    private interface ExceptionalSupplier<V,E extends Exception> {
+        V get() throws E;
     }
 
     private static AbstractNamespacedMetricExt getMetric(final AbstractMetricExt base,
@@ -159,9 +184,10 @@ private static IRubyObject toSymbolArray(final String... strings) {
 
     @Override
     public void push(Map<String, Object> event) {
-        final long start = System.nanoTime();
-        incrementCounters(1L);
-        writeClient.push(event);
-        incrementTimers(start);
+        executeWithTimers(() -> {
+            incrementCounters(1L);
+            writeClient.push(event);
+            return null;
+        });
     }
 }
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/AbstractNamespacedMetricExt.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/AbstractNamespacedMetricExt.java
index df559b84965..65cdc53c6e9 100644
--- a/logstash-core/src/main/java/org/logstash/instrument/metrics/AbstractNamespacedMetricExt.java
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/AbstractNamespacedMetricExt.java
@@ -43,6 +43,11 @@ public IRubyObject counter(final ThreadContext context, final IRubyObject key) {
         return getCounter(context, key);
     }
 
+    @JRubyMethod
+    public IRubyObject timer(final ThreadContext context, final IRubyObject key) {
+        return getTimer(context, key);
+    }
+
     @JRubyMethod
     public IRubyObject gauge(final ThreadContext context, final IRubyObject key,
         final IRubyObject value) {
@@ -89,6 +94,8 @@ protected abstract IRubyObject getGauge(ThreadContext context, IRubyObject key,
 
     protected abstract IRubyObject getCounter(ThreadContext context, IRubyObject key);
 
+    protected abstract IRubyObject getTimer(ThreadContext context, IRubyObject key);
+
     protected abstract IRubyObject doTime(ThreadContext context, IRubyObject key, Block block);
 
     protected abstract IRubyObject doReportTime(ThreadContext context,
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/MetricExt.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/MetricExt.java
index 301d598b4f7..354ea0420f9 100644
--- a/logstash-core/src/main/java/org/logstash/instrument/metrics/MetricExt.java
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/MetricExt.java
@@ -20,7 +20,7 @@
 
 package org.logstash.instrument.metrics;
 
-import java.util.concurrent.TimeUnit;
+import co.elastic.logstash.api.TimerMetric;
 import org.jruby.Ruby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
@@ -44,6 +44,9 @@ public final class MetricExt extends AbstractSimpleMetricExt {
 
     public static final RubySymbol COUNTER = RubyUtil.RUBY.newSymbol("counter");
 
+    public static final RubySymbol TIMER = RubyUtil.RUBY.newSymbol("timer");
+    public static final RubySymbol REPORT_UNTRACKED = RubyUtil.RUBY.newSymbol("report_untracked");
+
     private static final RubyFixnum ONE = RubyUtil.RUBY.newFixnum(1);
 
     private static final RubySymbol INCREMENT = RubyUtil.RUBY.newSymbol("increment");
@@ -145,7 +148,7 @@ protected IRubyObject doReportTime(final ThreadContext context, final IRubyObjec
         final IRubyObject key, final IRubyObject duration) {
         MetricExt.validateKey(context, null, key);
         return collector.callMethod(
-            context, "push", new IRubyObject[]{namespace, key, COUNTER, INCREMENT, duration}
+            context, "push", new IRubyObject[]{namespace, key, TIMER, REPORT_UNTRACKED, duration}
         );
     }
 
@@ -153,17 +156,12 @@ protected IRubyObject doReportTime(final ThreadContext context, final IRubyObjec
     protected IRubyObject doTime(final ThreadContext context, final IRubyObject namespace,
         final IRubyObject key, final Block block) {
         MetricExt.validateKey(context, null, key);
+
+        final TimerMetric timer = this.collector.callMethod(context, "get", new IRubyObject[]{namespace, key, TIMER}).toJava(TimerMetric.class);
         if (!block.isGiven()) {
-            return MetricExt.TimedExecution.create(this, namespace, key);
+            return MetricExt.TimedExecution.create(timer.begin());
         }
-        final long startTime = System.nanoTime();
-        final IRubyObject res = block.call(context);
-        this.reportTime(context, namespace, key, RubyFixnum.newFixnum(
-            context.runtime, TimeUnit.MILLISECONDS.convert(
-                System.nanoTime() - startTime, TimeUnit.NANOSECONDS
-            )
-        ));
-        return res;
+        return timer.time(() -> block.call(context));
     }
 
     @Override
@@ -181,33 +179,20 @@ public static final class TimedExecution extends RubyObject {
 
         private static final long serialVersionUID = 1L;
 
-        private final long startTime = System.nanoTime();
-
-        private MetricExt metric;
-
-        private transient IRubyObject namespace;
-
-        private transient IRubyObject key;
+        private TimerMetric.Committer committer;
 
-        public static MetricExt.TimedExecution create(final MetricExt metric,
-            final IRubyObject namespace, final IRubyObject key) {
+        public static MetricExt.TimedExecution create(final TimerMetric.Committer timerMetricCommitter) {
+            final ThreadContext context = RubyUtil.RUBY.getCurrentContext();
             final MetricExt.TimedExecution res =
                 new MetricExt.TimedExecution(RubyUtil.RUBY, RubyUtil.TIMED_EXECUTION_CLASS);
-            res.metric = metric;
-            res.namespace = namespace;
-            res.key = key;
+            res.committer = timerMetricCommitter;
             return res;
         }
 
         @JRubyMethod
         public RubyFixnum stop(final ThreadContext context) {
-            final RubyFixnum result = RubyFixnum.newFixnum(
-                context.runtime, TimeUnit.MILLISECONDS.convert(
-                    System.nanoTime() - startTime, TimeUnit.NANOSECONDS
-                )
-            );
-            metric.reportTime(context, namespace, key, result);
-            return result;
+            final long executionTime = committer.commit();
+            return RubyFixnum.newFixnum(context.runtime, executionTime);
         }
 
         public TimedExecution(final Ruby runtime, final RubyClass metaClass) {
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/NamespacedMetricExt.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/NamespacedMetricExt.java
index 66c24a93ab6..0b3c2ac40cd 100644
--- a/logstash-core/src/main/java/org/logstash/instrument/metrics/NamespacedMetricExt.java
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/NamespacedMetricExt.java
@@ -77,6 +77,13 @@ protected IRubyObject getCounter(final ThreadContext context, final IRubyObject
         );
     }
 
+    @Override
+    protected IRubyObject getTimer(ThreadContext context, IRubyObject key) {
+        return collector(context).callMethod(
+                context, "get", new IRubyObject[]{namespaceName, key, MetricExt.TIMER}
+        );
+    }
+
     @Override
     protected IRubyObject getGauge(final ThreadContext context, final IRubyObject key,
         final IRubyObject value) {
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/NullNamespacedMetricExt.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/NullNamespacedMetricExt.java
index e6ecbe21dfa..f19c85b264c 100644
--- a/logstash-core/src/main/java/org/logstash/instrument/metrics/NullNamespacedMetricExt.java
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/NullNamespacedMetricExt.java
@@ -31,6 +31,7 @@
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.logstash.RubyUtil;
+import org.logstash.instrument.metrics.timer.ExecutionMillisTimer;
 
 @JRubyClass(name = "NamespacedNullMetric", parent = "AbstractNamespacedMetric")
 public final class NullNamespacedMetricExt extends AbstractNamespacedMetricExt {
@@ -43,6 +44,8 @@ public final class NullNamespacedMetricExt extends AbstractNamespacedMetricExt {
 
     private NullMetricExt metric;
 
+    private static final IRubyObject NULL_TIMER = RubyUtil.toRubyObject(ExecutionMillisTimer.nullTimer());
+
     public static AbstractNamespacedMetricExt create(final NullMetricExt metric,
         final @SuppressWarnings("rawtypes") RubyArray namespaceName) {
         final NullNamespacedMetricExt res =
@@ -125,6 +128,11 @@ protected AbstractNamespacedMetricExt createNamespaced(final ThreadContext conte
     @Override
     public AbstractMetricExt getMetric() { return this.metric; }
 
+    @Override
+    protected IRubyObject getTimer(ThreadContext context, IRubyObject key) {
+        return NULL_TIMER;
+    }
+
     @JRubyClass(name = "NullCounter")
     public static final class NullCounter extends RubyObject {
 
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/counter/LongCounter.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/counter/LongCounter.java
index 49f4eb98002..05faaf3591c 100644
--- a/logstash-core/src/main/java/org/logstash/instrument/metrics/counter/LongCounter.java
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/counter/LongCounter.java
@@ -115,5 +115,4 @@ public void reset(){
         //replacing since LongAdder#reset "is only effective if there are no concurrent updates", we can not make that guarantee
         longAdder = new LongAdder();
     }
-
 }
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/timer/CombinedMillisTimer.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/timer/CombinedMillisTimer.java
new file mode 100644
index 00000000000..e70763b74f7
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/timer/CombinedMillisTimer.java
@@ -0,0 +1,60 @@
+package org.logstash.instrument.metrics.timer;
+
+import co.elastic.logstash.api.TimerMetric;
+
+import java.util.Objects;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
+
+public class CombinedMillisTimer implements TimerMetric {
+    private final TimerMetric[] wrappedTimerMetrics;
+
+    public static TimerMetric combine(final TimerMetric left, final TimerMetric right) {
+        System.err.format("%s::combine(%s, %s)\n", CombinedMillisTimer.class.getName(), left, right);
+        if (Objects.isNull(left) || Objects.equals(left, ExecutionMillisTimer.nullTimer())) { return Objects.requireNonNullElseGet(right, ExecutionMillisTimer::nullTimer); }
+        if (Objects.isNull(right) || Objects.equals(right, ExecutionMillisTimer.nullTimer())) { return Objects.requireNonNullElseGet(left, ExecutionMillisTimer::nullTimer); }
+
+        return new CombinedMillisTimer(new TimerMetric[]{left, right});
+    }
+
+    private CombinedMillisTimer(TimerMetric[] wrappedTimerMetrics) {
+        this.wrappedTimerMetrics = wrappedTimerMetrics;
+    }
+
+    @Override
+    public <R> R time(Supplier<R> supplier) {
+        final Committer committer = begin();
+        try {
+            return supplier.get();
+        } finally {
+            committer.commit();
+        }
+    }
+
+    @Override
+    public Committer begin() {
+        final Committer[] committers = Stream.of(this.wrappedTimerMetrics).map(TimerMetric::begin).toArray(Committer[]::new);
+        return new CombinedCommitter(committers);
+    }
+
+    @Override
+    public void reportUntracked(long millisecondsElapsed) {
+        Stream.of(wrappedTimerMetrics)
+                .forEach(timer -> timer.reportUntracked(millisecondsElapsed));
+    }
+
+    private class CombinedCommitter implements Committer {
+        private final Committer[] committers;
+        public CombinedCommitter(final Committer[] committers) {
+            this.committers = committers;
+        }
+
+        @Override
+        public long commit() {
+            return Stream.of(committers)
+                    .map(Committer::commit)
+                    .reduce(Math::max)
+                    .orElse(0L);
+        }
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/instrument/metrics/timer/ExecutionMillisTimer.java b/logstash-core/src/main/java/org/logstash/instrument/metrics/timer/ExecutionMillisTimer.java
new file mode 100644
index 00000000000..b234175850d
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/instrument/metrics/timer/ExecutionMillisTimer.java
@@ -0,0 +1,244 @@
+package org.logstash.instrument.metrics.timer;
+
+import co.elastic.logstash.api.TimerMetric;
+import org.jruby.RubySymbol;
+import org.jruby.runtime.ThreadContext;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.logstash.RubyUtil;
+import org.logstash.instrument.metrics.AbstractMetric;
+import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
+import org.logstash.instrument.metrics.MetricType;
+
+import java.util.Objects;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.LongAdder;
+import java.util.function.LongSupplier;
+import java.util.function.Supplier;
+
+/**
+ * An {@link ExecutionMillisTimer}'s value tracks the _cumulative_ execution time,
+ * including concurrent in-flight execution. The implementation is threadsafe and non-blocking.
+ *
+ * <p>It does so by keeping track of untracked and tracked elapsed time separately,
+ * with the tracked adjustment capable of calculating the elapsed time since its last checkpoint,
+ * during which it has had constant concurrency.
+ */
+public class ExecutionMillisTimer extends AbstractMetric<Long> implements TimerMetric {
+
+    private final LongAdder untrackedMillis = new LongAdder();
+    private final AtomicReference<MillisAdjustmentState> trackedMillisAdjustment;
+
+    // test-only dependency injection
+    private final LongSupplier nanoTimeSupplier;
+
+    private static final ExecutionMillisTimer NULL_TIMER = new ExecutionMillisTimer("null_timer"){
+        @Override public <R> R time(Supplier<R> supplier) { return supplier.get(); }
+        @Override public ExecutionCommitter begin() { return new ExecutionCommitter(System.nanoTime(), System::nanoTime); }
+        @Override public void reportUntracked(long millis) {}
+        @Override public Long getValue() { return 0L; }
+    };
+
+    public static ExecutionMillisTimer nullTimer() {
+        return NULL_TIMER;
+    }
+
+    public ExecutionMillisTimer(final String name) {
+        this(System::nanoTime, name);
+    }
+
+    ExecutionMillisTimer(final LongSupplier nanoTimeSupplier, final String name) {
+        super(name);
+        this.nanoTimeSupplier = Objects.requireNonNullElse(nanoTimeSupplier, System::nanoTime);
+        this.trackedMillisAdjustment = new AtomicReference<>(new StaticAdjustmentState());
+    }
+
+    @Override
+    public <R> R time(final Supplier<R> supplier){
+        final ExecutionCommitter executionCommitter = begin();
+        try {
+            return supplier.get();
+        } finally {
+            executionCommitter.commit();
+        }
+    }
+
+    @Override
+    public ExecutionCommitter begin() {
+        final long newCheckpointNanos = trackedMillisAdjustment.updateAndGet(MillisAdjustmentState::withIncrementedConcurrency).getCheckpointNanoTime();
+        return new ExecutionCommitter(newCheckpointNanos, () -> trackedMillisAdjustment.updateAndGet(MillisAdjustmentState::withDecrementedConcurrency).getCheckpointNanoTime());
+    }
+
+    @Override
+    public void reportUntracked(final long millis) {
+        untrackedMillis.add(millis);
+    }
+
+    @Override
+    public MetricType getType() {
+        return MetricType.COUNTER_LONG;
+    }
+
+    @Override
+    public Long getValue() {
+        return trackedMillisAdjustment.get().adjust(untrackedMillis.longValue());
+    }
+
+    public static ExecutionMillisTimer fromRubyBase(final AbstractNamespacedMetricExt metric,
+                                                    final RubySymbol key) {
+        final ThreadContext context = RubyUtil.RUBY.getCurrentContext();
+        final IRubyObject timer = metric.timer(context, key);
+
+        if (ExecutionMillisTimer.class.isAssignableFrom(timer.getJavaClass())) {
+            return timer.toJava(ExecutionMillisTimer.class);
+        } else {
+            return NULL_TIMER;
+        }
+    }
+
+    static class ExecutionCommitter implements Committer {
+        private final long startNanos;
+        private final LongSupplier atomicCommitAction;
+        private final AtomicBoolean committed = new AtomicBoolean(false);
+
+        /**
+         *
+         * @param startNanos a marker for the start time
+         * @param atomicCommitAction an action that will be executed exactly once,
+         *                           which returns the number of NANOSECONDS since the provided start time.
+         */
+        ExecutionCommitter(final long startNanos, final LongSupplier atomicCommitAction) {
+            this.startNanos = startNanos;
+            this.atomicCommitAction = atomicCommitAction;
+        }
+        @Override
+        public long commit() {
+            if (committed.compareAndSet(false, true)) {
+                final long commitNanos = atomicCommitAction.getAsLong();
+                return TimeUnit.NANOSECONDS.toMillis(commitNanos - this.startNanos);
+            } else {
+                return 0L;
+            }
+        }
+    }
+
+    interface MillisAdjustmentState {
+        long getCheckpointNanoTime();
+        MillisAdjustmentState withIncrementedConcurrency();
+        MillisAdjustmentState withDecrementedConcurrency();
+        long adjust(long externalMillis);
+    }
+
+    /**
+     * A {@link StaticAdjustmentState} is static, in that it is not tracking
+     * any concurrent executions, which makes calculations static and enables
+     * us to guard against negative concurrency.
+     */
+    private class StaticAdjustmentState implements MillisAdjustmentState {
+        private final long checkpointNanos;
+        private final long cumulativeMillis;
+        private final long excessNanos;
+
+        public StaticAdjustmentState(final long checkpointNanos, final long cumulativeMillis, final long excessNanos) {
+            this.checkpointNanos = checkpointNanos;
+            this.cumulativeMillis = cumulativeMillis + Math.floorDiv(excessNanos, 1_000_000);
+            this.excessNanos = Math.floorMod(excessNanos, 1_000_000);
+        }
+
+        public StaticAdjustmentState() {
+            this(nanoTimeSupplier.getAsLong(), 0L, 0L);
+        }
+
+        @Override
+        public DynamicAdjustmentState withIncrementedConcurrency() {
+            return new DynamicAdjustmentState(cumulativeMillis, excessNanos);
+        }
+
+        @Override
+        public MillisAdjustmentState withDecrementedConcurrency() {
+            throw new IllegalStateException("Timers cannot track negative concurrency");
+        }
+
+        @Override
+        public long adjust(final long externalMillis) {
+            return Math.addExact(externalMillis, this.cumulativeMillis);
+        }
+
+        @Override
+        public long getCheckpointNanoTime() {
+            return this.checkpointNanos;
+        }
+    }
+
+    /**
+     * An {@link DynamicAdjustmentState} is actively tracking execution with
+     * a non-zero concurrency. It holds sufficient information to mark a checkpoint,
+     * along with a known constant concurrency since that checkpoint, so that it can
+     * calculate the elapsed execution time of in-flight executions.
+     *
+     * <p>For example, if we are tracking N concurrent executions, our calculated value
+     * will be the value at our checkpoint plus N times the duration since that
+     * checkpoint.
+     */
+    private class DynamicAdjustmentState implements MillisAdjustmentState {
+        private final long checkpointNanoTime;
+        private final long committedMillis;
+        private final long committedExcessNanos;
+        private final int concurrency;
+        public DynamicAdjustmentState(final long committedMillis, final long committedExcessNanos) {
+            this(nanoTimeSupplier.getAsLong(), committedMillis, committedExcessNanos, 1);
+        }
+        private DynamicAdjustmentState(final long checkpointNanoTime,
+                                       final long committedMillis,
+                                       final long committedExcessNanos,
+                                       final int concurrency) {
+            this.checkpointNanoTime = checkpointNanoTime;
+            this.committedMillis = committedMillis + Math.floorDiv(committedExcessNanos, 1_000_000);
+            this.committedExcessNanos = Math.floorMod(committedExcessNanos, 1_000_000);
+            this.concurrency = concurrency;
+        }
+
+        @Override
+        public MillisAdjustmentState withIncrementedConcurrency() {
+            return adjustConcurrency(+1);
+        }
+
+        @Override
+        public MillisAdjustmentState withDecrementedConcurrency() {
+            return adjustConcurrency(-1);
+        }
+
+        @Override
+        public long getCheckpointNanoTime() {
+            return this.checkpointNanoTime;
+        }
+
+        @Override
+        public long adjust(final long externalMillis) {
+            final long excessNanos = calculateExcessNanos(nanoTimeSupplier.getAsLong());
+            final long excessMillis = TimeUnit.NANOSECONDS.toMillis(excessNanos);
+
+            final long dynamicMillis = Math.addExact(this.committedMillis, excessMillis);
+            return Math.addExact(externalMillis, dynamicMillis);
+        }
+
+        private MillisAdjustmentState adjustConcurrency(final int vector) {
+            final long newCheckpointNanoTime = nanoTimeSupplier.getAsLong();
+            final int newConcurrency = this.concurrency + vector;
+            final long excessNanos = calculateExcessNanos(newCheckpointNanoTime);
+
+            if (newConcurrency == 0) {
+                return new StaticAdjustmentState(newCheckpointNanoTime, this.committedMillis, excessNanos);
+            }
+            return new DynamicAdjustmentState(newCheckpointNanoTime, this.committedMillis, excessNanos, newConcurrency);
+        }
+
+        private long calculateExcessNanos(long proposedCheckpointNanoTime) {
+            final long deltaNanoTime = Math.subtractExact(proposedCheckpointNanoTime, this.checkpointNanoTime);
+            final long calculatedExcessNanos = Math.multiplyExact(deltaNanoTime, this.concurrency);
+
+            return Math.addExact(this.committedExcessNanos, calculatedExcessNanos);
+        }
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/NamespacedMetricImpl.java b/logstash-core/src/main/java/org/logstash/plugins/NamespacedMetricImpl.java
index 5322bc80ddd..2e4148678ea 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/NamespacedMetricImpl.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/NamespacedMetricImpl.java
@@ -23,6 +23,7 @@
 import co.elastic.logstash.api.CounterMetric;
 import co.elastic.logstash.api.Metric;
 import co.elastic.logstash.api.NamespacedMetric;
+import co.elastic.logstash.api.TimerMetric;
 import org.jruby.RubyArray;
 import org.jruby.RubyObject;
 import org.jruby.RubySymbol;
@@ -30,9 +31,11 @@
 import org.jruby.runtime.builtin.IRubyObject;
 import org.logstash.Rubyfier;
 import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
+import org.logstash.instrument.metrics.timer.ExecutionMillisTimer;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -60,6 +63,11 @@ public CounterMetric counter(final String metric) {
         return new CounterMetricImpl(this.threadContext, this.metrics, metric);
     }
 
+    @Override
+    public TimerMetric timer(String metric) {
+        return this.metrics.timer(this.threadContext, this.getSymbol(metric)).toJava(TimerMetric.class);
+    }
+
     @Override
     public NamespacedMetric namespace(final String... key) {
         final IRubyObject[] rubyfiedKeys = Stream.of(key)
@@ -87,16 +95,16 @@ public void increment(final String key, final int amount) {
 
     @Override
     public <T> T time(final String key, final Supplier<T> callable) {
-        final long start = System.nanoTime();
-        final T ret = callable.get();
-        final long end = System.nanoTime();
-        this.reportTime(key, TimeUnit.NANOSECONDS.toMillis(end - start));
-        return ret;
+        try {
+            return timer(key).time(callable::get);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
     }
 
     @Override
     public void reportTime(final String key, final long duration) {
-        this.metrics.reportTime(this.threadContext, this.getSymbol(key), this.convert(duration));
+        timer(key).reportUntracked(duration);
     }
 
     @Override
