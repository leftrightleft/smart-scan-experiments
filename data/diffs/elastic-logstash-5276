diff --git a/.gitignore b/.gitignore
index ced4dece32f..d2adcd08d7a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -26,3 +26,6 @@ spec/reports
 rspec.xml
 .install-done
 .vendor
+integration_run
+.mvn/
+
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5f8bf0bb62c..a6e95ad8763 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,13 +1,109 @@
-## 1.5.5 (Oct 29, 2015)
+## 2.3.1 (Apr 4, 2016)
 ### general
- - Update to JRuby 1.7.22
- - Improved default security configuration for SSL/TLS. Default is now TLS1.2 (#3955)
- - Fixed bug in JrJackson v0.3.5 when handing shared strings. This manifested into issues when 
-   JrJackson was used in json codec and ES output. (#4048, #4055
- - Added beats input in the default plugins list
+ - Fix a JRuby thread safety issue when using regular expression under multiple workers ([#4977](https://github.com/elastic/logstash/issues/4977)).
+ - Disable environment variables interpolation by default, this feature is now experimental to turn it on use the `--allow-env` flag ([#4958](https://github.com/elastic/logstash/issues/4958)).
+ - Hide sensitive data from from the log when shutting down a stale Logstash ([#4952](https://github.com/elastic/logstash/pull/4952)).
+ - Do not output the Configuration AST by default when running Logstash in debug mode, introduce `--debug-config` flag to display the AST ([#4965](https://github.com/elastic/logstash/issues/4964)).
+ - Fix the crash with the `--config-test` flag ([#4933](https://github.com/elastic/logstash/issues/4933)).
+ - Make filter conditionals work when running Logstash with the automatic configuration reloading. ([#4968](https://github.com/elastic/logstash/issues/4968)).
+ - Fix the stop command of the Ubuntu init script ([#4940](https://github.com/elastic/logstash/issues/4940)
+
+## input
+ - Beats 
+  - Do not use the identity map if we don't explicitly use the multiline codec ([#70](https://github.com/logstash-plugins/logstash-input-beats/pull/70)).
+
+## 2.3.0 (Mar 29, 2016)
+### general
+ - Added dynamic config, a new feature to track config file for changes and restart the 
+   pipeline (same process) with updated config changes. This feature can be enabled in two 
+   ways: Passing a CLI long-form option `--auto-reload` or with short-form `-r`. Another 
+   option, `--reload-interval <seconds>` controls how often LS should check the config files 
+   for changes. Alternatively, if you don't start with the CLI option, you can send SIGHUP 
+   or `kill -1` signal to LS to reload the config file, and restart the pipeline ([#4513](https://github.com/elastic/logstash/issues/4513)).
+ - Added support to evaluate environment variables inside the Logstash config. You can also specify a 
+   default if the variable is not defined. The syntax is `${myVar:default}` ([#3944](https://github.com/elastic/logstash/issues/3944)).
+ - Improved throughput performance across the board (up by 2x in some configs) by implementing Event 
+   representation in Java. Event is the main object that encapsulates data as it flows through 
+   Logstash and provides APIs for the plugins to perform processing. This change also enables 
+   faster serialization for future persistence work ([4191](https://github.com/elastic/logstash/issues/4191)).
+ - Added ability to configure custom garbage collection log file using `$LS_LOG_DIR`.
+ - Deprecated `bin/plugin` in favor of `bin/logstash-plugin`. In the next major version `bin/plugin` will 
+   be removed to prevent `PATH` being polluted when other components of the Elastic stack are installed on 
+   the same instance ([#4891](https://github.com/elastic/logstash/pull/4891)).
+ - Fixed a bug where new pipeline might break plugins by calling the `register` method twice causing 
+   undesired behavior ([#4851](https://github.com/elastic/logstash/issues/4851)).
+ - Made `JAVA_OPTS` and `LS_JAVA_OPTS` work consistently on Windows  ([#4758](https://github.com/elastic/logstash/pull/4758)).
+ - Fixed bug where specifying JMX parameters in `LS_JAVA_OPTS` caused Logstash not to restart properly
+   ([#4319](https://github.com/elastic/logstash/issues/4319)).
+ - Fixed a bug where upgrading plugins with Manticore threw an error and sometimes corrupted installation ([#4818](https://github.com/elastic/logstash/issues/4818)).
+ - Removed milestone warning that was displayed when the `--pluginpath` option was used to load plugins ([#4562](https://github.com/elastic/logstash/issues/4562)).
+ - Upgraded to JRuby 1.7.24.
+ - Reverted default output workers to 1. Perviously we had made output workers the same as number of pipeline
+   workers ([#4877](https://github.com/elastic/logstash/issues/4877)).
+   
+### input
+ - Beats
+   - Enhanced to verify client certificates against CA ([#8](https://github.com/logstash-plugins/logstash-input-beats/issues/8)).
+ - RabbitMQ
+   - Breaking Change: Metadata is now disabled by default because it was regressing performance.
+   - Improved performance by using an internal queue and bulk ACKs.
+ - Redis
+   - Increased the batch_size to 100 by default. This provides a big jump in throughput and 
+     reduction in CPU utilization ([#25](https://github.com/logstash-plugins/logstash-input-redis/issues/25)).
+ - JDBC
+   - Added retry connection feature ([#91](https://github.com/logstash-plugins/logstash-input-jdbc/issues/91)).
+   
+### filter
+  - DNS: 
+    - Improved performance by adding caches to both successful and failed requests.
+    - Added support for retrying with the `:max_retries` setting.
+    - Lowered the default value of timeout from 2 to 0.5 seconds.
+
+### output   
+  - Elasticsearch
+    - Bumped minimum manticore version to 0.5.4 which fixes a memory leak when sniffing 
+      is used ([#392](https://github.com/logstash-plugins/logstash-output-elasticsearch/issues/392)).
+    - Fixed bug when updating documents with doc_as_upsert and scripting.
+    - Made error messages more verbose and easier to parse by humans.
+    - Retryable failures are now logged at the info level instead of warning.
+
+## 2.1.0 (Nov 24, 2015)
+### general
+ - Added ability to install and upgrade Logstash plugins without requiring internet connectivity (#2376). 
+ - Support alternate or private Ruby gems server to install and update plugins (#3576).
+ - Added ability to reliably shutdown Logstash when there is a stall in event processing. This option 
+   can be enabled by passing `--allow-unsafe-shutdown` flag while starting Logstash. Please be aware that
+   any in-flight events will be lost when shutdown happens (#3451)
+ - Fixed a memory leak which could be triggered when events having a date were serialized to string (#4222).
+ - Added JDBC input to default package.
+ - Adding --debug to --configtest now shows the configuration in blocks annotated by source config file. Very
+   useful when using multiple config files in a directory. (#3243)
+ - Reset default worker threads to 1 when using non thread-safe filters like multiline (#4130).
+ - Fixed file permissions for the logrotate configuration file.
+ - Changed the default heap size from 500MB to 1GB (#3861)
+ - Fixed config check option when starting Logstash through init scripts (#3645)
+
+### input
+  Twitter
+    - Added an option to fetch data from the sample Twitter streaming endpoint (#21).
+    - Added hashtags, symbols and user_mentions as data for the non extended tweet event (#22).
+    - Added an option to filter per location and language (#20).
+    - Added an option to stream data from a list of users (#11).
+  Beats
+    - Properly handle multiline events from multiple sources, originating from Filebeat (#10).
+
+  File
+    - Properly handle multiline events from multiple sources (#44).
 
- ## output
- - HTTP: Fixed memory leak in http output with usage of manticore library (#24) 
+  Eventlog
+    - Change the underlying library to capture Event Logs from Windows more reliably (#11). 
+
+### output
+  Elasticsearch
+    - Improved the default template to use doc_values wherever possible.
+    - Improved the default template to disable fielddata on analyzed string fields.
+    - Added New setting: timeout. This lets you control the behavior of a slow/stuck request to Elasticsearch
+      that could be, for example, caused by network, firewall, or load balancer issues (#260).
 
 ## 2.0.0 (Oct 28, 2015)
 No additional changes from RC1 release. Please see below for changes in individual
@@ -17,7 +113,6 @@ pre-releases.
 ### filter
  - Fixed metrics filter to work with ES 2.0 changes which does not allow dots in field names
 
-
 ## 2.0.0-beta3 (October 19, 2015)
 ### general
  - Fixed bug in JrJackson v0.3.5 when handing shared strings. This manifested into issues when 
diff --git a/Gemfile b/Gemfile
index cef2642798b..6d1a3e0def4 100644
--- a/Gemfile
+++ b/Gemfile
@@ -2,7 +2,10 @@
 # If you modify this file manually all comments and formatting will be lost.
 
 source "https://rubygems.org"
-gem "logstash-core", "3.0.0.dev", :path => "."
+gem "logstash-core", "3.0.0.dev", :path => "./logstash-core"
+gem "logstash-core-event", "3.0.0.dev", :path => "./logstash-core-event"
+# gem "logstash-core-event-java", "3.0.0.dev", :path => "./logstash-core-event-java"
+gem "logstash-core-plugin-api", "1.0.0", :path => "./logstash-core-plugin-api"
 gem "file-dependencies", "0.1.6"
 gem "ci_reporter_rspec", "1.0.0", :group => :development
 gem "simplecov", :group => :development
diff --git a/Gemfile.jruby-1.9.lock b/Gemfile.jruby-1.9.lock
index a2accef2d25..0a8bf027261 100644
--- a/Gemfile.jruby-1.9.lock
+++ b/Gemfile.jruby-1.9.lock
@@ -1,32 +1,45 @@
 PATH
-  remote: .
+  remote: ./logstash-core
   specs:
     logstash-core (3.0.0.dev-java)
-      cabin (~> 0.7.0)
+      cabin (~> 0.8.0)
       clamp (~> 0.6.5)
-      concurrent-ruby (~> 0.9.1)
+      concurrent-ruby (= 0.9.2)
       filesize (= 0.0.4)
       gems (~> 0.8.3)
       i18n (= 0.6.9)
-      jrjackson (~> 0.3.5)
-      jruby-openssl (>= 0.9.11)
+      jrjackson (~> 0.3.7)
+      jruby-openssl (= 0.9.13)
+      logstash-core-event (= 3.0.0.dev)
       minitar (~> 0.5.4)
       pry (~> 0.10.1)
+      rubyzip (~> 1.1.7)
       stud (~> 0.0.19)
       thread_safe (~> 0.3.5)
       treetop (< 1.5.0)
 
+PATH
+  remote: ./logstash-core-event
+  specs:
+    logstash-core-event (3.0.0.dev-java)
+
+PATH
+  remote: ./logstash-core-plugin-api
+  specs:
+    logstash-core-plugin-api (1.0.0-java)
+      logstash-core (>= 2.0.0, <= 3.0.0.dev)
+
 GEM
   remote: https://rubygems.org/
   specs:
     addressable (2.3.8)
     arr-pm (0.0.10)
       cabin (> 0)
-    backports (3.6.6)
-    benchmark-ips (2.3.0)
+    backports (3.6.8)
+    benchmark-ips (2.5.0)
     builder (3.2.2)
-    cabin (0.7.1)
-    childprocess (0.5.6)
+    cabin (0.8.1)
+    childprocess (0.5.9)
       ffi (~> 1.0, >= 1.0.11)
     ci_reporter (2.0.0)
       builder (>= 2.1.2)
@@ -34,18 +47,16 @@ GEM
       ci_reporter (~> 2.0)
       rspec (>= 2.14, < 4)
     clamp (0.6.5)
-    coderay (1.1.0)
-    concurrent-ruby (0.9.1-java)
-    coveralls (0.8.3)
+    coderay (1.1.1)
+    concurrent-ruby (0.9.2-java)
+    coveralls (0.8.13)
       json (~> 1.8)
-      rest-client (>= 1.6.8, < 2)
-      simplecov (~> 0.10.0)
+      simplecov (~> 0.11.0)
       term-ansicolor (~> 1.3)
       thor (~> 0.19.1)
+      tins (~> 1.6.0)
     diff-lcs (1.2.5)
     docile (1.1.5)
-    domain_name (0.5.25)
-      unf (>= 0.0.5, < 1.0.0)
     faraday (0.9.2)
       multipart-post (>= 1.2, < 3)
     ffi (1.9.10-java)
@@ -63,14 +74,12 @@ GEM
       json (>= 1.7.7)
     gem_publisher (1.5.0)
     gems (0.8.3)
-    http-cookie (1.0.2)
-      domain_name (~> 0.5)
     i18n (0.6.9)
     insist (1.0.0)
-    jrjackson (0.3.5)
-    jruby-openssl (0.9.12-java)
+    jrjackson (0.3.8)
+    jruby-openssl (0.9.13-java)
     json (1.8.3-java)
-    kramdown (1.9.0)
+    kramdown (1.10.0)
     logstash-devutils (0.0.18-java)
       gem_publisher
       insist (= 1.0.0)
@@ -81,23 +90,17 @@ GEM
       rspec-wait
       stud (>= 0.0.20)
     method_source (0.8.2)
-    mime-types (2.6.2)
     minitar (0.5.4)
     multipart-post (2.0.0)
-    netrc (0.10.3)
     octokit (3.8.0)
       sawyer (~> 0.6.0, >= 0.5.3)
     polyglot (0.3.5)
-    pry (0.10.2-java)
+    pry (0.10.3-java)
       coderay (~> 1.1.0)
       method_source (~> 0.8.1)
       slop (~> 3.4)
       spoon (~> 0.0)
-    rake (10.4.2)
-    rest-client (1.8.0)
-      http-cookie (>= 1.0.2, < 2.0)
-      mime-types (>= 1.16, < 3.0)
-      netrc (~> 0.7)
+    rake (11.1.2)
     rspec (3.1.0)
       rspec-core (~> 3.1.0)
       rspec-expectations (~> 3.1.0)
@@ -110,13 +113,13 @@ GEM
     rspec-mocks (3.1.3)
       rspec-support (~> 3.1.0)
     rspec-support (3.1.2)
-    rspec-wait (0.0.7)
-      rspec (>= 2.11, < 3.4)
+    rspec-wait (0.0.8)
+      rspec (>= 2.11, < 3.5)
     rubyzip (1.1.7)
     sawyer (0.6.0)
       addressable (~> 2.3.5)
       faraday (~> 0.8, < 0.10)
-    simplecov (0.10.0)
+    simplecov (0.11.2)
       docile (~> 1.1.0)
       json (~> 1.8)
       simplecov-html (~> 0.10.0)
@@ -133,7 +136,6 @@ GEM
     treetop (1.4.15)
       polyglot
       polyglot (>= 0.3.1)
-    unf (0.1.4-java)
 
 PLATFORMS
   java
@@ -147,9 +149,12 @@ DEPENDENCIES
   fpm (~> 1.3.3)
   gems (~> 0.8.3)
   logstash-core (= 3.0.0.dev)!
+  logstash-core-event (= 3.0.0.dev)!
+  logstash-core-plugin-api (= 1.0.0)!
   logstash-devutils (~> 0.0.15)
   octokit (= 3.8.0)
   rspec (~> 3.1.0)
   rubyzip (~> 1.1.7)
   simplecov
   stud (~> 0.0.21)
+  tins (= 1.6)
diff --git a/LICENSE b/LICENSE
index 8026afdc77f..43976b73b2b 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,4 +1,4 @@
-Copyright (c) 2012–2015 Elasticsearch <http://www.elastic.co>
+Copyright (c) 2012–2016 Elasticsearch <http://www.elastic.co>
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
diff --git a/README.md b/README.md
index 7c908bfa0bf..7d6389ea702 100644
--- a/README.md
+++ b/README.md
@@ -2,15 +2,15 @@
 
 ### Build status
 
-| Branch | master   | 2.0 | 1.5
+| Branch | master | 2.x | 2.1
 |---|---|---|---|
-| core |[![Build Status](http://build-eu-00.elastic.co/view/LS%20Master/job/logstash_regression_master/badge/icon)](http://build-eu-00.elastic.co/view/LS%20Master/job/logstash_regression_master/)   | [![Build Status](http://build-eu-00.elastic.co/view/LS%202.0/job/logstash_regression_20/badge/icon)](http://build-eu-00.elastic.co/view/LS%202.0/job/logstash_regression_20/)  | [![Build Status](http://build-eu-00.elastic.co/view/LS%201.5/job/logstash_regression_15/badge/icon)](http://build-eu-00.elastic.co/view/LS%201.5/job/logstash_regression_15/)   |
-| integration | [![Build Status](http://build-eu-00.elastic.co/view/LS%20Master/job/Logstash_Master_Default_Plugins/badge/icon)](http://build-eu-00.elastic.co/view/LS%20Master/job/Logstash_Master_Default_Plugins/) | [![Build Status](http://build-eu-00.elastic.co/view/LS%202.0/job/Logstash_Default_Plugins_20/badge/icon)](http://build-eu-00.elastic.co/view/LS%202.0/job/Logstash_Default_Plugins_20/) | [![Build Status](http://build-eu-00.elastic.co/view/LS%201.5/job/Logstash_15_Default_Plugins/badge/icon)](http://build-eu-00.elastic.co/view/LS%201.5/job/Logstash_15_Default_Plugins/) |
+| core | [![Build Status](http://build-eu-00.elastic.co/view/LS%20Master/job/logstash_regression_master/badge/icon)](http://build-eu-00.elastic.co/view/LS%20Master/job/logstash_regression_master/) | [![Build Status](http://build-eu-00.elastic.co/view/LS%202.x/job/logstash_regression_2x/badge/icon)](http://build-eu-00.elastic.co/view/LS%202.x/job/logstash_regression_2x/) | [![Build Status](http://build-eu-00.elastic.co/view/LS%202.x/job/logstash_regression_21/badge/icon)](http://build-eu-00.elastic.co/view/LS%202.x/job/logstash_regression_21/) |
+| integration | [![Build Status](http://build-eu-00.elastic.co/view/LS%20Master/job/Logstash_Master_Default_Plugins/badge/icon)](http://build-eu-00.elastic.co/view/LS%20Master/job/Logstash_Master_Default_Plugins/) | [![Build Status](http://build-eu-00.elastic.co/view/LS%202.x/job/Logstash_Default_Plugins_2x/badge/icon)](http://build-eu-00.elastic.co/view/LS%202.x/job/Logstash_Default_Plugins_2x/) | [![Build Status](http://build-eu-00.elastic.co/view/LS%202.x/job/Logstash_Default_Plugins_21/badge/icon)](http://build-eu-00.elastic.co/view/LS%202.x/job/Logstash_Default_Plugins_21/) |
 
 Logstash is a tool for managing events and logs. You can use it to collect
 logs, parse them, and store them for later use (like, for searching).  If you
-store them in [Elasticsearch](http://www.elastic.co/guide/en/elasticsearch/reference/current/index.html),
-you can view and analyze them with [Kibana](http://www.elastic.co/guide/en/kibana/current/index.html).
+store them in [Elasticsearch](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html),
+you can view and analyze them with [Kibana](https://www.elastic.co/guide/en/kibana/current/index.html).
 
 It is fully free and fully open source. The license is Apache 2.0, meaning you
 are pretty much free to use it however you want in whatever way.
@@ -25,7 +25,7 @@ repositories under the [logstash-plugins](https://github.com/logstash-plugins) g
 gets published to RubyGems.org. Logstash has added plugin infrastructure to easily maintain the lifecyle of the plugin.
 For more details and rationale behind these changes, see our [blogpost](https://www.elastic.co/blog/plugin-ecosystem-changes/).
 
-[Elasticsearch logstash-contrib repo](https://github.com/elasticsearch/logstash-contrib) is deprecated. We
+[Elasticsearch logstash-contrib repo](https://github.com/elastic/logstash-contrib) is deprecated. We
 have moved all of the plugins that existed there into their own repositories. We are migrating all of the pull requests
 and issues from logstash-contrib to the new repositories.
 
@@ -43,7 +43,7 @@ Logstash core will continue to exist under this repository and all related issue
 
 - [#logstash on freenode IRC](https://webchat.freenode.net/?channels=logstash)
 - [logstash-users on Google Groups](https://groups.google.com/d/forum/logstash-users)
-- [Logstash Documentation](http://www.elastic.co/guide/en/logstash/current/index.html)
+- [Logstash Documentation](https://www.elastic.co/guide/en/logstash/current/index.html)
 - [Logstash Product Information](https://www.elastic.co/products/logstash)
 - [Elastic Support](https://www.elastic.co/subscriptions)
 
@@ -87,11 +87,6 @@ For testing you can use the *test* `rake` tasks and the `bin/rspec` command, see
     bin/rspec
     bin/rspec spec/foo/bar_spec.rb
 
----
-Note that if a plugin is installed using the plugin manager `bin/plugin install ...` do not forget to also install the plugins development dependencies using the following command after the plugin installation:
-
-    bin/plugin install --development
-
 ### Plugins tests
 
 To run the tests of all currently installed plugins:
@@ -119,7 +114,7 @@ The documentation for developing plugins can be found in the plugins README, see
 
 ## Drip Launcher
 
-[Drip](https://github.com/ninjudd/drip) is a tool which help solve the slow JVM startup problem. The drip script is intended to be a drop-in replacement for the java command. We recommend using drip during development, in particular for running tests. Using drip, the first invokation of a command will not be faster but the subsequent commands will be swift.
+[Drip](https://github.com/ninjudd/drip) is a tool that solves the slow JVM startup problem. The drip script is intended to be a drop-in replacement for the java command. We recommend using drip during development, in particular for running tests. Using drip, the first invocation of a command will not be faster but the subsequent commands will be swift.
 
 To tell logstash to use drip, either set the `USE_DRIP=1` environment variable or set `` JAVACMD=`which drip` ``.
 
@@ -130,7 +125,7 @@ Examples:
 
 **Caveats**
 
-Drip does not work with STDIN. You cannot use drip for running configs which uses the stdin plugin.
+Drip does not work with STDIN. You cannot use drip for running configs which use the stdin plugin.
 
 
 ## Building
diff --git a/Rakefile b/Rakefile
index cf702f08752..12b4a262110 100644
--- a/Rakefile
+++ b/Rakefile
@@ -1,6 +1,7 @@
 # encoding: utf-8
 
 $: << File.join(File.dirname(__FILE__), "lib")
+$: << File.join(File.dirname(__FILE__), "logstash-core/lib")
 
 task "default" => "help"
 
diff --git a/STYLE.md b/STYLE.md
index 894a31e88f3..5bc54a31766 100644
--- a/STYLE.md
+++ b/STYLE.md
@@ -27,6 +27,7 @@ Do this:
 * parentheses on function definitions/calls
 * explicit is better than implicit
   * implicit returns are forbidden except in the case of a single expression 
+* Avoid use of 'and' and 'or' in ruby code 
 
 The point is consistency and documentation. If you see inconsistencies, let me
 know, and I'll fix them :)
diff --git a/bin/logstash b/bin/logstash
index 02e4446009c..cb12395e1be 100755
--- a/bin/logstash
+++ b/bin/logstash
@@ -9,7 +9,7 @@
 # See 'bin/logstash help' for a list of commands.
 #
 # Supported environment variables:
-#   LS_HEAP_SIZE="xxx" size for the -Xmx${LS_HEAP_SIZE} maximum Java heap size option, default is "500m"
+#   LS_HEAP_SIZE="xxx" size for the -Xmx${LS_HEAP_SIZE} maximum Java heap size option, default is "1g"
 #   LS_JAVA_OPTS="xxx" to append extra options to the defaults JAVA_OPTS provided by logstash
 #   JAVA_OPTS="xxx" to *completely override* the defauls set of JAVA_OPTS provided by logstash
 #
@@ -19,7 +19,31 @@
 #   DEBUG=1 to output debugging information
 
 unset CDPATH
-. "$(cd `dirname $0`/..; pwd)/bin/logstash.lib.sh"
+# This unwieldy bit of scripting is to try to catch instances where Logstash
+# was launched from a symlink, rather than a full path to the Logstash binary
+if [ -L $0 ]; then
+  # Launched from a symlink
+  # --Test for the readlink binary
+  RL=$(which readlink)
+  if [ $? -eq 0 ]; then
+    # readlink exists
+    SOURCEPATH=$($RL $0)
+  else
+    # readlink not found, attempt to parse the output of stat
+    SOURCEPATH=$(stat -c %N $0 | awk '{print $3}' | sed -e 's/\‘//' -e 's/\’//')
+    if [ $? -ne 0 ]; then
+      # Failed to execute or parse stat
+      echo "Failed to find source library at path $(cd `dirname $0`/..; pwd)/bin/logstash.lib.sh"
+      echo "You may need to launch Logstash with a full path instead of a symlink."
+      exit 1
+    fi
+  fi
+else
+  # Not a symlink
+  SOURCEPATH=$0
+fi
+
+. "$(cd `dirname $SOURCEPATH`/..; pwd)/bin/logstash.lib.sh"
 setup
 
 case $1 in
diff --git a/bin/logstash-plugin b/bin/logstash-plugin
new file mode 100755
index 00000000000..39b19b8df30
--- /dev/null
+++ b/bin/logstash-plugin
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+unset CDPATH
+. "$(cd `dirname $0`/..; pwd)/bin/logstash.lib.sh"
+setup
+
+# bin/plugin is a short lived ruby script thus we can use aggressive "faster starting JRuby options"
+# see https://github.com/jruby/jruby/wiki/Improving-startup-time
+export JRUBY_OPTS="$JRUBY_OPTS -J-XX:+TieredCompilation -J-XX:TieredStopAtLevel=1 -J-noverify -X-C -Xcompile.invokedynamic=false"
+
+ruby_exec "${LOGSTASH_HOME}/lib/pluginmanager/main.rb" "$@"
diff --git a/bin/logstash-plugin.bat b/bin/logstash-plugin.bat
new file mode 100644
index 00000000000..4248264869f
--- /dev/null
+++ b/bin/logstash-plugin.bat
@@ -0,0 +1,15 @@
+@echo off
+
+SETLOCAL
+
+set SCRIPT_DIR=%~dp0
+CALL "%SCRIPT_DIR%\setup.bat"
+
+:EXEC
+if "%VENDORED_JRUBY%" == "" (
+  %RUBYCMD% "%LS_HOME%\lib\pluginmanager\main.rb" %*
+) else (
+  %JRUBY_BIN% %jruby_opts% "%LS_HOME%\lib\pluginmanager\main.rb" %*
+)
+
+ENDLOCAL
diff --git a/bin/logstash.lib.sh b/bin/logstash.lib.sh
index a5d6ccee3ec..c2058e5d5c7 100755
--- a/bin/logstash.lib.sh
+++ b/bin/logstash.lib.sh
@@ -1,5 +1,29 @@
 unset CDPATH
-LOGSTASH_HOME=$(cd `dirname $0`/..; pwd)
+# This unwieldy bit of scripting is to try to catch instances where Logstash
+# was launched from a symlink, rather than a full path to the Logstash binary
+if [ -L $0 ]; then
+  # Launched from a symlink
+  # --Test for the readlink binary
+  RL=$(which readlink)
+  if [ $? -eq 0 ]; then
+    # readlink exists
+    SOURCEPATH=$($RL $0)
+  else
+    # readlink not found, attempt to parse the output of stat
+    SOURCEPATH=$(stat -c %N $0 | awk '{print $3}' | sed -e 's/\‘//' -e 's/\’//')
+    if [ $? -ne 0 ]; then
+      # Failed to execute or parse stat
+      echo "Failed to set LOGSTASH_HOME from $(cd `dirname $0`/..; pwd)/bin/logstash.lib.sh"
+      echo "You may need to launch Logstash with a full path instead of a symlink."
+      exit 1
+    fi
+  fi
+else
+  # Not a symlink
+  SOURCEPATH=$0
+fi
+
+LOGSTASH_HOME=$(cd `dirname $SOURCEPATH`/..; pwd)
 export LOGSTASH_HOME
 
 # Defaults you can override with environment variables
@@ -35,6 +59,11 @@ setup_java() {
 
     JAVA_OPTS="$JAVA_OPTS -XX:CMSInitiatingOccupancyFraction=75"
     JAVA_OPTS="$JAVA_OPTS -XX:+UseCMSInitiatingOccupancyOnly"
+    # Causes the JVM to dump its heap on OutOfMemory.
+    JAVA_OPTS="$JAVA_OPTS -XX:+HeapDumpOnOutOfMemoryError"
+    # The path to the heap dump location
+    # This variable needs to be isolated since it may contain spaces
+    HEAP_DUMP_PATH="-XX:HeapDumpPath=${LOGSTASH_HOME}/heapdump.hprof"
   fi
 
   if [ "$LS_JAVA_OPTS" ] ; then
@@ -48,13 +77,16 @@ setup_java() {
   fi
 
   if [ "$LS_USE_GC_LOGGING" ] ; then
+    if [ -z "$LS_GC_LOG_FILE" ] ; then
+      LS_GC_LOG_FILE="./logstash-gc.log"
+    fi
     JAVA_OPTS="$JAVA_OPTS -XX:+PrintGCDetails"
     JAVA_OPTS="$JAVA_OPTS -XX:+PrintGCTimeStamps"
     JAVA_OPTS="$JAVA_OPTS -XX:+PrintClassHistogram"
     JAVA_OPTS="$JAVA_OPTS -XX:+PrintTenuringDistribution"
     JAVA_OPTS="$JAVA_OPTS -XX:+PrintGCApplicationStoppedTime"
-    JAVA_OPTS="$JAVA_OPTS -Xloggc:./logstash-gc.log"
-    echo "Writing garbage collection logs to ./logstash-gc.log"
+    JAVA_OPTS="$JAVA_OPTS -Xloggc:${LS_GC_LOG_FILE}"
+    echo "Writing garbage collection logs to ${LS_GC_LOG_FILE}"
   fi
 
   export JAVACMD
@@ -147,8 +179,8 @@ ruby_exec() {
     # $VENDORED_JRUBY is non-empty so use the vendored JRuby
 
     if [ "$DEBUG" ] ; then
-      echo "DEBUG: exec ${JRUBY_BIN} $(jruby_opts) $@"
+      echo "DEBUG: exec ${JRUBY_BIN} $(jruby_opts) "-J$HEAP_DUMP_PATH" $@"
     fi
-    exec "${JRUBY_BIN}" $(jruby_opts) "$@"
+    exec "${JRUBY_BIN}" $(jruby_opts) "-J$HEAP_DUMP_PATH" "$@"
   fi
 }
diff --git a/bin/plugin b/bin/plugin
index 39b19b8df30..aa2bafccdf6 100755
--- a/bin/plugin
+++ b/bin/plugin
@@ -1,11 +1,6 @@
 #!/bin/sh
 
-unset CDPATH
-. "$(cd `dirname $0`/..; pwd)/bin/logstash.lib.sh"
-setup
-
-# bin/plugin is a short lived ruby script thus we can use aggressive "faster starting JRuby options"
-# see https://github.com/jruby/jruby/wiki/Improving-startup-time
-export JRUBY_OPTS="$JRUBY_OPTS -J-XX:+TieredCompilation -J-XX:TieredStopAtLevel=1 -J-noverify -X-C -Xcompile.invokedynamic=false"
+echo "The use of bin/plugin is deprecated and will be removed in a feature release. Please use bin/logstash-plugin."
 
-ruby_exec "${LOGSTASH_HOME}/lib/pluginmanager/main.rb" "$@"
+unset CDPATH
+sh "$(cd `dirname $0`/..; pwd)/bin/logstash-plugin" "$@"
diff --git a/bin/plugin.bat b/bin/plugin.bat
index 4248264869f..46c8a60e0de 100644
--- a/bin/plugin.bat
+++ b/bin/plugin.bat
@@ -2,14 +2,7 @@
 
 SETLOCAL
 
-set SCRIPT_DIR=%~dp0
-CALL "%SCRIPT_DIR%\setup.bat"
-
-:EXEC
-if "%VENDORED_JRUBY%" == "" (
-  %RUBYCMD% "%LS_HOME%\lib\pluginmanager\main.rb" %*
-) else (
-  %JRUBY_BIN% %jruby_opts% "%LS_HOME%\lib\pluginmanager\main.rb" %*
-)
+ECHO "The use of bin/plugin is deprecated and will be removed in a feature release. Please use bin/logstash-plugin."
 
-ENDLOCAL
+set SCRIPT_DIR=%~dp0
+CALL "%SCRIPT_DIR%\logstash-plugin.bat" %*
diff --git a/bin/setup.bat b/bin/setup.bat
index 557df31e1a9..f2ac30383f8 100644
--- a/bin/setup.bat
+++ b/bin/setup.bat
@@ -15,40 +15,58 @@ goto finally
 
 :setup_jruby
 REM setup_java()
+if not defined JAVA_HOME IF EXIST %ProgramData%\Oracle\java\javapath\java.exe (
+    for /f "tokens=2 delims=[]" %%a in ('dir %ProgramData%\Oracle\java\javapath\java.exe') do @set JAVA_EXE=%%a
+)
+if defined JAVA_EXE set JAVA_HOME=%JAVA_EXE:\bin\java.exe=%
+if defined JAVA_EXE echo Using JAVA_HOME=%JAVA_HOME% retrieved from %ProgramData%\Oracle\java\javapath\java.exe
+
 if not defined JAVA_HOME goto missing_java_home
 REM ***** JAVA options *****
 
 if "%LS_HEAP_SIZE%" == "" (
-set LS_HEAP_SIZE=1g
+    set LS_HEAP_SIZE=1g
+)
+
+IF NOT "%JAVA_OPTS%" == "" (
+    ECHO JAVA_OPTS was set to [%JAVA_OPTS%]. Logstash will trust these options, and not set any defaults that it might usually set
+    goto opts_defined
 )
 
-set JAVA_OPTS=%JAVA_OPTS% -Xmx%LS_HEAP_SIZE%
-
-REM Enable aggressive optimizations in the JVM
-REM    - Disabled by default as it might cause the JVM to crash
-REM set JAVA_OPTS=%JAVA_OPTS% -XX:+AggressiveOpts
-
-set JAVA_OPTS=%JAVA_OPTS% -XX:+UseParNewGC
-set JAVA_OPTS=%JAVA_OPTS% -XX:+UseConcMarkSweepGC
-set JAVA_OPTS=%JAVA_OPTS% -XX:+CMSParallelRemarkEnabled
-set JAVA_OPTS=%JAVA_OPTS% -XX:SurvivorRatio=8
-set JAVA_OPTS=%JAVA_OPTS% -XX:MaxTenuringThreshold=1
-set JAVA_OPTS=%JAVA_OPTS% -XX:CMSInitiatingOccupancyFraction=75
-set JAVA_OPTS=%JAVA_OPTS% -XX:+UseCMSInitiatingOccupancyOnly
-
-REM GC logging options -- uncomment to enable
-REM JAVA_OPTS=%JAVA_OPTS% -XX:+PrintGCDetails
-REM JAVA_OPTS=%JAVA_OPTS% -XX:+PrintGCTimeStamps
-REM JAVA_OPTS=%JAVA_OPTS% -XX:+PrintClassHistogram
-REM JAVA_OPTS=%JAVA_OPTS% -XX:+PrintTenuringDistribution
-REM JAVA_OPTS=%JAVA_OPTS% -XX:+PrintGCApplicationStoppedTime
-REM JAVA_OPTS=%JAVA_OPTS% -Xloggc:/var/log/logstash/gc.log
-
-REM Causes the JVM to dump its heap on OutOfMemory.
-set JAVA_OPTS=%JAVA_OPTS% -XX:+HeapDumpOnOutOfMemoryError
-REM The path to the heap dump location, note directory must exists and have enough
-REM space for a full heap dump.
-REM JAVA_OPTS=%JAVA_OPTS% -XX:HeapDumpPath="$LS_HOME/logs/heapdump.hprof"
+    SET JAVA_OPTS=%JAVA_OPTS% -Xmx%LS_HEAP_SIZE%
+
+    REM Enable aggressive optimizations in the JVM
+    REM    - Disabled by default as it might cause the JVM to crash
+    REM set JAVA_OPTS=%JAVA_OPTS% -XX:+AggressiveOpts
+
+    SET JAVA_OPTS=%JAVA_OPTS% -XX:+UseParNewGC
+    SET JAVA_OPTS=%JAVA_OPTS% -XX:+UseConcMarkSweepGC
+    SET JAVA_OPTS=%JAVA_OPTS% -XX:+CMSParallelRemarkEnabled
+    SET JAVA_OPTS=%JAVA_OPTS% -XX:SurvivorRatio=8
+    SET JAVA_OPTS=%JAVA_OPTS% -XX:MaxTenuringThreshold=1
+    SET JAVA_OPTS=%JAVA_OPTS% -XX:CMSInitiatingOccupancyFraction=75
+    SET JAVA_OPTS=%JAVA_OPTS% -XX:+UseCMSInitiatingOccupancyOnly
+
+    REM GC logging options -- uncomment to enable
+    REM JAVA_OPTS=%JAVA_OPTS% -XX:+PrintGCDetails
+    REM JAVA_OPTS=%JAVA_OPTS% -XX:+PrintGCTimeStamps
+    REM JAVA_OPTS=%JAVA_OPTS% -XX:+PrintClassHistogram
+    REM JAVA_OPTS=%JAVA_OPTS% -XX:+PrintTenuringDistribution
+    REM JAVA_OPTS=%JAVA_OPTS% -XX:+PrintGCApplicationStoppedTime
+    REM JAVA_OPTS=%JAVA_OPTS% -Xloggc:/var/log/logstash/gc.log
+
+    REM Causes the JVM to dump its heap on OutOfMemory.
+    SET JAVA_OPTS=%JAVA_OPTS% -XX:+HeapDumpOnOutOfMemoryError
+    REM The path to the heap dump location, note directory must exists and have enough
+    REM space for a full heap dump.
+    SET JAVA_OPTS=%JAVA_OPTS% -XX:HeapDumpPath="$LS_HOME/heapdump.hprof"
+:opts_defined
+
+
+IF NOT "%LS_JAVA_OPTS%" == "" (
+    ECHO LS_JAVA_OPTS was set to [%LS_JAVA_OPTS%]. This will be appended to the JAVA_OPTS [%JAVA_OPTS%]
+    SET JAVA_OPTS=%JAVA_OPTS% %LS_JAVA_OPTS%
+)
 
 REM setup_vendored_jruby()
 set JRUBY_BIN="%LS_HOME%\vendor\jruby\bin\jruby"
diff --git a/ci/ci_setup.sh b/ci/ci_setup.sh
index fea695cb2c5..30795f47c5f 100755
--- a/ci/ci_setup.sh
+++ b/ci/ci_setup.sh
@@ -13,6 +13,11 @@ rm -rf vendor       # make sure there are no vendorized dependencies
 rm -rf .bundle
 rm -rf spec/reports # no stale spec reports from previous executions
 
+# Since we are using the system jruby, we need to make sure our jvm process
+# uses at least 1g of memory, If we don't do this we can get OOM issues when
+# installing gems. See https://github.com/elastic/logstash/issues/5179
+export JRUBY_OPTS="-J-Xmx1g"
+
 # Setup the environment
 rake bootstrap # Bootstrap your logstash instance
 
diff --git a/ci/ci_test.sh b/ci/ci_test.sh
index c0eadda6424..c9b7e9d9736 100755
--- a/ci/ci_test.sh
+++ b/ci/ci_test.sh
@@ -5,6 +5,11 @@
 # running the test suites here.
 ##
 
+# Since we are using the system jruby, we need to make sure our jvm process
+# uses at least 1g of memory, If we don't do this we can get OOM issues when
+# installing gems. See https://github.com/elastic/logstash/issues/5179
+export JRUBY_OPTS="-J-Xmx1g"
+
 SELECTED_TEST_SUITE=$1
 
 if [[ $SELECTED_TEST_SUITE == $"core-fail-fast" ]]; then
diff --git a/docs/asciidoc/static/command-line-flags.asciidoc b/docs/asciidoc/static/command-line-flags.asciidoc
deleted file mode 100644
index 839b162901b..00000000000
--- a/docs/asciidoc/static/command-line-flags.asciidoc
+++ /dev/null
@@ -1,49 +0,0 @@
-[[command-line-flags]]
-=== Command-line flags
-
-Logstash has the following flags. You can use the `--help` flag to display this information.
-
-[source,shell]
-----------------------------------
--f, --config CONFIGFILE
- Load the Logstash config from a specific file, directory, or a wildcard. If
- given a directory or wildcard, config files will be read from the directory in
- alphabetical order.
-
--e CONFIGSTRING
- Use the given string as the configuration data. Same syntax as the config file.
- If not input is specified, 'stdin { type => stdin }' is default. If no output
- is specified, 'stdout { codec => rubydebug }}' is default.
-
--w, --filterworkers COUNT
- Sets the number of filter workers to run (default: half the number of cores)
-
--l, --log FILE
- Log to a given path. Default is to log to stdout
-
---verbose
- Increase verbosity to the first level (info), less verbose.
-
---debug
- Increase verbosity to the last level (trace), more verbose.
-
--V, --version
-  Display the version of Logstash.
-
--p, --pluginpath
-  A path of where to find plugins. This flag can be given multiple times to include
-  multiple paths. Plugins are expected to be in a specific directory hierarchy:
-  'PATH/logstash/TYPE/NAME.rb' where TYPE is 'inputs' 'filters', 'outputs' or 'codecs'
-  and NAME is the name of the plugin.
-
--t, --configtest
-  Checks configuration and then exit. Note that grok patterns are not checked for 
-  correctness with this flag
-
--h, --help
-  Print help  
-
--v
- *DEPRECATED: see --verbose/debug* Increase verbosity. There are multiple levels
- of verbosity available with '-vv' currently being the highest
-----------------------------------
diff --git a/docs/asciidoc/static/getting-started-with-logstash.asciidoc b/docs/asciidoc/static/getting-started-with-logstash.asciidoc
deleted file mode 100644
index 354200b548d..00000000000
--- a/docs/asciidoc/static/getting-started-with-logstash.asciidoc
+++ /dev/null
@@ -1,57 +0,0 @@
-[[getting-started-with-logstash]]
-== Getting Started with Logstash
-
-This section guides you through the process of installing Logstash and verifying that everything is running properly. 
-Later sections deal with increasingly complex configurations to address selected use cases.
-
-[float]
-[[installing-logstash]]
-=== Install Logstash
-
-NOTE: Logstash requires Java 7 or later. Use the 
-http://www.oracle.com/technetwork/java/javase/downloads/index.html[official Oracle distribution] or an open-source 
-distribution such as http://openjdk.java.net/[OpenJDK].
-
-To check your Java version, run the following command:
-
-[source,shell]
-java -version
-
-On systems with Java installed, this command produces output similar to the following:
-
-[source,shell]
-java version "1.7.0_45"
-Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
-Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
-
-[float]
-[[installing-binary]]
-==== Installing from a downloaded binary
-
-Download the https://www.elastic.co/downloads/logstash[Logstash installation file] that matches your host environment. 
-Unpack the file. On supported Linux operating systems, you can <<package-repositories,use a package manager>> to 
-install Logstash.
-
-[[first-event]]
-=== Stashing Your First Event: Basic Logstash Example
-
-To test your Logstash installation, run the most basic Logstash pipeline:
-
-[source,shell]
-cd logstash-{logstash_version}
-bin/logstash -e 'input { stdin { } } output { stdout {} }'
-
-The `-e` flag enables you to specify a configuration directly from the command line. Specifying configurations at the 
-command line lets you quickly test configurations without having to edit a file between iterations.
-This pipeline takes input from the standard input, `stdin`, and moves that input to the standard output, `stdout`, in a 
-structured format. Type hello world at the command prompt to see Logstash respond:
-
-[source,shell]
-hello world
-2013-11-21T01:22:14.405+0000 0.0.0.0 hello world
-
-Logstash adds timestamp and IP address information to the message. Exit Logstash by issuing a *CTRL-D* command in the 
-shell where Logstash is running.
-
-The <<advanced-pipeline,Advanced Tutorial>> expands the capabilities of your Logstash instance to cover broader 
-use cases.
diff --git a/docs/asciidoc/static/howtos-and-tutorials.asciidoc b/docs/asciidoc/static/howtos-and-tutorials.asciidoc
deleted file mode 100644
index fe98a8e0cb9..00000000000
--- a/docs/asciidoc/static/howtos-and-tutorials.asciidoc
+++ /dev/null
@@ -1,16 +0,0 @@
-[[howtos-and-tutorials]]
-== Logstash HOWTOs and Tutorials
-Pretty self-explanatory, really
-
-=== Downloads and Releases
-* http://elasticsearch.org/#[Getting Started with Logstash]
-* http://elasticsearch.org/#[Configuration file overview]
-* http://elasticsearch.org/#[Command-line flags]
-* http://elasticsearch.org/#[The life of an event in Logstash]
-* http://elasticsearch.org/#[Using conditional logic]
-* http://elasticsearch.org/#[Glossary]
-* http://elasticsearch.org/#[referring to fields `[like][this]`]
-* http://elasticsearch.org/#[using the `%{fieldname}` syntax]
-* http://elasticsearch.org/#[Metrics from Logs]
-* http://elasticsearch.org/#[Using RabbitMQ]
-* http://elasticsearch.org/#[Contributing to Logstash]
diff --git a/docs/asciidoc/static/images/deploy_3.png b/docs/asciidoc/static/images/deploy_3.png
deleted file mode 100644
index cda4337fa9d..00000000000
Binary files a/docs/asciidoc/static/images/deploy_3.png and /dev/null differ
diff --git a/docs/asciidoc/static/life-of-an-event.asciidoc b/docs/asciidoc/static/life-of-an-event.asciidoc
deleted file mode 100644
index 569bd545f7c..00000000000
--- a/docs/asciidoc/static/life-of-an-event.asciidoc
+++ /dev/null
@@ -1,176 +0,0 @@
-[[pipeline]]
-=== Logstash Processing Pipeline
-
-The Logstash event processing pipeline has three stages: inputs -> filters ->
-outputs. Inputs generate events, filters modify them, and outputs ship them
-elsewhere. Inputs and outputs support codecs that enable you to encode or decode
-the data as it enters or exits the pipeline without having to use a separate
-filter.
-
-[float]
-==== Inputs
-You use inputs to get data into Logstash. Some of the more commonly-used inputs
-are:
-
-* *file*: reads from a file on the filesystem, much like the UNIX command
-`tail -0F`
-* *syslog*: listens on the well-known port 514 for syslog messages and parses
-according to the RFC3164 format
-* *redis*: reads from a redis server, using both redis channels and redis lists.
-Redis is often used as a "broker" in a centralized Logstash installation, which
-queues Logstash events from remote Logstash "shippers".
-* *lumberjack*: processes events sent in the lumberjack protocol. Now called
-https://github.com/elastic/logstash-forwarder[logstash-forwarder].
-
-For more information about the available inputs, see
-<<input-plugins,Input Plugins>>.
-
-[float]
-==== Filters
-Filters are intermediary processing devices in the Logstash pipeline. You can
-combine filters with conditionals to perform an action on an event if it meets
-certain criteria. Some useful filters include:
-
-* *grok*: parse and structure arbitrary text. Grok is currently the best way in
-Logstash to parse unstructured log data into something structured and queryable.
-With 120 patterns built-in to Logstash, it's more than likely you'll find one
-that meets your needs!
-* *mutate*: perform general transformations on event fields. You can rename,
-remove, replace, and modify fields in your events.
-* *drop*: drop an event completely, for example, 'debug' events.
-* *clone*: make a copy of an event, possibly adding or removing fields.
-* *geoip*: add information about geographical location of IP addresses (also
-displays amazing charts in Kibana!)
-
-For more information about the available filters, see
-<<filter-plugins,Filter Plugins>>.
-
-[float]
-==== Outputs
-Outputs are the final phase of the Logstash pipeline. An event can pass through
-multiple outputs, but once all output processing is complete, the event has
-finished its execution. Some commonly used outputs include:
-
-* *elasticsearch*: send event data to Elasticsearch. If you're planning to save
-your data in an efficient, convenient, and easily queryable format...
-Elasticsearch is the way to go. Period. Yes, we're biased :)
-* *file*: write event data to a file on disk.
-* *graphite*: send event data to graphite, a popular open source tool for
-storing and graphing metrics. http://graphite.wikidot.com/
-* *statsd*: send event data to statsd, a service that "listens for statistics,
-like counters and timers, sent over UDP and sends aggregates to one or more
-pluggable backend services". If you're already using statsd, this could be
-useful for you!
-
-For more information about the available outputs, see
-<<output-plugins,Output Plugins>>.
-
-[float]
-==== Codecs
-Codecs are basically stream filters that can operate as part of an input or
-output. Codecs enable you to easily separate the transport of your messages from
-the serialization process. Popular codecs include `json`, `msgpack`, and `plain`
-(text).
-
-* *json*: encode or decode data in the JSON format.
-* *multiline*: merge multiple-line text events such as java exception and
-stacktrace messages into a single event.
-
-For more information about the available codecs, see
-<<codec-plugins,Codec Plugins>>.
-
-[float]
-=== Fault Tolerance
-
-Events are passed from stage to stage using internal queues implemented with a
-Ruby `SizedQueue`. A `SizedQueue` has a maximum number of items it can contain.
-When the queue is at maximum capacity, all writes to the queue are blocked.
-
-Logstash sets the size of each queue to 20. This means a maximum of 20 events
-can be pending for the next stage, which helps prevent data loss and keeps
-Logstash from acting as a data storage system. These internal queues are not
-intended for storing messages long-term.
-
-The small queue sizes mean that Logstash simply blocks and stalls safely when
-there's a heavy load or temporary pipeline problems. The alternatives would be
-to either have an unlimited queue or drop messages when there's a problem. An
-unlimited queue can grow unbounded and eventually exceed memory, causing a crash
-that loses all of the queued messages. In most cases, dropping messages outright
-is equally undesirable.
-
-An output can fail or have problems due to downstream issues, such as a full
-disk, permissions problems, temporary network failures, or service outages. Most
-outputs keep retrying to ship events affected by the failure.
-
-If an output is failing, the output thread waits until the output is able to
-successfully send the message. The output stops reading from the output queue,
-which means the queue can fill up with events.
-
-When the output queue is full, filters are blocked because they cannot write new
-events to the output queue. While they are blocked from writing to the output
-queue, filters stop reading from the filter queue. Eventually, this can cause
-the filter queue (input -> filter) to fill up.
-
-A full filter queue blocks inputs from writing to the filters. This causes all
-inputs to stop processing data from wherever they're getting new events.
-
-In ideal circumstances, this behaves similarly to when the tcp window closes to
-0. No new data is sent because the receiver hasn't finished processing the
-current queue of data, but as soon as the downstream (output) problem is
-resolved, messages start flowing again.
-
-[float]
-=== Thread Model
-
-The thread model in Logstash is currently:
-
-[source,js]
-----------------------------------
-input threads | filter worker threads | output worker
-----------------------------------
-
-Filters are optional, so if you have no filters defined it is simply:
-
-[source,js]
-----------------------------------
-input threads | output worker
-----------------------------------
-
-Each input runs in a thread by itself. This prevents busier inputs from being
-blocked by slower ones. It also allows for easier containment of scope because
-each input has a thread.
-
-The filter thread model is a 'worker' model where each worker receives an event
-and applies all filters, in order, before sending it on to the output queue.
-This allows scalability across CPUs because many filters are CPU intensive
-(permitting that we have thread safety).
-
-The default number of filter workers is 1, but you can increase this number by
-specifying the '-w' flag when you run the Logstash agent.
-
-The output worker model is currently a single thread. Outputs receive events in
-the order the outputs are defined in the config file.
-
-Outputs might decide to temporarily buffer events before publishing them. One
-example of this is the `elasticsearch` output, which buffers events and flushes
-them all at once using a separate thread. This mechanism (buffering many events
-and writing in a separate thread) can improve performance because it prevents
-the Logstash pipeline from being stalled waiting for a response from
-elasticsearch.
-
-[float]
-=== Resource Usage
-
-Logstash typically has at least 3 threads (2 if you have no filters). One input
-thread, one filter worker thread, and one output thread. If you see Logstash
-using multiple CPUs, this is likely why. If you want to know more about what
-each thread is doing, you should read this article:
-http://www.semicomplete.com/blog/geekery/debugging-java-performance.html[Debugging Java Performance].
-Threads in Java have names and you can use `jstack` and `top` to figure out who
-is using what resources.
-
-On Linux platforms, Logstash labels all the threads it can with something
-descriptive. For example, inputs show up as `<inputname`, filter workers show up
-as `|worker`, and outputs show up as `>outputworker`.  Where possible, other
-threads are also labeled to help you identify their purpose should you wonder
-why they are consuming resources!
diff --git a/docs/asciidoc/static/logstash-docs-home.asciidoc b/docs/asciidoc/static/logstash-docs-home.asciidoc
deleted file mode 100644
index 19bd3281184..00000000000
--- a/docs/asciidoc/static/logstash-docs-home.asciidoc
+++ /dev/null
@@ -1,30 +0,0 @@
-[[logstash-docs-home]]
-== Logstash Documentation
-Pretty self-explanatory, really
-
-=== Downloads and Releases
-* http://www.elasticsearch.org/overview/logstash/download/[Download Logstash 1.4.2]
-* http://www.elasticsearch.org/blog/apt-and-yum-repositories/[package repositories]
-* http://www.elasticsearch.org/blog/logstash-1-4-2/[release notes]
-* https://github.com/elasticsearch/logstash/blob/master/CHANGELOG[view changelog]
-* https://github.com/elasticsearch/puppet-logstash[Puppet Module]
-
-=== Plugins
-* http://elasticsearch.org/#[contrib plugins]
-* http://elasticsearch.org/#[writing your own plugins]
-* http://elasticsearch.org/#[Inputs] / http://elasticsearch.org/#[Filters] / http://elasticsearch.org/#[Outputs]
-* http://elasticsearch.org/#[Codecs]
-* http://elasticsearch.org/#[(more)]
-
-=== HOWTOs, References, Information
-* http://elasticsearch.org/#[Getting Started with Logstash]
-* http://elasticsearch.org/#[Configuration file overview]
-* http://elasticsearch.org/#[Command-line flags]
-* http://elasticsearch.org/#[The life of an event in Logstash]
-* http://elasticsearch.org/#[Using conditional logic]
-* http://elasticsearch.org/#[Glossary]
-* http://elasticsearch.org/#[(more)]
-
-=== About / Videos / Blogs
-* http://elasticsearch.org/#[Videos]
-* http://elasticsearch.org/#[Blogs]
diff --git a/docs/asciidoc/static/repositories.asciidoc b/docs/asciidoc/static/repositories.asciidoc
deleted file mode 100644
index 7a394885dac..00000000000
--- a/docs/asciidoc/static/repositories.asciidoc
+++ /dev/null
@@ -1,86 +0,0 @@
-[[package-repositories]]
-== Package Repositories
-
-We also have repositories available for APT and YUM based distributions. Note
-that we only provide binary packages, but no source packages, as the packages
-are created as part of the Logstash build.
-
-We have split the Logstash package repositories by version into separate urls 
-to avoid accidental upgrades across major or minor versions. For all 1.5.x 
-releases use 1.5 as version number, for 1.4.x use 1.4, etc.
-
-We use the PGP key
-http://pgp.mit.edu/pks/lookup?op=vindex&search=0xD27D666CD88E42B4[D88E42B4],
-Elastic's Signing Key, with fingerprint
-
-    4609 5ACC 8548 582C 1A26 99A9 D27D 666C D88E 42B4
-
-to sign all our packages. It is available from http://pgp.mit.edu.
-
-[float]
-=== APT
-
-Download and install the Public Signing Key:
-
-[source,sh]
---------------------------------------------------
-wget -qO - https://packages.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -
---------------------------------------------------
-
-Add the repository definition to your `/etc/apt/sources.list` file:
-
-["source","sh",subs="attributes,callouts"]
---------------------------------------------------
-echo "deb http://packages.elastic.co/logstash/{branch}/debian stable main" | sudo tee -a /etc/apt/sources.list
---------------------------------------------------
-
-[WARNING]
-==================================================
-Use the `echo` method described above to add the Logstash repository.  Do not
-use `add-apt-repository` as it will add a `deb-src` entry as well, but we do not
-provide a source package. If you have added the `deb-src` entry, you will see an
-error like the following:
-
-    Unable to find expected entry 'main/source/Sources' in Release file (Wrong sources.list entry or malformed file)
-
-Just delete the `deb-src` entry from the `/etc/apt/sources.list` file and the
-installation should work as expected.
-==================================================
-
-Run `sudo apt-get update` and the repository is ready for use. You can install
-it with:
-
-[source,sh]
---------------------------------------------------
-sudo apt-get update && sudo apt-get install logstash
---------------------------------------------------
-
-[float]
-=== YUM
-
-Download and install the public signing key:
-
-[source,sh]
---------------------------------------------------
-rpm --import https://packages.elastic.co/GPG-KEY-elasticsearch
---------------------------------------------------
-
-Add the following in your `/etc/yum.repos.d/` directory
-in a file with a `.repo` suffix, for example `logstash.repo`
-
-["source","sh",subs="attributes,callouts"]
---------------------------------------------------
-[logstash-{branch}]
-name=Logstash repository for {branch}.x packages
-baseurl=http://packages.elastic.co/logstash/{branch}/centos
-gpgcheck=1
-gpgkey=http://packages.elastic.co/GPG-KEY-elasticsearch
-enabled=1
---------------------------------------------------
-
-And your repository is ready for use. You can install it with:
-
-[source,sh]
---------------------------------------------------
-yum install logstash
---------------------------------------------------
diff --git a/docs/asciidocgen.rb b/docs/asciidocgen.rb
index c95a4f2b79d..5392e6a6440 100644
--- a/docs/asciidocgen.rb
+++ b/docs/asciidocgen.rb
@@ -6,6 +6,7 @@
 $: << File.join(File.dirname(__FILE__), "..", "lib")
 $: << File.join(File.dirname(__FILE__), "..", "rakelib")
 
+require_relative "../lib/bootstrap/environment" #needed for LogStash::Environment constants LOGSTASH_HOME
 require "logstash/config/mixin"
 require "logstash/inputs/base"
 require "logstash/codecs/base"
@@ -161,7 +162,7 @@ def generate(file, settings)
     load file
 
     # Get the correct base path
-    base = File.join(::LogStash::Environment::LOGSTASH_HOME,'lib/logstash', file.split("/")[-2])
+    base = File.join(::LogStash::Environment::LOGSTASH_HOME,'logstash-core/lib/logstash', file.split("/")[-2])
 
     # parse base first
     parse(File.new(File.join(base, "base.rb"), "r").read)
diff --git a/docs/configuration.md b/docs/configuration.md
deleted file mode 100644
index 7cd59fb6090..00000000000
--- a/docs/configuration.md
+++ /dev/null
@@ -1,322 +0,0 @@
----
-title: Configuration Language - Logstash
-layout: content_right
----
-# Logstash Config Language
-
-The Logstash config language aims to be simple.
-
-There are 3 main sections: inputs, filters, outputs. Each section has
-configurations for each plugin available in that section.
-
-Example:
-
-    # This is a comment. You should use comments to describe
-    # parts of your configuration.
-    input {
-      ...
-    }
-
-    filter {
-      ...
-    }
-
-    output {
-      ...
-    }
-
-## Filters and Ordering
-
-For a given event, are applied in the order of appearance in the
-configuration file.
-
-## Comments
-
-Comments are the same as in ruby, perl, and python. Starts with a '#' character.
-Example:
-
-    # this is a comment
-
-    input { # comments can appear at the end of a line, too
-      # ...
-    }
-
-## Plugins
-
-The input, filter and output sections all let you configure plugins. Plugin
-configuration consists of the plugin name followed by a block of settings for
-that plugin. For example, how about two file inputs:
-
-    input {
-      file {
-        path => "/var/log/messages"
-        type => "syslog"
-      }
-
-      file {
-        path => "/var/log/apache/access.log"
-        type => "apache"
-      }
-    }
-
-The above configures two file separate inputs. Both set two
-configuration settings each: 'path' and 'type'. Each plugin has different
-settings for configuring it; seek the documentation for your plugin to
-learn what settings are available and what they mean. For example, the
-[file input][fileinput] documentation will explain the meanings of the
-path and type settings.
-
-[fileinput]: inputs/file
-
-## Value Types
-
-The documentation for a plugin may enforce a configuration field having a
-certain type.  Examples include boolean, string, array, number, hash,
-etc.
-
-### <a name="boolean"></a>Boolean
-
-A boolean must be either `true` or `false`. Note the lack of quotes around
-`true` and `false`.
-
-Examples:
-
-    debug => true
-
-### <a name="string"></a>String
-
-A string must be a single value.
-
-Example:
-
-    name => "Hello world"
-
-Single, unquoted words are valid as strings, too, but you should use quotes.
-
-### <a name="number"></a>Number
-
-Numbers must be valid numerics (floating point or integer are OK).
-
-Example:
-
-    port => 33
-
-### <a name="array"></a>Array
-
-An array can be a single string value or multiple. If you specify the same
-field multiple times, it appends to the array.
-
-Examples:
-
-    path => [ "/var/log/messages", "/var/log/*.log" ]
-    path => "/data/mysql/mysql.log"
-
-The above makes 'path' a 3-element array including all 3 strings.
-
-### <a name="hash"></a>Hash
-
-A hash is basically the same syntax as Ruby hashes.
-The key and value are simply pairs, such as:
-
-    match => {
-      "field1" => "value1"
-      "field2" => "value2"
-      ...
-    }
-
-## <a name="eventdependent"></a>Event Dependent Configuration
-
-The logstash agent is a processing pipeline with 3 stages: inputs -> filters ->
-outputs. Inputs generate events, filters modify them, outputs ship them
-elsewhere.
-
-All events have properties. For example, an apache access log would have things
-like status code (200, 404), request path ("/", "index.html"), HTTP verb
-(GET, POST), client IP address, etc. Logstash calls these properties "fields."
-
-Some of the configuration options in Logstash require the existence of fields in
-order to function.  Because inputs generate events, there are no fields to
-evaluate within the input block--they do not exist yet!  
-
-Because of their dependency on events and fields, the following configuration
-options will only work within filter and output blocks.
-
-**IMPORTANT: Field references, sprintf format and conditionals, described below,
-will not work in an input block.
-
-### <a name="fieldreferences"></a>Field References
-
-In many cases, it is useful to be able to refer to a field by name. To do this,
-you can use the Logstash field reference syntax.
-
-By way of example, let us suppose we have this event:
-
-    {
-      "agent": "Mozilla/5.0 (compatible; MSIE 9.0)",
-      "ip": "192.168.24.44",
-      "request": "/index.html"
-      "response": {
-        "status": 200,
-        "bytes": 52353
-      },
-      "ua": {
-        "os": "Windows 7"
-      }
-    }
-
-- the syntax to access fields is `[fieldname]`.
-- if you are only referring to a **top-level field**, you can omit the `[]` and
-simply say `fieldname`.
-- in the case of **nested fields**, like the "os" field above, you need
-the full path to that field: `[ua][os]`.
-
-### <a name="sprintf"></a>sprintf format
-
-This syntax is also used in what Logstash calls 'sprintf format'. This format
-allows you to refer to field values from within other strings. For example, the
-statsd output has an 'increment' setting, to allow you to keep a count of
-apache logs by status code:
-
-    output {
-      statsd {
-        increment => "apache.%{[response][status]}"
-      }
-    }
-
-You can also do time formatting in this sprintf format. Instead of specifying a
-field name, use the `+FORMAT` syntax where `FORMAT` is a
-[time format](http://joda-time.sourceforge.net/apidocs/org/joda/time/format/DateTimeFormat.html).
-
-For example, if you want to use the file output to write to logs based on the
-hour and the 'type' field:
-
-    output {
-      file {
-        path => "/var/log/%{type}.%{+yyyy.MM.dd.HH}"
-      }
-    }
-
-### <a name="conditionals"></a>Conditionals
-
-Sometimes you only want a filter or output to process an event under
-certain conditions. For that, you'll want to use a conditional!
-
-Conditionals in Logstash look and act the same way they do in programming
-languages. You have `if`, `else if` and `else` statements. Conditionals may be
-nested if you need that.
-
-The syntax is follows:
-
-    if EXPRESSION {
-      ...
-    } else if EXPRESSION {
-      ...
-    } else {
-      ...
-    }
-
-What's an expression? Comparison tests, boolean logic, etc!
-
-The following comparison operators  are supported:
-
-* equality, etc: ==,  !=,  <,  >,  <=,  >=
-* regexp: =~, !~
-* inclusion: in, not in
-
-The following boolean operators are supported:
-
-* and, or, nand, xor
-
-The following unary operators are supported:
-
-* !
-
-Expressions may contain expressions. Expressions may be negated with `!`.
-Expressions may be grouped with parentheses `(...)`. Expressions can be long
-and complex.
-
-For example, if we want to remove the field `secret` if the field
-`action` has a value of `login`:
-
-    filter {
-      if [action] == "login" {
-        mutate { remove => "secret" }
-      }
-    }
-
-The above uses the field reference syntax to get the value of the
-`action` field. It is compared against the text `login` and, if equal,
-allows the mutate filter to delete the field named `secret`.
-
-How about a more complex example?
-
-* alert nagios of any apache events with status 5xx
-* record any 4xx status to elasticsearch
-* record all status code hits via statsd
-
-How about telling nagios of any http event that has a status code of 5xx?
-
-    output {
-      if [type] == "apache" {
-        if [status] =~ /^5\d\d/ {
-          nagios { ...  }
-        } else if [status] =~ /^4\d\d/ {
-          elasticsearch { ... }
-        }
-
-        statsd { increment => "apache.%{status}" }
-      }
-    }
-
-You can also do multiple expressions in a single condition:
-
-    output {
-      # Send production errors to pagerduty
-      if [loglevel] == "ERROR" and [deployment] == "production" {
-        pagerduty {
-          ...
-        }
-      }
-    }
-    
-You can test whether a field was present, regardless of its value:
-
-    if [exception_message] {
-      # If the event has an exception_message field, set the level
-      mutate { add_field => { "level" => "ERROR" } }
-    }
-
-Here are some examples for testing with the in conditional:
-
-    filter {
-      if [foo] in [foobar] {
-        mutate { add_tag => "field in field" }
-      }
-      if [foo] in "foo" {
-        mutate { add_tag => "field in string" }
-      }
-      if "hello" in [greeting] {
-        mutate { add_tag => "string in field" }
-      }
-      if [foo] in ["hello", "world", "foo"] {
-        mutate { add_tag => "field in list" }
-      }
-      if [missing] in [alsomissing] {
-        mutate { add_tag => "shouldnotexist" }
-      }
-      if !("foo" in ["hello", "world"]) {
-        mutate { add_tag => "shouldexist" }
-      }
-    }
-
-Or, to test if grok was successful:
-
-    output {
-      if "_grokparsefailure" not in [tags] {
-        elasticsearch { ... }
-      }
-    }
-
-## Further Reading
-
-For more information, see [the plugin docs index](index)
diff --git a/docs/contrib-plugins.md b/docs/contrib-plugins.md
deleted file mode 100644
index d4adbcee8d2..00000000000
--- a/docs/contrib-plugins.md
+++ /dev/null
@@ -1,59 +0,0 @@
----
-title: Logstash Contrib plugins
-layout: content_right
----
-
-# contrib plugins
-
-As logstash has grown, we've accumulated a massive repository of plugins. Well
-over 100 plugins, it became difficult for the project maintainers to adequately
-support everything effectively.
-
-In order to improve the quality of popular plugins, we've moved the
-less-commonly-used plugins to a separate repository we're calling "contrib".
-Concentrating common plugin usage into core solves a few problems, most notably
-user complaints about the size of logstash releases, support/maintenance costs,
-etc.
-
-It is our intent that this separation will improve life for users. If it
-doesn't, please file a bug so we can work to address it!
-
-If a plugin is available in the 'contrib' package, the documentation for that
-plugin will note this boldly at the top of that plugin's documentation.
-
-Contrib plugins reside in a [separate github project](https://github.com/elasticsearch/logstash-contrib).
-
-# Packaging
-
-At present, the contrib modules are available as a tarball.
-
-# Automated Installation
-
-The `bin/plugin` script will handle the installation for you:
-
-    cd /path/to/logstash
-    bin/plugin install contrib
-
-# Manual Installation
-
-The contrib plugins can be extracted on top of an existing Logstash installation. 
-
-For example, if I've extracted `logstash-%VERSION%.tar.gz` into `/path`, e.g.
- 
-    cd /path
-    tar zxf ~/logstash-%VERSION%.tar.gz
-
-It will have a `/path/logstash-%VERSION%` directory, e.g.
-
-    $ ls
-    logstash-%VERSION%
-
-The method to install the contrib tarball is identical.
-
-    cd /path
-    wget http://download.elasticsearch.org/logstash/logstash/logstash-contrib-%VERSION%.tar.gz
-    tar zxf ~/logstash-contrib-%VERSION%.tar.gz
-
-This will install the contrib plugins in the same directory as the core
-install. These plugins will be available to logstash the next time it starts.
-
diff --git a/docs/docgen.rb b/docs/docgen.rb
deleted file mode 100644
index f64a7f8f853..00000000000
--- a/docs/docgen.rb
+++ /dev/null
@@ -1,250 +0,0 @@
-require "rubygems"
-require "erb"
-require "optparse"
-require "kramdown" # markdown parser
-
-$: << Dir.pwd
-$: << File.join(File.dirname(__FILE__), "..", "lib")
-
-require "logstash/config/mixin"
-require "logstash/inputs/base"
-require "logstash/codecs/base"
-require "logstash/filters/base"
-require "logstash/outputs/base"
-require "logstash/version"
-
-class LogStashConfigDocGenerator
-  COMMENT_RE = /^ *#(?: (.*)| *$)/
-
-  def initialize
-    @rules = {
-      COMMENT_RE => lambda { |m| add_comment(m[1]) },
-      /^ *class.*< *LogStash::(Outputs|Filters|Inputs|Codecs)::(Base|Threadable)/ => \
-        lambda { |m| set_class_description },
-      /^ *config +[^=].*/ => lambda { |m| add_config(m[0]) },
-      /^ *milestone .*/ => lambda { |m| set_milestone(m[0]) },
-      /^ *config_name .*/ => lambda { |m| set_config_name(m[0]) },
-      /^ *flag[( ].*/ => lambda { |m| add_flag(m[0]) },
-      /^ *(class|def|module) / => lambda { |m| clear_comments },
-    }
-
-    if File.exists?("build/contrib_plugins")
-      @contrib_list = File.read("build/contrib_plugins").split("\n")
-    else
-      @contrib_list = []
-    end
-  end
-
-  def parse(string)
-    clear_comments
-    buffer = ""
-    string.split(/\r\n|\n/).each do |line|
-      # Join long lines
-      if line =~ COMMENT_RE
-        # nothing
-      else
-        # Join extended lines
-        if line =~ /(, *$)|(\\$)|(\[ *$)/
-          buffer += line.gsub(/\\$/, "")
-          next
-        end
-      end
-
-      line = buffer + line
-      buffer = ""
-
-      @rules.each do |re, action|
-        m = re.match(line)
-        if m
-          action.call(m)
-        end
-      end # RULES.each
-    end # string.split("\n").each
-  end # def parse
-
-  def set_class_description
-    @class_description = @comments.join("\n")
-    clear_comments
-  end # def set_class_description
-
-  def add_comment(comment)
-    return if comment == "encoding: utf-8"
-    @comments << comment
-  end # def add_comment
-
-  def add_config(code)
-    # I just care about the 'config :name' part
-    code = code.sub(/,.*/, "")
-
-    # call the code, which calls 'config' in this class.
-    # This will let us align comments with config options.
-    name, opts = eval(code)
-
-    # TODO(sissel): This hack is only required until regexp configs
-    # are gone from logstash.
-    name = name.to_s unless name.is_a?(Regexp)
-
-    description = Kramdown::Document.new(@comments.join("\n")).to_html
-    @attributes[name][:description] = description
-    clear_comments
-  end # def add_config
-
-  def add_flag(code)
-    # call the code, which calls 'config' in this class.
-    # This will let us align comments with config options.
-    #p :code => code
-    fixed_code = code.gsub(/ do .*/, "")
-    #p :fixedcode => fixed_code
-    name, description = eval(fixed_code)
-    @flags[name] = description
-    clear_comments
-  end # def add_flag
-
-  def set_config_name(code)
-    name = eval(code)
-    @name = name
-  end # def set_config_name
-
-  def set_milestone(code)
-    @milestone = eval(code)
-  end
-
-  # pretend to be the config DSL and just get the name
-  def config(name, opts={})
-    return name, opts
-  end # def config
-
-  # Pretend to support the flag DSL
-  def flag(*args, &block)
-    name = args.first
-    description = args.last
-    return name, description
-  end # def config
-
-  # pretend to be the config dsl's 'config_name' method
-  def config_name(name)
-    return name
-  end # def config_name
-
-  # pretend to be the config dsl's 'milestone' method
-  def milestone(m)
-    return m
-  end # def milestone
-
-  def clear_comments
-    @comments.clear
-  end # def clear_comments
-
-  def generate(file, settings)
-    @class_description = ""
-    @milestone = ""
-    @comments = []
-    @attributes = Hash.new { |h,k| h[k] = {} }
-    @flags = {}
-
-    # local scoping for the monkeypatch belowg
-    attributes = @attributes
-    # Monkeypatch the 'config' method to capture
-    # Note, this monkeypatch requires us do the config processing
-    # one at a time.
-    #LogStash::Config::Mixin::DSL.instance_eval do
-      #define_method(:config) do |name, opts={}|
-        #p name => opts
-        #attributes[name].merge!(opts)
-      #end
-    #end
-
-    # Loading the file will trigger the config dsl which should
-    # collect all the config settings.
-    load file
-
-    # parse base first
-    parse(File.new(File.join(File.dirname(file), "base.rb"), "r").read)
-
-    # Now parse the real library
-    code = File.new(file).read
-
-    # inputs either inherit from Base or Threadable.
-    if code =~ /\< LogStash::Inputs::Threadable/
-      parse(File.new(File.join(File.dirname(file), "threadable.rb"), "r").read)
-    end
-
-    if code =~ /include LogStash::PluginMixins/
-      mixin = code.gsub(/.*include LogStash::PluginMixins::(\w+)\s.*/m, '\1')
-      mixin.gsub!(/(.)([A-Z])/, '\1_\2')
-      mixin.downcase!
-      parse(File.new(File.join(File.dirname(file), "..", "plugin_mixins", "#{mixin}.rb")).read)
-    end
-
-    parse(code)
-
-    puts "Generating docs for #{file}"
-
-    if @name.nil?
-      $stderr.puts "Missing 'config_name' setting in #{file}?"
-      return nil
-    end
-
-    klass = LogStash::Config::Registry.registry[@name]
-    if klass.ancestors.include?(LogStash::Inputs::Base)
-      section = "input"
-    elsif klass.ancestors.include?(LogStash::Filters::Base)
-      section = "filter"
-    elsif klass.ancestors.include?(LogStash::Outputs::Base)
-      section = "output"
-    elsif klass.ancestors.include?(LogStash::Codecs::Base)
-      section = "codec"
-    end
-
-    template_file = File.join(File.dirname(__FILE__), "plugin-doc.html.erb")
-    template = ERB.new(File.new(template_file).read, nil, "-")
-
-    is_contrib_plugin = @contrib_list.include?(file)
-
-    # descriptions are assumed to be markdown
-    description = Kramdown::Document.new(@class_description).to_html
-
-    klass.get_config.each do |name, settings|
-      @attributes[name].merge!(settings)
-    end
-    sorted_attributes = @attributes.sort { |a,b| a.first.to_s <=> b.first.to_s }
-    klassname = LogStash::Config::Registry.registry[@name].to_s
-    name = @name
-
-    synopsis_file = File.join(File.dirname(__FILE__), "plugin-synopsis.html.erb")
-    synopsis = ERB.new(File.new(synopsis_file).read, nil, "-").result(binding)
-
-    if settings[:output]
-      dir = File.join(settings[:output], section + "s")
-      path = File.join(dir, "#{name}.html")
-      Dir.mkdir(settings[:output]) if !File.directory?(settings[:output])
-      Dir.mkdir(dir) if !File.directory?(dir)
-      File.open(path, "w") do |out|
-        html = template.result(binding)
-        html.gsub!("%VERSION%", LOGSTASH_VERSION)
-        html.gsub!("%PLUGIN%", @name)
-        out.puts(html)
-      end
-    else
-      puts template.result(binding)
-    end
-  end # def generate
-
-end # class LogStashConfigDocGenerator
-
-if __FILE__ == $0
-  opts = OptionParser.new
-  settings = {}
-  opts.on("-o DIR", "--output DIR",
-          "Directory to output to; optional. If not specified,"\
-          "we write to stdout.") do |val|
-    settings[:output] = val
-  end
-
-  args = opts.parse(ARGV)
-
-  args.each do |arg|
-    gen = LogStashConfigDocGenerator.new
-    gen.generate(arg, settings)
-  end
-end
diff --git a/docs/extending/example-add-a-new-filter.md b/docs/extending/example-add-a-new-filter.md
deleted file mode 100644
index 6b613226735..00000000000
--- a/docs/extending/example-add-a-new-filter.md
+++ /dev/null
@@ -1,108 +0,0 @@
----
-title: How to extend - logstash
-layout: content_right
----
-# Add a new filter
-
-This document shows you how to add a new filter to logstash.
-
-For a general overview of how to add a new plugin, see [the extending
-logstash](.) overview.
-
-## Write code.
-
-Let's write a 'hello world' filter. This filter will replace the 'message' in
-the event with "Hello world!"
-
-First, logstash expects plugins in a certain directory structure: `logstash/TYPE/PLUGIN_NAME.rb`
-
-Since we're creating a filter, let's mkdir this:
-
-    mkdir -p logstash/filters/
-    cd logstash/filters
-
-Now add the code:
-
-    # Call this file 'foo.rb' (in logstash/filters, as above)
-    require "logstash/filters/base"
-    require "logstash/namespace"
-
-    class LogStash::Filters::Foo < LogStash::Filters::Base
-
-      # Setting the config_name here is required. This is how you
-      # configure this filter from your logstash config.
-      #
-      # filter {
-      #   foo { ... }
-      # }
-      config_name "foo"
-
-      # New plugins should start life at milestone 1.
-      milestone 1
-
-      # Replace the message with this value.
-      config :message, :validate => :string
-
-      public
-      def register
-        # nothing to do
-      end # def register
-
-      public
-      def filter(event)
-        # return nothing unless there's an actual filter event
-        return unless filter?(event)
-        if @message
-          # Replace the event message with our message as configured in the
-          # config file.
-          event["message"] = @message
-        end
-        # filter_matched should go in the last line of our successful code 
-        filter_matched(event)
-      end # def filter
-    end # class LogStash::Filters::Foo
-
-## Add it to your configuration
-
-For this simple example, let's just use stdin input and stdout output.
-The config file looks like this:
-
-    input { 
-      stdin { type => "foo" } 
-    }
-    filter {
-      if [type] == "foo" {
-        foo {
-          message => "Hello world!"
-        }
-      }
-    }
-    output {
-      stdout { }
-    }
-
-Call this file 'example.conf'
-
-## Tell logstash about it.
-
-Depending on how you installed logstash, you have a few ways of including this
-plugin.
-
-You can use the agent flag --pluginpath flag to specify where the root of your
-plugin tree is. In our case, it's the current directory.
-
-    % bin/logstash --pluginpath your/plugin/root -f example.conf
-
-## Example running
-
-In the example below, I typed in "the quick brown fox" after running the java
-command.
-
-    % bin/logstash -f example.conf
-    the quick brown fox   
-    2011-05-12T01:05:09.495000Z stdin://snack.home/: Hello world!
-
-The output is the standard logstash stdout output, but in this case our "the
-quick brown fox" message was replaced with "Hello world!"
-
-All done! :)
diff --git a/docs/extending/index.md b/docs/extending/index.md
deleted file mode 100644
index 4a4ab66d877..00000000000
--- a/docs/extending/index.md
+++ /dev/null
@@ -1,91 +0,0 @@
----
-title: How to extend - logstash
-layout: content_right
----
-# Extending logstash
-
-You can add your own input, output, or filter plugins to logstash.
-
-If you're looking to extend logstash today, please look at the existing plugins.
-
-## Good examples of plugins
-
-* [inputs/tcp](https://github.com/logstash/logstash/blob/master/lib/logstash/inputs/tcp.rb)
-* [filters/multiline](https://github.com/logstash/logstash/blob/master/lib/logstash/filters/multiline.rb)
-* [outputs/mongodb](https://github.com/logstash/logstash/blob/master/lib/logstash/outputs/mongodb.rb)
-
-## Common concepts
-
-* The `config_name` sets the name used in the config file.
-* The `milestone` sets the milestone number of the plugin. See <../plugin-milestones> for more info.
-* The `config` lines define config options.
-* The `register` method is called per plugin instantiation. Do any of your initialization here.
-
-### Required modules
-
-All plugins should require the Logstash module.
-
-    require 'logstash/namespace'
-
-### Plugin name
-
-Every plugin must have a name set with the `config_name` method. If this
-is not specified plugins will fail to load with an error.
-
-### Milestones
-
-Every plugin needs a milestone set using `milestone`. See
-<../plugin-milestones> for more info.
-
-### Config lines
-
-The `config` lines define configuration options and are constructed like
-so:
-
-    config :host, :validate => :string, :default => "0.0.0.0"
-
-The name of the option is specified, here `:host` and then the
-attributes of the option. They can include `:validate`, `:default`,
-`:required` (a Boolean `true` or `false`), `:deprecated` (also a
-Boolean), and `:obsolete` (a String value).  
- 
-## Inputs
-
-All inputs require the LogStash::Inputs::Base class:
-
-    require 'logstash/inputs/base'
- 
-Inputs have two methods: `register` and `run`.
-
-* Each input runs as its own thread.
-* The `run` method is expected to run-forever.
-
-## Filters
-
-All filters require the LogStash::Filters::Base class:
-
-    require 'logstash/filters/base'
- 
-Filters have two methods: `register` and `filter`.
-
-* The `filter` method gets an event. 
-* Call `event.cancel` to drop the event.
-* To modify an event, simply make changes to the event you are given.
-* The return value is ignored.
-
-## Outputs
-
-All outputs require the LogStash::Outputs::Base class:
-
-    require 'logstash/outputs/base'
- 
-Outputs have two methods: `register` and `receive`.
-
-* The `register` method is called per plugin instantiation. Do any of your initialization here.
-* The `receive` method is called when an event gets pushed to your output
-
-## Example: a new filter
-
-Learn by example how to [add a new filter to logstash](example-add-a-new-filter)
-
-
diff --git a/docs/flags.md b/docs/flags.md
deleted file mode 100644
index e7777f372fe..00000000000
--- a/docs/flags.md
+++ /dev/null
@@ -1,45 +0,0 @@
----
-title: Command-line flags - logstash
-layout: content_right
----
-# Command-line flags
-
-## Agent
-
-The logstash agent has the following flags (also try using the '--help' flag)
-
-<dl>
-<dt> -f, --config CONFIGFILE </dt>
-<dd> Load the logstash config from a specific file, directory, or a
-wildcard. If given a directory or wildcard, config files will be read
-from the directory in alphabetical order. </dd>
-<dt> -e CONFIGSTRING </dt>
-<dd> Use the given string as the configuration data. Same syntax as the
-config file. If not input is specified, 'stdin { type => stdin }' is
-default. If no output is specified, 'stdout { debug => true }}' is
-default. </dd>
-<dt> -w, --filterworkers COUNT </dt>
-<dd> Run COUNT filter workers (default: 1) </dd>
-<dt> -l, --log FILE </dt>
-<dd> Log to a given path. Default is to log to stdout </dd>
-<dt> --verbose </dt>
-<dd> Increase verbosity to the first level, less verbose.</dd>
-<dt> --debug </dt>
-<dd> Increase verbosity to the last level, more verbose.</dd>
-<dt> -v  </dt>
-<dd> *DEPRECATED: see --verbose/debug* Increase verbosity. There are multiple levels of verbosity available with
-'-vv' currently being the highest </dd>
-<dt> --pluginpath PLUGIN_PATH </dt>
-<dd> A colon-delimted path to find other logstash plugins in </dd>
-</dl>
-
-
-## Web
-
-<dl>
-<dt> -a, --address ADDRESS </dt>
-<dd>Address on which to start webserver. Default is 0.0.0.0.</dd>
-<dt> -p, --port PORT</dt>
-<dd>Port on which to start webserver. Default is 9292.</dd>
-</dl>
-
diff --git a/docs/generate_index.rb b/docs/generate_index.rb
deleted file mode 100644
index 6e7bed8e45b..00000000000
--- a/docs/generate_index.rb
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/usr/bin/env ruby
-
-require "erb"
-
-if ARGV.size != 1
-  $stderr.puts "No path given to search for plugin docs"
-  $stderr.puts "Usage: #{$0} plugin_doc_dir"
-  exit 1
-end
-
-def plugins(glob)
-  files = Dir.glob(glob)
-  names = files.collect { |f| File.basename(f).gsub(".html", "") }
-  return names.sort
-end # def plugins
-
-basedir = ARGV[0]
-docs = {
-  "inputs" => plugins(File.join(basedir, "inputs/*.html")),
-  "codecs" => plugins(File.join(basedir, "codecs/*.html")),
-  "filters" => plugins(File.join(basedir, "filters/*.html")),
-  "outputs" => plugins(File.join(basedir, "outputs/*.html")),
-}
-
-template_path = File.join(File.dirname(__FILE__), "index.html.erb")
-template = File.new(template_path).read
-erb = ERB.new(template, nil, "-")
-puts erb.result(binding)
diff --git a/docs/learn.md b/docs/learn.md
deleted file mode 100644
index 2599edc4494..00000000000
--- a/docs/learn.md
+++ /dev/null
@@ -1,46 +0,0 @@
----
-title: Learn - logstash
-layout: content_right
----
-# What is Logstash?
-
-Logstash is a tool for managing your logs.
-
-It helps you take logs and other event data from your systems and move it into
-a central place. Logstash is open source and completely free. You can find
-support on the discussion forum and on IRC.
-
-For an overview of Logstash and why you would use it, you should watch the
-presentation I gave at CarolinaCon 2011: 
-[video here](http://carolinacon.blip.tv/file/5105901/). This presentation covers
-Logstash, how you can use it, some alternatives, logging best practices,
-parsing tools, etc. Video also below:
-
-<!--
-<embed src="http://blip.tv/play/gvE9grjcdQI" type="application/x-shockwave-flash" width="480" height="296" allowscriptaccess="always" allowfullscreen="true"></embed>
-
-The slides are available online here: [slides](http://goo.gl/68c62). The slides
-include speaker notes (click 'actions' then 'speaker notes').
--->
-<iframe width="480" height="296" src="http://www.youtube.com/embed/RuUFnog29M4" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
-
-The slides are available online here: [slides](http://semicomplete.com/presentations/logstash-puppetconf-2012/).
-
-## Getting Help
-
-There's [documentation](.) here on this site. If that isn't sufficient, you can
-use the discussion [forum](https://discuss.elastic.co/c/logstash). Further, there is also
-an IRC channel - #logstash on irc.freenode.org.
-
-If you find a bug or have a feature request, file them
-on [github](https://github.com/elasticsearch/logstas/issues). (Honestly though, if you prefer email or irc
-for such things, that works for me, too.)
-
-## Download It
-
-[Download logstash-%VERSION%](https://download.elastic.co/logstash/logstash/logstash-%VERSION%.tar.gz)
-
-## What's next?
-
-Try this [guide](tutorials/getting-started-with-logstash) for a simple
-real-world example getting started using Logstash.
diff --git a/docs/life-of-an-event.md b/docs/life-of-an-event.md
deleted file mode 100644
index f7dd640995b..00000000000
--- a/docs/life-of-an-event.md
+++ /dev/null
@@ -1,109 +0,0 @@
----
-title: the life of an event - logstash
-layout: content_right
----
-# the life of an event
-
-The logstash agent is an event pipeline.
-
-## The Pipeline
-
-The logstash agent is a processing pipeline with 3 stages: inputs -> filters ->
-outputs. Inputs generate events, filters modify them, outputs ship them
-elsewhere.
-
-Internal to logstash, events are passed from each phase using internal queues.
-It is implemented with a 'SizedQueue' in Ruby. SizedQueue allows a bounded
-maximum of items in the queue such that any writes to the queue will block if
-the queue is full at maximum capacity.
-
-Logstash sets each queue size to 20. This means only 20 events can be pending
-into the next phase - this helps reduce any data loss and in general avoids
-logstash trying to act as a data storage system. These internal queues are not
-for storing messages long-term.
-
-## Fault Tolerance
-
-Starting at outputs, here's what happens when things break.
-
-An output can fail or have problems because of some downstream cause, such as
-full disk, permissions problems, temporary network failures, or service
-outages. Most outputs should keep retrying to ship any events that were
-involved in the failure.
-
-If an output is failing, the output thread will wait until this output is
-healthy again and able to successfully send the message. Therefore, the output
-queue will stop being read from by this output and will eventually fill up with
-events and block new events from being written to this queue.
-
-A full output queue means filters will block trying to write to the output
-queue. Because filters will be stuck, blocked writing to the output queue, they
-will stop reading from the filter queue which will eventually cause the filter
-queue (input -> filter) to fill up.
-
-A full filter queue will cause inputs to block when writing to the filters.
-This will cause each input to block, causing each input to stop processing new
-data from wherever that input is getting new events.
-
-In ideal circumstances, this will behave similarly to when the tcp window
-closes to 0, no new data is sent because the receiver hasn't finished
-processing the current queue of data, but as soon as the downstream (output)
-problem is resolved, messages will begin flowing again..
-
-## Thread Model
-
-The thread model in logstash is currently:
-
-    input threads | filter worker threads | output worker
-
-Filters are optional, so you will have this model if you have no filters
-defined:
-
-    input threads | output worker
-
-Each input runs in a thread by itself. This allows busier inputs to not be
-blocked by slower ones, etc. It also allows for easier containment of scope
-because each input has a thread.
-
-The filter thread model is a 'worker' model where each worker receives an event
-and applies all filters, in order, before emitting that to the output queue.
-This allows scalability across CPUs because many filters are CPU intensive
-(permitting that we have thread safety). 
-
-The default number of filter workers is 1, but you can increase this number
-with the '-w' flag on the agent.
-
-The output worker model is currently a single thread. Outputs will receive
-events in the order they are defined in the config file. 
-
-Outputs may decide to buffer events temporarily before publishing them,
-possibly in a separate thread. One example of this is the elasticsearch output
-which will buffer events and flush them all at once, in a separate thread. This
-mechanism (buffering many events + writing in a separate thread) can improve
-performance so the logstash pipeline isn't stalled waiting for a response from
-elasticsearch.
-
-## Consequences and Expectations
-
-Small queue sizes mean that logstash simply blocks and stalls safely during
-times of load or other temporary pipeline problems. There are two alternatives
-to this - unlimited queue length and dropping messages. Unlimited queues grow
-grow unbounded and eventually exceed memory causing a crash which loses all of
-those messages. Dropping messages is also an undesirable behavior in most cases.
-
-At a minimum, logstash will have probably 3 threads (2 if you have no filters).
-One input, one filter worker, and one output thread each.
-
-If you see logstash using multiple CPUs, this is likely why. If you want to
-know more about what each thread is doing, you should read this:
-<http://www.semicomplete.com/blog/geekery/debugging-java-performance.html>.
-
-Threads in java have names, and you can use jstack and top to figure out who is
-using what resources. The URL above will help you learn how to do this.
-
-On Linux platforms, logstash will label all the threads it can with something
-descriptive. Inputs will show up as "<inputname" and filter workers as
-"|worker" and outputs as ">outputworker" (or something similar).  Other threads
-may be labeled as well, and are intended to help you identify their purpose
-should you wonder why they are consuming resources!
-
diff --git a/docs/logging-tool-comparisons.md b/docs/logging-tool-comparisons.md
deleted file mode 100644
index a39fea0546e..00000000000
--- a/docs/logging-tool-comparisons.md
+++ /dev/null
@@ -1,60 +0,0 @@
----
-title: Logging tools comparisons - logstash
-layout: content_right
----
-# Logging tools comparison
-
-The information below is provided as "best effort" and is not strictly intended
-as a complete source of truth. If the information below is unclear or incorrect, please
-email the logstash-users list (or send a pull request with the fix) :)
-
-Where feasible, this document will also provide information on how you can use
-logstash with these other projects.
-
-# logstash
-
-Primary goal: Make log/event data and analytics accessible.
-
-Overview: Where your logs come from, how you store them, or what you do with
-them is up to you. Logstash exists to help make such actions easier and faster.
-
-It provides you a simple event pipeline for taking events and logs from any
-input, manipulating them with filters, and sending them to any output. Inputs
-can be files, network, message brokers, etc. Filters are date and string
-parsers, grep-like, etc. Outputs are data stores (elasticsearch, mongodb, etc),
-message systems (rabbitmq, stomp, etc), network (tcp, syslog), etc.
-
-It also provides a web interface for doing search and analytics on your
-logs.
-
-# graylog2
-
-[http://graylog2.org/](http://graylog2.org)
-
-_Overview to be written_
-
-You can use graylog2 with logstash by using the 'gelf' output to send logstash
-events to a graylog2 server. This gives you logstash's excellent input and
-filter features while still being able to use the graylog2 web interface.
-
-# whoops
-
-[whoops site](http://www.whoopsapp.com/)
-
-_Overview to be written_
-
-A logstash output to whoops is coming soon - <https://logstash.jira.com/browse/LOGSTASH-133>
-
-# flume
-
-[flume site](https://github.com/cloudera/flume/wiki)
-
-Flume is primarily a transport system aimed at reliably copying logs from
-application servers to HDFS.
-
-You can use it with logstash by having a syslog sink configured to shoot logs
-at a logstash syslog input.
-
-# scribe
-
-_Overview to be written_
diff --git a/docs/plugin-milestones.md b/docs/plugin-milestones.md
deleted file mode 100644
index 5d72e9ac472..00000000000
--- a/docs/plugin-milestones.md
+++ /dev/null
@@ -1,41 +0,0 @@
----
-title: Plugin Milestones - logstash
-layout: content_right
----
-# Plugin Milestones
-
-Plugins (inputs/outputs/filters/codecs) have a milestone label in logstash.
-This is to provide an indicator to the end-user as to the kinds of changes
-a given plugin could have between logstash releases.
-
-The desire here is to allow plugin developers to quickly iterate on possible
-new plugins while conveying to the end-user a set of expectations about that
-plugin.
-
-## Milestone 1
-
-Plugins at this milestone need your feedback to improve! Plugins at this
-milestone may change between releases as the community figures out the best way
-for the plugin to behave and be configured.
-
-## Milestone 2
-
-Plugins at this milestone are more likely to have backwards-compatibility to
-previous releases than do Milestone 1 plugins. This milestone also indicates
-a greater level of in-the-wild usage by the community than the previous
-milestone.
-
-## Milestone 3
-
-Plugins at this milestone have strong promises towards backwards-compatibility.
-This is enforced with automated tests to ensure behavior and configuration are
-consistent across releases.
-
-## Milestone 0
-
-This milestone appears at the bottom of the page because it is very
-infrequently used.
-
-This milestone marker is used to generally indicate that a plugin has no
-active code maintainer nor does it have support from the community in terms
-of getting help.
diff --git a/docs/release-notes.md b/docs/release-notes.md
deleted file mode 100644
index 254fee6b6c7..00000000000
--- a/docs/release-notes.md
+++ /dev/null
@@ -1,64 +0,0 @@
----
-title: release notes for %VERSION%
-layout: content_right
----
-
-# %VERSION% - Release Notes
-
-This document is targeted at existing users of Logstash who are upgrading from
-an older version to version %VERSION%. This document is intended to supplement
-a the [changelog
-file](https://github.com/elasticsearch/logstash/blob/v%VERSION%/CHANGELOG) by
-providing more details on certain changes.
-
-### tarball 
-
-With Logstash 1.4.0, we stopped shipping the jar file and started shipping a
-tarball instead.
-
-Past releases have been a single jar file which included all Ruby and Java
-library dependencies to eliminate deployment pains. We still ship all
-the dependencies for you! The jar file served us well, but over time we found
-Java’s default heap size, garbage collector, and other settings weren’t well
-suited to Logstash.
-
-In order to provide better Java defaults, we’ve changed to releasing a tarball
-(.tar.gz) that includes all the same dependencies. What does this mean to you?
-Instead of running `java -jar logstash.jar ...` you run `bin/logstash ...` (for
-Windows users, `bin/logstash.bat`)
-
-One pleasant side effect of using a tarball is that the Logstash code itself is
-much more accessible and able to satisfy any curiosity you may have.
-
-The new way to do things is:
-
-* Download logstash tarball
-* Unpack it (`tar -zxf logstash-%VERSION%.tar.gz`)
-* `cd logstash-%VERSION%`
-% Run it: `bin/logstash ...`
-
-The old way to run logstash of `java -jar logstash.jar` is now replaced with
-`bin/logstash`. The command line arguments are exactly the same after that.
-For example:
-
-    # Old way:
-    `% java -jar logstash-1.3.3-flatjar.jar agent -f logstash.conf`
-
-    # New way:
-    `% bin/logstash agent -f logstash.conf`
-
-### plugins
-
-Logstash has grown brilliantly over the past few years with great contributions
-from the community. Now having 165 plugins, it became hard for us (the Logstash
-engineering team) to reliably support all the wonderful technologies in each
-contributed plugin. We combed through all the plugins and picked the ones we
-felt strongly we could support, and those now ship by default with Logstash.
-
-All the other plugins are now available in a contrib package. All plugins
-continue to be open source and free, of course! Installing plugins is very easy:
-
-....
-    % cd /path/to/logstash-%VERSION%/
-    % bin/plugin install [PLUGIN_NAME]
-....
diff --git a/docs/repositories.md b/docs/repositories.md
deleted file mode 100644
index 21075147db7..00000000000
--- a/docs/repositories.md
+++ /dev/null
@@ -1,35 +0,0 @@
----
-title: repositories - logstash
-layout: content_right
----
-# Logstash repositories
-
-We also have Logstash available as APT and YUM repositories.
-
-Our public signing key can be found on the [Elasticsearch packages apt GPG signing key page](https://packages.elasticsearch.org/GPG-KEY-elasticsearch)
-
-## Apt based distributions
-
-Add the key:
-
-    wget -O - https://packages.elasticsearch.org/GPG-KEY-elasticsearch | apt-key add -
-
-Add the repo to /etc/apt/sources.list
-
-    deb http://packages.elasticsearch.org/logstash/1.4/debian stable main
-
-
-## YUM based distributions
-
-Add the key:
-
-    rpm --import https://packages.elasticsearch.org/GPG-KEY-elasticsearch
-
-Add the repo to /etc/yum.repos.d/ directory
-
-    [logstash-1.4]
-    name=logstash repository for 1.4.x packages
-    baseurl=https://packages.elasticsearch.org/logstash/1.4/centos
-    gpgcheck=1
-    gpgkey=https://packages.elasticsearch.org/GPG-KEY-elasticsearch
-    enabled=1
diff --git a/docs/asciidoc/static/advanced-pipeline.asciidoc b/docs/static/advanced-pipeline.asciidoc
similarity index 57%
rename from docs/asciidoc/static/advanced-pipeline.asciidoc
rename to docs/static/advanced-pipeline.asciidoc
index 867f0a80263..6e9d84c3ec2 100644
--- a/docs/asciidoc/static/advanced-pipeline.asciidoc
+++ b/docs/static/advanced-pipeline.asciidoc
@@ -1,14 +1,14 @@
 [[advanced-pipeline]]
 === Setting Up an Advanced Logstash Pipeline
 
-A Logstash pipeline in most use cases has one or more input, filter, and output plugins. The scenarios in this section 
+A Logstash pipeline in most use cases has one or more input, filter, and output plugins. The scenarios in this section
 build Logstash configuration files to specify these plugins and discuss what each plugin is doing.
 
-The Logstash configuration file defines your _Logstash pipeline_. When you start a Logstash instance, use the 
+The Logstash configuration file defines your _Logstash pipeline_. When you start a Logstash instance, use the
 `-f <path/to/file>` option to specify the configuration file that defines that instance’s pipeline.
 
-A Logstash pipeline has two required elements, `input` and `output`, and one optional element, `filter`. The input 
-plugins consume data from a source, the filter plugins modify the data as you specify, and the output plugins write 
+A Logstash pipeline has two required elements, `input` and `output`, and one optional element, `filter`. The input
+plugins consume data from a source, the filter plugins modify the data as you specify, and the output plugins write
 the data to a destination.
 
 image::static/images/basic_logstash_pipeline.png[]
@@ -16,6 +16,7 @@ image::static/images/basic_logstash_pipeline.png[]
 The following text represents the skeleton of a configuration pipeline:
 
 [source,shell]
+--------------------------------------------------------------------------------
 # The # character at the beginning of a line indicates a comment. Use
 # comments to describe your configuration.
 input {
@@ -23,12 +24,13 @@ input {
 # The filter part of this file is commented out to indicate that it is
 # optional.
 # filter {
-# 
+#
 # }
 output {
 }
+--------------------------------------------------------------------------------
 
-This skeleton is non-functional, because the input and output sections don’t have any valid options defined. The 
+This skeleton is non-functional, because the input and output sections don’t have any valid options defined. The
 examples in this tutorial build configuration files to address specific use cases.
 
 Paste the skeleton into a file named `first-pipeline.conf` in your home Logstash directory.
@@ -36,32 +38,36 @@ Paste the skeleton into a file named `first-pipeline.conf` in your home Logstash
 [[parsing-into-es]]
 ==== Parsing Apache Logs into Elasticsearch
 
-This example creates a Logstash pipeline that takes Apache web logs as input, parses those logs to create specific, 
+This example creates a Logstash pipeline that takes Apache web logs as input, parses those logs to create specific,
 named fields from the logs, and writes the parsed data to an Elasticsearch cluster.
 
-You can download the sample data set used in this example 
+You can download the sample data set used in this example
 https://download.elastic.co/demos/logstash/gettingstarted/logstash-tutorial.log.gz[here]. Unpack this file.
 
 [float]
 [[configuring-file-input]]
-===== Configuring Logstash for File Input
+==== Configuring Logstash for File Input
 
-To start your Logstash pipeline, configure the Logstash instance to read from a file using the 
+To start your Logstash pipeline, configure the Logstash instance to read from a file using the
 {logstash}plugins-inputs-file.html[file] input plugin.
 
 Edit the `first-pipeline.conf` file to add the following text:
 
 [source,json]
+--------------------------------------------------------------------------------
 input {
     file {
         path => "/path/to/logstash-tutorial.log"
         start_position => beginning <1>
+        ignore_older => 0 <2>
     }
 }
+--------------------------------------------------------------------------------
 
-<1> The default behavior of the file input plugin is to monitor a file for new information, in a manner similar to the 
-UNIX `tail -f` command. To change this default behavior and process the entire file, we need to specify the position 
+<1> The default behavior of the file input plugin is to monitor a file for new information, in a manner similar to the
+UNIX `tail -f` command. To change this default behavior and process the entire file, we need to specify the position
 where Logstash starts processing the file.
+<2> The default behavior of the file input plugin is to ignore files whose last modification is greater than 86400s. To change this default behavior and process the tutorial file (which date can be much older than a day), we need to specify to not ignore old files.
 
 Replace `/path/to/` with the actual path to the location of `logstash-tutorial.log` in your file system.
 
@@ -69,20 +75,22 @@ Replace `/path/to/` with the actual path to the location of `logstash-tutorial.l
 [[configuring-grok-filter]]
 ===== Parsing Web Logs with the Grok Filter Plugin
 
-The {logstash}plugins-filters-grok.html[`grok`] filter plugin is one of several plugins that are available by default in 
-Logstash. For details on how to manage Logstash plugins, see the <<working-with-plugins,reference documentation>> for 
+The {logstash}plugins-filters-grok.html[`grok`] filter plugin is one of several plugins that are available by default in
+Logstash. For details on how to manage Logstash plugins, see the <<working-with-plugins,reference documentation>> for
 the plugin manager.
 
-Because the `grok` filter plugin looks for patterns in the incoming log data, configuration requires you to make 
-decisions about how to identify the patterns that are of interest to your use case. A representative line from the web 
+Because the `grok` filter plugin looks for patterns in the incoming log data, configuration requires you to make
+decisions about how to identify the patterns that are of interest to your use case. A representative line from the web
 server log sample looks like this:
 
 [source,shell]
-83.149.9.216 - - [04/Jan/2015:05:13:42 +0000] "GET /presentations/logstash-monitorama-2013/images/kibana-search.png 
-HTTP/1.1" 200 203023 "http://semicomplete.com/presentations/logstash-monitorama-2013/" "Mozilla/5.0 (Macintosh; Intel 
+--------------------------------------------------------------------------------
+83.149.9.216 - - [04/Jan/2015:05:13:42 +0000] "GET /presentations/logstash-monitorama-2013/images/kibana-search.png
+HTTP/1.1" 200 203023 "http://semicomplete.com/presentations/logstash-monitorama-2013/" "Mozilla/5.0 (Macintosh; Intel
 Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.77 Safari/537.36"
+--------------------------------------------------------------------------------
 
-The IP address at the beginning of the line is easy to identify, as is the timestamp in brackets. In this tutorial, use 
+The IP address at the beginning of the line is easy to identify, as is the timestamp in brackets. In this tutorial, use
 the `%{COMBINEDAPACHELOG}` grok pattern, which structures lines from the Apache log using the following schema:
 
 [horizontal]
@@ -102,19 +110,22 @@ User agent:: `agent`
 Edit the `first-pipeline.conf` file to add the following text:
 
 [source,json]
+--------------------------------------------------------------------------------
 filter {
     grok {
         match => { "message" => "%{COMBINEDAPACHELOG}"}
     }
 }
+--------------------------------------------------------------------------------
 
 After processing, the sample line has the following JSON representation:
 
 [source,json]
+--------------------------------------------------------------------------------
 {
 "clientip" : "83.149.9.216",
 "ident" : ,
-"auth" : , 
+"auth" : ,
 "timestamp" : "04/Jan/2015:05:13:42 +0000",
 "verb" : "GET",
 "request" : "/presentations/logstash-monitorama-2013/images/kibana-search.png",
@@ -124,41 +135,46 @@ After processing, the sample line has the following JSON representation:
 "referrer" : "http://semicomplete.com/presentations/logstash-monitorama-2013/",
 "agent" : "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/32.0.1700.77 Safari/537.36"
 }
+--------------------------------------------------------------------------------
 
 [float]
 [[indexing-parsed-data-into-elasticsearch]]
 ===== Indexing Parsed Data into Elasticsearch
 
-Now that the web logs are broken down into specific fields, the Logstash pipeline can index the data into an 
+Now that the web logs are broken down into specific fields, the Logstash pipeline can index the data into an
 Elasticsearch cluster. Edit the `first-pipeline.conf` file to add the following text after the `input` section:
 
 [source,json]
+--------------------------------------------------------------------------------
 output {
     elasticsearch {
     }
 }
+--------------------------------------------------------------------------------
 
 With this configuration, Logstash uses http protocol to connect to Elasticsearch. The above example assumes Logstash
 and Elasticsearch to be running on the same instance. You can specify a remote Elasticsearch instance using `hosts`
-configuration like `hosts => "es-machine:9092"`. 
+configuration like `hosts => "es-machine:9092"`.
 
 [float]
 [[configuring-geoip-plugin]]
 ===== Enhancing Your Data with the Geoip Filter Plugin
 
-In addition to parsing log data for better searches, filter plugins can derive supplementary information from existing 
-data. As an example, the {logstash}plugins-filters-geoip.html[`geoip`] plugin looks up IP addresses, derives geographic 
+In addition to parsing log data for better searches, filter plugins can derive supplementary information from existing
+data. As an example, the {logstash}plugins-filters-geoip.html[`geoip`] plugin looks up IP addresses, derives geographic
 location information from the addresses, and adds that location information to the logs.
 
-Configure your Logstash instance to use the `geoip` filter plugin by adding the following lines to the `filter` section 
+Configure your Logstash instance to use the `geoip` filter plugin by adding the following lines to the `filter` section
 of the `first-pipeline.conf` file:
 
 [source,json]
+--------------------------------------------------------------------------------
 geoip {
     source => "clientip"
 }
+--------------------------------------------------------------------------------
 
-The `geoip` plugin configuration requires data that is already defined as separate fields. Make sure that the `geoip` 
+The `geoip` plugin configuration requires data that is already defined as separate fields. Make sure that the `geoip`
 section is after the `grok` section of the configuration file.
 
 Specify the name of the field that contains the IP address to look up. In this tutorial, the field name is `clientip`.
@@ -171,6 +187,7 @@ At this point, your `first-pipeline.conf` file has input, filter, and output sec
 like this:
 
 [source,json]
+--------------------------------------------------------------------------------
 input {
     file {
         path => "/Users/palecur/logstash-1.5.2/logstash-tutorial-dataset"
@@ -189,28 +206,36 @@ output {
     elasticsearch {}
     stdout {}
 }
+--------------------------------------------------------------------------------
 
 To verify your configuration, run the following command:
 
 [source,shell]
+--------------------------------------------------------------------------------
 bin/logstash -f first-pipeline.conf --configtest
+--------------------------------------------------------------------------------
 
 The `--configtest` option parses your configuration file and reports any errors. When the configuration file passes
 the configuration test, start Logstash with the following command:
 
 [source,shell]
+--------------------------------------------------------------------------------
 bin/logstash -f first-pipeline.conf
+--------------------------------------------------------------------------------
 
 Try a test query to Elasticsearch based on the fields created by the `grok` filter plugin:
 
 [source,shell]
+--------------------------------------------------------------------------------
 curl -XGET 'localhost:9200/logstash-$DATE/_search?q=response=200'
+--------------------------------------------------------------------------------
 
 Replace $DATE with the current date, in YYYY.MM.DD format.
 
 Since our sample has just one 200 HTTP response, we get one hit back:
 
 [source,json]
+--------------------------------------------------------------------------------
 {"took":2,
 "timed_out":false,
 "_shards":{"total":5,
@@ -242,17 +267,21 @@ Since our sample has just one 200 HTTP response, we get one hit back:
     }]
   }
 }
+--------------------------------------------------------------------------------
 
 Try another search for the geographic information derived from the IP address:
 
 [source,shell]
+--------------------------------------------------------------------------------
 curl -XGET 'localhost:9200/logstash-$DATE/_search?q=geoip.city_name=Buffalo'
+--------------------------------------------------------------------------------
 
 Replace $DATE with the current date, in YYYY.MM.DD format.
 
 Only one of the log entries comes from Buffalo, so the query produces a single response:
 
 [source,json]
+--------------------------------------------------------------------------------
 {"took":3,
 "timed_out":false,
 "_shards":{
@@ -303,20 +332,21 @@ Only one of the log entries comes from Buffalo, so the query produces a single r
   }]
  }
 }
+--------------------------------------------------------------------------------
 
 [[multiple-input-output-plugins]]
 ==== Multiple Input and Output Plugins
 
-The information you need to manage often comes from several disparate sources, and use cases can require multiple 
-destinations for your data. Your Logstash pipeline can use multiple input and output plugins to handle these 
+The information you need to manage often comes from several disparate sources, and use cases can require multiple
+destinations for your data. Your Logstash pipeline can use multiple input and output plugins to handle these
 requirements.
 
-This example creates a Logstash pipeline that takes input from a Twitter feed and the Logstash Forwarder client, then 
+This example creates a Logstash pipeline that takes input from a Twitter feed and the Filebeat client, then
 sends the information to an Elasticsearch cluster as well as writing the information directly to a file.
 
 [float]
 [[twitter-configuration]]
-===== Reading from a Twitter feed
+==== Reading from a Twitter feed
 
 To add a Twitter feed, you need several pieces of information:
 
@@ -326,98 +356,105 @@ To add a Twitter feed, you need several pieces of information:
 * An _oauth token_, which identifies the Twitter account using this app.
 * An _oauth token secret_, which serves as the password of the Twitter account.
 
-Visit https://dev.twitter.com/apps to set up a Twitter account and generate your consumer key and secret, as well as 
+Visit https://dev.twitter.com/apps to set up a Twitter account and generate your consumer key and secret, as well as
 your OAuth token and secret.
 
 Use this information to add the following lines to the `input` section of the `first-pipeline.conf` file:
 
 [source,json]
+--------------------------------------------------------------------------------
 twitter {
     consumer_key =>
     consumer_secret =>
     keywords =>
     oauth_token =>
-    oauth_token_secret => 
+    oauth_token_secret =>
 }
+--------------------------------------------------------------------------------
 
 [float]
 [[configuring-lsf]]
-===== The Logstash Forwarder
+==== The Filebeat Client
 
-The https://github.com/elastic/logstash-forwarder[Logstash Forwarder] is a lightweight, resource-friendly tool that 
-collects logs from files on the server and forwards these logs to your Logstash instance for processing. The 
-Logstash Forwarder uses a secure protocol called _lumberjack_ to communicate with your Logstash instance. The 
-lumberjack protocol is designed for reliability and low latency. The Logstash Forwarder uses the computing resources of 
-the machine hosting the source data, and the Lumberjack input plugin minimizes the resource demands on the Logstash 
-instance.
+The https://github.com/elastic/beats/tree/master/filebeat[filebeat] client is a lightweight, resource-friendly tool that
+collects logs from files on the server and forwards these logs to your Logstash instance for processing. The
+Filebeat client uses the secure Beats protocol to communicate with your Logstash instance. The
+lumberjack protocol is designed for reliability and low latency. Filebeat uses the computing resources of
+the machine hosting the source data, and the {logstash}plugins-inputs-beats.html[Beats input] plugin minimizes the
+resource demands on the Logstash instance.
 
-NOTE: In a typical use case, the Logstash Forwarder client runs on a separate machine from the machine running your 
-Logstash instance. For the purposes of this tutorial, both Logstash and the Logstash Forwarder will be running on the
+NOTE: In a typical use case, Filebeat runs on a separate machine from the machine running your
+Logstash instance. For the purposes of this tutorial, Logstash and Filebeat are running on the
 same machine.
 
-Default Logstash configuration includes the {logstash}plugins-inputs-lumberjack.html[Lumberjack input plugin], which is 
-designed to be resource-friendly. To install the Logstash Forwarder on your data source machine, install the 
-appropriate package from the main Logstash https://www.elastic.co/downloads/logstash[product page].
+Default Logstash configuration includes the {logstash}plugins-inputs-beats.html[Beats input plugin], which is
+designed to be resource-friendly. To install Filebeat on your data source machine, download the
+appropriate package from the Filebeat https://www.elastic.co/downloads/beats/filebeat[product page].
 
-Create a configuration file for the Logstash Forwarder similar to the following example:
+Create a configuration file for Filebeat similar to the following example:
 
-[source,json]
+[source,shell]
 --------------------------------------------------------------------------------
-{
-    "network": {
-        "servers": [ "localhost:5043" ],
-        "ssl ca": "/path/to/localhost.crt", <1>
-        "timeout": 15
-    },
-    "files": [
-        {
-            "paths": [
-                "/path/to/sample-log" <2>
-            ],
-            "fields": { "type": "apache" }
-        }
-    ]
-}
+filebeat:
+  prospectors:
+    -
+      paths:
+        - "/path/to/sample-log" <1>
+      fields:
+        type: syslog
+output:
+  logstash:
+    hosts: ["localhost:5043"]
+  tls:
+    certificate: /path/to/ssl-certificate.crt <2>
+    certificate_key: /path/to/ssl-certificate.key
+    certificate_authorities: /path/to/ssl-certificate.crt
+    timeout: 15
 --------------------------------------------------------------------------------
 
-<1> Path to the SSL certificate for the Logstash instance.
-<2> Path to the file or files that the Logstash Forwarder processes.
+<1> Path to the file or files that Filebeat processes.
+<2> Path to the SSL certificate for the Logstash instance.
 
-Save this configuration file as `logstash-forwarder.conf`. 
+Save this configuration file as `filebeat.yml`.
 
-Configure your Logstash instance to use the Lumberjack input plugin by adding the following lines to the `input` section 
+Configure your Logstash instance to use the Filebeat input plugin by adding the following lines to the `input` section
 of the `first-pipeline.conf` file:
 
 [source,json]
-lumberjack {
+--------------------------------------------------------------------------------
+beats {
     port => "5043"
+    ssl => true
     ssl_certificate => "/path/to/ssl-cert" <1>
     ssl_key => "/path/to/ssl-key" <2>
 }
+--------------------------------------------------------------------------------
 
-<1> Path to the SSL certificate that the Logstash instance uses to authenticate itself to Logstash Forwarder.
+<1> Path to the SSL certificate that the Logstash instance uses to authenticate itself to Filebeat.
 <2> Path to the key for the SSL certificate.
 
 [float]
 [[logstash-file-output]]
-===== Writing Logstash Data to a File
+==== Writing Logstash Data to a File
 
-You can configure your Logstash pipeline to write data directly to a file with the 
+You can configure your Logstash pipeline to write data directly to a file with the
 {logstash}plugins-outputs-file.html[`file`] output plugin.
 
-Configure your Logstash instance to use the `file` output plugin by adding the following lines to the `output` section 
+Configure your Logstash instance to use the `file` output plugin by adding the following lines to the `output` section
 of the `first-pipeline.conf` file:
 
 [source,json]
+--------------------------------------------------------------------------------
 file {
     path => /path/to/target/file
 }
+--------------------------------------------------------------------------------
 
 [float]
 [[multiple-es-nodes]]
-===== Writing to multiple Elasticsearch nodes
+==== Writing to multiple Elasticsearch nodes
 
-Writing to multiple Elasticsearch nodes lightens the resource demands on a given Elasticsearch node, as well as 
+Writing to multiple Elasticsearch nodes lightens the resource demands on a given Elasticsearch node, as well as
 providing redundant points of entry into the cluster when a particular node is unavailable.
 
 To configure your Logstash instance to write to multiple Elasticsearch nodes, edit the output section of the `first-pipeline.conf` file to read:
@@ -431,7 +468,7 @@ output {
 }
 --------------------------------------------------------------------------------
 
-Use the IP addresses of three non-master nodes in your Elasticsearch cluster in the host line. When the `hosts` 
+Use the IP addresses of three non-master nodes in your Elasticsearch cluster in the host line. When the `hosts`
 parameter lists multiple IP addresses, Logstash load-balances requests across the list of addresses. Also note that
 default port for Elasticsearch is `9200` and can be omitted in the configuration above.
 
@@ -451,8 +488,9 @@ input {
         oauth_token =>
         oauth_token_secret =>
     }
-    lumberjack {
+    beats {
         port => "5043"
+        ssl => true
         ssl_certificate => "/path/to/ssl-cert"
         ssl_key => "/path/to/ssl-key"
     }
@@ -467,34 +505,108 @@ output {
 }
 --------------------------------------------------------------------------------
 
-Logstash is consuming data from the Twitter feed you configured, receiving data from the Logstash Forwarder, and 
+Logstash is consuming data from the Twitter feed you configured, receiving data from Filebeat, and
 indexing this information to three nodes in an Elasticsearch cluster as well as writing to a file.
 
-At the data source machine, run the Logstash Forwarder with the following command:
+At the data source machine, run Filebeat with the following command:
 
 [source,shell]
-logstash-forwarder -config logstash-forwarder.conf
+--------------------------------------------------------------------------------
+sudo ./filebeat -e -c filebeat.yml -d "publish"
+--------------------------------------------------------------------------------
 
-Logstash Forwarder will attempt to connect on port 5403. Until Logstash starts with an active Lumberjack plugin, there 
+Filebeat will attempt to connect on port 5403. Until Logstash starts with an active Beats plugin, there
 won’t be any answer on that port, so any messages you see regarding failure to connect on that port are normal for now.
 
 To verify your configuration, run the following command:
 
 [source,shell]
+--------------------------------------------------------------------------------
 bin/logstash -f first-pipeline.conf --configtest
+--------------------------------------------------------------------------------
 
 The `--configtest` option parses your configuration file and reports any errors. When the configuration file passes
 the configuration test, start Logstash with the following command:
 
 [source,shell]
+--------------------------------------------------------------------------------
 bin/logstash -f first-pipeline.conf
+--------------------------------------------------------------------------------
 
 Use the `grep` utility to search in the target file to verify that information is present:
 
 [source,shell]
+--------------------------------------------------------------------------------
 grep Mozilla /path/to/target/file
+--------------------------------------------------------------------------------
 
 Run an Elasticsearch query to find the same information in the Elasticsearch cluster:
 
 [source,shell]
+--------------------------------------------------------------------------------
 curl -XGET 'localhost:9200/logstash-2015.07.30/_search?q=agent=Mozilla'
+--------------------------------------------------------------------------------
+
+[[stalled-shutdown]]
+=== Stalled Shutdown Detection
+
+Shutting down a running Logstash instance involves the following steps:
+
+* Stop all input, filter and output plugins
+* Process all in-flight events
+* Terminate the Logstash process
+
+The following conditions affect the shutdown process:
+
+* An input plugin receiving data at a slow pace.
+* A slow filter, like a Ruby filter executing `sleep(10000)` or an Elasticsearch filter that is executing a very heavy
+query.
+* A disconnected output plugin that is waiting to reconnect to flush in-flight events.
+
+These situations make the duration and success of the shutdown process unpredictable.
+
+Logstash has a stall detection mechanism that analyzes the behavior of the pipeline and plugins during shutdown.
+This mechanism produces periodic information about the count of inflight events in internal queues and a list of busy
+worker threads.
+
+To enable Logstash to forcibly terminate in the case of a stalled shutdown, use the `--allow-unsafe-shutdown` flag when
+you start Logstash.
+
+[[shutdown-stall-example]]
+==== Stall Detection Example
+
+In this example, slow filter execution prevents the pipeline from clean shutdown. By starting Logstash with the
+`--allow-unsafe-shutdown` flag, quitting with *Ctrl+C* results in an eventual shutdown that loses 20 events.
+
+========
+[source,shell]
+% bin/logstash -e 'input { generator { } } filter { ruby { code => "sleep 10000" } } \
+                     output { stdout { codec => dots } }' -w 1 --allow-unsafe-shutdown
+Default settings used: Filter workers: 1
+Logstash startup completed
+^CSIGINT received. Shutting down the pipeline. {:level=>:warn}
+Received shutdown signal, but pipeline is still waiting for in-flight events
+to be processed. Sending another ^C will force quit Logstash, but this may cause
+data loss. {:level=>:warn}
+ {:level=>:warn, "INFLIGHT_EVENT_COUNT"=>{"input_to_filter"=>20, "total"=>20},
+ "STALLING_THREADS"=>
+ {["LogStash::Filters::Ruby", {"code"=>"sleep 10000"}]=>[{"thread_id"=>15,
+ "name"=>"|filterworker.0", "current_call"=>"
+ (ruby filter code):1:in `sleep'"}]}}
+The shutdown process appears to be stalled due to busy or blocked plugins. Check
+    the logs for more information.
+{:level=>:error}
+ {:level=>:warn, "INFLIGHT_EVENT_COUNT"=>{"input_to_filter"=>20, "total"=>20},
+ "STALLING_THREADS"=>
+ {["LogStash::Filters::Ruby", {"code"=>"sleep 10000"}]=>[{"thread_id"=>15,
+ "name"=>"|filterworker.0", "current_call"=>"
+ (ruby filter code):1:in `sleep'"}]}}
+ {:level=>:warn, "INFLIGHT_EVENT_COUNT"=>{"input_to_filter"=>20, "total"=>20},
+ "STALLING_THREADS"=>
+ {["LogStash::Filters::Ruby", {"code"=>"sleep 10000"}]=>[{"thread_id"=>15,
+ "name"=>"|filterworker.0", "current_call"=>"
+ (ruby filter code):1:in `sleep'"}]}}
+Forcefully quitting logstash.. {:level=>:fatal}
+========
+
+When `--allow-unsafe-shutdown` isn't enabled, Logstash continues to run and produce these reports periodically.
diff --git a/docs/asciidoc/static/breaking-changes.asciidoc b/docs/static/breaking-changes.asciidoc
similarity index 62%
rename from docs/asciidoc/static/breaking-changes.asciidoc
rename to docs/static/breaking-changes.asciidoc
index 1232e49276c..163ecab020a 100644
--- a/docs/asciidoc/static/breaking-changes.asciidoc
+++ b/docs/static/breaking-changes.asciidoc
@@ -1,29 +1,38 @@
 [[breaking-changes]]
-== Breaking changes
+== Breaking Changes
 
-Version 2.0 of Logstash has some changes that are incompatible with previous versions of Logstash. This section discusses 
+**Breaking changes in 2.2**
+Although 2.2 is fully compatible with configurations from older versions, there are some architectural 
+changes to the pipeline that users need to take into consideration before deploying in production. 
+These changes are not strictly "breaking" in the semantic versioning sense, but they make Logstash behave differently 
+in runtime, and can also affect performance. We have compiled such a list in the <<upgrading-logstash-2.2>> section. 
+Please review it before deploying 2.2 version.
+
+**Changes in 2.0**
+
+Version 2.0 of Logstash has some changes that are incompatible with previous versions of Logstash. This section discusses
 what you need to be aware of when migrating to this version.
 
 [float]
-=== Elasticsearch Output Default
+== Elasticsearch Output Default
 
 Starting with the 2.0 release of Logstash, the default Logstash output for Elasticsearch is HTTP. To use the `node` or
-`transport` protocols, download the https://www.elastic.co/guide/en/logstash/2.0/plugins-outputs-elasticsearch_java.html[Elasticsearch Java plugin]. The 
+`transport` protocols, download the https://www.elastic.co/guide/en/logstash/2.0/plugins-outputs-elasticsearch_java.html[Elasticsearch Java plugin]. The
 Logstash HTTP output to Elasticsearch now supports sniffing.
 
-NOTE: The `elasticsearch_java` plugin has two versions specific to the version of the underlying Elasticsearch cluster. 
+NOTE: The `elasticsearch_java` plugin has two versions specific to the version of the underlying Elasticsearch cluster.
 Be sure to specify the correct value for the `--version` option during installation:
-* For Elasticsearch versions before 2.0, use the command 
+* For Elasticsearch versions before 2.0, use the command
 `bin/plugin install --version 1.5.x logstash-output-elasticsearch_java`
-* For Elasticsearch versions 2.0 and after, use the command 
+* For Elasticsearch versions 2.0 and after, use the command
 `bin/plugin install --version 2.0.0 logstash-output-elasticsearch_java`
 
 [float]
-==== Configuration Changes
+=== Configuration Changes
 
 The Elasticsearch output plugin configuration has the following changes:
 
-* The `host` configuration option is now `hosts`, allowing you to specify multiple hosts and associated ports in the 
+* The `host` configuration option is now `hosts`, allowing you to specify multiple hosts and associated ports in the
 `myhost:9200` format
 * New options: `bind_host`, `bind_port`, `cluster`, `embedded`, `embedded_http_port`, `port`, `sniffing_delay`
 * The `max_inflight_requests` option, which was deprecated in the 1.5 release, is now removed
@@ -42,20 +51,22 @@ Configuration files with these settings present are invalid and prevent Logstash
 === Kafka Output Configuration Changes
 
 The 2.0 release of Logstash includes a new version of the Kafka output plugin with significant configuration changes.
-Please compare the documentation pages for the 
+Please compare the documentation pages for the
 https://www.elastic.co/guide/en/logstash/1.5/plugins-outputs-kafka.html[Logstash 1.5] and
-https://www.elastic.co/guide/en/logstash/2.0/plugins-outputs-kafka.html[Logstash 2.0] versions of the Kafka output plugin 
+https://www.elastic.co/guide/en/logstash/2.0/plugins-outputs-kafka.html[Logstash 2.0] versions of the Kafka output plugin
 and update your configuration files accordingly.
 
 [float]
 === Metrics Filter Changes
-Prior implementations of the metrics filter plugin used dotted field names. Elasticsearch does not allow field names to have dots, beginning with version 2.0, so a change was made to use sub-fields instead of dots in this plugin. Please note that these changes make version 3.0.0 of the metrics filter plugin incompatible with previous releases.
+Prior implementations of the metrics filter plugin used dotted field names. Elasticsearch does not allow field names to
+have dots, beginning with version 2.0, so a change was made to use sub-fields instead of dots in this plugin. Please note
+that these changes make version 3.0.0 of the metrics filter plugin incompatible with previous releases.
 
 
 [float]
 === Filter Worker Default Change
 
-Starting with the 2.0 release of Logstash, the default value of the `filter_workers` configuration option for filter 
-plugins is half of the available CPU cores, instead of 1. This change increases parallelism in filter execution for 
-resource-intensive filtering operations. You can continue to use the `-w` flag to manually set the value for this option, 
+Starting with the 2.0 release of Logstash, the default value of the `filter_workers` configuration option for filter
+plugins is half of the available CPU cores, instead of 1. This change increases parallelism in filter execution for
+resource-intensive filtering operations. You can continue to use the `-w` flag to manually set the value for this option,
 as in previous releases.
diff --git a/docs/asciidoc/static/codec.asciidoc b/docs/static/codec.asciidoc
similarity index 100%
rename from docs/asciidoc/static/codec.asciidoc
rename to docs/static/codec.asciidoc
diff --git a/docs/static/command-line-flags.asciidoc b/docs/static/command-line-flags.asciidoc
new file mode 100644
index 00000000000..a1f9059109e
--- /dev/null
+++ b/docs/static/command-line-flags.asciidoc
@@ -0,0 +1,77 @@
+[[command-line-flags]]
+=== Command-line flags
+
+Logstash has the following flags. You can use the `--help` flag to display this information.
+
+[source,shell]
+----------------------------------
+-f, --config CONFIGFILE
+ Load the Logstash config from a specific file, directory, or a wildcard. If
+ given a directory or wildcard, config files will be read from the directory in
+ alphabetical order.
+
+-e CONFIGSTRING
+ Use the given string as the configuration data. Same syntax as the config file.
+ If not input is specified, 'stdin { type => stdin }' is default. If no output
+ is specified, 'stdout { codec => rubydebug }}' is default.
+
+-w, --filterworkers COUNT
+ Sets the number of pipeline workers (threads) to run for filter and output
+ processing (default: number of cores).
+ If you find that events are backing up, or that the CPU is not saturated, consider increasing
+ this number to better utilize machine processing power.
+ NOTE: --filterworkers is deprecated. Please use --pipeline-workers or -w
+
+-b, --pipeline-batch-size SIZE
+ This parameter defines the maximum number of events an individual worker thread will collect
+ before attempting to execute its filters and outputs. Default is 125 events.
+ Larger batch sizes are generally more efficient, but come at the cost of increased memory
+ overhead. You may have to increase the JVM heap size by setting the `LS_HEAP_SIZE`
+ variable to effectively use the option.
+
+-u, --pipeline-batch-delay DELAY_IN_MS
+ When creating pipeline event batches, how long to wait while polling for the next event.
+ Default is 5ms.
+
+-l, --log FILE
+ Log to a given path. Default is to log to stdout
+
+--verbose
+ Increase verbosity to the first level (info), less verbose.
+
+--debug
+ Increase verbosity to the last level (trace), more verbose.
+
+--debug-config
+ Print the compiled config ruby code out as a debug log (you must also have --debug enabled).
+ WARNING: This will include any 'password' options passed to plugin configs as plaintext, and may result
+ in plaintext passwords appearing in your logs!
+
+-V, --version
+  Display the version of Logstash.
+
+-p, --pluginpath
+  A path of where to find plugins. This flag can be given multiple times to include
+  multiple paths. Plugins are expected to be in a specific directory hierarchy:
+  'PATH/logstash/TYPE/NAME.rb' where TYPE is 'inputs' 'filters', 'outputs' or 'codecs'
+  and NAME is the name of the plugin.
+
+-t, --configtest
+  Checks configuration and then exit. Note that grok patterns are not checked for
+  correctness with this flag.
+  Logstash can read multiple config files from a directory. If you combine this
+  flag with `--debug`, Logstash will log the combined config file, annotating the
+  individual config blocks with the source file it came from.
+  
+-r, --[no-]auto-reload
+  Monitor configuration changes and reload the configuration whenever it is changed.
+
+--allow-env
+  EXPERIMENTAL: Enable environment variable templating within configuration parameters.
+  
+--reload-interval RELOAD_INTERVAL
+  Specifies how often Logstash checks the config files for changes. The default is every 3 seconds.
+
+-h, --help
+  Print help
+----------------------------------
diff --git a/docs/asciidoc/static/configuration.asciidoc b/docs/static/configuration.asciidoc
similarity index 90%
rename from docs/asciidoc/static/configuration.asciidoc
rename to docs/static/configuration.asciidoc
index adcd454e700..f839ddf00ae 100644
--- a/docs/asciidoc/static/configuration.asciidoc
+++ b/docs/static/configuration.asciidoc
@@ -366,7 +366,7 @@ What's an expression? Comparison tests, boolean logic, and so on!
 You can use the following comparison operators:
 
 * equality: `==`,  `!=`,  `<`,  `>`,  `<=`, `>=`
-* regexp: `=~`, `!~`
+* regexp: `=~`, `!~` (checks a pattern on the right against a string value on the left)
 * inclusion: `in`, `not in`
 
 The supported boolean operators are:
@@ -387,7 +387,7 @@ For example, the following conditional uses the mutate filter to remove the fiel
 ----------------------------------
 filter {
   if [action] == "login" {
-    mutate { remove => "secret" }
+    mutate { remove_field => "secret" }
   }
 }
 ----------------------------------
@@ -406,7 +406,7 @@ output {
 }
 ----------------------------------
 
-The `in` conditional enables you to compare against the value of a field:
+You can use the `in` operator to test whether a field contains a specific string, key, or (for lists) element:
 
 [source,js]
 ----------------------------------
@@ -433,7 +433,7 @@ filter {
 ----------------------------------
 
 You use the `not in` conditional the same way. For example,
-you could use `not in` to only route events to elasticsearch
+you could use `not in` to only route events to Elasticsearch
 when `grok` is successful:
 
 [source,js]
@@ -445,13 +445,20 @@ output {
 }
 ----------------------------------
 
+You can check for the existence of a specific field, but there's currently no way to differentiate between a field that
+doesn't exist versus a field that's simply false. The expression `if [foo]` returns `false` when:
+
+* `[foo]` doesn't exist in the event,
+* `[foo]` exists in the event, but is false, or
+* `[foo]` exists in the event, but is nil
+
 For more complex examples, see <<using-conditionals, Using Conditionals>>.
 
 [float]
 [[metadata]]
 ==== The @metadata field
 
-In Logstash 1.5 there is a new, special field, called `@metadata`.  The contents
+In Logstash 1.5 and later, there is a special field called `@metadata`.  The contents
 of `@metadata` will not be part of any of your events at output time, which
 makes it great to use for conditionals, or extending and building event fields
 with field reference and sprintf formatting.
@@ -599,6 +606,184 @@ output {
 }
 ----------------------------------
 
+[[environment-variables]]
+=== Using Environment Variables in Configuration
+==== Overview
+
+* You can set environment variable references into Logstash plugins configuration using `${var}` or `$var`.
+* Each reference will be replaced by environment variable value at Logstash startup.
+* The replacement is case-sensitive.
+* References to undefined variables raise a Logstash configuration error.
+* A default value can be given by using the form `${var:default value}`.
+* You can add environment variable references in any plugin option type : string, number, boolean, array or hash.
+* Environment variables are immutable. If you update the environment variable, you'll have to restart Logstash to pick the updated value.
+
+==== Examples
+
+[cols="a,a,a"]
+|==================================
+|Logstash config source	|Environment 	|Logstash config result
+
+|
+[source,ruby]
+----
+input {
+  tcp {
+    port => "$TCP_PORT"
+  }
+}
+----
+
+|
+[source,shell]
+----
+export TCP_PORT=12345
+----
+|
+[source,ruby]
+----
+input {
+  tcp {
+    port => 12345
+  }
+}
+----
+|
+[source,ruby]
+----
+input {
+  tcp {
+    port => "${TCP_PORT}"
+  }
+}
+----
+
+|
+[source,shell]
+----
+export TCP_PORT=12345
+----
+|
+[source,ruby]
+----
+input {
+  tcp {
+    port => 12345
+  }
+}
+----
+|
+[source,ruby]
+----
+input {
+  tcp {
+    port => "${TCP_PORT}"
+  }
+}
+----
+
+|
+No TCP_PORT defined
+|
+Raise a logstash configuration error
+|
+[source,ruby]
+----
+input {
+  tcp {
+    port => "${TCP_PORT:54321}"
+  }
+}
+----
+
+|
+No TCP_PORT defined
+|
+[source,ruby]
+----
+input {
+  tcp {
+    port => 54321
+  }
+}
+----
+|
+[source,ruby]
+----
+input {
+  tcp {
+    port => "${TCP_PORT:54321}"
+  }
+}
+----
+
+|
+[source,shell]
+----
+export TCP_PORT=12345
+----
+|
+[source,ruby]
+----
+input {
+  tcp {
+    port => 12345
+  }
+}
+----
+|
+[source,ruby]
+----
+filter {
+  mutate {
+    add_tag => [ "tag1", "${ENV_TAG}" ]
+  }
+}
+----
+
+|
+[source,shell]
+----
+export ENV_TAG="tag2"
+----
+|
+[source,ruby]
+----
+filter {
+  mutate {
+    add_tag => [ "tag1", "tag2" ]
+  }
+}
+----
+|
+[source,ruby]
+----
+filter {
+  mutate {
+    add_field => {
+      "my_path" => "${HOME}/file.log"
+    }
+  }
+}
+----
+|
+[source,shell]
+----
+export HOME="/path"
+----
+|
+[source,ruby]
+----
+filter {
+  mutate {
+    add_field => {
+      "my_path" => "/path/file.log"
+    }
+  }
+}
+----
+|==================================
+
 [[config-examples]]
 === Logstash Configuration Examples
 The following examples illustrate how you can configure Logstash to filter events, process Apache logs and syslog messages, and use conditionals to control what events are processed by a filter or output.
@@ -773,7 +958,7 @@ This example labels all events using the `type` field, but doesn't actually pars
 Similarly, you can use conditionals to direct events to particular outputs. For example, you could:
 
 * alert nagios of any apache events with status 5xx
-* record any 4xx status to elasticsearch
+* record any 4xx status to Elasticsearch
 * record all status code hits via statsd
 
 To tell nagios about any http event that has a 5xx status code, you
@@ -822,7 +1007,6 @@ filter {
       add_field => [ "received_at", "%{@timestamp}" ]
       add_field => [ "received_from", "%{host}" ]
     }
-    syslog_pri { }
     date {
       match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
     }
diff --git a/docs/static/contributing-patch.asciidoc b/docs/static/contributing-patch.asciidoc
new file mode 100644
index 00000000000..470841574f2
--- /dev/null
+++ b/docs/static/contributing-patch.asciidoc
@@ -0,0 +1,397 @@
+[[contributing-patch-plugin]]
+=== Contributing a Patch to a Logstash Plugin
+
+This section discusses the information you need to know to successfully contribute a patch to a Logstash plugin.
+
+Each plugin defines its own configuration options. These control the behaviour of the plugin to some degree. Configuration 
+option definitions commonly include:
+
+* Data validation
+* The default value
+* Any required flags
+
+Plugins are subclasses of a Logstash base class. A plugin's base class defines common configuration and methods.
+
+==== Input Plugins
+
+Input plugins ingest data from an external source. Input plugins are always associated with a codec. An input plugin 
+always has an associated codec plugin. Input and codec plugins operate in conjuction to create a Logstash event and add 
+that event to the processing queue. An input codec is a subclass of the `LogStash::Inputs::Base` class.
+
+.Input API
+[horizontal]
+`#register() -> nil`:: Required. This API sets up resources for the plugin, typically the connection to the 
+external source.
+`#run(queue) -> nil`:: Required. This API fetches or listens for source data, typically looping until stopped. Must handle 
+errors inside the loop. Pushes any created events to the queue object specified in the method argument. Some inputs may 
+receive batched data to minimize the external call overhead.
+`#stop() -> nil`:: Optional. Stops external connections and cleans up.
+
+==== Codec Plugins
+
+Codec plugins decode input data that has a specific structure, such as JSON input data. A codec plugin is a subclass of 
+`LogStash::Codecs::Base`.
+
+.Codec API
+[horizontal]
+`#register() -> nil`:: Identical to the API of the same name for input plugins.
+`#decode(data){|event| block} -> nil`:: Must be implemented. Used to create an Event from the raw data given in the method 
+argument. Must handle errors. The caller must provide a Ruby block. The block is called with the created Event.
+`#encode(event) -> nil`:: Required.  Used to create a structured data object from the given Event. May handle 
+errors. This method calls a block that was previously stored as @on_event with two arguments: the original event and the 
+data object.
+
+==== Filter Plugins
+
+A mechanism to change, mutate or merge one or more Events. A filter plugin is a subclass of the `LogStash::Filters::Base` 
+class.
+
+.Filter API
+[horizontal]
+`#register() -> nil`:: Identical to the API of the same name for input plugins.
+`#filter(event) -> nil`:: Required. May handle errors. Used to apply a mutation function to the given event.
+
+==== Output Plugins
+
+A mechanism to send an event to an external destination. This process may require serialization. An output plugin is a 
+subclass of the `LogStash::Outputs::Base` class.
+
+.Output API
+[horizontal]
+`#register() -> nil`:: Identical to the API of the same name for input plugins.
+`#receive(event) -> nil`:: Required. Must handle errors. Used to prepare the given event for transmission to 
+the external destination. Some outputs may buffer the prepared events to batch transmit to the destination.
+
+[[patch-process]]
+==== Process
+
+A bug or feature is identified. An issue is created in the plugin repository. A patch is created and a pull request (PR) 
+is submitted. After review and possible rework the PR is merged and the plugin is published.
+
+The <<community-maintainer,Community Maintainer Guide>> explains, in more detail, the process of getting a patch accepted, 
+merged and published.  The Community Maintainer Guide also details the roles that contributors and maintainers are 
+expected to perform.
+
+==== Testing Methodologies
+
+===== Test Driven Development
+
+Test Driven Development, colloquially known as TDD, describes a methodology for using tests to guide evolution of source
+code. For our purposes, we are only going to use a part of it, that is, before writing the fix - we create tests that 
+illustrate the bug by failing. We stop when we have written enough code to make the tests pass and submit the fix and 
+tests as a patch. It is not necessary to write the tests before the fix, but it is very easy to write a passing test 
+afterwards that may not actually verify that the fault is really fixed especially if the fault can be triggered via 
+multiple execution paths or varying input data.
+
+===== The RSpec Framework
+
+Logstash uses Rspec, a Ruby testing framework, to define and run the test suite. What follows is a summary of various 
+sources.
+
+. Rspec Example
+[source,ruby]
+ 1 # encoding: utf-8
+ 2 require "logstash/devutils/rspec/spec_helper"
+ 3 require "logstash/plugin"
+ 4
+ 5 describe "outputs/riemann" do
+ 6   describe "#register" do
+ 7     let(:output) do
+ 8       LogStash::Plugin.lookup("output", "riemann").new(configuration)
+ 9     end
+10
+11     context "when no protocol is specified" do
+12       let(:configuration) { Hash.new }
+13
+14       it "the method completes without error" do
+15         expect {output.register}.not_to raise_error
+16       end
+17     end
+18
+19     context "when a bad protocol is specified" do
+20       let(:configuration) { {"protocol" => "fake"} }
+21
+22       it "the method fails with error" do
+23         expect {output.register}.to raise_error
+24       end
+25     end
+26
+27     context "when the tcp protocol is specified" do
+28       let(:configuration) { {"protocol" => "tcp"} }
+29
+30       it "the method completes without error" do
+31         expect {output.register}.not_to raise_error
+32       end
+33     end
+34   end
+35
+36   describe "#receive" do
+37     let(:output) do
+38       LogStash::Plugin.lookup("output", "riemann").new(configuration)
+39     end
+40
+41     context "when operating normally" do
+42       let(:configuration) { Hash.new }
+43       let(:event) do
+44         data = {"message"=>"hello", "@version"=>"1",
+45                 "@timestamp"=>"2015-06-03T23:34:54.076Z",
+46                 "host"=>"vagrant-ubuntu-trusty-64"}
+47         LogStash::Event.new(data)
+48       end
+49
+50       before(:example) do
+51         output.register
+52       end
+53
+54       it "should accept the event" do
+55         expect { output.receive event }.not_to raise_error
+56       end
+57     end
+58   end
+59 end
+
+.Describe blocks (lines 5, 6 and 36 in Example 1)
+[source,ruby]
+describe(string){block} -> nil
+describe(Class){block} -> nil
+
+With RSpec, we are always describing the plugin method behavior. The describe block is added in logical sections and can
+accept either an existing class name or a string. The string used in line 5 is the plugin name. Line 6 is the register 
+method, line 36 is the receive method. It is a RSpec convention to prefix instance methods with one hash and class 
+methods with one dot.
+
+.Context blocks (lines 11, 19, 27 and 41)
+[source,ruby]
+context(string){block} -> nil
+
+In RSpec, context blocks define sections that group tests by a variation.  The string should start with the word `when` 
+and then detail the variation. See line 11.  The tests in the content block should should only be for that variation.
+
+.Let blocks (lines 7, 12, 20, 28, 37, 42 and 43)
+[source,ruby]
+let(symbol){block} -> nil
+
+In RSpec, `let` blocks define resources for use in the test blocks. These resources are reinitialized for every test 
+block. They are available as method calls inside the test block. Define `let` blocks in `describe` and `context` blocks, 
+which scope the `let` block and any other nested blocks.
+You can use other `let` methods defined later within the `let` block body. See lines 7-9, which define the output resource 
+and use the configuration method, defined with different variations in lines 12, 20 and 28.
+
+.Before blocks (line 50)
+[source,ruby]
+before(symbol){block} -> nil - symbol is one of :suite, :context, :example, but :all and :each are synonyms for :suite and :example respectively.
+
+In RSpec, `before` blocks are used to further set up any resources that would have been initialized in a `let` block.
+You cannot define `let` blocks inside `before` blocks.
+
+You can also define `after` blocks, which are typically used to clean up any setup activity performed by a `before` block.
+
+.It blocks (lines 14, 22, 30 and 54)
+[source,ruby]
+it(string){block} -> nil
+
+In RSpec, `it` blocks set the expectations that verify the behavior of the tested code. The string should not start with 
+'it' or 'should', but needs to express the outcome of the expectation.  When put together the texts from the enclosing 
+describe, `context` and `it` blocks should form a fairly readable sentence, as in lines 5, 6, 11 and 14:
+
+[source,ruby]
+outputs/riemann 
+#register when no protocol is specified the method completes without error
+
+Readable code like this make the goals of tests easy to understand.
+
+.Expect method (lines 15, 23, 31, 55)
+[source,ruby]
+expect(object){block} -> nil
+
+In RSpec, the expect method verifies a statement that compares an actual result to an expected result. The `expect` method 
+is usually paired with a call to the `to` or `not_to` methods. Use the block form when expecting errors or observing for 
+changes. The `to` or `not_to` methods require a `matcher` object that encapsulates the expected value. The argument form 
+of the `expect` method encapsulates the actual value. When put together the whole line tests the actual against the 
+expected value.
+
+.Matcher methods (lines 15, 23, 31, 55)
+[source,ruby]
+raise_error(error class|nil) -> matcher instance
+be(object) -> matcher instance
+eq(object) -> matcher instance
+eql(object) -> matcher instance
+  for more see http://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers
+
+In RSpec, a matcher is an object generated by the equivalent method call (be, eq) that will be used to evaluate the 
+expected against the actual values.
+
+==== Putting it all together
+
+This example fixes an https://github.com/logstash-plugins/logstash-output-zeromq/issues/9[issue] in the ZeroMQ output 
+plugin. The issue does not require knowledge of ZeroMQ.
+
+The activities in this example have the following prerequisites:
+
+--
+* A minimal knowledge of Git and Github. See the https://help.github.com/categories/bootcamp/[Github boot camp].
+* A text editor.
+* A JRuby https://www.ruby-lang.org/en/documentation/installation/#managers[runtime] 
+https://howistart.org/posts/ruby/1[environment]. The `chruby` tool manages Ruby versions.
+* JRuby 1.7.22 or later.
+* The `bundler` and `rake` gems installed. 
+* ZeroMQ http://zeromq.org/intro:get-the-software[installed].
+--
+
+. In Github, fork the ZeroMQ https://github.com/logstash-plugins/logstash-output-zeromq[output plugin repository].
+
+. On your local machine, https://help.github.com/articles/fork-a-repo/[clone] the fork to a known folder such as
+`logstash/`.
+
+. Open the following files in a text editor:
+  * `logstash-output-zeromq/lib/logstash/outputs/zeromq.rb`
+  * `logstash-output-zeromq/lib/logstash/util/zeromq.rb`
+  * `logstash-output-zeromq/spec/outputs/zeromq_spec.rb`
+
+. According to the issue, log output in server mode must indicate `bound`. Furthermore, the test file contains no tests.
++
+NOTE: Line 21 of `util/zeromq.rb` reads `@logger.info("0mq: #{server? ? 'connected' : 'bound'}", :address => address)`
+
+. In the text editor, set the file encoding and require `zeromq.rb` for the file `zeromq_spec.rb` by adding the following 
+lines:
++
+[source,ruby]
+# encoding: utf-8
+require "logstash/outputs/zeromq"
+require "logstash/devutils/rspec/spec_helper"
+
+. The desired error message should read:
++
+[source,ruby]
+LogStash::Outputs::ZeroMQ when in server mode a 'bound' info line is logged 
++
+To properly generate this message, add a `describe` block with the fully qualified class name as the argument, a context 
+block, and an `it` block.
++
+[source,ruby]
+describe LogStash::Outputs::ZeroMQ do
+  context "when in server mode" do
+    it "a 'bound' info line is logged" do
+    end
+  end
+end
+
+. To add the missing test, use an instance of the ZeroMQ output and a substitute logger. This examle uses an RSpec feature 
+called _test doubles_ as the substitute logger.
++
+Add the following lines to `zeromq_spec.rb`, after `describe LogStash::Outputs::ZeroMQ do` and before `context "when in 
+server mode" do`:
+[source,ruby]
+  let(:output) { described_class.new("mode" => "server", "topology" => "pushpull" }
+  let(:tracer) { double("logger") }
+
+. Add the body to the `it` block. Add the following five lines after the line `context "when in server mode" do`: 
+[source,ruby]
+      allow(tracer).to receive(:debug)<1>
+      output.logger = logger<2>
+      expect(tracer).to receive(:info).with("0mq: bound", {:address=>"tcp://127.0.0.1:2120"})<3>
+      output.register<4>
+      output.do_close<5>
+
+<1> Allow the double to receive `debug` method calls.
+<2> Make the output use the test double.
+<3> Set an expectation on the test to receive an `info` method call.
+<4> Call `register` on the output.
+<5> Call `do_close` on the output so the test does not hang.
+
+At the end of the modifications, the relevant code section reads:
+
+[source,ruby]
+--------
+# encoding: utf-8
+require "logstash/outputs/zeromq"
+require "logstash/devutils/rspec/spec_helper"
+
+describe LogStash::Outputs::ZeroMQ do
+  let(:output) { described_class.new("mode" => "server", "topology" => "pushpull") }
+  let(:tracer) { double("logger") }
+
+  context "when in server mode" do
+    it "a ‘bound’ info line is logged" do
+      allow(tracer).to receive(:debug)
+      output.logger = tracer
+      expect(tracer).to receive(:info).with("0mq: bound", {:address=>"tcp://127.0.0.1:2120"})
+      output.register
+      output.do_close
+    end
+  end
+end
+--------
+
+To run this test:
+
+. Open a terminal window
+. Mavigate to the cloned plugin folder
+. The first time you run the test, run the command `bundle install`
+. Run the command `bundle exec rspec`
+
+Assuming all prerequisites were installed correctly, the test fails with output similar to:
+
+[source,shell]
+--------
+Using Accessor#strict_set for specs
+Run options: exclude {:redis=>true, :socket=>true, :performance=>true, :couchdb=>true, :elasticsearch=>true, 
+:elasticsearch_secure=>true, :export_cypher=>true, :integration=>true, :windows=>true}
+
+LogStash::Outputs::ZeroMQ
+  when in server mode
+    a ‘bound’ info line is logged (FAILED - 1)
+
+Failures:
+
+  1) LogStash::Outputs::ZeroMQ when in server mode a ‘bound’ info line is logged
+     Failure/Error: output.register
+       Double "logger" received :info with unexpected arguments
+         expected: ("0mq: bound", {:address=>"tcp://127.0.0.1:2120"})
+              got: ("0mq: connected", {:address=>"tcp://127.0.0.1:2120"})
+     # ./lib/logstash/util/zeromq.rb:21:in `setup'
+     # ./lib/logstash/outputs/zeromq.rb:92:in `register'
+     # ./lib/logstash/outputs/zeromq.rb:91:in `register'
+     # ./spec/outputs/zeromq_spec.rb:13:in `(root)'
+     # /Users/guy/.gem/jruby/1.9.3/gems/rspec-wait-0.0.7/lib/rspec/wait.rb:46:in `(root)'
+
+Finished in 0.133 seconds (files took 1.28 seconds to load)
+1 example, 1 failure
+
+Failed examples:
+
+rspec ./spec/outputs/zeromq_spec.rb:10 # LogStash::Outputs::ZeroMQ when in server mode a ‘bound’ info line is logged
+
+Randomized with seed 2568
+--------
+
+To correct the error, open the `util/zeromq.rb` file in your text editor and swap the positions of the words `connected` 
+and `bound` on line 21. Line 21 now reads:
+
+[source,ruby]
+@logger.info("0mq: #{server? ? 'bound' : 'connected'}", :address => address)
+
+Run the test again with the `bundle exec rspec` command.
+
+The test passes with output similar to:
+
+[source,shell]
+--------
+Using Accessor#strict_set for specs
+Run options: exclude {:redis=>true, :socket=>true, :performance=>true, :couchdb=>true, :elasticsearch=>true, :elasticsearch_secure=>true, :export_cypher=>true, :integration=>true, :windows=>true}
+
+LogStash::Outputs::ZeroMQ
+  when in server mode
+    a ‘bound’ info line is logged
+
+Finished in 0.114 seconds (files took 1.22 seconds to load)
+1 example, 0 failures
+
+Randomized with seed 45887
+--------
+
+https://help.github.com/articles/fork-a-repo/#next-steps[Commit] the changes to git and Github.
+
+Your pull request is visible from the https://github.com/logstash-plugins/logstash-output-zeromq/pulls[Pull Requests] 
+section of the original Github repository. The plugin maintainers review your work, suggest changes if necessary, and
+merge and publish a new version of the plugin.
diff --git a/docs/asciidoc/static/contributing-to-logstash.asciidoc b/docs/static/contributing-to-logstash.asciidoc
similarity index 89%
rename from docs/asciidoc/static/contributing-to-logstash.asciidoc
rename to docs/static/contributing-to-logstash.asciidoc
index ab9dc568ff7..238b26fa4fe 100644
--- a/docs/asciidoc/static/contributing-to-logstash.asciidoc
+++ b/docs/static/contributing-to-logstash.asciidoc
@@ -14,10 +14,14 @@ Since plugins can now be developed and deployed independently of the Logstash
 core, there are documents which guide you through the process of coding and
 deploying your own plugins:
 
+
 * http://www.elasticsearch.org/guide/en/logstash/current/_how_to_write_a_logstash_input_plugin.html[How to write a Logstash input plugin]
 * http://www.elasticsearch.org/guide/en/logstash/current/_how_to_write_a_logstash_codec_plugin.html[How to write a Logstash codec plugin]
 * http://www.elasticsearch.org/guide/en/logstash/current/_how_to_write_a_logstash_filter_plugin.html[How to write a Logstash filter plugin]
 * http://www.elasticsearch.org/guide/en/logstash/current/_how_to_write_a_logstash_output_plugin.html[How to write a Logstash output plugin]
+* <<contributing-patch-plugin,Contributing a Patch to a Logstash Plugin>>
+* <<community-maintainer,Community Maintainer's Guide>>
+* <<submitting-plugin,Submitting a Plugin>>
 
 [float]
 ==== Plugin API Changes added[2.0]
@@ -27,10 +31,10 @@ for plugin shutdown: `stop`, `stop?`, and `close`.
 
 * Call the `stop` method from outside the plugin thread. This method signals the plugin to stop.
 * The `stop?` method returns `true` when the `stop` method has already been called for that plugin.
-* The `close` method performs final bookkeeping and cleanup after the plugin's `run` method and the plugin's thread both 
+* The `close` method performs final bookkeeping and cleanup after the plugin's `run` method and the plugin's thread both
 exit. The `close` method is a a new name for the method known as `teardown` in previous versions of Logstash.
 
-The `shutdown`, `finished`, `finished?`, `running?`, and `terminating?` methods are redundant and no longer present in the 
+The `shutdown`, `finished`, `finished?`, `running?`, and `terminating?` methods are redundant and no longer present in the
 Plugin Base class.
 
 Sample code for the new plugin shutdown APIs is https://github.com/logstash-plugins/logstash-input-example/blob/master/lib/logstash/inputs/example.rb[available].
diff --git a/docs/asciidoc/static/deploying.asciidoc b/docs/static/deploying.asciidoc
similarity index 63%
rename from docs/asciidoc/static/deploying.asciidoc
rename to docs/static/deploying.asciidoc
index a81239ddcfe..e57cd85554b 100644
--- a/docs/asciidoc/static/deploying.asciidoc
+++ b/docs/static/deploying.asciidoc
@@ -1,20 +1,20 @@
 [[deploying-and-scaling]]
 === Deploying and Scaling Logstash
 
-As your use case for Logstash evolves, the preferred architecture at a given scale will change. This section discusses 
-a range of Logstash architectures in increasing order of complexity, starting from a minimal installation and adding 
-elements to the system. The example deployments in this section write to an Elasticsearch cluster, but Logstash can 
+As your use case for Logstash evolves, the preferred architecture at a given scale will change. This section discusses
+a range of Logstash architectures in increasing order of complexity, starting from a minimal installation and adding
+elements to the system. The example deployments in this section write to an Elasticsearch cluster, but Logstash can
 write to a large variety of {logstash}output-plugins.html[endpoints].
 
 [float]
 [[deploying-minimal-install]]
 ==== The Minimal Installation
 
-The minimal Logstash installation has one Logstash instance and one Elasticsearch instance. These instances are 
-directly connected. Logstash uses an {logstash}input-plugins.html[_input plugin_] to ingest data and an 
-Elasticsearch {logstash}output-plugins.html[_output plugin_] to index the data in Elasticsearch, following the Logstash 
-{logstash}pipeline.html[_processing pipeline_]. A Logstash instance has a fixed pipeline constructed at startup, 
-based on the instance’s configuration file. You must specify an input plugin. Output defaults to `stdout`, and the 
+The minimal Logstash installation has one Logstash instance and one Elasticsearch instance. These instances are
+directly connected. Logstash uses an {logstash}input-plugins.html[_input plugin_] to ingest data and an
+Elasticsearch {logstash}output-plugins.html[_output plugin_] to index the data in Elasticsearch, following the Logstash
+{logstash}pipeline.html[_processing pipeline_]. A Logstash instance has a fixed pipeline constructed at startup,
+based on the instance’s configuration file. You must specify an input plugin. Output defaults to `stdout`, and the
 filtering section of the pipeline, which is discussed in the next section, is optional.
 
 image::static/images/deploy_1.png[]
@@ -23,34 +23,33 @@ image::static/images/deploy_1.png[]
 [[deploying-filter-threads]]
 ==== Using Filters
 
-Log data is typically unstructured, often contains extraneous information that isn’t relevant to your use case, and 
-sometimes is missing relevant information that can be derived from the log contents. You can use a 
-{logstash}filter-plugins.html[filter plugin] to parse the log into fields, remove unnecessary information, and derive 
-additional information from the existing fields. For example, filters can derive geolocation information from an IP 
-address and add that information to the logs, or parse and structure arbitrary text with the 
+Log data is typically unstructured, often contains extraneous information that isn’t relevant to your use case, and
+sometimes is missing relevant information that can be derived from the log contents. You can use a
+{logstash}filter-plugins.html[filter plugin] to parse the log into fields, remove unnecessary information, and derive
+additional information from the existing fields. For example, filters can derive geolocation information from an IP
+address and add that information to the logs, or parse and structure arbitrary text with the
 {logstash}plugins-filters-grok.html[grok] filter.
 
-Adding a filter plugin can significantly affect performance, depending on the amount of computation the filter plugin 
-performs, as well as on the volume of the logs being processed. The `grok` filter’s regular expression computation is 
-particularly resource-intensive. One way to address this increased demand for computing resources is to use 
-parallel processing on multicore machines. Use the `-w` switch to set the number of execution threads for Logstash 
+Adding a filter plugin can significantly affect performance, depending on the amount of computation the filter plugin
+performs, as well as on the volume of the logs being processed. The `grok` filter’s regular expression computation is
+particularly resource-intensive. One way to address this increased demand for computing resources is to use
+parallel processing on multicore machines. Use the `-w` switch to set the number of execution threads for Logstash
 filtering tasks. For example the `bin/logstash -w 8` command uses eight different threads for filter processing.
 
 image::static/images/deploy_2.png[]
 
 [float]
-[[deploying-logstash-forwarder]]
-==== Using Logstash Forwarder
+[[deploying-filebeat]]
+==== Using Filebeat
 
-The https://github.com/elastic/logstash-forwarder[Logstash Forwarder] is a lightweight, resource-friendly tool written 
-in Go that collects logs from files on the server and forwards these logs to other machines for processing. The 
-Logstash Forwarder uses a secure protocol called Lumberjack to communicate with a centralized Logstash instance. 
-Configure the Logstash instances that receive Lumberjack data to use the 
-{logstash}plugins-inputs-lumberjack.html[Lumberjack input plugin].
+https://www.elastic.co/guide/en/beats/filebeat/current/index.html[Filebeat] is a lightweight, resource-friendly tool
+written in Go that collects logs from files on the server and forwards these logs to other machines for processing.
+Filebeat uses the https://www.elastic.co/guide/en/beats/libbeat/current/index.html[Beats] protocol to communicate with a
+centralized Logstash instance. Configure the Logstash instances that receive Beats data to use the
+{logstash}plugins-inputs-beats.html[Beats input plugin].
 
-The Logstash Forwarder uses the computing resources of the machine hosting the source data, and the Lumberjack input 
-plugin minimizes the resource demands on the Logstash instance, making this architecture attractive for use cases with 
-resource constraints.
+Filebeat uses the computing resources of the machine hosting the source data, and the Beats input plugin minimizes the
+resource demands on the Logstash instance, making this architecture attractive for use cases with resource constraints.
 
 image::static/images/deploy_3.png[]
 
@@ -58,33 +57,33 @@ image::static/images/deploy_3.png[]
 [[deploying-larger-cluster]]
 ==== Scaling to a Larger Elasticsearch Cluster
 
-Typically, Logstash does not communicate with a single Elasticsearch node, but with a cluster that comprises several 
+Typically, Logstash does not communicate with a single Elasticsearch node, but with a cluster that comprises several
 nodes. By default, Logstash uses the HTTP protocol to move data into the cluster.
 
-You can use the Elasticsearch HTTP REST APIs to index data into the Elasticsearch cluster. These APIs represent the 
-indexed data in JSON. Using the REST APIs does not require the Java client classes or any additional JAR 
-files and has no performance disadvantages compared to the transport or node protocols. You can secure communications 
+You can use the Elasticsearch HTTP REST APIs to index data into the Elasticsearch cluster. These APIs represent the
+indexed data in JSON. Using the REST APIs does not require the Java client classes or any additional JAR
+files and has no performance disadvantages compared to the transport or node protocols. You can secure communications
 that use the HTTP REST APIs with the {shield}[Shield] plugin, which supports SSL and HTTP basic authentication.
 
-When you use the HTTP protocol, you can configure the Logstash Elasticsearch output plugin to automatically 
-load-balance indexing requests across a 
+When you use the HTTP protocol, you can configure the Logstash Elasticsearch output plugin to automatically
+load-balance indexing requests across a
 specified set of hosts in the Elasticsearch cluster. Specifying multiple Elasticsearch nodes also provides high availability for the Elasticsearch cluster by routing traffic to active Elasticsearch nodes.
 
-You can also use the Elasticsearch Java APIs to serialize the data into a binary representation, using 
-the transport protocol. The transport protocol can sniff the endpoint of the request and select an 
-arbitrary client or data node in the Elasticsearch cluster. 
+You can also use the Elasticsearch Java APIs to serialize the data into a binary representation, using
+the transport protocol. The transport protocol can sniff the endpoint of the request and select an
+arbitrary client or data node in the Elasticsearch cluster.
 
-Using the HTTP or transport protocols keep your Logstash instances separate from the Elasticsearch cluster. The node 
-protocol, by contrast, has the machine running the Logstash instance join the Elasticsearch cluster, running an 
-Elasticsearch instance. The data that needs indexing propagates from this node to the rest of the cluster. Since the 
-machine is part of the cluster, the cluster topology is available, making the node protocol a good fit for use cases 
+Using the HTTP or transport protocols keep your Logstash instances separate from the Elasticsearch cluster. The node
+protocol, by contrast, has the machine running the Logstash instance join the Elasticsearch cluster, running an
+Elasticsearch instance. The data that needs indexing propagates from this node to the rest of the cluster. Since the
+machine is part of the cluster, the cluster topology is available, making the node protocol a good fit for use cases
 that use a relatively small number of persistent connections.
 
-You can also use a third-party hardware or software load balancer to handle connections between Logstash and 
+You can also use a third-party hardware or software load balancer to handle connections between Logstash and
 external applications.
 
 NOTE: Make sure that your Logstash configuration does not connect directly to Elasticsearch dedicated
-{ref}modules-node.html[master nodes], which perform dedicated cluster management. Connect Logstash to client or data 
+{ref}modules-node.html[master nodes], which perform dedicated cluster management. Connect Logstash to client or data
 nodes to protect the stability of your Elasticsearch cluster.
 
 image::static/images/deploy_4.png[]
@@ -93,19 +92,19 @@ image::static/images/deploy_4.png[]
 [[deploying-message-queueing]]
 ==== Managing Throughput Spikes with Message Queueing
 
-When the data coming into a Logstash pipeline exceeds the Elasticsearch cluster's ability to ingest the data, you can 
-use a message queue as a buffer. By default, Logstash throttles incoming events when 
-indexer consumption rates fall below incoming data rates. Since this throttling can lead to events being buffered at 
+When the data coming into a Logstash pipeline exceeds the Elasticsearch cluster's ability to ingest the data, you can
+use a message queue as a buffer. By default, Logstash throttles incoming events when
+indexer consumption rates fall below incoming data rates. Since this throttling can lead to events being buffered at
 the data source, preventing backpressure with message queues becomes an important part of managing your deployment.
 
-Adding a message queue to your Logstash deployment also provides a level of protection from data loss. When a Logstash 
-instance that has consumed data from the message queue fails, the data can be replayed from the message queue to an 
+Adding a message queue to your Logstash deployment also provides a level of protection from data loss. When a Logstash
+instance that has consumed data from the message queue fails, the data can be replayed from the message queue to an
 active Logstash instance.
 
-Several third-party message queues exist, such as Redis, Kafka, or RabbitMQ. Logstash provides input and output plugins 
-to integrate with several of these third-party message queues. When your Logstash deployment has a message queue 
-configured, Logstash functionally exists in two phases: shipping instances, which handles data ingestion and storage in 
-the message queue, and indexing instances, which retrieve the data from the message queue, apply any configured 
+Several third-party message queues exist, such as Redis, Kafka, or RabbitMQ. Logstash provides input and output plugins
+to integrate with several of these third-party message queues. When your Logstash deployment has a message queue
+configured, Logstash functionally exists in two phases: shipping instances, which handles data ingestion and storage in
+the message queue, and indexing instances, which retrieve the data from the message queue, apply any configured
 filtering, and write the filtered data to an Elasticsearch index.
 
 image::static/images/deploy_5.png[]
@@ -114,20 +113,20 @@ image::static/images/deploy_5.png[]
 [[deploying-logstash-ha]]
 ==== Multiple Connections for Logstash High Availability
 
-To make your Logstash deployment more resilient to individual instance failures, you can set up a load balancer between 
-your data source machines and the Logstash cluster. The load balancer handles the individual connections to the 
+To make your Logstash deployment more resilient to individual instance failures, you can set up a load balancer between
+your data source machines and the Logstash cluster. The load balancer handles the individual connections to the
 Logstash instances to ensure continuity of data ingestion and processing even when an individual instance is unavailable.
 
 image::static/images/deploy_6.png[]
 
-The architecture in the previous diagram is unable to process input from a specific type, such as an RSS feed or a 
-file, if the Logstash instance dedicated to that input type becomes unavailable. For more robust input processing, 
+The architecture in the previous diagram is unable to process input from a specific type, such as an RSS feed or a
+file, if the Logstash instance dedicated to that input type becomes unavailable. For more robust input processing,
 configure each Logstash instance for multiple inputs, as in the following diagram:
 
 image::static/images/deploy_7.png[]
 
-This architecture parallelizes the Logstash workload based on the inputs you configure. With more inputs, you can add 
-more Logstash instances to scale horizontally. Separate parallel pipelines also increases the reliability of your stack 
+This architecture parallelizes the Logstash workload based on the inputs you configure. With more inputs, you can add
+more Logstash instances to scale horizontally. Separate parallel pipelines also increases the reliability of your stack
 by eliminating single points of failure.
 
 [float]
@@ -141,7 +140,7 @@ A mature Logstash deployment typically has the following pipeline:
 * The _filter_ tier applies parsing and other processing to the data consumed from the message queue.
 * The _indexing_ tier moves the processed data into Elasticsearch.
 
-Any of these layers can be scaled by adding computing resources. Examine the performance of these components regularly 
-as your use case evolves and add resources as needed. When Logstash routinely throttles incoming events, consider 
-adding storage for your message queue. Alternately, increase the Elasticsearch cluster's rate of data consumption by 
+Any of these layers can be scaled by adding computing resources. Examine the performance of these components regularly
+as your use case evolves and add resources as needed. When Logstash routinely throttles incoming events, consider
+adding storage for your message queue. Alternately, increase the Elasticsearch cluster's rate of data consumption by
 adding more Logstash indexing instances.
diff --git a/docs/asciidoc/static/filter.asciidoc b/docs/static/filter.asciidoc
similarity index 100%
rename from docs/asciidoc/static/filter.asciidoc
rename to docs/static/filter.asciidoc
diff --git a/docs/static/getting-started-with-logstash.asciidoc b/docs/static/getting-started-with-logstash.asciidoc
new file mode 100644
index 00000000000..8f4e575b82e
--- /dev/null
+++ b/docs/static/getting-started-with-logstash.asciidoc
@@ -0,0 +1,157 @@
+[[getting-started-with-logstash]]
+== Getting Started with Logstash
+
+This section guides you through the process of installing Logstash and verifying that everything is running properly.
+Later sections deal with increasingly complex configurations to address selected use cases. This section includes the
+following topics:
+
+* <<installing-logstash>>
+* <<first-event>>
+* <<advanced-pipeline>>
+* <<stalled-shutdown>>
+* <<pipeline>>
+
+
+[[installing-logstash]]
+=== Installing Logstash
+
+NOTE: Logstash requires Java 7 or later. Use the
+http://www.oracle.com/technetwork/java/javase/downloads/index.html[official Oracle distribution] or an open-source
+distribution such as http://openjdk.java.net/[OpenJDK].
+
+To check your Java version, run the following command:
+
+[source,shell]
+java -version
+
+On systems with Java installed, this command produces output similar to the following:
+
+[source,shell]
+java version "1.7.0_45"
+Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
+Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
+
+[float]
+[[installing-binary]]
+=== Installing from a Downloaded Binary
+
+Download the https://www.elastic.co/downloads/logstash[Logstash installation file] that matches your host environment.
+Unpack the file. Do not install Logstash into a directory path that contains colon (:) characters. 
+
+On supported Linux operating systems, you can use a package manager to install Logstash.
+
+[float]
+[[package-repositories]]
+=== Installing from Package Repositories
+
+We also have repositories available for APT and YUM based distributions. Note
+that we only provide binary packages, but no source packages, as the packages
+are created as part of the Logstash build.
+
+We have split the Logstash package repositories by version into separate urls
+to avoid accidental upgrades across major or minor versions. For all 1.5.x
+releases use 1.5 as version number, for 1.4.x use 1.4, etc.
+
+We use the PGP key
+https://pgp.mit.edu/pks/lookup?op=vindex&search=0xD27D666CD88E42B4[D88E42B4],
+Elastic's Signing Key, with fingerprint
+
+    4609 5ACC 8548 582C 1A26 99A9 D27D 666C D88E 42B4
+
+to sign all our packages. It is available from https://pgp.mit.edu.
+
+[float]
+==== APT
+
+Download and install the Public Signing Key:
+
+[source,sh]
+--------------------------------------------------
+wget -qO - https://packages.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -
+--------------------------------------------------
+
+Add the repository definition to your `/etc/apt/sources.list` file:
+
+["source","sh",subs="attributes,callouts"]
+--------------------------------------------------
+echo "deb https://packages.elastic.co/logstash/{branch}/debian stable main" | sudo tee -a /etc/apt/sources.list
+--------------------------------------------------
+
+[WARNING]
+==================================================
+Use the `echo` method described above to add the Logstash repository.  Do not
+use `add-apt-repository` as it will add a `deb-src` entry as well, but we do not
+provide a source package. If you have added the `deb-src` entry, you will see an
+error like the following:
+
+    Unable to find expected entry 'main/source/Sources' in Release file (Wrong sources.list entry or malformed file)
+
+Just delete the `deb-src` entry from the `/etc/apt/sources.list` file and the
+installation should work as expected.
+==================================================
+
+Run `sudo apt-get update` and the repository is ready for use. You can install
+it with:
+
+[source,sh]
+--------------------------------------------------
+sudo apt-get update && sudo apt-get install logstash
+--------------------------------------------------
+
+[float]
+==== YUM
+
+Download and install the public signing key:
+
+[source,sh]
+--------------------------------------------------
+rpm --import https://packages.elastic.co/GPG-KEY-elasticsearch
+--------------------------------------------------
+
+Add the following in your `/etc/yum.repos.d/` directory
+in a file with a `.repo` suffix, for example `logstash.repo`
+
+["source","sh",subs="attributes,callouts"]
+--------------------------------------------------
+[logstash-{branch}]
+name=Logstash repository for {branch}.x packages
+baseurl=https://packages.elastic.co/logstash/{branch}/centos
+gpgcheck=1
+gpgkey=https://packages.elastic.co/GPG-KEY-elasticsearch
+enabled=1
+--------------------------------------------------
+
+And your repository is ready for use. You can install it with:
+
+[source,sh]
+--------------------------------------------------
+yum install logstash
+--------------------------------------------------
+
+[[first-event]]
+=== Stashing Your First Event: Basic Logstash Example
+
+To test your Logstash installation, run the most basic Logstash pipeline:
+
+["source","sh",subs="attributes"]
+--------------------------------------------------
+cd logstash-{logstash_version}
+bin/logstash -e 'input { stdin { } } output { stdout {} }'
+--------------------------------------------------
+
+The `-e` flag enables you to specify a configuration directly from the command line. Specifying configurations at the
+command line lets you quickly test configurations without having to edit a file between iterations.
+This pipeline takes input from the standard input, `stdin`, and moves that input to the standard output, `stdout`, in a
+structured format.
+
+Once "Logstash startup completed" is displayed, type hello world at the command prompt to see Logstash respond:
+
+[source,shell]
+hello world
+2013-11-21T01:22:14.405+0000 0.0.0.0 hello world
+
+Logstash adds timestamp and IP address information to the message. Exit Logstash by issuing a *CTRL-D* command in the
+shell where Logstash is running.
+
+The <<advanced-pipeline,Advanced Tutorial>> expands the capabilities of your Logstash instance to cover broader
+use cases.
diff --git a/docs/asciidoc/static/images/basic_logstash_pipeline.png b/docs/static/images/basic_logstash_pipeline.png
similarity index 100%
rename from docs/asciidoc/static/images/basic_logstash_pipeline.png
rename to docs/static/images/basic_logstash_pipeline.png
diff --git a/docs/asciidoc/static/images/deploy_1.png b/docs/static/images/deploy_1.png
similarity index 100%
rename from docs/asciidoc/static/images/deploy_1.png
rename to docs/static/images/deploy_1.png
diff --git a/docs/asciidoc/static/images/deploy_2.png b/docs/static/images/deploy_2.png
similarity index 100%
rename from docs/asciidoc/static/images/deploy_2.png
rename to docs/static/images/deploy_2.png
diff --git a/docs/static/images/deploy_3.png b/docs/static/images/deploy_3.png
new file mode 100644
index 00000000000..96bc119c3e0
Binary files /dev/null and b/docs/static/images/deploy_3.png differ
diff --git a/docs/asciidoc/static/images/deploy_4.png b/docs/static/images/deploy_4.png
similarity index 100%
rename from docs/asciidoc/static/images/deploy_4.png
rename to docs/static/images/deploy_4.png
diff --git a/docs/asciidoc/static/images/deploy_5.png b/docs/static/images/deploy_5.png
similarity index 100%
rename from docs/asciidoc/static/images/deploy_5.png
rename to docs/static/images/deploy_5.png
diff --git a/docs/asciidoc/static/images/deploy_6.png b/docs/static/images/deploy_6.png
similarity index 100%
rename from docs/asciidoc/static/images/deploy_6.png
rename to docs/static/images/deploy_6.png
diff --git a/docs/asciidoc/static/images/deploy_7.png b/docs/static/images/deploy_7.png
similarity index 100%
rename from docs/asciidoc/static/images/deploy_7.png
rename to docs/static/images/deploy_7.png
diff --git a/docs/asciidoc/static/images/logstash.png b/docs/static/images/logstash.png
similarity index 100%
rename from docs/asciidoc/static/images/logstash.png
rename to docs/static/images/logstash.png
diff --git a/docs/static/images/pipeline_correct_load.png b/docs/static/images/pipeline_correct_load.png
new file mode 100644
index 00000000000..02e7f484ed7
Binary files /dev/null and b/docs/static/images/pipeline_correct_load.png differ
diff --git a/docs/static/images/pipeline_overload.png b/docs/static/images/pipeline_overload.png
new file mode 100644
index 00000000000..4b8dd0dc667
Binary files /dev/null and b/docs/static/images/pipeline_overload.png differ
diff --git a/docs/asciidoc/static/include/pluginbody.asciidoc b/docs/static/include/pluginbody.asciidoc
similarity index 97%
rename from docs/asciidoc/static/include/pluginbody.asciidoc
rename to docs/static/include/pluginbody.asciidoc
index 2a073e03290..0627c6bff9b 100644
--- a/docs/asciidoc/static/include/pluginbody.asciidoc
+++ b/docs/static/include/pluginbody.asciidoc
@@ -262,7 +262,7 @@ endif::filter_method[]
 // Output (conditionally recognized by the presence of the receive_method
 // attribute)
 // /////////////////////////////////////////////////////////////////////////////
-ifdef::receive_method[]
+ifdef::multi_receive_method[]
 [source,ruby]
 [subs="attributes"]
 ----------------------------------
@@ -275,17 +275,43 @@ require "logstash/namespace"
 class LogStash::{pluginclass}::{pluginnamecap} < LogStash::{pluginclass}::Base
   config_name "example"
 
+  # If declared logstash will only allow a single instance of this plugin
+  # to exist, regardless of how many CPU cores logstash detects. This is best
+  # used in cases like the File output, where separate threads writing to a single
+  # File would only cause problems.
+  #
+  # respond_to? check needed for backwards compatibility with < 2.2 Logstashes
+  declare_workers_not_supported! if self.respond_to?(:declare_workers_not_supported!)
+
+  # If declared threadsafe logstash will only ever create one
+  # instance of this plugin per pipeline.
+  # That instance will be shared across all workers
+  # It is up to the plugin author to correctly write concurrent code!
+  #
+  # respond_to? check needed for backwards compatibility with < 2.2 Logstashes
+  declare_threadsafe! if self.respond_to?(:declare_threadsafe!)
+
   public
   def register
+    # Does the same thing as declare_workers_not_supported!
+    # But works in < 2.2 logstashes
+    # workers_not_supported
   end # def register
 
   public
+  # Takes an array of events
+  def multi_receive(events)
+  end # def multi_receive
+
+  public
+  # Needed for logstash < 2.2 compatibility
+  # Takes events one at a time
   def receive(event)
   end # def receive
 
 end # class LogStash::{pluginclass}::{pluginnamecap}
 ----------------------------------
-endif::receive_method[]
+endif::multi_receive_method[]
 
 ==== Coding {plugintype} plugins
 
@@ -681,7 +707,7 @@ endif::blockinput[]
 endif::run_method[]
 
 // /////////////////////////////////////////////////////////////////////////////
-// If receive_method is defined (should only be for output plugin page)
+// If multi_receive_method is defined (should only be for output plugin page)
 // /////////////////////////////////////////////////////////////////////////////
 ifdef::receive_method[]
 
diff --git a/docs/asciidoc/static/input.asciidoc b/docs/static/input.asciidoc
similarity index 100%
rename from docs/asciidoc/static/input.asciidoc
rename to docs/static/input.asciidoc
diff --git a/docs/asciidoc/static/introduction.asciidoc b/docs/static/introduction.asciidoc
similarity index 73%
rename from docs/asciidoc/static/introduction.asciidoc
rename to docs/static/introduction.asciidoc
index ec9af52cd15..9b69959d6a6 100644
--- a/docs/asciidoc/static/introduction.asciidoc
+++ b/docs/static/introduction.asciidoc
@@ -1,15 +1,3 @@
-[[introduction]]
-== Logstash Introduction
-
-Logstash is an open source data collection engine with real-time pipelining capabilities. Logstash can dynamically 
-unify data from disparate sources and normalize the data into destinations of your choice. Cleanse and democratize all 
-your data for diverse advanced downstream analytics and visualization use cases.
-
-While Logstash originally drove innovation in log collection, its capabilities extend well beyond that use case. Any 
-type of event can be enriched and transformed with a broad array of input, filter, and output plugins, with many 
-native codecs further simplifying the ingestion process. Logstash accelerates your insights by harnessing a greater 
-volume and variety of data.
-
 [float]
 [[power-of-logstash]]
 == The Power of Logstash
@@ -39,14 +27,13 @@ Collect more, so you can know more. Logstash welcomes data of all shapes and siz
 Where it all started.
 
 * Handle all types of logging data
-** Easily ingest a multitude of web logs like <<parsing-into-es,Apache>>, and application 
+** Easily ingest a multitude of web logs like <<parsing-into-es,Apache>>, and application
 logs like <<plugins-inputs-log4j,log4j>> for Java
-** Capture many other log formats like <<plugins-inputs-syslog,syslog>>, 
+** Capture many other log formats like <<plugins-inputs-syslog,syslog>>,
 <<plugins-inputs-eventlog,Windows event logs>>, networking and firewall logs, and more
-* Enjoy complementary secure log forwarding capabilities with https://github.com/elastic/logstash-forwarder[Logstash 
-Forwarder]
-* Collect metrics from <<plugins-inputs-ganglia,Ganglia>>, <<plugins-codecs-collectd,collectd>>, 
-<<plugins-codecs-netflow,NetFlow>>, <<plugins-inputs-jmx,JMX>>, and many other infrastructure 
+* Enjoy complementary secure log forwarding capabilities with https://github.com/elastic/beats/tree/master/filebeat[Filebeat]
+* Collect metrics from <<plugins-inputs-ganglia,Ganglia>>, <<plugins-codecs-collectd,collectd>>,
+<<plugins-codecs-netflow,NetFlow>>, <<plugins-inputs-jmx,JMX>>, and many other infrastructure
 and application platforms over <<plugins-inputs-tcp,TCP>> and <<plugins-inputs-udp,UDP>>
 
 [float]
@@ -54,12 +41,12 @@ and application platforms over <<plugins-inputs-tcp,TCP>> and <<plugins-inputs-u
 
 Unlock the World Wide Web.
 
-* Transform <<plugins-inputs-http,HTTP requests>> into events 
+* Transform <<plugins-inputs-http,HTTP requests>> into events
 (https://www.elastic.co/blog/introducing-logstash-input-http-plugin[blog])
 ** Consume from web service firehoses like <<plugins-inputs-twitter,Twitter>> for social sentiment analysis
 ** Webhook support for GitHub, HipChat, JIRA, and countless other applications
 ** Enables many https://www.elastic.co/guide/en/watcher/current/logstash-integration.html[Watcher] alerting use cases
-* Create events by polling <<plugins-inputs-http_poller,HTTP endpoints>> on demand 
+* Create events by polling <<plugins-inputs-http_poller,HTTP endpoints>> on demand
 (https://www.elastic.co/blog/introducing-logstash-http-poller[blog])
 ** Universally capture health, performance, metrics, and other types of data from web application interfaces
 ** Perfect for scenarios where the control of polling is preferred over receiving
@@ -69,10 +56,10 @@ Unlock the World Wide Web.
 
 Discover more value from the data you already own.
 
-* Better understand your data from any relational database or NoSQL store with a 
+* Better understand your data from any relational database or NoSQL store with a
 <<plugins-inputs-jdbc,JDBC>> interface (https://www.elastic.co/blog/logstash-jdbc-input-plugin[blog])
-* Unify diverse data streams from messaging queues like Apache <<plugins-outputs-kafka,Kafka>> 
-(https://www.elastic.co/blog/logstash-kafka-intro[blog]), <<plugins-outputs-rabbitmq,RabbitMQ>>, 
+* Unify diverse data streams from messaging queues like Apache <<plugins-outputs-kafka,Kafka>>
+(https://www.elastic.co/blog/logstash-kafka-intro[blog]), <<plugins-outputs-rabbitmq,RabbitMQ>>,
 <<plugins-outputs-sqs,Amazon SQS>>, and <<plugins-outputs-zeromq,ZeroMQ>>
 
 [float]
@@ -80,41 +67,41 @@ Discover more value from the data you already own.
 
 Explore an expansive breadth of other data.
 
-* In this age of technological advancement, the massive IoT world unleashes endless use cases through capturing and 
+* In this age of technological advancement, the massive IoT world unleashes endless use cases through capturing and
 harnessing data from connected sensors.
-* Logstash is the common event collection backbone for ingestion of data shipped from mobile devices to intelligent 
+* Logstash is the common event collection backbone for ingestion of data shipped from mobile devices to intelligent
 homes, connected vehicles, healthcare sensors, and many other industry specific applications.
-* https://www.elastic.co/elasticon/2015/sf/if-it-moves-measure-it-logging-iot-with-elk[Watch] as Logstash, in 
-conjunction with the broader ELK stack, centralizes and enriches sensor data to gain deeper knowledge regarding a 
+* https://www.elastic.co/elasticon/2015/sf/if-it-moves-measure-it-logging-iot-with-elk[Watch] as Logstash, in
+conjunction with the broader ELK stack, centralizes and enriches sensor data to gain deeper knowledge regarding a
 residential home.
 
 [float]
 == Easily Enrich Everything
 
-The better the data, the better the knowledge. Clean and transform your data during ingestion to gain near real-time 
-insights immediately at index or output time. Logstash comes out-of-box with many aggregations and mutations along 
+The better the data, the better the knowledge. Clean and transform your data during ingestion to gain near real-time
+insights immediately at index or output time. Logstash comes out-of-box with many aggregations and mutations along
 with pattern matching, geo mapping, and dynamic lookup capabilities.
 
-* <<plugins-filters-grok,Grok>> is the bread and butter of Logstash filters and is used ubiquitously to derive 
-structure out of unstructured data. Enjoy a wealth of integrated patterns aimed to help quickly resolve web, systems, 
+* <<plugins-filters-grok,Grok>> is the bread and butter of Logstash filters and is used ubiquitously to derive
+structure out of unstructured data. Enjoy a wealth of integrated patterns aimed to help quickly resolve web, systems,
 networking, and other types of event formats.
-* Expand your horizons by deciphering <<plugins-filters-geoip,geo coordinates>> from IP addresses, normalizing 
-<<plugins-filters-date,date>> complexity, simplifying <<plugins-filters-kv,key-value pairs>> and 
-<<plugins-filters-csv,CSV>> data, <<plugins-filters-anonymize,anonymizing>> sensitive information, and further 
-enriching your data with <<plugins-filters-translate,local lookups>> or Elasticsearch 
+* Expand your horizons by deciphering <<plugins-filters-geoip,geo coordinates>> from IP addresses, normalizing
+<<plugins-filters-date,date>> complexity, simplifying <<plugins-filters-kv,key-value pairs>> and
+<<plugins-filters-csv,CSV>> data, <<plugins-filters-anonymize,anonymizing>> sensitive information, and further
+enriching your data with <<plugins-filters-translate,local lookups>> or Elasticsearch
 <<plugins-filters-elasticsearch,queries>>.
-* Codecs are often used to ease the processing of common event structures like <<plugins-codecs-json,JSON>> 
+* Codecs are often used to ease the processing of common event structures like <<plugins-codecs-json,JSON>>
 and <<plugins-codecs-multiline,multiline>> events.
 
 [float]
 == Choose Your Stash
 
-Route your data where it matters most. Unlock various downstream analytical and operational use cases by storing, 
+Route your data where it matters most. Unlock various downstream analytical and operational use cases by storing,
 analyzing, and taking action on your data.
 
 [cols="a,a"]
 |=======================================================================
-| 
+|
 
 *Analysis*
 
@@ -129,9 +116,9 @@ analyzing, and taking action on your data.
 * <<plugins-outputs-s3,S3>>
 * <<plugins-outputs-google_cloud_storage,Google Cloud Storage>>
 
-| 
+|
 
-*Monitoring*          
+*Monitoring*
 
 * <<plugins-outputs-nagios,Nagios>>
 * <<plugins-outputs-ganglia,Ganglia>>
@@ -140,7 +127,7 @@ analyzing, and taking action on your data.
 * <<plugins-outputs-datadog,Datadog>>
 * <<plugins-outputs-cloudwatch,CloudWatch>>
 
-| 
+|
 
 *Alerting*
 
diff --git a/docs/static/life-of-an-event.asciidoc b/docs/static/life-of-an-event.asciidoc
new file mode 100644
index 00000000000..a4712ba46c4
--- /dev/null
+++ b/docs/static/life-of-an-event.asciidoc
@@ -0,0 +1,158 @@
+[[pipeline]]
+=== Logstash Processing Pipeline
+
+The Logstash event processing pipeline has three stages: inputs -> filters ->
+outputs. Inputs generate events, filters modify them, and outputs ship them
+elsewhere. Inputs and outputs support codecs that enable you to encode or decode
+the data as it enters or exits the pipeline without having to use a separate
+filter.
+
+[float]
+==== Inputs
+You use inputs to get data into Logstash. Some of the more commonly-used inputs
+are:
+
+* *file*: reads from a file on the filesystem, much like the UNIX command
+`tail -0F`
+* *syslog*: listens on the well-known port 514 for syslog messages and parses
+according to the RFC3164 format
+* *redis*: reads from a redis server, using both redis channels and redis lists.
+Redis is often used as a "broker" in a centralized Logstash installation, which
+queues Logstash events from remote Logstash "shippers".
+* *beats*: processes events sent by https://www.elastic.co/downloads/beats/filebeat[Filebeat].
+
+For more information about the available inputs, see
+<<input-plugins,Input Plugins>>.
+
+[float]
+==== Filters
+Filters are intermediary processing devices in the Logstash pipeline. You can
+combine filters with conditionals to perform an action on an event if it meets
+certain criteria. Some useful filters include:
+
+* *grok*: parse and structure arbitrary text. Grok is currently the best way in
+Logstash to parse unstructured log data into something structured and queryable.
+With 120 patterns built-in to Logstash, it's more than likely you'll find one
+that meets your needs!
+* *mutate*: perform general transformations on event fields. You can rename,
+remove, replace, and modify fields in your events.
+* *drop*: drop an event completely, for example, 'debug' events.
+* *clone*: make a copy of an event, possibly adding or removing fields.
+* *geoip*: add information about geographical location of IP addresses (also
+displays amazing charts in Kibana!)
+
+For more information about the available filters, see
+<<filter-plugins,Filter Plugins>>.
+
+[float]
+==== Outputs
+Outputs are the final phase of the Logstash pipeline. An event can pass through
+multiple outputs, but once all output processing is complete, the event has
+finished its execution. Some commonly used outputs include:
+
+* *elasticsearch*: send event data to Elasticsearch. If you're planning to save
+your data in an efficient, convenient, and easily queryable format...
+Elasticsearch is the way to go. Period. Yes, we're biased :)
+* *file*: write event data to a file on disk.
+* *graphite*: send event data to graphite, a popular open source tool for
+storing and graphing metrics. http://graphite.wikidot.com/
+* *statsd*: send event data to statsd, a service that "listens for statistics,
+like counters and timers, sent over UDP and sends aggregates to one or more
+pluggable backend services". If you're already using statsd, this could be
+useful for you!
+
+For more information about the available outputs, see
+<<output-plugins,Output Plugins>>.
+
+[float]
+==== Codecs
+Codecs are basically stream filters that can operate as part of an input or
+output. Codecs enable you to easily separate the transport of your messages from
+the serialization process. Popular codecs include `json`, `msgpack`, and `plain`
+(text).
+
+* *json*: encode or decode data in the JSON format.
+* *multiline*: merge multiple-line text events such as java exception and
+stacktrace messages into a single event.
+
+For more information about the available codecs, see
+<<codec-plugins,Codec Plugins>>.
+
+[float]
+=== Fault Tolerance
+
+Logstash keeps all events in main memory during processing. Logstash responds to a SIGTERM by attempting to halt inputs and waiting for pending events to finish processing before shutting down. When the pipeline cannot be flushed due to a stuck output or filter, Logstash waits indefinitely. For example, when a pipeline sends output to a database that is unreachable by the Logstash instance, the instance waits indefinitely after receiving a SIGTERM.
+
+To enable Logstash to detect these situations and terminate with a stalled pipeline, use the `--allow-unsafe-shutdown` flag.
+
+WARNING: Unsafe shutdowns, force-kills of the Logstash process, or crashes of the Logstash process for any other reason result in data loss. Shut down Logstash safely whenever possible.
+
+[float]
+==== Execution Model
+
+The Logstash pipeline coordinates the execution of inputs, filters, and outputs. The following schematic sketches the data flow of a pipeline:
+
+[source,js]
+---------------------------------------------------
+input threads | pipeline worker threads
+---------------------------------------------------
+
+Pipelines in the current release of Logstash process filtering and output in the same thread. Prior to the 2.2 release of Logstash, filtering and output were distinct stages handled by distinct threads.
+This change to the Logstash architecture improves performance and enables future persistence capabilities. The new pipeline substantially improves thread liveness, decreases resource usage, and increases throughput. The current Logstash pipeline is a micro-batching pipeline, which is inherently more efficient than a one-at-a-time approach. These efficiencies come in many places, two of the more prominent ones being a reduction in contention and a consequent improvement in thread liveness. These efficiencies are especially noticeable on many-core machines.
+
+Each `input {}` statement in the Logstash configuration file runs in its own thread. Inputs write events to a common Java https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/SynchronousQueue.html[SynchronousQueue]. This queue holds no events, instead transferring each pushed event to a free worker, blocking if all workers are busy. Each pipeline worker thread takes a batch of events off this queue, creating a buffer per worker, runs the batch of  events through the configured filters, then runs the filtered events through any outputs. The size of the batch and number of pipeline worker threads are configurable. The following pseudocode illustrates the process flow:
+
+[source,ruby]
+synchronous_queue = SynchronousQueue.new
+inputs.each do |input|
+  Thread.new do
+    input.run(synchronous_queue)
+  end
+end
+num_pipeline_workers.times do
+  Thread.new do
+    while true
+      batch = take_batch(synchronous_queue, batch_size, batch_delay)
+      output_batch(filter_batch(batch))
+    end
+  end
+end
+wait_for_threads_to_terminate()
+
+There are three configurable options in the pipeline, `--pipeline-workers`, `--pipeline-batch-size`, and `--pipeline-batch-delay`.
+The `--pipeline-workers` or `-w` parameter determines how many threads to run for filter and output processing. If you find that events are backing up, or that the CPU is not saturated, consider increasing the value of this parameter to make better use of available processing power. Good results can even be found increasing this number past the number of available processors as these threads may spend significant time in an I/O wait state when writing to external systems. Legal values for this parameter are positive integers.
+
+The `--pipeline-batch-size` or `-b` parameter defines the maximum number of events an individual worker thread collects before attempting to execute filters and outputs. Larger batch sizes are generally more efficient, but increase memory overhead. Some hardware configurations require you to increase JVM heap size by setting the `LS_HEAP_SIZE` variable to avoid performance degradation with this option. Values of this parameter in excess of the optimum range cause performance degradation due to frequent garbage collection or JVM crashes related to out-of-memory exceptions. Output plugins can process each batch as a logical unit. The Elasticsearch output, for example, issues https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html[bulk requests] for each batch received. Tuning the `-b` parameter adjusts the size of bulk requests sent to Elasticsearch.
+
+The `--pipeline-batch-delay` option rarely needs to be tuned. This option adjusts the latency of the Logstash pipeline. Pipeline batch delay is the maximum amount of time in milliseconds that Logstash waits for new messages after receiving an event in the current pipeline worker thread. After this time elapses, Logstash begins to execute filters and outputs.The maximum time that Logstash waits between receiving an event and processing that event in a filter is the product of the `pipeline_batch_delay` and  `pipeline_batch_size` settings.
+
+[float]
+==== Notes on Pipeline Configuration and Performance
+
+The total number of inflight events is determined by the product of the  `pipeline_workers` and `pipeline_batch_size` parameters. This product is referred to as the _inflight count_.  Keep the value of the inflight count in mind as you adjust the `pipeline_workers` and `pipeline_batch_size` parameters. Pipelines that intermittently receive large events at irregular intervals require sufficient memory to handle these spikes. Configure the `LS_HEAP_SIZE` option accordingly.
+
+The Logstash defaults are chosen to provide fast, safe performance for most users. To increase performance, increase the number of pipeline workers or the batch size, taking into account the following suggestions:
+
+Measure each change to make sure it increases, rather than decreases, performance.
+Ensure that you leave enough memory available to cope with a sudden increase in event size. For example, an application that generates exceptions that are represented as large blobs of text.
+The number of workers may be set higher than the number of CPU cores since outputs often spend idle time in I/O wait conditions.
+
+Threads in Java have names and you can use the `jstack`, `top`, and the VisualVM graphical tools to figure out which resources a given thread uses.
+
+On Linux platforms, Logstash labels all the threads it can with something descriptive. For example, inputs show up as `[base]<inputname`, filter/output workers show up as `[base]>workerN`, where N is an integer.  Where possible, other threads are also labeled to help you identify their purpose.
+
+[float]
+==== Profiling the Heap
+
+When tuning Logstash you may have to adjust the heap size. You can use the https://visualvm.java.net/[VisualVM] tool to profile the heap. The *Monitor* pane in particular is useful for checking whether your heap allocation is sufficient for the current workload. The screenshots below show sample *Monitor* panes. The first pane examines a Logstash instance configured with too many inflight events. The second pane examines a Logstash instance configured with an appropriate amount of inflight events. Note that the specific batch sizes used here are most likely not applicable to your specific workload, as the memory demands of Logstash vary in large part based on the type of messages you are sending.
+
+image::static/images/pipeline_overload.png[]
+
+image::static/images/pipeline_correct_load.png[]
+
+In the first example we see that the CPU isn’t being used very efficiently. In fact, the JVM is often times having to stop the VM for “full GCs”. Full garbage collections are a common symptom of excessive memory pressure. This is visible in the spiky pattern on the CPU chart. In the more efficiently configured example, the GC graph pattern is more smooth, and the CPU is used in a more uniform manner. You can also see that there is ample headroom between the allocated heap size, and the maximum allowed, giving the JVM GC a lot of room to work with.
+
+Examining the in-depth GC statistics with a tool similar to the excellent https://visualvm.java.net/plugins.html[VisualGC] plugin shows that the over-allocated VM spends very little time in the efficient Eden GC, compared to the time spent in the more resource-intensive Old Gen “Full” GCs.
+
+NOTE: As long as the GC pattern is acceptable, heap sizes that occasionally increase to the maximum are acceptable. Such heap size spikes happen in response to a burst of large events passing through the pipeline. In general practice, maintain a gap between the used amount of heap memory and the maximum.
+This document is not a comprehensive guide to JVM GC tuning. Read the official http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html[Oracle guide] for more information on the topic. We also recommend reading http://www.semicomplete.com/blog/geekery/debugging-java-performance.html[Debugging Java Performance].
diff --git a/docs/asciidoc/static/logstash-glossary.asciidoc b/docs/static/logstash-glossary.asciidoc
similarity index 96%
rename from docs/asciidoc/static/logstash-glossary.asciidoc
rename to docs/static/logstash-glossary.asciidoc
index 9715ffa6c76..82f04943471 100644
--- a/docs/asciidoc/static/logstash-glossary.asciidoc
+++ b/docs/static/logstash-glossary.asciidoc
@@ -1,4 +1,4 @@
-== Glossary 
+== Glossary
 Logstash Glossary
 
 apache ::
@@ -9,7 +9,7 @@ agent ::
 
 
 broker ::
-	An intermediary used in a multi-tiered Logstash deployment which allows a queueing mechanism to be used. Examples of brokers are Redis, RabbitMQ, and Apache Kafka. This pattern is a common method of building fault-tolerance into a Logstash architecture. 
+	An intermediary used in a multi-tiered Logstash deployment which allows a queueing mechanism to be used. Examples of brokers are Redis, RabbitMQ, and Apache Kafka. This pattern is a common method of building fault-tolerance into a Logstash architecture.
 
 buffer::
 	Within Logstash, a temporary storage area where events can queue up, waiting to be processed. The default queue size is 20 events, but it is not recommended to increase this, as Logstash is not designed to operate as a queueing mechanism.
@@ -27,7 +27,7 @@ conditional::
 	In a computer programming context, a control flow which executes certain actions based on true/false values of a statement (called the condition). Often expressed in the form of "if ... then ... (elseif ...) else". Logstash has built-in conditionals to allow users control of the plugin pipeline.
 
 elasticsearch::
-	An open-source, Lucene-based, RESTful search and analytics engine written in Java, with supported clients in various languages such as Perl, Python, Ruby, Java, etc. 
+	An open-source, Lucene-based, RESTful search and analytics engine written in Java, with supported clients in various languages such as Perl, Python, Ruby, Java, etc.
 
 event::
 	In Logstash parlance, a single unit of information, containing a timestamp plus additional data. An event arrives via an input, and is subsequently parsed, timestamped, and passed through the Logstash pipeline.
@@ -39,7 +39,7 @@ file::
 	A resource storing binary data (which might be text, image, application, etc.) on a physical storage media. In the Logstash context, a common input source which monitors a growing collection of text-based log lines.
 
 filter:
-	An intermediary processing mechanism in the Lostash pipeline. Typically, filters act upon event data after it has been ingested via inputs, by mutating, enriching, and/or modifying the data according to configuration rules. The second phase of the typical Logstash pipeline (inputs->filters->outputs). 
+	An intermediary processing mechanism in the Lostash pipeline. Typically, filters act upon event data after it has been ingested via inputs, by mutating, enriching, and/or modifying the data according to configuration rules. The second phase of the typical Logstash pipeline (inputs->filters->outputs).
 
 fluentd::
 	Like Logstash, another open-source tool for collecting logs and events, with plugins to extend functionality.
@@ -60,7 +60,7 @@ indexer::
 	Refers to a Logstash instance which is tasked with interfacing with an Elasticsearch cluster in order to index event data.
 
 input::
-	The means for ingesting data into Logstash. Inputs allow users to pull data from files, network sockets, other applications, etc. The initial phase of the typical Logstash pipeline (inputs->filters->outputs). 
+	The means for ingesting data into Logstash. Inputs allow users to pull data from files, network sockets, other applications, etc. The initial phase of the typical Logstash pipeline (inputs->filters->outputs).
 
 jar / jarfile::
 	A packaging method for Java libraries. Since Logstash runs on the JRuby runtime environment, it is possible to use these Java libraries to provide extra functionality to Logstash.
@@ -69,7 +69,7 @@ java::
 	An object-oriented programming language popular for its flexibility, extendability and portability.
 
 jRuby:
-	JRuby is a 100% Java implementation of the Ruby programming language, which allows Ruby to run in the JVM. Logstash typically runs in JRuby, which provides it with a fast, extensible runtime environment. 
+	JRuby is a 100% Java implementation of the Ruby programming language, which allows Ruby to run in the JVM. Logstash typically runs in JRuby, which provides it with a fast, extensible runtime environment.
 
 kibana::
 	A visual tool for viewing time-based data which has been stored in Elasticsearch. Kibana features a powerful set of functionality based on panels which query Elasticsearch in different ways.
@@ -87,7 +87,7 @@ lumberjack::
 	A protocol for shipping logs from one location to another, in a secure and optimized manner. Also the (deprecated) name of a software application, now known as Logstash Forwarder (LSF).
 
 output::
-	The means for passing event data out of Logstash into other applications, network endpoints, files, etc. The last phase of the typical Logstash pipeline (inputs->filters->outputs). 
+	The means for passing event data out of Logstash into other applications, network endpoints, files, etc. The last phase of the typical Logstash pipeline (inputs->filters->outputs).
 
 pipeline::
 	A term used to describe the flow of events through the Logstash workflow. The pipeline typically consists of a series of inputs, filters, and outputs.
@@ -129,4 +129,4 @@ type::
 	In Elasticsearch type, a type can be compared to a table in a relational database. Each type has a list of fields that can be specified for documents of that type. The mapping defines how each field in the document is analyzed. To index documents, it is required to specify both an index and a type.
 
 worker::
-	The filter thread model used by Logstash, where each worker receives an event and applies all filters, in order, before emitting the event to the output queue. This allows scalability across CPUs because many filters are CPU intensive (permitting that we have thread safety). 
+	The filter thread model used by Logstash, where each worker receives an event and applies all filters, in order, before emitting the event to the output queue. This allows scalability across CPUs because many filters are CPU intensive (permitting that we have thread safety).
diff --git a/docs/static/maintainer-guide.asciidoc b/docs/static/maintainer-guide.asciidoc
new file mode 100644
index 00000000000..383867aedaa
--- /dev/null
+++ b/docs/static/maintainer-guide.asciidoc
@@ -0,0 +1,222 @@
+[[community-maintainer]]
+=== Logstash Plugins Community Maintainer Guide
+
+This document, to be read by new Maintainers, should explain their responsibilities.  It was inspired by the
+http://rfc.zeromq.org/spec:22[C4] document from the ZeroMQ project.  This document is subject to change and suggestions
+through Pull Requests and issues are strongly encouraged.
+
+[float]
+=== Contribution Guidelines
+
+For general guidance around contributing to Logstash Plugins, see the
+https://www.elastic.co/guide/en/logstash/current/contributing-to-logstash.html[_Contributing to Logstash_] section.
+
+[float]
+=== Document Goals
+
+To help make the Logstash plugins community  participation easy with positive feedback.
+
+To increase diversity.
+
+To reduce code review, merge and release dependencies on the core team by providing support and tools to the Community and
+Maintainers.
+
+To support the natural life cycle of a plugin.
+
+To codify the roles and responsibilities of: Maintainers and Contributors with specific focus on patch testing, code
+review, merging and release.
+
+[float]
+=== Development Workflow
+
+All Issues and Pull Requests must be tracked using the Github issue tracker.
+
+The plugin uses the http://www.apache.org/licenses/LICENSE-2.0[Apache 2.0 license]. Maintainers should check whether a
+patch introduces code which has an incompatible license. Patch ownership and copyright is defined in the Elastic
+https://www.elastic.co/contributor-agreement[Contributor License Agreement] (CLA).
+
+[float]
+==== Terminology
+
+A "Contributor" is a role a person assumes when providing a patch. Contributors will not have commit access to the
+repository. They need to sign the Elastic https://www.elastic.co/contributor-agreement[Contributor License Agreement]
+before a patch can be reviewed. Contributors can add themselves to the plugin Contributor list.
+
+A "Maintainer" is a role a person assumes when maintaining a plugin and keeping it healthy, including triaging issues, and
+reviewing and merging patches.
+
+[float]
+==== Patch Requirements
+
+A patch is a minimal and accurate answer to exactly one identified and agreed upon problem. It must conform to the
+https://github.com/elastic/logstash/blob/master/STYLE.md[code style guidelines] and must include RSpec tests that verify
+the fitness of the solution.
+
+A patch will be automatically tested by a CI system that will report on the Pull Request status.
+
+A patch CLA will be automatically verified and reported on the Pull Request status.
+
+A patch commit message has a single short (less than 50 character) first line summarizing the change, a blank second line,
+and any additional lines as necessary for change explanation and rationale.
+
+A patch is mergeable when it satisfies the above requirements and has been reviewed positively by at least one other
+person.
+
+[float]
+==== Development Process
+
+A user will log an issue on the issue tracker describing the problem they face or observe with as much detail as possible.
+
+To work on an issue, a Contributor forks the plugin repository and then works on their forked repository and submits a
+patch by creating a pull request back to the plugin.
+
+Maintainers must not merge patches where the author has not signed the CLA.
+
+Before a patch can be accepted it should be reviewed. Maintainers should merge accepted patches without delay.
+
+Maintainers should not merge their own patches except in exceptional cases, such as non-responsiveness from other
+Maintainers or core team for an extended period (more than 2 weeks).
+
+Reviewer’s comments should not be based on personal preferences.
+
+The Maintainers should label Issues and Pull Requests.
+
+Maintainers should involve the core team if help is needed to reach consensus.
+
+Review non-source changes such as documentation in the same way as source code changes.
+
+[float]
+==== Branch Management
+
+The plugin has a master branch that always holds the latest in-progress version and should always build.  Topic branches
+should kept to the minimum.
+
+[float]
+==== Changelog Management
+
+Every plugin should have a changelog (CHANGELOG.md).  If not, please create one.  When changes are made to a plugin, make sure to include a changelog entry under the respective version to document the change.  The changelog should be easily understood from a user point of view.  As we iterate and release plugins rapidly, users use the changelog as a mechanism for deciding whether to update.
+
+Changes that are not user facing should be tagged as `internal:`.  For example:
+
+[source,markdown]
+ - internal: Refactored specs for better testing
+ - config: Default timeout configuration changed from 10s to 5s
+
+[float]
+===== Detailed format of CHANGELOG.md
+
+Sharing a similar format of CHANGELOG.md in plugins ease readability for users.
+Please see following annotated example and see a concrete example in https://raw.githubusercontent.com/logstash-plugins/logstash-filter-date/master/CHANGELOG.md[logstash-filter-date].
+
+[source,markdown]
+----
+## 1.0.x                              // <1> <2>
+ - change description                 // <3>
+ - tag: change description            // <3> <4>
+ - tag1,tag2: change description      // <3> <5>
+ - tag: Multi-line description        // <3> <6>
+   must be indented and can use
+   additional markdown syntax
+                                      // <7>
+## 1.0.0                              // <8>
+[...]
+
+----
+<1> Latest version is the first line of CHANGELOG.md
+<2> Each version identifier should be a level-2 header using `##`
+<3> One change description is described as a list item using a dash `-` aligned under the version identifier
+<4> One change can be tagged by a word and suffixed by `:`. +
+    Common tags are `bugfix`, `feature`, `doc`, `test` or `internal`.
+<5> One change can have multiple tags separated by a comma and suffixed by `:`
+<6> A multi-line change description must be properly indented
+<7> Please take care to *separate versions with an empty line*
+<8> Previous version identifier
+
+[float]
+==== Continuous Integration
+
+Plugins are setup with automated continuous integration (CI) environments and there should be a corresponding badge on each Github page.  If it’s missing, please contact the Logstash core team.
+
+Every Pull Request opened automatically triggers a CI run.  To conduct a manual run, comment “Jenkins, please test this.” on the Pull Request.
+
+[float]
+=== Versioning Plugins
+
+Logstash core and its plugins have separate product development lifecycles. Hence the versioning and release strategy for
+the core and plugins do not have to be aligned. In fact, this was one of our goals during the great separation of plugins
+work in Logstash 1.5.
+
+At times, there will be changes in core API in Logstash, which will require mass update of plugins to reflect the changes
+in core. However, this does not happen frequently.
+
+For plugins, we would like to adhere to a versioning and release strategy that can better inform our users, about any
+breaking changes to the Logstash configuration formats and functionality.
+
+Plugin releases follows a three-placed numbering scheme X.Y.Z. where X denotes a major release version which may break
+compatibility with existing configuration or functionality. Y denotes releases which includes features which are backward
+compatible. Z denotes releases which includes bug fixes and patches.
+
+[float]
+==== Changing the version
+
+Version can be changed in the Gemspec, which needs to be associated with a changelog entry. Following this, we can publish
+the gem to RubyGem.org manually. At this point only the core developers can publish a gem.
+
+[float]
+==== Labeling
+
+Labeling is a critical aspect of maintaining plugins. All issues in GitHub should be labeled correctly so it can:
+
+* Provide good feedback to users/developers
+* Help prioritize changes
+* Be used in release notes
+
+Most labels are self explanatory, but here’s a quick recap of few important labels:
+
+* `bug`: Labels an issue as an unintentional defect
+* `needs details`: If a the issue reporter has incomplete details, please ask them for more info and label as needs
+details.
+* `missing cla`: Contributor License Agreement is missing and patch cannot be accepted without it
+* `adopt me`: Ask for help from the community to take over this issue
+* `enhancement`: New feature, not a bug fix
+* `needs tests`: Patch has no tests, and cannot be accepted without unit/integration tests
+* `docs`: Documentation related issue/PR
+
+[float]
+=== Logging
+
+Although it’s important not to bog down performance with excessive logging, debug level logs can be immensely helpful when
+diagnosing and troubleshooting issues with Logstash.  Please remember to liberally add debug logs wherever it makes sense
+as users will be forever gracious.
+
+[source,shell]
+@logger.debug("Logstash loves debug logs!", :actions => actions)
+
+[float]
+=== Contributor License Agreement (CLA) Guidance
+
+[qanda]
+Why is a https://www.elastic.co/contributor-agreement[CLA] required?::
+     We ask this of all Contributors in order to assure our users of the origin and continuing existence of the code. We
+     are not asking Contributors to assign copyright to us, but to give us the right to distribute a Contributor’s code
+     without restriction.
+
+Please make sure the CLA is signed by every Contributor prior to reviewing PRs and commits.::
+     Contributors only need to sign the CLA once and should sign with the same email as used in Github. If a Contributor
+     signs the CLA after a PR is submitted, they can refresh the automated CLA checker by pushing another
+     comment on the PR after 5 minutes of signing.
+
+[float]
+=== Need Help?
+
+Ping @logstash-core on Github to get the attention of the Logstash core team.
+
+[float]
+=== Community Administration
+
+The core team is there to support the plugin Maintainers and overall ecosystem.
+
+Maintainers should propose Contributors to become a Maintainer.
+
+Contributors and Maintainers should follow the Elastic Community https://www.elastic.co/community/codeofconduct[Code of
+Conduct].  The core team should block or ban "bad actors".
diff --git a/docs/asciidoc/static/managing-multiline-events.asciidoc b/docs/static/managing-multiline-events.asciidoc
similarity index 65%
rename from docs/asciidoc/static/managing-multiline-events.asciidoc
rename to docs/static/managing-multiline-events.asciidoc
index 1185348bc7d..e9ee8bc12fa 100644
--- a/docs/asciidoc/static/managing-multiline-events.asciidoc
+++ b/docs/static/managing-multiline-events.asciidoc
@@ -1,43 +1,32 @@
 [[multiline]]
 === Managing Multiline Events
 
-Several use cases generate events that span multiple lines of text. In order to correctly handle these multline events, 
+Several use cases generate events that span multiple lines of text. In order to correctly handle these multiline events,
 Logstash needs to know how to tell which lines are part of a single event.
 
-Multiline event processing is complex and relies on proper event ordering. The best way to guarantee ordered log 
-processing is to implement the processing as early in the pipeline as possible. The preferred tool in the Logstash 
-pipeline is the {logstash}plugins-codecs-multiline.html[multiline codec], which merges lines from a single input using 
+Multiline event processing is complex and relies on proper event ordering. The best way to guarantee ordered log
+processing is to implement the processing as early in the pipeline as possible. The preferred tool in the Logstash
+pipeline is the {logstash}plugins-codecs-multiline.html[multiline codec], which merges lines from a single input using
 a simple set of rules.
 
-For more complex needs, the {logstash}plugins-filters-multiline.html[multiline filter] performs a similar task at the 
-filter stage of processing, where the Logstash instance aggregates multiple inputs.
 
 The most important aspects of configuring either multiline plugin are the following:
 
-* The `pattern` option specifies a regular expression. Lines that match the specified regular expression are considered 
-either continuations of a previous line or the start of a new multiline event. You can use 
+* The `pattern` option specifies a regular expression. Lines that match the specified regular expression are considered
+either continuations of a previous line or the start of a new multiline event. You can use
 {logstash}plugins-filters-grok.html[grok] regular expression templates with this configuration option.
-* The `what` option takes two values: `previous` or `next`. The `previous` value specifies that lines that match the 
-value in the `pattern` option are part of the previous line. The `next` value specifies that lines that match the value 
-in the `pattern` option are part of the following line.* The `negate` option applies the multiline codec to lines that 
+* The `what` option takes two values: `previous` or `next`. The `previous` value specifies that lines that match the
+value in the `pattern` option are part of the previous line. The `next` value specifies that lines that match the value
+in the `pattern` option are part of the following line.* The `negate` option applies the multiline codec to lines that
 _do not_ match the regular expression specified in the `pattern` option.
 
-See the full documentation for the {logstash}plugins-codecs-multiline.html[multiline codec] or the 
+See the full documentation for the {logstash}plugins-codecs-multiline.html[multiline codec] or the
 {logstash}plugins-filters-multiline.html[multiline filter] plugin for more information on configuration options.
 
-==== Multiline Special Cases
-
-* The current release of the multiline codec plugin treats all input from the 
-{logstash}plugins-inputs-lumberjack[lumberjack] input plugin as a single stream. When your use case involves the 
-Logstash Forwarder processing multiple files concurrently, proper event ordering can be challenging to maintain, and 
-any resulting errors can be difficult to diagnose. Carefully monitor the output of Logstash configurations that involve 
-multiline processing of multiple files handled by the Logstash Forwarder.
-
-* The multiline codec plugin does not support file input from files that contain events from multiple sources.
-
-* The multiline filter plugin is not thread-safe. Avoid using multiple filter workers with the multiline filter.
-
-NOTE: You can track the progress of upgrades to the functionality of the multiline codec at 
+NOTE: For more complex needs, the {logstash}plugins-filters-multiline.html[multiline filter] performs a similar task at
+the filter stage of processing, where the Logstash instance aggregates multiple inputs.
+The multiline filter plugin is not thread-safe. Avoid using multiple filter workers with the multiline filter. You can
+track the progress of upgrades to the functionality of the multiline codec at
 https://github.com/logstash-plugins/logstash-codec-multiline/issues/10[this Github issue].
 
 ==== Examples of Multiline Plugin Configuration
@@ -50,7 +39,7 @@ The examples in this section cover the following use cases:
 
 ===== Java Stack Traces
 
-Java stack traces consist of multiple lines, with each line after the initial line beginning with whitespace, as in 
+Java stack traces consist of multiple lines, with each line after the initial line beginning with whitespace, as in
 this example:
 
 [source,java]
@@ -75,7 +64,7 @@ This configuration merges any line that begins with whitespace up to the previou
 
 ===== Line Continuations
 
-Several programming languages use the `\` character at the end of a line to denote that the line continues, as in this 
+Several programming languages use the `\` character at the end of a line to denote that the line continues, as in this
 example:
 
 [source,c]
@@ -98,11 +87,11 @@ This configuration merges any line that ends with the `\` character with the fol
 
 ===== Timestamps
 
-Activity logs from services such as Elasticsearch typically begin with a timestamp, followed by information on the 
+Activity logs from services such as Elasticsearch typically begin with a timestamp, followed by information on the
 specific activity, as in this example:
 
 [source,shell]
-[2015-08-24 11:49:14,389][INFO ][env                      ] [Letha] using [1] data paths, mounts [[/ 
+[2015-08-24 11:49:14,389][INFO ][env                      ] [Letha] using [1] data paths, mounts [[/
 (/dev/disk1)]], net usable_space [34.5gb], net total_space [118.9gb], types [hfs]
 
 To consolidate these lines into a single event in Logstash, use the following configuration for the multiline codec:
@@ -119,5 +108,5 @@ input {
   }
 }
 
-This configuration uses the `negate` option to specify that any line that does not begin with a timestamp belongs to 
+This configuration uses the `negate` option to specify that any line that does not begin with a timestamp belongs to
 the previous line.
diff --git a/docs/static/offline-plugins.asciidoc b/docs/static/offline-plugins.asciidoc
new file mode 100644
index 00000000000..c5f20e29aea
--- /dev/null
+++ b/docs/static/offline-plugins.asciidoc
@@ -0,0 +1,67 @@
+[[offline-plugins]]
+=== Offline Plugin Management
+
+The Logstash <<working-with-plugins,plugin manager>> was introduced in the 1.5 release. This section discusses setting up
+local repositories of plugins for use on systems without access to the Internet.
+
+The procedures in this section require a staging machine running Logstash that has access to a public or private Rubygems
+server. This staging machine downloads and packages the files used for offline installation.
+
+See the <<private-rubygem,Private Gem Repositories>> section for information on setting up your own private
+Rubygems server.
+
+Users who can work with a larger Logstash artifact size can use the *Logstash (All Plugins)* download link from the
+https://www.elastic.co/downloads/logstash[Logstash product page] to download Logstash bundled with the latest version of
+all available plugins. You can distribute this bundle to all nodes without further plugin staging.
+
+[float]
+=== Building the Offline Package
+
+Working with offline plugins requires you to create an _offline package_, which is a compressed file that contains all of
+the plugins your offline Logstash installation requires, along with the dependencies for those plugins.
+
+. Create the offline package with the `bin/plugin pack` subcommand.
++
+When you run the `bin/plugin pack` subcommand, Logstash creates a compressed bundle that contains all of the currently
+installed plugins and the dependencies for those plugins. By default, the compressed bundle is a GZipped TAR file when you
+run the `bin/plugin pack` subcommand on a UNIX machine. By default, when you run the `bin/plugin pack` subcommand on a
+Windows machine, the compressed bundle is a ZIP file. See <<managing-packs,Managing Plugin Packs>> for details on changing
+these default behaviors.
++
+NOTE: Downloading all dependencies for the specified plugins may take some time, depending on the plugins listed.
+
+. Move the compressed bundle to the offline machines that are the source for offline plugin installation, then use the
+`bin/plugin unpack` subcommand to make the packaged plugins available.
+
+[float]
+=== Install or Update a local plugin
+
+To install or update a local plugin, use the `--local` option with the install and update commands, as in the following
+examples:
+
+.Installing a local plugin
+============
+`bin/plugin install --local logstash-input-jdbc`
+============
+
+.Updating a local plugin
+============
+`bin/plugin update --local logstash-input-jdbc`
+============
+
+.Updating all local plugins in one command
+============
+`bin/plugin update --local`
+============
+
+[float]
+[[managing-packs]]
+=== Managing Plugin Packs
+
+The `pack` and `unpack` subcommands for `bin/plugin` take the following options:
+
+[horizontal]
+`--tgz`:: Generate the offline package as a GZipped TAR file. The default behavior on UNIX systems.
+`--zip`:: Generate the offline package as a ZIP file. The default behavior on Windows systems.
+`[packname] --override`:: Generates a new offline package that overwrites an existing offline with the specified name.
+`[packname] --[no-]clean`: Deletes offline packages matching the specified name.
diff --git a/docs/asciidoc/static/output.asciidoc b/docs/static/output.asciidoc
similarity index 88%
rename from docs/asciidoc/static/output.asciidoc
rename to docs/static/output.asciidoc
index ac6ccdee269..0f9b1b1c0a1 100644
--- a/docs/asciidoc/static/output.asciidoc
+++ b/docs/static/output.asciidoc
@@ -1,5 +1,5 @@
 :register_method:	true
-:receive_method:	true
+:multi_receive_method:	true
 :plugintype:    	output
 :pluginclass:   	Outputs
 :pluginname:    	example
@@ -9,6 +9,6 @@
 
 :getstarted: Let's step through creating an {plugintype} plugin using the https://github.com/logstash-plugins/logstash-output-example/[example {plugintype} plugin].
 
-:methodheader: Logstash outputs must implement the `register` and `receive` methods.
+:methodheader: Logstash outputs must implement the `register` and `multi_receive` methods.
 
 include::include/pluginbody.asciidoc[]
diff --git a/docs/asciidoc/static/plugin-manager.asciidoc b/docs/static/plugin-manager.asciidoc
similarity index 65%
rename from docs/asciidoc/static/plugin-manager.asciidoc
rename to docs/static/plugin-manager.asciidoc
index f15ea99dbd0..de4587332b7 100644
--- a/docs/asciidoc/static/plugin-manager.asciidoc
+++ b/docs/static/plugin-manager.asciidoc
@@ -1,15 +1,17 @@
 [[working-with-plugins]]
 == Working with plugins
 
-Logstash has a rich collection of input, filter, codec and output plugins. Plugins are available as self-contained packages called gems and hosted on RubyGems.org. The plugin manager accesed via `bin/plugin` script is used to manage the lifecycle of plugins in your Logstash deployment. You can install, uninstall and upgrade plugins using these Command Line Interface (CLI) described below.
-
-NOTE: Some sections here are for advanced users
+Logstash has a rich collection of input, filter, codec and output plugins. Plugins are available as self-contained
+packages called gems and hosted on RubyGems.org. The plugin manager accesed via `bin/plugin` script is used to manage the
+lifecycle of plugins in your Logstash deployment. You can install, uninstall and upgrade plugins using these Command Line
+Interface (CLI) described below.
 
 [float]
 [[listing-plugins]]
 === Listing plugins
 
-Logstash release packages bundle common plugins so you can use them out of the box. To list the plugins currently available in your deployment:
+Logstash release packages bundle common plugins so you can use them out of the box. To list the plugins currently
+available in your deployment:
 
 [source,shell]
 ----------------------------------
@@ -30,7 +32,9 @@ bin/plugin list --group output <4>
 [[installing-plugins]]
 === Adding plugins to your deployment
 
-The most common situation when dealing with plugin installation is when you have access to internet. Using this method, you will be able to retrieve plugins hosted on the public repository (RubyGems.org) and install on top of your Logstash installation.
+The most common situation when dealing with plugin installation is when you have access to internet. Using this method,
+you will be able to retrieve plugins hosted on the public repository (RubyGems.org) and install on top of your Logstash
+installation.
 
 [source,shell]
 ----------------------------------
@@ -43,7 +47,8 @@ Once the plugin is successfully installed, you can start using it in your config
 [float]
 ==== Advanced: Adding a locally built plugin
 
-In some cases, you want to install plugins which have not yet been released and not hosted on RubyGems.org. Logstash provides you the option to install a locally built plugin which is packaged as a ruby gem. Using a file location:
+In some cases, you want to install plugins which have not yet been released and not hosted on RubyGems.org. Logstash
+provides you the option to install a locally built plugin which is packaged as a ruby gem. Using a file location:
 
 [source,shell]
 ----------------------------------
@@ -54,7 +59,8 @@ bin/plugin install /path/to/logstash-output-kafka-1.0.0.gem
 [float]
 ==== Advanced: Using `--pluginpath`
 
-Using the `--pluginpath` flag, you can load a plugin source code located on your file system. Typically this is used by developers who are iterating on a custom plugin and want to test it before creating a ruby gem.
+Using the `--pluginpath` flag, you can load a plugin source code located on your file system. Typically this is used by
+developers who are iterating on a custom plugin and want to test it before creating a ruby gem.
 
 [source,shell]
 ----------------------------------
@@ -65,7 +71,8 @@ bin/logstash --pluginpath /opt/shared/lib/logstash/input/my-custom-plugin-code.r
 [float]
 === Updating plugins
 
-Plugins have their own release cycle and are often released independent of Logstash’s core release cycle. Using the update sub-command you can get the latest or update to a particular version of the plugin.
+Plugins have their own release cycle and are often released independent of Logstash’s core release cycle. Using the update
+subcommand you can get the latest or update to a particular version of the plugin.
 
 [source,shell]
 ----------------------------------
@@ -91,7 +98,9 @@ bin/plugin uninstall logstash-output-kafka
 [float]
 === Proxy Support
 
-The previous sections relied on Logstash being able to communicate with RubyGems.org. In certain environments, Forwarding Proxy is used to handle HTTP requests. Logstash Plugins can be installed and updated through a Proxy by setting the `HTTP_PROXY` environment variable:
+The previous sections relied on Logstash being able to communicate with RubyGems.org. In certain environments, Forwarding
+Proxy is used to handle HTTP requests. Logstash Plugins can be installed and updated through a Proxy by setting the
+`HTTP_PROXY` environment variable:
 
 [source,shell]
 ----------------------------------
@@ -101,3 +110,7 @@ bin/plugin install logstash-output-kafka
 ----------------------------------
 
 Once set, plugin commands install, update can be used through this proxy.
+
+include::offline-plugins.asciidoc[]
+
+include::private-gem-repo.asciidoc[]
\ No newline at end of file
diff --git a/docs/static/private-gem-repo.asciidoc b/docs/static/private-gem-repo.asciidoc
new file mode 100644
index 00000000000..dd96f63a60d
--- /dev/null
+++ b/docs/static/private-gem-repo.asciidoc
@@ -0,0 +1,53 @@
+[[private-rubygem]]
+=== Private Gem Repositories
+
+The Logstash plugin manager connects to a Ruby gems repository to install and update Logstash plugins. By default, this
+repository is http://rubygems.org.
+
+Some use cases are unable to use the default repository, as in the following examples:
+
+* A firewall blocks access to the default repository.
+* You are developing your own plugins locally.
+* Airgap requirements on the local system.
+
+When you use a custom gem repository, be sure to make plugin dependencies available.
+
+Several open source projects enable you to run your own plugin server, among them:
+
+* https://github.com/geminabox/geminabox[Geminabox]
+* https://github.com/PierreRambaud/gemirro[Gemirro]
+* https://gemfury.com/[Gemfury]
+* http://www.jfrog.com/open-source/[Artifactory]
+
+==== Editing the Gemfile
+
+The gemfile is a configuration file that specifies information required for plugin management. Each gem file has a
+`source` line that specifies a location for plugin content.
+
+By default, the gemfile's `source` line reads:
+
+[source,shell]
+----------
+# This is a Logstash generated Gemfile.
+# If you modify this file manually all comments and formatting will be lost.
+
+source "https://rubygems.org"
+----------
+
+To change the source, edit the `source` line to contain your preferred source, as in the following example:
+
+[source,shell]
+----------
+# This is a Logstash generated Gemfile.
+# If you modify this file manually all comments and formatting will be lost.
+
+source "https://my.private.repository"
+----------
+
+After saving the new version of the gemfile, use <<working-with-plugins,plugin management commands>> normally.
+
+The following links contain further material on setting up some commonly used repositories:
+
+* https://github.com/geminabox/geminabox/blob/master/README.markdown[Geminabox]
+* https://www.jfrog.com/confluence/display/RTF/RubyGems+Repositories[Artifactory]
+* Running a http://guides.rubygems.org/run-your-own-gem-server/[rubygems mirror]
diff --git a/docs/static/releasenotes.asciidoc b/docs/static/releasenotes.asciidoc
new file mode 100644
index 00000000000..35af69bdd25
--- /dev/null
+++ b/docs/static/releasenotes.asciidoc
@@ -0,0 +1,67 @@
+[[releasenotes]]
+== Logstash 2.3 Release Notes
+
+* Added dynamic config, a new feature to track config file for changes and restart the 
+  pipeline (same process) with updated config changes. This feature can be enabled in two 
+  ways: Passing a CLI long-form option `--auto-reload` or with short-form `-r`. Another 
+  option, `--reload-interval <seconds>` controls how often LS should check the config files 
+  for changes. Alternatively, if you don't start with the CLI option, you can send SIGHUP 
+  or `kill -1` signal to LS to reload the config file, and restart the pipeline ({lsissue}4513[Issue 4513]).
+* Added support to evaluate environment variables inside the Logstash config. You can also specify a 
+  default if the variable is not defined. The syntax is `${myVar:default}` ({lsissue}3944[Issue 3944]).
+* Added ability to configure custom garbage collection log file using `$LS_LOG_DIR`.
+* Deprecated `bin/plugin` in favor of `bin/logstash-plugin`. In the next major version `bin/plugin` will 
+  be removed to prevent `PATH` being polluted when other components of the Elastic stack are installed on 
+  the same instance ({lsissue}4891[Issue 4891]).
+* Fixed a bug where new pipeline might break plugins by calling the `register` method twice causing 
+  undesired behavior ({lsissue}4851[Issue 4851])).
+* Made `JAVA_OPTS` and `LS_JAVA_OPTS` work consistently on Windows ({lsissue}4758[Issue 4758]).
+* Fixed a bug where specifying JMX parameters in `LS_JAVA_OPTS` caused Logstash not to restart properly
+  ({lsissue}4319[Issue 4319]).
+* Fixed a bug where upgrading plugins with Manticore threw an error and sometimes corrupted installation ({lsissue}4818[Issue 4818]).
+* Removed milestone warning that was displayed when the `--pluginpath` option was used to load plugins ({lsissue}4562[Issue 4562]).
+* Upgraded to JRuby 1.7.24.
+* Reverted default output workers to 1. Previously we had made output workers the same as number of pipeline workers (#4877). 
+
+[float]
+== Input Plugins
+
+*`Beats`*:
+
+* Enhanced to verify client certificates against CA (https://github.com/logstash-plugins/logstash-input-beats/issues/8[Issue 8]).
+
+*`RabbitMQ`*:
+
+* Breaking Change: Metadata is now disabled by default because it was regressing performance.
+* Improved performance by using an internal queue and bulk ACKs.
+
+*`Redis`*:
+
+* Increased the batch_size to 100 by default. This provides a big jump in throughput and 
+  reduction in CPU utilization (https://github.com/logstash-plugins/logstash-input-redis/issues/25[Issue 25])
+
+*`JDBC`*:
+
+* Added retry connection feature (https://github.com/logstash-plugins/logstash-input-http/issues/33[Issue 33])
+
+[float]
+== Filter Plugins
+
+*`DNS`*:
+
+* Improved performance by adding caches to both successful and failed requests.
+* Added support for retrying with the `:max_retries` setting.
+* Lowered the default value of timeout from 2 to 0.5 seconds.
+
+[float]
+== Output Plugins
+
+*`Elasticsearch`*:
+
+* Bumped minimum manticore version to 0.5.4 which fixes a memory leak when sniffing 
+  is used (https://github.com/logstash-plugins/logstash-output-elasticsearch/issues/392[Issue 392]).
+* Fixed bug when updating documents with doc_as_upsert and scripting.   
+* Made error messages more verbose and easier to parse by humans.
+* Retryable failures are now logged at the info level instead of warning.
+
+
diff --git a/docs/static/reloading-config.asciidoc b/docs/static/reloading-config.asciidoc
new file mode 100644
index 00000000000..22f3118aac6
--- /dev/null
+++ b/docs/static/reloading-config.asciidoc
@@ -0,0 +1,43 @@
+[[reloading-config]]
+=== Reloading the Config File
+
+Starting with Logstash 2.3, you can set Logstash to detect and reload configuration
+changes automatically.
+
+To enable automatic config reloading, start Logstash with the `--auto-reload` (or `-r`)
+command-line option specified. For example:
+
+[source,shell]
+----------------------------------
+bin/logstash –f apache.config --auto-reload
+----------------------------------
+
+NOTE: The `--auto-reload` option is not available when you specify the `-e` flag to pass
+in  configuration settings from the command-line.
+
+By default, Logstash checks for configuration changes every 3 seconds. To change this interval,
+use the `--reload-interval <seconds>` option,  where `seconds` specifies how often Logstash
+checks the config files for changes. 
+
+If Logstash is already running without auto-reload enabled, you can force Logstash to
+reload the config file and restart the pipeline by sending a SIGHUP (signal hangup) to the
+process running Logstash. For example:
+
+[source,shell]
+----------------------------------
+kill -1 14175
+----------------------------------
+
+Where 14175 is the ID of the process running Logstash.
+
+==== How Automatic Config Reloading Works
+
+When Logstash detects a change in a config file, it stops the current pipeline by stopping
+all inputs, and it attempts to create a new pipeline that uses the updated configuration.
+After validating the syntax of the new configuration, Logstash verifies that all inputs
+and outputs can be initialized (for example, that all required ports are open). If the checks
+are successful, Logstash swaps the existing pipeline with the new pipeline. If the checks
+fail, the old pipeline continues to function, and the errors are propagated to the console.
+
+During automatic config reloading, the JVM is not restarted. The creating and swapping of
+pipelines all happens within the same process. 
diff --git a/docs/asciidoc/static/roadmap/index.asciidoc b/docs/static/roadmap/index.asciidoc
similarity index 89%
rename from docs/asciidoc/static/roadmap/index.asciidoc
rename to docs/static/roadmap/index.asciidoc
index b6c33abcc92..b52e271675a 100644
--- a/docs/asciidoc/static/roadmap/index.asciidoc
+++ b/docs/static/roadmap/index.asciidoc
@@ -72,8 +72,7 @@ https://github.com/elastic/logstash/labels/resiliency[resiliency] tag.
 
 *Known unknowns.* If we don’t know it’s happening, it’s hard for us to fix it!
 Please report your issues in GitHub, under the
-https://github.com/elastic/logstash/issues[Logstash],
-https://github.com/elastic/logstash-forwarder/issues[Logstash Forwarder], or
+https://github.com/elastic/logstash/issues[Logstash] or
 individual https://github.com/logstash-plugins/[Logstash plugin] repositories.
 
 == Manageability
@@ -125,12 +124,6 @@ distributing the load between instances based on the latest cluster state. This
 is a complex use case that will require input from the community on current
 approaches to implementing HA and load balancing of Logstash instances.
 
-== Logstash Forwarder
-[float]
-=== status: ongoing
-
-https://github.com/elastic/logstash-forwarder/[Logstash Forwarder] is a lightweight shipper for tailing files and forwarding this data to Logstash for further processing. It is often used in lieu of running Logstash on the servers, because it is lightweight, written in Go, and consumes less resources. It was created before we had the Beats framework for shipping data from servers and is currently maintained separately. We plan to move the Logstash Forwarder functionality to https://github.com/elastic/filebeat/[Filebeat] in the Beats framework, which is also written in Go. The first version of Filebeat will leverage the libbeat infrastructure and preserve existing features. Over time, we plan to enhance Filebeat with capabilities such as multiline and filtering support. Since Filebeat will serve as the direct replacement for Logstash Forwarder, we are not planning additional releases beyond http://www.elasticsearch.org/blog/logstash-forwarder-0-4-0-released/[Logstash Forwarder 0.4.0].
-
 == Performance
 [float]
 === status: ongoing; v1.5, v2.x
@@ -187,4 +180,4 @@ In Logstash 1.5, we made it easier than ever to add and maintain plugins by
 putting each plugin into its own repository (see "Plugin Framework" section).
 We also greatly improved the S3, Twitter, RabbitMQ plugins. To follow requests
 for new Logstash plugins or contribute to the discussion, look for issues that
-have the {LABELS}new-plugin[new-plugin] tag in Github.
\ No newline at end of file
+have the {LABELS}new-plugin[new-plugin] tag in Github.
diff --git a/docs/static/submitting-a-plugin.asciidoc b/docs/static/submitting-a-plugin.asciidoc
new file mode 100644
index 00000000000..d85db91a8ff
--- /dev/null
+++ b/docs/static/submitting-a-plugin.asciidoc
@@ -0,0 +1,107 @@
+[[submitting-plugin]]
+=== Submitting your plugin to RubyGems.org and the logstash-plugins repository
+
+Logstash uses http://rubygems.org[RubyGems.org] as its repository for all plugin
+artifacts. Once you have developed your new plugin, you can make it available to
+Logstash users by simply publishing it to RubyGems.org.
+
+==== Licensing
+Logstash and all its plugins are licensed under
+https://github.com/elasticsearch/logstash/blob/master/LICENSE[Apache License, version 2 ("ALv2")].
+If you make your plugin publicly available via http://rubygems.org[RubyGems.org],
+please make sure to have this line in your gemspec:
+
+* `s.licenses = ['Apache License (2.0)']`
+
+==== Publishing to http://rubygems.org[RubyGems.org]
+
+To begin, you’ll need an account on RubyGems.org
+
+* https://rubygems.org/sign_up[Sign-up for a RubyGems account].
+
+After creating an account,
+http://guides.rubygems.org/rubygems-org-api/#api-authorization[obtain] an API
+key from RubyGems.org. By default, RubyGems uses the file `~/.gem/credentials`
+to store your API key. These credentials will be used to publish the gem.
+Replace `username` and `password` with the credentials you created at
+RubyGems.org:
+
+[source,sh]
+----------------------------------
+curl -u username:password https://rubygems.org/api/v1/api_key.yaml > ~/.gem/credentials
+chmod 0600 ~/.gem/credentials
+----------------------------------
+
+Before proceeding, make sure you have the right version in your gemspec file
+and commit your changes.
+
+* `s.version = '0.1.0'`
+
+To publish version 0.1.0 of your new logstash gem:
+
+[source,sh]
+----------------------------------
+bundle install
+bundle exec rake vendor
+bundle exec rspec
+bundle exec rake publish_gem
+----------------------------------
+
+[NOTE]
+========
+Executing `rake publish_gem`:
+
+. Reads the version from the gemspec file (`s.version = '0.1.0'`)
+. Checks in your local repository if a tag exists for that version. If the tag
+already exists, it aborts the process. Otherwise, it creates a new version tag
+in your local repository.
+. Builds the gem
+. Publishes the gem to RubyGems.org
+========
+
+That's it! Your plugin is published! Logstash users can now install your plugin
+by running:
+
+[source,sh]
+[subs="attributes"]
+----------------------------------
+bin/plugin install logstash-{plugintype}-mypluginname
+----------------------------------
+
+==== Contributing your source code to https://github.com/logstash-plugins[logstash-plugins]
+
+It is not required to contribute your source code to
+https://github.com/logstash-plugins[logstash-plugins] github organization, but
+we always welcome new plugins!
+
+==== Benefits
+
+Some of the many benefits of having your plugin in the logstash-plugins
+repository are:
+
+* **Discovery** Your plugin will appear in the http://www.elasticsearch.org/guide/en/logstash/current/index.html[Logstash Reference],
+where Logstash users look first for plugins and documentation.
+* **Documentation** Your plugin documentation will automatically be added to the
+ http://www.elasticsearch.org/guide/en/logstash/current/index.html[Logstash Reference].
+* **Testing** With our testing infrastructure, your plugin will be continuously
+tested against current and future releases of Logstash.  As a result, users will
+have the assurance that if incompatibilities arise, they will be quickly
+discovered and corrected.
+
+==== Acceptance Guidelines
+
+* **Code Review** Your plugin must be reviewed by members of the community for
+coherence, quality, readability, stability and security.
+* **Tests** Your plugin must contain tests to be accepted.  These tests are also
+subject to code review for scope and completeness.  It's ok if you don't know
+how to write tests -- we will guide you. We are working on publishing a guide to
+creating tests for Logstash which will make it easier.  In the meantime, you can
+refer to http://betterspecs.org/ for examples.
+
+To begin migrating your plugin to logstash-plugins, simply create a new
+https://github.com/elasticsearch/logstash/issues[issue] in
+the Logstash repository. When the acceptance guidelines are completed, we will
+facilitate the move to the logstash-plugins organization using the recommended
+https://help.github.com/articles/transferring-a-repository/#transferring-from-a-user-to-an-organization[github process].
+
+pass::[<?edit_url?>]
diff --git a/docs/asciidoc/static/upgrading.asciidoc b/docs/static/upgrading.asciidoc
similarity index 59%
rename from docs/asciidoc/static/upgrading.asciidoc
rename to docs/static/upgrading.asciidoc
index 3043c67d5b0..a4465decc2e 100644
--- a/docs/asciidoc/static/upgrading.asciidoc
+++ b/docs/static/upgrading.asciidoc
@@ -16,7 +16,7 @@ This procedure uses <<package-repositories,package managers>> to upgrade Logstas
 1. Shut down your Logstash pipeline, including any inputs that send events to Logstash.
 2. Using the directions in the _Package Repositories_ section, update your repository links to point to the 2.0 repositories
 instead of the previous version.
-3. Run the `apt-get update logstash` or `yum update logstash` command as appropriate for your operating system.
+3. Run the `apt-get upgrade logstash` or `yum update logstash` command as appropriate for your operating system.
 4. Test your configuration file with the `logstash --configtest -f <configuration-file>` command. Configuration options for
 some Logstash plugins have changed in the 2.0 release.
 5. Restart your Logstash pipeline after updating your configuration file.
@@ -78,3 +78,33 @@ of workers by passing a command line flag such as:
 [source,shell]
 bin/logstash `-w 1`
 
+[[upgrading-logstash-2.2]]
+=== Upgrading Logstash to 2.2
+
+Logstash 2.2 re-architected the pipeline stages to provide more performance and help future enhancements in resiliency.
+The new pipeline introduced micro-batches, processing groups of events at a time. The default batch size is
+125 per worker. Also, the filter and output stages are executed in the same thread, but still, as different stages.
+The CLI flag `--pipeline-workers` or `-w` control the number of execution threads, which is set by default to number of cores.
+
+**Considerations for Elasticsearch Output**
+The default batch size of the pipeline is 125 events per worker. This will by default also be the bulk size
+used for the elasticsearch output. The Elasticsearch output's `flush_size` now acts only as a maximum bulk
+size (still defaulting to 500). For example, if your pipeline batch size is 3000 events, Elasticsearch
+Output will send 500 events at a time, in 6 separate bulk requests. In other words, for Elasticsearch output,
+bulk request size is chunked based on `flush_size` and `--pipeline-batch-size`. If `flush_size` is set greater
+than `--pipeline-batch-size`, it is ignored and `--pipeline-batch-size` will be used.
+
+The default number of output workers in Logstash 2.2 is now equal to the number of pipeline workers (`-w`)
+unless overridden in the Logstash config file. This can be problematic for some users as the
+extra workers may consume extra resources like file handles, especially in the case of the Elasticsearch
+output. Users with more than one Elasticsearch host may want to override the `workers` setting
+for the Elasticsearch output in their Logstash config to constrain that number to a low value, between 1 to 4.
+
+**Performance Tuning in 2.2**
+Since both filters and output workers are on the same thread, this could lead to threads being idle in I/O wait state.
+Thus, in 2.2, you can safely set `-w` to a number which is a multiple of the number of cores on your machine.
+A common way to tune performance is keep increasing the `-w` beyond the # of cores until performance no longer
+improves. A note of caution - make sure you also keep heapsize in mind, because the number of in-flight events
+are `#workers * batch_size * average_event size`. More in-flight events could add to memory pressure, eventually
+leading to Out of Memory errors. You can change the heapsize in Logstash by setting `LS_HEAP_SIZE`
+
diff --git a/docs/tutorials/10-minute-walkthrough/apache-elasticsearch.conf b/docs/tutorials/10-minute-walkthrough/apache-elasticsearch.conf
deleted file mode 100644
index 854fb1d9d27..00000000000
--- a/docs/tutorials/10-minute-walkthrough/apache-elasticsearch.conf
+++ /dev/null
@@ -1,35 +0,0 @@
-input {
-  tcp { 
-    type => "apache"
-    port => 3333
-  } 
-}
-
-filter {
-  if [type] == "apache" {
-    grok {
-      # See the following URL for a complete list of named patterns
-      # logstash/grok ships with by default:
-      # https://github.com/logstash/logstash/tree/master/patterns
-      #
-      # The grok filter will use the below pattern and on successful match use
-      # any captured values as new fields in the event.
-      match => { "message" => "%{COMBINEDAPACHELOG}" }
-    }
-
-    date {
-      # Try to pull the timestamp from the 'timestamp' field (parsed above with
-      # grok). The apache time format looks like: "18/Aug/2011:05:44:34 -0700"
-      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
-    }
-  }
-}
-
-output {
-  elasticsearch {
-    # Setting 'embedded' will run  a real elasticsearch server inside logstash.
-    # This option below saves you from having to run a separate process just
-    # for ElasticSearch, so you can get started quicker!
-    embedded => true
-  }
-}
diff --git a/docs/tutorials/10-minute-walkthrough/apache-parse.conf b/docs/tutorials/10-minute-walkthrough/apache-parse.conf
deleted file mode 100644
index dc0653cfa76..00000000000
--- a/docs/tutorials/10-minute-walkthrough/apache-parse.conf
+++ /dev/null
@@ -1,33 +0,0 @@
-input {
-  tcp { 
-    type => "apache"
-    port => 3333
-  } 
-}
-
-filter {
-  if [type] == "apache" {
-    grok {
-      # See the following URL for a complete list of named patterns
-      # logstash/grok ships with by default:
-      # https://github.com/logstash/logstash/tree/master/patterns
-      #
-      # The grok filter will use the below pattern and on successful match use
-      # any captured values as new fields in the event.
-      match => { "message" => "%{COMBINEDAPACHELOG}" }
-    }
-
-    date {
-      # Try to pull the timestamp from the 'timestamp' field (parsed above with
-      # grok). The apache time format looks like: "18/Aug/2011:05:44:34 -0700"
-      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
-    }
-  }
-}
-
-output {
-  # Use stdout in debug mode again to see what logstash makes of the event.
-  stdout {
-    codec => rubydebug
-  }
-}
diff --git a/docs/tutorials/10-minute-walkthrough/apache_log.1 b/docs/tutorials/10-minute-walkthrough/apache_log.1
deleted file mode 100644
index f7911a7eb0a..00000000000
--- a/docs/tutorials/10-minute-walkthrough/apache_log.1
+++ /dev/null
@@ -1 +0,0 @@
-129.92.249.70 - - [18/Aug/2011:06:00:14 -0700] "GET /style2.css HTTP/1.1" 200 1820 "http://www.semicomplete.com/blog/geekery/bypassing-captive-portals.html" "Mozilla/5.0 (iPad; U; CPU OS 4_3_5 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8L1 Safari/6533.18.5"
diff --git a/docs/tutorials/10-minute-walkthrough/apache_log.2.bz2 b/docs/tutorials/10-minute-walkthrough/apache_log.2.bz2
deleted file mode 100644
index 841e7b6b1f0..00000000000
Binary files a/docs/tutorials/10-minute-walkthrough/apache_log.2.bz2 and /dev/null differ
diff --git a/docs/tutorials/10-minute-walkthrough/hello-search.conf b/docs/tutorials/10-minute-walkthrough/hello-search.conf
deleted file mode 100644
index c99f014658a..00000000000
--- a/docs/tutorials/10-minute-walkthrough/hello-search.conf
+++ /dev/null
@@ -1,25 +0,0 @@
-input {
-  stdin { 
-    # A type is a label applied to an event. It is used later with filters
-    # to restrict what filters are run against each event.
-    type => "human"
-  } 
-}
-
-output {
-  # Print each event to stdout.
-  stdout {
-    # Enabling 'rubydebug' codec on the stdout output will make logstash
-    # pretty-print the entire event as something similar to a JSON representation.
-    codec => rubydebug
-  }
-  
-  # You can have multiple outputs. All events generally to all outputs.
-  # Output events to elasticsearch
-  elasticsearch {
-    # Setting 'embedded' will run  a real elasticsearch server inside logstash.
-    # This option below saves you from having to run a separate process just
-    # for ElasticSearch, so you can get started quicker!
-    embedded => true
-  }
-}
diff --git a/docs/tutorials/10-minute-walkthrough/hello.conf b/docs/tutorials/10-minute-walkthrough/hello.conf
deleted file mode 100644
index 3d80679931d..00000000000
--- a/docs/tutorials/10-minute-walkthrough/hello.conf
+++ /dev/null
@@ -1,16 +0,0 @@
-input {
-  stdin { 
-    # A type is a label applied to an event. It is used later with filters
-    # to restrict what filters are run against each event.
-    type => "human"
-  } 
-}
-
-output {
-  # Print each event to stdout.
-  stdout {
-    # Enabling 'rubydebug' codec on the stdout output will make logstash
-    # pretty-print the entire event as something similar to a JSON representation.
-    codec => rubydebug
-  }
-}
diff --git a/docs/tutorials/10-minute-walkthrough/index.md b/docs/tutorials/10-minute-walkthrough/index.md
deleted file mode 100644
index a8602e68d60..00000000000
--- a/docs/tutorials/10-minute-walkthrough/index.md
+++ /dev/null
@@ -1,101 +0,0 @@
----
-title: Logstash 10-Minute Tutorial
-layout: content_right
----
-# Logstash 10-minute Tutorial
-
-## Step 1 - Download
-
-### Download logstash:
-
-* [logstash-%VERSION%.tar.gz](https://download.elasticsearch.org/logstash/logstash/logstash-%VERSION%.tar.gz)
-
-    curl -O https://download.elasticsearch.org/logstash/logstash/logstash-%VERSION%.tar.gz
-
-### Unpack it
-
-    tar -xzf logstash-%VERSION%.tar.gz
-    cd logstash-%VERSION%
-
-### Requirements:
-
-* Java
-
-### The Secret:
-
-Logstash is written in JRuby, but I release standalone jar files for easy
-deployment, so you don't need to download JRuby or most any other dependencies.
-
-I bake as much as possible into the single release file.
-
-## Step 2 - A hello world.
-
-### Download this config file:
-
-* [hello.conf](hello.conf)
-
-### Run it:
-
-    bin/logstash agent -f hello.conf
-
-Type stuff on standard input. Press enter. Watch what event Logstash sees.
-Press ^C to kill it.
-
-## Step 3 - Add ElasticSearch
-
-### Download this config file:
-
-* [hello-search.conf](hello-search.conf)
-
-### Run it:
-
-    bin/logstash agent -f hello-search.conf
-
-Same config as step 2, but now we are also writing events to ElasticSearch. Do
-a search for `*` (all):
-
-    curl 'http://localhost:9200/_search?pretty=1&q=*'
-
-### Download
-
-* [apache-parse.conf](apache-parse.conf)
-* [apache_log.1](apache_log.1) (a single apache log line)
-
-### Run it
-
-    bin/logstash agent -f apache-parse.conf
-
-Logstash will now be listening on TCP port 3333. Send an Apache log message at it:
-
-    nc localhost 3333 < apache_log.1
-
-The expected output can be viewed here: [step-5-output.txt](step-5-output.txt)
-
-## Step 6 - real world example + search
-
-Same as the previous step, but we'll output to ElasticSearch now.
-
-### Download
-
-* [apache-elasticsearch.conf](apache-elasticsearch.conf)
-* [apache_log.2.bz2](apache_log.2.bz2) (2 days of apache logs)
-
-### Run it
-
-    bin/logstash agent -f apache-elasticsearch.conf
-
-Logstash should be all set for you now. Start feeding it logs:
-
-    bzip2 -d apache_log.2.bz2
-
-    nc localhost 3333 < apache_log.2
-
-## Want more?
-
-For further learning, try these:
-
-* [Watch a presentation on logstash](http://www.youtube.com/embed/RuUFnog29M4)
-* [Getting started 'standalone' guide](http://logstash.net/docs/%VERSION%/tutorials/getting-started-simple)
-* [Getting started 'centralized' guide](http://logstash.net/docs/%VERSION%/tutorials/getting-started-centralized) -
-  learn how to build out your logstash infrastructure and centralize your logs.
-* [Dive into the docs](http://logstash.net/docs/%VERSION%/)
diff --git a/docs/tutorials/10-minute-walkthrough/step-5-output.txt b/docs/tutorials/10-minute-walkthrough/step-5-output.txt
deleted file mode 100644
index ec87c0cebda..00000000000
--- a/docs/tutorials/10-minute-walkthrough/step-5-output.txt
+++ /dev/null
@@ -1,17 +0,0 @@
-{
-  "type"        => "apache",
-  "clientip"          => "129.92.249.70",
-  "ident"             => "-",
-  "auth"              => "-",
-  "timestamp"         => "18/Aug/2011:06:00:14 -0700",
-  "verb"              => "GET",
-  "request"           => "/style2.css",
-  "httpversion"       => "1.1",
-  "response"          => "200",
-  "bytes"             => "1820",
-  "referrer"          => "http://www.semicomplete.com/blog/geekery/bypassing-captive-portals.html",
-  "agent"             => "\"Mozilla/5.0 (iPad; U; CPU OS 4_3_5 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8L1 Safari/6533.18.5\"",
-  "@timestamp"   => "2011-08-18T13:00:14.000Z",
-  "host" => "127.0.0.1",
-  "message"     => "129.92.249.70 - - [18/Aug/2011:06:00:14 -0700] \"GET /style2.css HTTP/1.1\" 200 1820 \"http://www.semicomplete.com/blog/geekery/bypassing-captive-portals.html\" \"Mozilla/5.0 (iPad; U; CPU OS 4_3_5 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8L1 Safari/6533.18.5\"\n"
-}
diff --git a/docs/tutorials/getting-started-with-logstash.asciidoc b/docs/tutorials/getting-started-with-logstash.asciidoc
deleted file mode 100644
index e38ebb62508..00000000000
--- a/docs/tutorials/getting-started-with-logstash.asciidoc
+++ /dev/null
@@ -1,436 +0,0 @@
-= Getting Started with Logstash
-
-== Introduction
-Logstash is a tool for receiving, processing and outputting logs. All kinds of logs. System logs, webserver logs, error logs, application logs and just about anything you can throw at it. Sounds great, eh?
-
-Using Elasticsearch as a backend datastore, and kibana as a frontend reporting tool, Logstash acts as the workhorse, creating a powerful pipeline for storing, querying and analyzing your logs. With an arsenal of built-in inputs, filters, codecs and outputs, you can harness some powerful functionality with a small amount of effort. So, let's get started!
-
-=== Prerequisite: Java
-The only prerequisite required by Logstash is a Java runtime. You can check that you have it installed by running the  command `java -version` in your shell. Here's something similar to what you might see:
-----
-> java -version
-java version "1.7.0_45"
-Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
-Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
-----
-It is recommended to run a recent version of Java in order to ensure the greatest success in running Logstash.
-
-It's fine to run an open-source version such as OpenJDK: +
-http://openjdk.java.net/
-
-Or you can use the official Oracle version: +
-http://www.oracle.com/technetwork/java/index.html
-
-Once you have verified the existence of Java on your system, we can move on!
-
-== Up and Running!
-
-=== Logstash in two commands
-First, we're going to download the 'logstash' binary and run it with a very simple configuration.
-----
-curl -O https://download.elasticsearch.org/logstash/logstash/logstash-%VERSION%.tar.gz
-----
-Now you should have the file named 'logstash-%VERSION%.tar.gz' on your local filesystem. Let's unpack it:
-----
-tar zxvf logstash-%VERSION%.tar.gz
-cd logstash-%VERSION%
-----
-Here, we are telling the *tar* command that we are sending it a gzipped file (*z* flag), that we would like to extract the file (*x* flag), that we would like to do so verbosely (*v* flag), and that we will provide a filename for *tar* (*f* flag).
-
-Now let's run it:
-----
-bin/logstash -e 'input { stdin { } } output { stdout {} }'
-----
-
-Now type something into your command prompt, and you will see it output by Logstash:
-----
-hello world
-2013-11-21T01:22:14.405+0000 0.0.0.0 hello world
-----
-
-OK, that's interesting... We ran Logstash with an input called "stdin", and an output named "stdout", and Logstash basically echoed back whatever we typed in some sort of structured format. Note that specifying the *-e* command line flag allows Logstash to accept a configuration directly from the command line. This is especially useful for quickly testing configurations without having to edit a file between iterations.
-
-Let's try a slightly fancier example. First, you should exit Logstash by issuing a 'CTRL-D' command (or 'CTRL-C Enter') in the shell in which it is running. Now run Logstash again with the following command:
-----
-bin/logstash -e 'input { stdin { } } output { stdout { codec => rubydebug } }'
-----
-
-And then try another test input, typing the text "goodnight moon":
-----
-goodnight moon
-{
-  "message" => "goodnight moon",
-  "@timestamp" => "2013-11-20T23:48:05.335Z",
-  "@version" => "1",
-  "host" => "my-laptop"
-}
-----
-
-So, by re-configuring the "stdout" output (adding a "codec"), we can change the output of Logstash. By adding inputs, outputs and filters to your configuration, it's possible to massage the log data in many ways, in order to maximize flexibility of the stored data when you are querying it.
-
-== Storing logs with Elasticsearch
-Now, you're probably saying, "that's all fine and dandy, but typing all my logs into Logstash isn't really an option, and merely seeing them spit to STDOUT isn't very useful." Good point. First, let's set up Elasticsearch to store the messages we send into Logstash. If you don't have Elasticsearch already installed, you can http://www.elasticsearch.org/download/[download the RPM or DEB package], or install manually by downloading the current release tarball, by issuing the following four commands:
-----
-curl -O https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-%ELASTICSEARCH_VERSION%.tar.gz
-tar zxvf elasticsearch-%ELASTICSEARCH_VERSION%.tar.gz
-cd elasticsearch-%ELASTICSEARCH_VERSION%/
-./bin/elasticsearch
-----
-
-NOTE: This tutorial specifies running Logstash %VERSION% with Elasticsearch %ELASTICSEARCH_VERSION%. Each release of Logstash has a *recommended* version of Elasticsearch to pair with. Make sure the versions match based on the http://www.elasticsearch.org/overview/logstash[Logstash version] you're running!
-
-More detailed information on installing and configuring Elasticsearch can be found on http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/index.html[The Elasticsearch reference pages]. However, for the purposes of Getting Started with Logstash, the default installation and configuration of Elasticsearch should be sufficient.
-
-Now that we have Elasticsearch running on port 9200 (we do, right?), Logstash can be simply configured to use Elasticsearch as its backend. The defaults for both Logstash and Elasticsearch are fairly sane and well thought out, so we can omit the optional configurations within the elasticsearch output:
-----
-bin/logstash -e 'input { stdin { } } output { elasticsearch { host => localhost } }'
-----
-
-Type something, and Logstash will process it as before (this time you won't see any output, since we don't have the stdout output configured)
-----
-you know, for logs
-----
-
-You can confirm that ES actually received the data by making a curl request and inspecting the return:
-----
-curl 'http://localhost:9200/_search?pretty'
-----
-
-which should return something like this:
-----
-{
-  "took" : 2,
-  "timed_out" : false,
-  "_shards" : {
-    "total" : 5,
-    "successful" : 5,
-    "failed" : 0
-  },
-  "hits" : {
-    "total" : 1,
-    "max_score" : 1.0,
-    "hits" : [ {
-      "_index" : "logstash-2013.11.21",
-      "_type" : "logs",
-      "_id" : "2ijaoKqARqGvbMgP3BspJA",
-      "_score" : 1.0, "_source" : {"message":"you know, for logs","@timestamp":"2013-11-21T18:45:09.862Z","@version":"1","host":"my-laptop"}
-    } ]
-  }
-}
-----
-
-Congratulations! You've successfully stashed logs in Elasticsearch via Logstash.
-
-=== Elasticsearch Plugins (an aside)
-Another very useful tool for querying your Logstash data (and Elasticsearch in general) is the Elasticsearch-kopf plugin. Here is more information on http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-plugins.html[Elasticsearch plugins]. To install elasticsearch-kopf, simply issue the following command in your Elasticsearch directory (the same one in which you ran Elasticsearch earlier):
-----
-bin/plugin -install lmenezes/elasticsearch-kopf
-----
-Now you can browse to http://localhost:9200/_plugin/kopf[http://localhost:9200/_plugin/kopf] to browse your Elasticsearch data, settings and mappings!
-
-=== Multiple Outputs
-As a quick exercise in configuring multiple Logstash outputs, let's invoke Logstash again, using both the 'stdout' as well as the 'elasticsearch' output:
-----
-bin/logstash -e 'input { stdin { } } output { elasticsearch { host => localhost } stdout { } }'
-----
-Typing a phrase will now echo back to your terminal, as well as save in Elasticsearch! (Feel free to verify this using curl, kibana or elasticsearch-kopf).
-
-=== Default - Daily Indices
-You might notice that Logstash was smart enough to create a new index in Elasticsearch... The default index name is in the form of 'logstash-YYYY.MM.DD', which essentially creates one index per day. At midnight (GMT?), Logstash will automagically rotate the index to a fresh new one, with the new current day's timestamp. This allows you to keep windows of data, based on how far retroactively you'd like to query your log data. Of course, you can always archive (or re-index) your data to an alternate location, where you are able to query further into the past. If you'd like to simply delete old indices after a certain time period, you can use the https://github.com/elasticsearch/curator[Elasticsearch Curator tool].
-
-== Moving On
-Now you're ready for more advanced configurations. At this point, it makes sense for a quick discussion of some of the core features of Logstash, and how they interact with the Logstash engine.
-
-=== The Life of an Event
-
-Inputs, Outputs, Codecs and Filters are at the heart of the Logstash configuration. By creating a pipeline of event processing, Logstash is able to extract the relevant data from your logs and make it available to elasticsearch, in order to efficiently query your data. To get you thinking about the various options available in Logstash, let's discuss some of the more common configurations currently in use. For more details, read about http://logstash.net/docs/latest/life-of-an-event[the Logstash event pipeline].
-
-==== Inputs
-Inputs are the mechanism for passing log data to Logstash. Some of the more useful, commonly-used ones are:
-
-* *file*: reads from a file on the filesystem, much like the UNIX command "tail -0F"
-* *syslog*: listens on the well-known port 514 for syslog messages and parses according to RFC3164 format
-* *redis*: reads from a redis server, using both redis channels and also redis lists. Redis is often used as a "broker" in a centralized Logstash installation, which queues Logstash events from remote Logstash "shippers".
-* *lumberjack*: processes events sent in the lumberjack protocol. Now called https://github.com/elasticsearch/logstash-forwarder[logstash-forwarder].
-
-==== Filters
-Filters are used as intermediary processing devices in the Logstash chain. They are often combined with conditionals in order to perform a certain action on an event, if it matches particular criteria. Some useful filters:
-
-* *grok*: parses arbitrary text and structure it. Grok is currently the best way in Logstash to parse unstructured log data into something structured and queryable. With 120 patterns shipped built-in to Logstash, it's more than likely you'll find one that meets your needs!
-* *mutate*: The mutate filter allows you to do general mutations to fields. You can rename, remove, replace, and modify fields in your events.
-* *drop*: drop an event completely, for example, 'debug' events.
-* *clone*: make a copy of an event, possibly adding or removing fields.
-* *geoip*: adds information about geographical location of IP addresses (and displays amazing charts in kibana)
-
-==== Outputs
-Outputs are the final phase of the Logstash pipeline. An event may pass through multiple outputs during processing, but once all outputs are complete, the event has finished its execution. Some commonly used outputs include:
-
-* *elasticsearch*: If you're planning to save your data in an efficient, convenient and easily queryable format... Elasticsearch is the way to go. Period. Yes, we're biased :)
-* *file*: writes event data to a file on disk.
-* *graphite*: sends event data to graphite, a popular open source tool for storing and graphing metrics. http://graphite.wikidot.com/
-* *statsd*: a service which "listens for statistics, like counters and timers, sent over UDP and sends aggregates to one or more pluggable backend services". If you're already using statsd, this could be useful for you!
-
-==== Codecs
-Codecs are basically stream filters which can operate as part of an input, or an output. Codecs allow you to easily separate the transport of your messages from the serialization process. Popular codecs include 'json', 'msgpack' and 'plain' (text).
-
-* *json*: encode / decode data in JSON format
-* *multiline*: Takes multiple-line text events and merge them into a single event, e.g. java exception and stacktrace messages
-
-For the complete list of (current) configurations, visit the Logstash "plugin configuration" section of the http://www.elasticsearch.org/overview/logstash[Logstash documentation page].
-
-
-== More fun with Logstash
-=== Persistent Configuration files
-
-Specifying configurations on the command line using '-e' is only so helpful, and more advanced setups will require more lengthy, long-lived configurations. First, let's create a simple configuration file, and invoke Logstash using it. Create a file named "logstash-simple.conf" and save it in the same directory as Logstash.
-
-----
-input { stdin { } }
-output {
-  elasticsearch { host => localhost }
-  stdout { codec => rubydebug }
-}
-----
-
-Then, run this command:
-
-----
-bin/logstash -f logstash-simple.conf
-----
-
-Et voilà! Logstash will read in the configuration file you just created and run as in the example we saw earlier. Note that we used the '-f' to read in the file, rather than the '-e' to read the configuration from the command line. This is a very simple case, of course, so let's move on to some more complex examples.
-
-=== Testing Your Configuration Files
-
-After creating a new or complex configuration file, it can be helpful to quickly test that the file is formatted correctly. We can verify our configuration file is formatted correctly by using the *--configtest* flag.
-
-----
-bin/logstash -f logstash-simple.conf --configtest
-----
-
-=== Filters
-Filters are an in-line processing mechanism which provide the flexibility to slice and dice your data to fit your needs. Let's see one in action, namely the *grok filter*.
-
-----
-input { stdin { } }
-
-filter {
-  grok {
-    match => { "message" => "%{COMBINEDAPACHELOG}" }
-  }
-  date {
-    match => [ "timestamp" , "dd/MMM/yyyy:HH:mm:ss Z" ]
-  }
-}
-
-output {
-  elasticsearch { host => localhost }
-  stdout { codec => rubydebug }
-}
-----
-Run Logstash with this configuration:
-
-----
-bin/logstash -f logstash-filter.conf
-----
-
-Now paste this line into the terminal (so it will be processed by the stdin input):
-----
-127.0.0.1 - - [11/Dec/2013:00:01:45 -0800] "GET /xampp/status.php HTTP/1.1" 200 3891 "http://cadenza/xampp/navi.php" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:25.0) Gecko/20100101 Firefox/25.0"
-----
-You should see something returned to STDOUT which looks like this:
-----
-{
-        "message" => "127.0.0.1 - - [11/Dec/2013:00:01:45 -0800] \"GET /xampp/status.php HTTP/1.1\" 200 3891 \"http://cadenza/xampp/navi.php\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:25.0) Gecko/20100101 Firefox/25.0\"",
-     "@timestamp" => "2013-12-11T08:01:45.000Z",
-       "@version" => "1",
-           "host" => "cadenza",
-       "clientip" => "127.0.0.1",
-          "ident" => "-",
-           "auth" => "-",
-      "timestamp" => "11/Dec/2013:00:01:45 -0800",
-           "verb" => "GET",
-        "request" => "/xampp/status.php",
-    "httpversion" => "1.1",
-       "response" => "200",
-          "bytes" => "3891",
-       "referrer" => "\"http://cadenza/xampp/navi.php\"",
-          "agent" => "\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:25.0) Gecko/20100101 Firefox/25.0\""
-}
-----
-As you can see, Logstash (with help from the *grok* filter) was able to parse the log line (which happens to be in Apache "combined log" format) and break it up into many different discrete bits of information. This will be extremely useful later when we start querying and analyzing our log data... for example, we'll be able to run reports on HTTP response codes, IP addresses, referrers, etc. very easily. There are quite a few grok patterns included with Logstash out-of-the-box, so it's quite likely if you're attempting to parse a fairly common log format, someone has already done the work for you. For more details, see the list of https://github.com/logstash/logstash/blob/master/patterns/grok-patterns[logstash grok patterns] on github.
-
-The other filter used in this example is the *date* filter. This filter parses out a timestamp and uses it as the timestamp for the event (regardless of when you're ingesting the log data). You'll notice that the @timestamp field in this example is set to December 11, 2013, even though Logstash is ingesting the event at some point afterwards. This is handy when backfilling logs, for example... the ability to tell Logstash "use this value as the timestamp for this event". For non-english installation you may have to precise the locale in date filter (locale => en).
-
-== Useful Examples
-
-=== Apache logs (from files)
-Now, let's configure something actually *useful*... apache2 access log files! We are going to read the input from a file on the localhost, and use a *conditional* to process the event according to our needs. First, create a file called something like 'logstash-apache.conf' with the following contents (you'll need to change the log's file path to suit your needs):
-
-----
-input {
-  file {
-    path => "/tmp/access_log"
-    start_position => "beginning"
-  }
-}
-
-filter {
-  if [path] =~ "access" {
-    mutate { replace => { "type" => "apache_access" } }
-    grok {
-      match => { "message" => "%{COMBINEDAPACHELOG}" }
-    }
-  }
-  date {
-    match => [ "timestamp" , "dd/MMM/yyyy:HH:mm:ss Z" ]
-  }
-}
-
-output {
-  elasticsearch {
-    host => localhost
-  }
-  stdout { codec => rubydebug }
-}
-
-----
-Then, create the file you configured above (in this example, "/tmp/access_log") with the following log lines as contents (or use some from your own webserver):
-
-----
-71.141.244.242 - kurt [18/May/2011:01:48:10 -0700] "GET /admin HTTP/1.1" 301 566 "-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.3) Gecko/20100401 Firefox/3.6.3"
-134.39.72.245 - - [18/May/2011:12:40:18 -0700] "GET /favicon.ico HTTP/1.1" 200 1189 "-" "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; InfoPath.2; .NET4.0C; .NET4.0E)"
-98.83.179.51 - - [18/May/2011:19:35:08 -0700] "GET /css/main.css HTTP/1.1" 200 1837 "http://www.safesand.com/information.htm" "Mozilla/5.0 (Windows NT 6.0; WOW64; rv:2.0.1) Gecko/20100101 Firefox/4.0.1"
-----
-
-Now run it with the -f flag as in the last example:
-----
-bin/logstash -f logstash-apache.conf
-----
-You should be able to see your apache log data in Elasticsearch now! You'll notice that Logstash opened the file you configured, and read through it, processing any events it encountered. Any additional lines logged to this file will also be captured, processed by Logstash as events and stored in Elasticsearch. As an added bonus, they will be stashed with the field "type" set to "apache_access" (this is done by the type => "apache_access" line in the input configuration).
-
-In this configuration, Logstash is only watching the apache access_log, but it's easy enough to watch both the access_log and the error_log (actually, any file matching '*log'), by changing one line in the above configuration, like this:
-
-----
-input {
-  file {
-    path => "/tmp/*_log"
-...
-----
-Now, rerun Logstash, and you will see both the error and access logs processed via Logstash. However, if you inspect your data (using elasticsearch-kopf, perhaps), you will see that the access_log was broken up into discrete fields, but not the error_log. That's because we used a "grok" filter to match the standard combined apache log format and automatically split the data into separate fields. Wouldn't it be nice *if* we could control how a line was parsed, based on its format? Well, we can...
-
-Also, you might have noticed that Logstash did not reprocess the events which were already seen in the access_log file. Logstash is able to save its position in files, only processing new lines as they are added to the file. Neat!
-
-=== Conditionals
-Now we can build on the previous example, where we introduced the concept of a *conditional*. A conditional should be familiar to most Logstash users, in the general sense. You may use 'if', 'else if' and 'else' statements, as in many other programming languages. Let's label each event according to which file it appeared in (access_log, error_log and other random files which end with "log").
-
-----
-input {
-  file {
-    path => "/tmp/*_log"
-  }
-}
-
-filter {
-  if [path] =~ "access" {
-    mutate { replace => { type => "apache_access" } }
-    grok {
-      match => { "message" => "%{COMBINEDAPACHELOG}" }
-    }
-    date {
-      match => [ "timestamp" , "dd/MMM/yyyy:HH:mm:ss Z" ]
-    }
-  } else if [path] =~ "error" {
-    mutate { replace => { type => "apache_error" } }
-  } else {
-    mutate { replace => { type => "random_logs" } }
-  }
-}
-
-output {
-  elasticsearch { host => localhost }
-  stdout { codec => rubydebug }
-}
-----
-
-You'll notice we've labeled all events using the "type" field, but we didn't actually parse the "error" or "random" files... There are so many types of error logs that it's better left as an exercise for you, depending on the logs you're seeing.
-
-=== Syslog
-OK, now we can move on to another incredibly useful example: *syslog*. Syslog is one of the most common use cases for Logstash, and one it handles exceedingly well (as long as the log lines conform roughly to RFC3164 :). Syslog is the de facto UNIX networked logging standard, sending messages from client machines to a local file, or to a centralized log server via rsyslog. For this example, you won't need a functioning syslog instance; we'll fake it from the command line, so you can get a feel for what happens.
-
-First, let's make a simple configuration file for Logstash + syslog, called 'logstash-syslog.conf'.
-
-----
-input {
-  tcp {
-    port => 5000
-    type => syslog
-  }
-  udp {
-    port => 5000
-    type => syslog
-  }
-}
-
-filter {
-  if [type] == "syslog" {
-    grok {
-      match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
-      add_field => [ "received_at", "%{@timestamp}" ]
-      add_field => [ "received_from", "%{host}" ]
-    }
-    syslog_pri { }
-    date {
-      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
-    }
-  }
-}
-
-output {
-  elasticsearch { host => localhost }
-  stdout { codec => rubydebug }
-}
-----
-Run it as normal:
-----
-bin/logstash -f logstash-syslog.conf
-----
-Normally, a client machine would connect to the Logstash instance on port 5000 and send its message. In this simplified case, we're simply going to telnet to Logstash and enter a log line (similar to how we entered log lines into STDIN earlier). First, open another shell window to interact with the Logstash syslog input and type the following command:
-
-----
-telnet localhost 5000
-----
-
-You can copy and paste the following lines as samples (feel free to try some of your own, but keep in mind they might not parse if the grok filter is not correct for your data):
-
-----
-Dec 23 12:11:43 louis postfix/smtpd[31499]: connect from unknown[95.75.93.154]
-Dec 23 14:42:56 louis named[16000]: client 199.48.164.7#64817: query (cache) 'amsterdamboothuren.com/MX/IN' denied
-Dec 23 14:30:01 louis CRON[619]: (www-data) CMD (php /usr/share/cacti/site/poller.php >/dev/null 2>/var/log/cacti/poller-error.log)
-Dec 22 18:28:06 louis rsyslogd: [origin software="rsyslogd" swVersion="4.2.0" x-pid="2253" x-info="http://www.rsyslog.com"] rsyslogd was HUPed, type 'lightweight'.
-----
-
-Now you should see the output of Logstash in your original shell as it processes and parses messages!
-
-----
-{
-                 "message" => "Dec 23 14:30:01 louis CRON[619]: (www-data) CMD (php /usr/share/cacti/site/poller.php >/dev/null 2>/var/log/cacti/poller-error.log)",
-              "@timestamp" => "2013-12-23T22:30:01.000Z",
-                "@version" => "1",
-                    "type" => "syslog",
-                    "host" => "0:0:0:0:0:0:0:1:52617",
-        "syslog_timestamp" => "Dec 23 14:30:01",
-         "syslog_hostname" => "louis",
-          "syslog_program" => "CRON",
-              "syslog_pid" => "619",
-          "syslog_message" => "(www-data) CMD (php /usr/share/cacti/site/poller.php >/dev/null 2>/var/log/cacti/poller-error.log)",
-             "received_at" => "2013-12-23 22:49:22 UTC",
-           "received_from" => "0:0:0:0:0:0:0:1:52617",
-    "syslog_severity_code" => 5,
-    "syslog_facility_code" => 1,
-         "syslog_facility" => "user-level",
-         "syslog_severity" => "notice"
-}
-----
-
-Congratulations! You're well on your way to being a real Logstash power user. You should be comfortable configuring, running and sending events to Logstash, but there's much more to explore.
diff --git a/docs/tutorials/just-enough-rabbitmq-for-logstash.md b/docs/tutorials/just-enough-rabbitmq-for-logstash.md
deleted file mode 100644
index 060fa6f0ac2..00000000000
--- a/docs/tutorials/just-enough-rabbitmq-for-logstash.md
+++ /dev/null
@@ -1,201 +0,0 @@
----
-title: Just Enough RabbitMQ - logstash
-layout: content_right
----
-
-While configuring your RabbitMQ broker is out of scope for logstash, it's important
-to understand how logstash uses RabbitMQ. To do that, we need to understand a
-little about AMQP.
-
-You should also consider reading
-[this](http://www.rabbitmq.com/tutorials/amqp-concepts.html) at the RabbitMQ
-website.
-
-# Exchanges, queues and bindings; OH MY!
-
-You can get a long way by understanding a few key terms.
-
-## Exchanges
-
-Exchanges are for message **producers**. In Logstash, we map these to
-**outputs**.  Logstash puts messages on exchanges.  There are many types of
-exchanges and they are discussed below.
-
-## Queues
-
-Queues are for message **consumers**. In Logstash, we map these to inputs.
-Logstash reads messages from queues.  Optionally, queues can consume only a
-subset of messages. This is done with "routing keys".
-
-## Bindings
-
-Just having a producer and a consumer is not enough. We must `bind` a queue to
-an exchange.  When we bind a queue to an exchange, we can optionally provide a
-routing key.  Routing keys are discussed below.
-
-## Broker
-
-A broker is simply the AMQP server software. There are several brokers, but this
-tutorial will cover the most common (and arguably popular), [RabbitMQ](http://www.rabbitmq.com).
-
-# Routing Keys
-
-Simply put, routing keys are somewhat like tags for messages. In practice, they
-are hierarchical in nature with the each level separated by a dot:
-
-- `messages.servers.production`
-- `sports.atlanta.baseball`
-- `company.myorg.mydepartment`
-
-Routing keys are really handy with a tool like logstash where you
-can programatically define the routing key for a given event using the metadata that logstash provides:
-
-- `logs.servers.production.host1`
-- `logs.servers.development.host1.syslog`
-- `logs.servers.application_foo.critical`
-
-From a consumer/queue perspective, routing keys also support two types wildcards - `#` and `*`.
-
-- `*` (asterisk) matches any single word.
-- `#` (hash) matches any number of words and behaves like a traditional wildcard.
-
-Using the above examples, if you wanted to bind to an exchange and see messages
-for just production, you would use the routing key `logs.servers.production.*`.
-If you wanted to see messages for host1, regardless of environment you could
-use `logs.servers.%.host1.#`.
-
-Wildcards can be a bit confusing but a good general rule to follow is to use
-`*` in places where you need wildcards for a known element.  Use `#` when you
-need to match any remaining placeholders. Note that wildcards in routing keys
-only make sense on the consumer/queue binding, not in the publishing/exchange
-side.
-
-We'll get into some of that neat stuff below. For now, it's enough to
-understand the general idea behind routing keys.
-
-# Exchange types
-
-There are three primary types of exchanges that you'll see.
-
-## Direct
-
-A direct exchange is one that is probably most familiar to people. Message
-comes in and, assuming there is a queue bound, the message is picked up.  You
-can have multiple queues bound to the same direct exchange. The best way to
-understand this pattern is pool of workers (queues) that read from a direct
-exchange to get units of work. Only one consumer will see a given message in a
-direct exchange.
-
-You can set routing keys on messages published to a direct exchange. This
-allows you do have workers that do different tasks read from the same global
-pool of messages yet consume only the ones they know how to handle.
-
-The RabbitMQ concepts guide (linked below) does a good job of describing this
-visually
-[here](http://www.rabbitmq.com/img/tutorials/intro/exchange-direct.png)
-
-## Fanout
-
-Fanouts are another type of exchange. Unlike direct exchanges, every queue
-bound to a fanout exchange will see the same messages.  This is best described
-as a PUB/SUB pattern. This is helpful when you need broadcast messages to
-multiple interested parties.
-
-Fanout exchanges do NOT support routing keys. All bound queues see all
-messages.
-
-## Topic
-
-Topic exchanges are special type of fanout exchange. Fanout exchanges don't
-support routing keys. Topic exchanges do support them.  Just like a fanout
-exchange, all bound queues see all messages with the additional filter of the
-routing key.
-
-# RabbitMQ in logstash
-
-As stated earlier, in Logstash, Outputs publish to Exchanges. Inputs read from
-Queues that are bound to Exchanges.  Logstash uses the `bunny` RabbitMQ library for
-interaction with a broker. Logstash endeavors to expose as much of the
-configuration for both exchanges and queues.  There are many different tunables
-that you might be concerned with setting - including things like message
-durability or persistence of declared queues/exchanges.  See the relevant input
-and output documentation for RabbitMQ for a full list of tunables.
-
-# Sample configurations, tips, tricks and gotchas
-
-There are several examples in the logstash source directory of RabbitMQ usage,
-however a few general rules might help eliminate any issues.
-
-## Check your bindings
-
-If logstash is publishing the messages and logstash is consuming the messages,
-the `exchange` value for the input should match the `name` in the output.
-
-sender agent
-
-    input { stdin { type = "test" } }
-    output {
-      rabbitmq {
-        exchange => "test_exchange"
-        host => "my_rabbitmq_server"
-        exchange_type => "fanout"
-      }
-    }
-
-receiver agent
-
-    input {
-      rabbitmq {
-        queue => "test_queue"
-        host => "my_rabbitmq_server"
-        exchange => "test_exchange" # This matches the exchange declared above
-      }
-    }
-    output { stdout { debug => true }}
-
-## Message persistence
-
-By default, logstash will attempt to ensure that you don't lose any messages.
-This is reflected in the RabbitMQ default settings as well.  However there are
-cases where you might not want this. A good example is where RabbitMQ is not your
-primary method of shipping.
-
-In the following example, we use RabbitMQ as a sniffing interface. Our primary
-destination is the embedded ElasticSearch instance. We have a secondary RabbitMQ
-output that we use for duplicating messages. However we disable persistence and
-durability on this interface so that messages don't pile up waiting for
-delivery. We only use RabbitMQ when we want to watch messages in realtime.
-Additionally, we're going to leverage routing keys so that we can optionally
-filter incoming messages to subsets of hosts. The exercise of getting messages
-to this logstash agent are left up to the user.
-
-    input { 
-      # some input definition here
-    }
-
-    output {
-      elasticsearch { embedded => true }
-      rabbitmq {
-        exchange => "logtail"
-        host => "my_rabbitmq_server"
-        exchange_type => "topic" # We use topic here to enable pub/sub with routing keys
-        key => "logs.%{host}"
-        durable => false # If rabbitmq restarts, the exchange disappears.
-        auto_delete => true # If logstash disconnects, the exchange goes away
-        persistent => false # Messages are not persisted to disk
-      }
-    }
-
-Now if you want to stream logs in realtime, you can use the programming
-language of your choice to bind a queue to the `logtail` exchange.  If you do
-not specify a routing key, you will see every message that comes in to
-logstash. However, you can specify a routing key like `logs.apache1` and see
-only messages from host `apache1`.
-
-Note that any logstash variable is valid in the key definition. This allows you
-to create really complex routing key hierarchies for advanced filtering.
-
-Note that RabbitMQ has specific rules about durability and persistence matching
-on both the queue and exchange. You should read the RabbitMQ documentation to
-make sure you don't crash your RabbitMQ server with messages awaiting someone
-to pick them up.
diff --git a/docs/tutorials/media/frontend-response-codes.png b/docs/tutorials/media/frontend-response-codes.png
deleted file mode 100644
index e5b0ed47ee9..00000000000
Binary files a/docs/tutorials/media/frontend-response-codes.png and /dev/null differ
diff --git a/docs/tutorials/metrics-from-logs.md b/docs/tutorials/metrics-from-logs.md
deleted file mode 100644
index a044fef0fb9..00000000000
--- a/docs/tutorials/metrics-from-logs.md
+++ /dev/null
@@ -1,84 +0,0 @@
----
-title: Metrics from Logs - logstash
-layout: content_right
----
-# Pull metrics from logs
-
-Logs are more than just text. How many customers signed up today? How many HTTP
-errors happened this week? When was your last puppet run?
-
-Apache logs give you the http response code and bytes sent - that's useful in a
-graph. Metrics occur in logs so frequently there are piles of tools available to
-help process them.
-
-Logstash can help (and even replace some tools you might already be using).
-
-## Example: Replacing Etsy's Logster
-
-[Etsy](https://github.com/etsy) has some excellent open source tools. One of
-them, [logster](https://github.com/etsy/logster), is meant to help you pull
-metrics from logs and ship them to [graphite](http://graphite.wikidot.com/) so
-you can make pretty graphs of those metrics.
-
-One sample logster parser is one that pulls http response codes out of your
-apache logs: [SampleLogster.py](https://github.com/etsy/logster/blob/master/logster/parsers/SampleLogster.py)
-
-The above code is roughly 50 lines of python and only solves one specific
-problem in only apache logs: count http response codes by major number (1xx,
-2xx, 3xx, etc). To be completely fair, you could shrink the code required for
-a Logster parser, but size is not strictly the point, here.
-
-## Keep it simple
-
-Logstash can do more than the above, simpler, and without much coding skill:
-
-    input {
-      file { 
-        path => "/var/log/apache/access.log" 
-        type => "apache-access"
-      }
-    }
-
-    filter {
-      grok { 
-        type => "apache-access"
-        pattern => "%{COMBINEDAPACHELOG}" 
-      }
-    }
-
-    output {
-      statsd { 
-        # Count one hit every event by response
-        increment => "apache.response.%{response}" 
-      }
-    }
-
-The above uses grok to parse fields out of apache logs and using the statsd
-output to increment counters based on the response code. Of course, now that we
-are parsing apache logs fully, we can trivially add additional metrics:
-
-    output {
-      statsd {
-        # Count one hit every event by response
-        increment => "apache.response.%{response}"
-
-        # Use the 'bytes' field from the apache log as the count value.
-        count => [ "apache.bytes", "%{bytes}" ]
-      }
-    }
-
-Now adding additional metrics is just one more line in your logstash config
-file. BTW, the 'statsd' output writes to another Etsy tool,
-[statsd](https://github.com/etsy/statsd), which helps build counters/latency
-data and ship it to graphite for graphing.
-
-Using the logstash config above and a bunch of apache access requests, you might end up
-with a graph that looks like this:
-
-![apache response codes graphed with graphite, fed data with logstash](media/frontend-response-codes.png)
-
-The point made above is not "logstash is better than Logster" - the point is
-that logstash is a general-purpose log management and pipelining tool and that
-while you can centralize logs with logstash, you can read, modify, and write
-them to and from just about anywhere.
-
diff --git a/docs/tutorials/zeromq.md b/docs/tutorials/zeromq.md
deleted file mode 100644
index 796ec0ea3ae..00000000000
--- a/docs/tutorials/zeromq.md
+++ /dev/null
@@ -1,118 +0,0 @@
----
-title: ZeroMQ - logstash
-layout: content_right
----
-
-*ZeroMQ support in Logstash is currently in an experimental phase. As such, parts of this document are subject to change.*
-
-# ZeroMQ
-Simply put ZeroMQ (0mq) is a socket on steroids. This makes it a perfect compliment to Logstash - a pipe on steroids.
-
-ZeroMQ allows you to easily create sockets of various types for moving data around. These sockets are refered to in ZeroMQ by the behavior of each side of the socket pair:
-
-* PUSH/PULL
-* REQ/REP
-* PUB/SUB
-* ROUTER/DEALER
-
-There is also a `PAIR` socket type as well.
-
-Additionally, the socket type is independent of the connection method. A PUB/SUB socket pair could have the SUB side of the socket be a listener and the PUB side a connecting client. This makes it very easy to fit ZeroMQ into various firewalled architectures.
-
-Note that this is not a full-fledged tutorial on ZeroMQ. It is a tutorial on how Logstash uses ZeroMQ.
-
-# ZeroMQ and logstash
-In the spirit of ZeroMQ, Logstash takes these socket type pairs and uses them to create topologies with some very simply rules that make usage very easy to understand:
-
-* The receiving end of a socket pair is always a logstash input
-* The sending end of a socket pair is always a logstash output
-* By default, inputs `bind`/listen and outputs `connect`
-* Logstash refers to the socket pairs as topologies and mirrors the naming scheme from ZeroMQ
-* By default, ZeroMQ inputs listen on all interfaces on port 2120, ZeroMQ outputs connect to `localhost` on port 2120
-
-The currently understood Logstash topologies for ZeroMQ inputs and outputs are:
-
-* `pushpull`
-* `pubsub`
-* `pair`
-
-We have found from various discussions that these three topologies will cover most of user's needs. We hope to expose the full span of ZeroMQ socket types as time goes on.
-
-By keeping the options simple, this allows you to get started VERY easily with what are normally complex message flows. No more confusion over `exchanges` and `queues` and `brokers`. If you need to add fanout capability to your flow, you can simply use the following configs:
-
-* _node agent lives at 192.168.1.2_
-* _indexer agent lives at 192.168.1.1_
-
-    # Node agent config
-    input { stdin { type => "test-stdin-input" } }
-    output { zeromq { topology => "pubsub" address => "tcp://192.168.1.1.:2120" } }
-
-    # Indexer agent config
-    input { zeromq { topology => "pubsub" } }
-    output { stdout { debug => true }}
-
-If for some reason you need connections to initiate from the indexer because of firewall rules:
-
-    # Node agent config - now listening on all interfaces port 2120
-    input { stdin { type => "test-stdin-input" } }
-    output { zeromq { topology => "pubsub" address => "tcp://*.:2120" mode => "server" } }
-
-    # Indexer agent config
-    input { zeromq { topology => "pubsub" address => "tcp://192.168.1.2" mode => "client" } }
-    output { stdout { debug => true }}
-
-As stated above, by default `inputs` always start as listeners and `outputs` always start as initiators. Please don't confuse what happens once the socket is connect with the direction of the connection. ZeroMQ separates connection from topology. In the second case of the above configs, once the two sockets are connected, regardless of who initiated the connection, the message flow itself is absolute. The indexer is reading events from the node.
-
-# Which topology to use
-The choice of topology can be broken down very easily based on need
-
-## one to one
-Use `pair` topology. On the output side, specify the ipaddress and port of the input side.
-
-## broadcast
-Use `pubsub`
-If you need to broadcast ALL messages to multiple hosts that each need to see all events, use `pubsub`. Note that all events are broadcast to all subscribers. When using `pubsub` you might also want to investigate the `topic` configuration option which allows subscribers to see only a subset of messages.
-
-## Filter workers
-Use `pushpull`
-In `pushpull`, ZeroMQ automatically load balances to all connected peers. This means that no peer sees the same message as any other peer.
-
-# What's with the address format?
-ZeroMQ supports multiple types of transports:
-
-* inproc:// (unsupported by logstash due to threading)
-* tcp:// (exactly what it sounds like)
-* ipc:// (probably useless in logstash)
-* pgm:// and epgm:// (a multicast format - only usable with PUB and SUB socket types)
-
-For pretty much all cases, you'll be using `tcp://` transports with Logstash.
-
-## Topic - applies to `pubsub`
-This opt mimics the routing keys functionality in AMQP. Imagine you have a network of receivers but only a subset of the messages need to be seen by a subset of the hosts. You can use this option as a routing key to facilite that:
-
-    # This output is a PUB
-    output {
-    zeromq { topology => "pubsub" topic => "logs.production.%{host}" }
-    }
-
-    # This input is a SUB
-    # I only care about db1 logs
-    input { zeromq { type => "db1logs" address => "tcp://<ipaddress>:2120" topic => "logs.production.db1"}}
-
-One thing important to note about 0mq PUBSUB and topics is that all filtering is done on the subscriber side. The subscriber will get ALL messages but discard any that don't match the topic.
-
-Also important to note is that 0mq doesn't do topic in the same sense as an AMQP broker might. When a SUB socket gets a message, it compares the first bytes of the message against the topic. However, this isn't always flexible depending on the format of your message. The common practice then, is to send a 0mq multipart message and make the first part the topic. The next parts become the actual message body.
-
-This is approach is how logstash handles this. When using PUBSUB, Logstash will send a multipart message where the first part is the name of the topic and the second part is the event. This is important to know if you are sending to a SUB input from sources other than Logstash.
-
-# sockopts
-Sockopts is not you choosing between blue or black socks. ZeroMQ supports setting various flags or options on sockets. In the interest of minimizing configuration syntax, these are _hidden_ behind a logstash configuration element called `sockopts`. You probably won't need to tune these for most cases. If you do need to tune them, you'll probably set the following:
-
-## ZMQ::HWM - sets the high water mark
-The high water mark is the maximum number of messages a given socket pair can have in its internal queue. Use this to throttle essentially.
-
-## ZMQ::SWAP_SIZE
-TODO
-
-## ZMQ::IDENTITY
-TODO
diff --git a/lib/bootstrap/bundler.rb b/lib/bootstrap/bundler.rb
index 23944d347fe..1a7bb057219 100644
--- a/lib/bootstrap/bundler.rb
+++ b/lib/bootstrap/bundler.rb
@@ -27,6 +27,16 @@ def set_key(key, value, hash, file)
           value
         end
       end
+
+      # This patch makes rubygems fetch directly from the remote servers
+      # the dependencies he need and might not have downloaded in a local
+      # repository. This basically enabled the offline feature to work as
+      # we remove the gems from the vendor directory before packacing.
+      ::Bundler::Source::Rubygems.module_exec do
+        def cached_gem(spec)
+          cached_built_in_gem(spec)
+        end
+      end
     end
 
     def setup!(options = {})
@@ -56,11 +66,19 @@ def setup!(options = {})
 
     # execute bundle install and capture any $stdout output. any raised exception in the process will be trapped
     # and returned. logs errors to $stdout.
-    # @param options [Hash] invoke options with default values, :max_tries => 10, :clean => false, :install => false, :update => false
-    # @param   options[:update] must be either false or a String or an Array of String
+    # @param [Hash] options invoke options with default values, :max_tries => 10, :clean => false, :install => false, :update => false
+    # @option options [Boolean] :max_tries The number of times bundler is going to try the installation before failing (default: 10)
+    # @option options [Boolean] :clean It cleans the unused gems (default: false)
+    # @option options [Boolean] :install Run the installation of a set of gems defined in a Gemfile (default: false)
+    # @option options [Boolean, String, Array] :update Update the current environment, must be either false or a String or an Array of String (default: false)
+    # @option options [Boolean] :local Do not attempt to fetch gems remotely and use the gem cache instead (default: false)
+    # @option options [Boolean] :package Locks and then caches all dependencies to be reused later on (default: false)
+    # @option options [Boolean] :all It packages dependencies defined with :git or :path (default: false)
+    # @option options [Array] :without  Exclude gems that are part of the specified named group (default: [:development])
     # @return [String, Exception] the installation captured output and any raised exception or nil if none
     def invoke!(options = {})
-      options = {:max_tries => 10, :clean => false, :install => false, :update => false, :without => [:development]}.merge(options)
+      options = {:max_tries => 10, :clean => false, :install => false, :update => false, :local => false,
+                 :all => false, :package => false, :without => [:development]}.merge(options)
       options[:without] = Array(options[:without])
       options[:update] = Array(options[:update]) if options[:update]
 
@@ -80,20 +98,28 @@ def invoke!(options = {})
       LogStash::Bundler.patch!
 
       # force Rubygems sources to our Gemfile sources
-      ::Gem.sources = options[:rubygems_source] if options[:rubygems_source]
+      ::Gem.sources = ::Gem::SourceList.from(options[:rubygems_source]) if options[:rubygems_source]
 
       ::Bundler.settings[:path] = LogStash::Environment::BUNDLE_DIR
       ::Bundler.settings[:gemfile] = LogStash::Environment::GEMFILE_PATH
       ::Bundler.settings[:without] = options[:without].join(":")
 
-      try = 0
+      if !debug?
+        # Will deal with transient network errors
+        execute_bundler_with_retry(options)
+      else
+        options[:verbose] = true
+        execute_bundler(options)
+      end
+    end
 
+    def execute_bundler_with_retry(options)
+      try = 0
       # capture_stdout also traps any raised exception and pass them back as the function return [output, exception]
       output, exception = capture_stdout do
         loop do
           begin
-            ::Bundler.reset!
-            ::Bundler::CLI.start(bundler_arguments(options))
+            execute_bundler(options)
             break
           rescue ::Bundler::VersionConflict => e
             $stderr.puts("Plugin version conflict, aborting")
@@ -115,12 +141,20 @@ def invoke!(options = {})
           end
         end
       end
-
       raise exception if exception
 
       return output
     end
 
+    def execute_bundler(options)
+      ::Bundler.reset!
+      ::Bundler::CLI.start(bundler_arguments(options))
+    end
+
+    def debug?
+      ENV["DEBUG"]
+    end
+
     # build Bundler::CLI.start arguments array from the given options hash
     # @param option [Hash] the invoke! options hash
     # @return [Array<String>] Bundler::CLI.start string arguments array
@@ -130,13 +164,23 @@ def bundler_arguments(options = {})
       if options[:install]
         arguments << "install"
         arguments << "--clean" if options[:clean]
+        if options[:local]
+          arguments << "--local"
+          arguments << "--no-prune" # From bundler docs: Don't remove stale gems from the cache.
+        end
       elsif options[:update]
         arguments << "update"
         arguments << options[:update]
+        arguments << "--local" if options[:local]
       elsif options[:clean]
         arguments << "clean"
+      elsif options[:package]
+        arguments << "package"
+        arguments << "--all" if options[:all]
       end
 
+      arguments << "--verbose" if options[:verbose]
+
       arguments.flatten
     end
 
diff --git a/lib/bootstrap/environment.rb b/lib/bootstrap/environment.rb
index 9f3e59f5b08..50f2211160a 100644
--- a/lib/bootstrap/environment.rb
+++ b/lib/bootstrap/environment.rb
@@ -16,6 +16,7 @@ module Environment
     BUNDLE_DIR = ::File.join(LOGSTASH_HOME, "vendor", "bundle")
     GEMFILE_PATH = ::File.join(LOGSTASH_HOME, "Gemfile")
     LOCAL_GEM_PATH = ::File.join(LOGSTASH_HOME, 'vendor', 'local_gems')
+    CACHE_PATH = File.join(LOGSTASH_HOME, "vendor", "cache")
 
     # @return [String] the ruby version string bundler uses to craft its gem path
     def gem_ruby_version
@@ -32,9 +33,26 @@ def ruby_engine
       RUBY_ENGINE
     end
 
+    def windows?
+      ::Gem.win_platform?
+    end
+
+    def jruby?
+      @jruby ||= !!(RUBY_PLATFORM == "java")
+    end
+
     def logstash_gem_home
       ::File.join(BUNDLE_DIR, ruby_engine, gem_ruby_version)
     end
+
+    def vendor_path(path)
+      return ::File.join(LOGSTASH_HOME, "vendor", path)
+    end
+
+    def pattern_path(path)
+      return ::File.join(LOGSTASH_HOME, "patterns", path)
+    end
+
   end
 end
 
diff --git a/lib/bootstrap/rspec.rb b/lib/bootstrap/rspec.rb
index f32057c7f9c..4c95f3bfc76 100755
--- a/lib/bootstrap/rspec.rb
+++ b/lib/bootstrap/rspec.rb
@@ -7,6 +7,7 @@
 
 require "rspec/core"
 require "rspec"
+require 'ci/reporter/rake/rspec_loader'
 
 status = RSpec::Core::Runner.run(ARGV.empty? ? ["spec"] : ARGV).to_i
 exit status if status != 0
diff --git a/lib/bootstrap/util/compress.rb b/lib/bootstrap/util/compress.rb
new file mode 100644
index 00000000000..79bd38461b4
--- /dev/null
+++ b/lib/bootstrap/util/compress.rb
@@ -0,0 +1,122 @@
+# encoding: utf-8
+require "zip"
+require "rubygems/package"
+require "fileutils"
+require "zlib"
+require "stud/temporary"
+
+module LogStash
+
+  class CompressError < StandardError; end
+
+  module Util
+    module Zip
+
+      extend self
+
+      # Extract a zip file into a destination directory.
+      # @param source [String] The location of the file to extract
+      # @param target [String] Where you do want the file to be extracted
+      # @raise [IOError] If the target directory already exist
+      def extract(source, target)
+        raise CompressError.new("Directory #{target} exist") if ::File.exist?(target)
+        ::Zip::File.open(source) do |zip_file|
+          zip_file.each do |file|
+            path = ::File.join(target, file.name)
+            FileUtils.mkdir_p(::File.dirname(path))
+            zip_file.extract(file, path)
+          end
+        end
+      end
+
+      # Compress a directory into a zip file
+      # @param dir [String] The directory to be compressed
+      # @param target [String] Destination to save the generated file
+      # @raise [IOError] If the target file already exist
+      def compress(dir, target)
+        raise CompressError.new("File #{target} exist") if ::File.exist?(target)
+        ::Zip::File.open(target, ::Zip::File::CREATE) do |zipfile|
+          Dir.glob("#{dir}/**/*").each do |file|
+            path_in_zip = file.gsub("#{dir}/","")
+            zipfile.add(path_in_zip, file)
+          end
+        end
+      end
+    end
+
+    module Tar
+
+      extend self
+
+      # Extract a tar.gz file into a destination directory.
+      # @param source [String] The location of the file to extract
+      # @param target [String] Where you do want the file to be extracted
+      # @raise [IOError] If the target directory already exist
+      def extract(file, target)
+        raise CompressError.new("Directory #{target} exist") if ::File.exist?(target)
+
+        FileUtils.mkdir(target)
+        Zlib::GzipReader.open(file) do |gzip_file|
+          ::Gem::Package::TarReader.new(gzip_file) do |tar_file|
+            tar_file.each do |entry|
+              target_path = ::File.join(target, entry.full_name)
+
+              if entry.directory?
+                FileUtils.mkdir_p(target_path)
+              else # is a file to be extracted
+                ::File.open(target_path, "wb") { |f| f.write(entry.read) }
+              end
+            end
+          end
+        end
+      end
+
+      # Compress a directory into a tar.gz file
+      # @param dir [String] The directory to be compressed
+      # @param target [String] Destination to save the generated file
+      # @raise [IOError] If the target file already exist
+      def compress(dir, target)
+        raise CompressError.new("File #{target} exist") if ::File.exist?(target)
+
+        Stud::Temporary.file do |tar_file|
+          ::Gem::Package::TarWriter.new(tar_file) do |tar|
+            Dir.glob("#{dir}/**/*").each do |file|
+              name = file.gsub("#{dir}/","")
+              stats = ::File.stat(file)
+              mode  = stats.mode
+
+              if ::File.directory?(file)
+                tar.mkdir(name, mode)
+              else # is a file to be added
+                tar.add_file(name,mode) do |out|
+                  File.open(file, "rb") do |fd|
+                    chunk = nil
+                    size = 0
+                    size += out.write(chunk) while chunk = fd.read(16384)
+                    if stats.size != size
+                      raise "Failure to write the entire file (#{path}) to the tarball. Expected to write #{stats.size} bytes; actually write #{size}"
+                    end
+                  end
+                end
+              end
+            end
+          end
+
+          tar_file.rewind
+          gzip(target, tar_file)
+        end
+      end
+
+      # Compress a file using gzip
+      # @param path [String] The location to be compressed
+      # @param target_file [String] Destination of the generated file
+      def gzip(path, target_file)
+        ::File.open(path, "wb") do |file|
+          gzip_file = ::Zlib::GzipWriter.new(file)
+          gzip_file.write(target_file.read)
+          gzip_file.close
+        end
+      end
+    end
+  end
+end
diff --git a/lib/logstash-event.rb b/lib/logstash-event.rb
deleted file mode 100644
index 0f44322944b..00000000000
--- a/lib/logstash-event.rb
+++ /dev/null
@@ -1,2 +0,0 @@
-# encoding: utf-8
-require "logstash/event"
diff --git a/lib/logstash/agent.rb b/lib/logstash/agent.rb
deleted file mode 100644
index bb6734f8ad1..00000000000
--- a/lib/logstash/agent.rb
+++ /dev/null
@@ -1,339 +0,0 @@
-# encoding: utf-8
-require "clamp" # gem 'clamp'
-require "logstash/environment"
-require "logstash/errors"
-require "logstash/config/cpu_core_strategy"
-require "uri"
-require "net/http"
-LogStash::Environment.load_locale!
-
-class LogStash::Agent < Clamp::Command
-  DEFAULT_INPUT = "input { stdin { type => stdin } }"
-  DEFAULT_OUTPUT = "output { stdout { codec => rubydebug } }"
-
-  option ["-f", "--config"], "CONFIG_PATH",
-    I18n.t("logstash.agent.flag.config"),
-    :attribute_name => :config_path
-
-  option "-e", "CONFIG_STRING",
-    I18n.t("logstash.agent.flag.config-string",
-           :default_input => DEFAULT_INPUT, :default_output => DEFAULT_OUTPUT),
-    :default => "", :attribute_name => :config_string
-
-  option ["-w", "--filterworkers"], "COUNT",
-    I18n.t("logstash.agent.flag.filterworkers"),
-    :attribute_name => :filter_workers,
-    :default => LogStash::Config::CpuCoreStrategy.fifty_percent, &:to_i
-
-  option ["-l", "--log"], "FILE",
-    I18n.t("logstash.agent.flag.log"),
-    :attribute_name => :log_file
-
-  # Old support for the '-v' flag'
-  option "-v", :flag,
-    I18n.t("logstash.agent.flag.verbosity"),
-    :attribute_name => :verbosity, :multivalued => true
-
-  option "--quiet", :flag, I18n.t("logstash.agent.flag.quiet")
-  option "--verbose", :flag, I18n.t("logstash.agent.flag.verbose")
-  option "--debug", :flag, I18n.t("logstash.agent.flag.debug")
-
-  option ["-V", "--version"], :flag,
-    I18n.t("logstash.agent.flag.version")
-
- option ["-p", "--pluginpath"] , "PATH",
-   I18n.t("logstash.agent.flag.pluginpath"),
-   :multivalued => true,
-   :attribute_name => :plugin_paths
-
-  option ["-t", "--configtest"], :flag,
-    I18n.t("logstash.agent.flag.configtest"),
-    :attribute_name => :config_test
-
-  # Emit a warning message.
-  def warn(message)
-    # For now, all warnings are fatal.
-    raise LogStash::ConfigurationError, message
-  end # def warn
-
-  # Emit a failure message and abort.
-  def fail(message)
-    raise LogStash::ConfigurationError, message
-  end # def fail
-
-  def report(message)
-    # Print to stdout just in case we're logging to a file
-    puts message
-    @logger.log(message) if log_file
-  end
-
-  # Run the agent. This method is invoked after clamp parses the
-  # flags given to this program.
-  def execute
-    require "logstash/pipeline"
-    require "cabin" # gem 'cabin'
-    require "logstash/plugin"
-    @logger = Cabin::Channel.get(LogStash)
-
-    if version?
-      show_version
-      return 0
-    end
-
-    # temporarily send logs to stdout as well if a --log is specified
-    # and stdout appears to be a tty
-    show_startup_errors = log_file && STDOUT.tty?
-
-    if show_startup_errors
-      stdout_logs = @logger.subscribe(STDOUT)
-    end
-    configure
-
-    # You must specify a config_string or config_path
-    if @config_string.nil? && @config_path.nil?
-      fail(help + "\n" + I18n.t("logstash.agent.missing-configuration"))
-    end
-
-    @config_string = @config_string.to_s
-
-    if @config_path
-      # Append the config string.
-      # This allows users to provide both -f and -e flags. The combination
-      # is rare, but useful for debugging.
-      @config_string = @config_string + load_config(@config_path)
-    else
-      # include a default stdin input if no inputs given
-      if @config_string !~ /input *{/
-        @config_string += DEFAULT_INPUT
-      end
-      # include a default stdout output if no outputs given
-      if @config_string !~ /output *{/
-        @config_string += DEFAULT_OUTPUT
-      end
-    end
-
-    begin
-      pipeline = LogStash::Pipeline.new(@config_string)
-    rescue LoadError => e
-      fail("Configuration problem.")
-    end
-
-    # Make SIGINT shutdown the pipeline.
-    sigint_id = Stud::trap("INT") do
-
-      if @interrupted_once
-        @logger.fatal(I18n.t("logstash.agent.forced_sigint"))
-        exit
-      else
-        @logger.warn(I18n.t("logstash.agent.sigint"))
-        Thread.new(@logger) {|logger| sleep 5; logger.warn(I18n.t("logstash.agent.slow_shutdown")) }
-        @interrupted_once = true
-        shutdown(pipeline)
-      end
-    end
-
-    # Make SIGTERM shutdown the pipeline.
-    sigterm_id = Stud::trap("TERM") do
-      @logger.warn(I18n.t("logstash.agent.sigterm"))
-      shutdown(pipeline)
-    end
-
-    Stud::trap("HUP") do
-      @logger.info(I18n.t("logstash.agent.sighup"))
-      configure_logging(log_file)
-    end
-
-    pipeline.configure("filter-workers", filter_workers)
-
-    # Stop now if we are only asking for a config test.
-    if config_test?
-      report "Configuration OK"
-      return
-    end
-
-    @logger.unsubscribe(stdout_logs) if show_startup_errors
-
-    # TODO(sissel): Get pipeline completion status.
-    pipeline.run
-    return 0
-  rescue LogStash::ConfigurationError => e
-    @logger.unsubscribe(stdout_logs) if show_startup_errors
-    report I18n.t("logstash.agent.error", :error => e)
-    if !config_test?
-      report I18n.t("logstash.agent.configtest-flag-information")
-    end
-    return 1
-  rescue => e
-    @logger.unsubscribe(stdout_logs) if show_startup_errors
-    report I18n.t("oops", :error => e)
-    report e.backtrace if @logger.debug? || $DEBUGLIST.include?("stacktrace")
-    return 1
-  ensure
-    @log_fd.close if @log_fd
-    Stud::untrap("INT", sigint_id) unless sigint_id.nil?
-    Stud::untrap("TERM", sigterm_id) unless sigterm_id.nil?
-  end # def execute
-
-  def shutdown(pipeline)
-    pipeline.shutdown do
-      InflightEventsReporter.logger = @logger
-      InflightEventsReporter.start(pipeline.input_to_filter, pipeline.filter_to_output, pipeline.outputs)
-    end
-  end
-
-  def show_version
-    show_version_logstash
-
-    if [:info, :debug].include?(verbosity?) || debug? || verbose?
-      show_version_ruby
-      show_version_java if LogStash::Environment.jruby?
-      show_gems if [:debug].include?(verbosity?) || debug?
-    end
-  end # def show_version
-
-  def show_version_logstash
-    require "logstash/version"
-    puts "logstash #{LOGSTASH_VERSION}"
-  end # def show_version_logstash
-
-  def show_version_ruby
-    puts RUBY_DESCRIPTION
-  end # def show_version_ruby
-
-  def show_version_java
-    properties = java.lang.System.getProperties
-    puts "java #{properties["java.version"]} (#{properties["java.vendor"]})"
-    puts "jvm #{properties["java.vm.name"]} / #{properties["java.vm.version"]}"
-  end # def show_version_java
-
-  def show_gems
-    require "rubygems"
-    Gem::Specification.each do |spec|
-      puts "gem #{spec.name} #{spec.version}"
-    end
-  end # def show_gems
-
-  # Do any start-time configuration.
-  #
-  # Log file stuff, plugin path checking, etc.
-  def configure
-    configure_logging(log_file)
-    configure_plugin_paths(plugin_paths)
-  end # def configure
-
-  # Point logging at a specific path.
-  def configure_logging(path)
-    # Set with the -v (or -vv...) flag
-    if quiet?
-      @logger.level = :error
-    elsif verbose?
-      @logger.level = :info
-    elsif debug?
-      @logger.level = :debug
-    else
-      # Old support for the -v and -vv stuff.
-      if verbosity? && verbosity?.any?
-        # this is an array with length of how many times the flag is given
-        if verbosity?.length == 1
-          @logger.warn("The -v flag is deprecated and will be removed in a future release. You should use --verbose instead.")
-          @logger.level = :info
-        else
-          @logger.warn("The -vv flag is deprecated and will be removed in a future release. You should use --debug instead.")
-          @logger.level = :debug
-        end
-      else
-        @logger.level = :warn
-      end
-    end
-
-    if log_file
-      # TODO(sissel): Implement file output/rotation in Cabin.
-      # TODO(sissel): Catch exceptions, report sane errors.
-      begin
-        @log_fd.close if @log_fd
-        @log_fd = File.new(path, "a")
-      rescue => e
-        fail(I18n.t("logstash.agent.configuration.log_file_failed",
-                    :path => path, :error => e))
-      end
-
-      puts "Sending logstash logs to #{path}."
-      @logger.unsubscribe(@logger_subscription) if @logger_subscription
-      @logger_subscription = @logger.subscribe(@log_fd)
-    else
-      @logger.subscribe(STDOUT)
-    end
-
-    # TODO(sissel): redirect stdout/stderr to the log as well
-    # http://jira.codehaus.org/browse/JRUBY-7003
-  end # def configure_logging
-
-  # add the given paths for ungemified/bare plugins lookups
-  # @param paths [String, Array<String>] plugins path string or list of path strings to add
-  def configure_plugin_paths(paths)
-    Array(paths).each do |path|
-      fail(I18n.t("logstash.agent.configuration.plugin_path_missing", :path => path)) unless File.directory?(path)
-      LogStash::Environment.add_plugin_path(path)
-    end
-  end
-
-  def load_config(path)
-    begin
-      uri = URI.parse(path)
-
-      case uri.scheme
-      when nil then
-        local_config(path)
-      when /http/ then
-        fetch_config(uri)
-      when "file" then
-        local_config(uri.path)
-      else
-        fail(I18n.t("logstash.agent.configuration.scheme-not-supported", :path => path))
-      end
-    rescue URI::InvalidURIError
-      # fallback for windows.
-      # if the parsing of the file failed we assume we can reach it locally.
-      # some relative path on windows arent parsed correctly (.\logstash.conf)
-      local_config(path)
-    end
-  end
-
-  def local_config(path)
-    path = File.expand_path(path)
-    path = File.join(path, "*") if File.directory?(path)
-
-    if Dir.glob(path).length == 0
-      fail(I18n.t("logstash.agent.configuration.file-not-found", :path => path))
-    end
-
-    config = ""
-    encoding_issue_files = []
-    Dir.glob(path).sort.each do |file|
-      next unless File.file?(file)
-      if file.match(/~$/)
-        @logger.debug("NOT reading config file because it is a temp file", :file => file)
-        next
-      end
-      @logger.debug("Reading config file", :file => file)
-      cfg = File.read(file)
-      if !cfg.ascii_only? && !cfg.valid_encoding?
-        encoding_issue_files << file
-      end
-      config << cfg + "\n"
-    end
-    if (encoding_issue_files.any?)
-      fail("The following config files contains non-ascii characters but are not UTF-8 encoded #{encoding_issue_files}")
-    end
-    return config
-  end # def load_config
-
-  def fetch_config(uri)
-    begin
-      Net::HTTP.get(uri) + "\n"
-    rescue Exception => e
-      fail(I18n.t("logstash.agent.configuration.fetch-failed", :path => uri.to_s, :message => e.message))
-    end
-  end
-
-end # class LogStash::Agent
diff --git a/lib/logstash/patches/bundler.rb b/lib/logstash/patches/bundler.rb
deleted file mode 100644
index 25d93a09148..00000000000
--- a/lib/logstash/patches/bundler.rb
+++ /dev/null
@@ -1,36 +0,0 @@
-# encoding: utf-8
-# Bundler monkey patches
-module ::Bundler
-  # Patch bundler to write a .lock file specific to the version of ruby.
-  # This keeps MRI/JRuby/RBX from conflicting over the Gemfile.lock updates
-  module SharedHelpers
-    def default_lockfile
-      ruby = "#{LogStash::Environment.ruby_engine}-#{LogStash::Environment.ruby_abi_version}"
-      Pathname.new("#{default_gemfile}.#{ruby}.lock")
-    end
-  end
-
-  # Patch to prevent Bundler to save a .bundle/config file in the root 
-  # of the application
-  class Settings
-    def set_key(key, value, hash, file)
-      key = key_for(key)
-
-      unless hash[key] == value
-        hash[key] = value
-        hash.delete(key) if value.nil?
-      end
-
-      value
-    end
-  end
-
-  # Add the Bundler.reset! method which has been added in master but is not in 1.7.9.
-  class << self
-    unless self.method_defined?("reset!")
-      def reset!
-        @definition = nil
-      end
-    end
-  end
-end
diff --git a/lib/logstash/pipeline.rb b/lib/logstash/pipeline.rb
deleted file mode 100644
index b3081073704..00000000000
--- a/lib/logstash/pipeline.rb
+++ /dev/null
@@ -1,312 +0,0 @@
-# encoding: utf-8
-require "thread"
-require "stud/interval"
-require "concurrent"
-require "logstash/namespace"
-require "logstash/errors"
-require "logstash/event"
-require "logstash/config/file"
-require "logstash/filters/base"
-require "logstash/inputs/base"
-require "logstash/outputs/base"
-require "logstash/util/reporter"
-require "logstash/config/cpu_core_strategy"
-require "logstash/util/defaults_printer"
-
-class LogStash::Pipeline
-  attr_reader :inputs, :filters, :outputs, :input_to_filter, :filter_to_output
-
-  def initialize(configstr)
-    @logger = Cabin::Channel.get(LogStash)
-
-    @inputs = nil
-    @filters = nil
-    @outputs = nil
-
-    grammar = LogStashConfigParser.new
-    @config = grammar.parse(configstr)
-    if @config.nil?
-      raise LogStash::ConfigurationError, grammar.failure_reason
-    end
-    # This will compile the config to ruby and evaluate the resulting code.
-    # The code will initialize all the plugins and define the
-    # filter and output methods.
-    code = @config.compile
-    # The config code is hard to represent as a log message...
-    # So just print it.
-    @logger.debug? && @logger.debug("Compiled pipeline code:\n#{code}")
-    begin
-      eval(code)
-    rescue => e
-      raise
-    end
-
-    @input_to_filter = SizedQueue.new(20)
-    # if no filters, pipe inputs directly to outputs
-    @filter_to_output = filters? ? SizedQueue.new(20) : @input_to_filter
-
-    @settings = {
-      "filter-workers" => LogStash::Config::CpuCoreStrategy.fifty_percent
-    }
-
-    # @ready requires thread safety since it is typically polled from outside the pipeline thread
-    @ready = Concurrent::AtomicBoolean.new(false)
-    @input_threads = []
-  end # def initialize
-
-  def ready?
-    @ready.value
-  end
-
-  def configure(setting, value)
-    if setting == "filter-workers" && value > 1
-      # Abort if we have any filters that aren't threadsafe
-      plugins = @filters.select { |f| !f.threadsafe? }.collect { |f| f.class.config_name }
-      if !plugins.size.zero?
-        raise LogStash::ConfigurationError, "Cannot use more than 1 filter worker because the following plugins don't work with more than one worker: #{plugins.join(", ")}"
-      end
-    end
-    @settings[setting] = value
-  end
-
-  def filters?
-    return @filters.any?
-  end
-
-  def run
-    @logger.terminal(LogStash::Util::DefaultsPrinter.print(@settings))
-
-    begin
-      start_inputs
-      start_filters if filters?
-      start_outputs
-    ensure
-      # it is important to garantee @ready to be true after the startup sequence has been completed
-      # to potentially unblock the shutdown method which may be waiting on @ready to proceed
-      @ready.make_true
-    end
-
-    @logger.info("Pipeline started")
-    @logger.terminal("Logstash startup completed")
-
-    wait_inputs
-
-    if filters?
-      shutdown_filters
-      wait_filters
-      flush_filters_to_output!(:final => true)
-    end
-
-    shutdown_outputs
-    wait_outputs
-
-    @logger.info("Pipeline shutdown complete.")
-    @logger.terminal("Logstash shutdown completed")
-
-    # exit code
-    return 0
-  end # def run
-
-  def wait_inputs
-    @input_threads.each(&:join)
-  end
-
-  def shutdown_filters
-    @flusher_thread.kill
-    @input_to_filter.push(LogStash::SHUTDOWN)
-  end
-
-  def wait_filters
-    @filter_threads.each(&:join) if @filter_threads
-  end
-
-  def shutdown_outputs
-    # nothing, filters will do this
-    @filter_to_output.push(LogStash::SHUTDOWN)
-  end
-
-  def wait_outputs
-    # Wait for the outputs to stop
-    @output_threads.each(&:join)
-  end
-
-  def start_inputs
-    moreinputs = []
-    @inputs.each do |input|
-      if input.threadable && input.threads > 1
-        (input.threads - 1).times do |i|
-          moreinputs << input.clone
-        end
-      end
-    end
-    @inputs += moreinputs
-
-    @inputs.each do |input|
-      input.register
-      start_input(input)
-    end
-  end
-
-  def start_filters
-    @filters.each(&:register)
-    to_start = @settings["filter-workers"]
-    @filter_threads = to_start.times.collect do
-      Thread.new { filterworker }
-    end
-    actually_started = @filter_threads.select(&:alive?).size
-    msg = "Worker threads expected: #{to_start}, worker threads started: #{actually_started}"
-    if actually_started < to_start
-      @logger.warn(msg)
-    else
-      @logger.info(msg)
-    end
-    @flusher_thread = Thread.new { Stud.interval(5) { @input_to_filter.push(LogStash::FLUSH) } }
-  end
-
-  def start_outputs
-    @outputs.each(&:register)
-    @output_threads = [
-      Thread.new { outputworker }
-    ]
-  end
-
-  def start_input(plugin)
-    @input_threads << Thread.new { inputworker(plugin) }
-  end
-
-  def inputworker(plugin)
-    LogStash::Util::set_thread_name("<#{plugin.class.config_name}")
-    begin
-      plugin.run(@input_to_filter)
-    rescue => e
-      # if plugin is stopping, ignore uncatched exceptions and exit worker
-      if plugin.stop?
-        @logger.debug("Input plugin raised exception during shutdown, ignoring it.",
-                      :plugin => plugin.class.config_name, :exception => e,
-                      :backtrace => e.backtrace)
-        return
-      end
-
-      # otherwise, report error and restart
-      if @logger.debug?
-        @logger.error(I18n.t("logstash.pipeline.worker-error-debug",
-                             :plugin => plugin.inspect, :error => e.to_s,
-                             :exception => e.class,
-                             :stacktrace => e.backtrace.join("\n")))
-      else
-        @logger.error(I18n.t("logstash.pipeline.worker-error",
-                             :plugin => plugin.inspect, :error => e))
-      end
-
-      # Assuming the failure that caused this exception is transient,
-      # let's sleep for a bit and execute #run again
-      sleep(1)
-      retry
-    ensure
-      plugin.do_close
-    end
-  end # def inputworker
-
-  def filterworker
-    LogStash::Util.set_thread_name("|worker")
-    begin
-      while true
-        event = @input_to_filter.pop
-
-        case event
-        when LogStash::Event
-          # filter_func returns all filtered events, including cancelled ones
-          filter_func(event).each { |e| @filter_to_output.push(e) unless e.cancelled? }
-        when LogStash::FlushEvent
-          # handle filter flushing here so that non threadsafe filters (thus only running one filterworker)
-          # don't have to deal with thread safety implementing the flush method
-          flush_filters_to_output!
-        when LogStash::ShutdownEvent
-          # pass it down to any other filterworker and stop this worker
-          @input_to_filter.push(event)
-          break
-        end
-      end
-    rescue Exception => e
-      # Plugins authors should manage their own exceptions in the plugin code
-      # but if an exception is raised up to the worker thread they are considered
-      # fatal and logstash will not recover from this situation.
-      #
-      # Users need to check their configuration or see if there is a bug in the
-      # plugin.
-      @logger.error("Exception in filterworker, the pipeline stopped processing new events, please check your filter configuration and restart Logstash.",
-                    "exception" => e, "backtrace" => e.backtrace)
-      raise
-    ensure
-      @filters.each(&:do_close)
-    end
-  end # def filterworker
-
-  def outputworker
-    LogStash::Util.set_thread_name(">output")
-    @outputs.each(&:worker_setup)
-
-    while true
-      event = @filter_to_output.pop
-      break if event == LogStash::SHUTDOWN
-      output_func(event)
-    end
-  ensure
-    @outputs.each do |output|
-      output.worker_plugins.each(&:do_close)
-    end
-  end # def outputworker
-
-  # initiate the pipeline shutdown sequence
-  # this method is intended to be called from outside the pipeline thread
-  # @param before_stop [Proc] code block called before performing stop operation on input plugins
-  def shutdown(&before_stop)
-    # shutdown can only start once the pipeline has completed its startup.
-    # avoid potential race conditoon between the startup sequence and this
-    # shutdown method which can be called from another thread at any time
-    sleep(0.1) while !ready?
-
-    # TODO: should we also check against calling shutdown multiple times concurently?
-
-    before_stop.call if block_given?
-
-    @inputs.each(&:do_stop)
-  end # def shutdown
-
-  def plugin(plugin_type, name, *args)
-    args << {} if args.empty?
-    klass = LogStash::Plugin.lookup(plugin_type, name)
-    return klass.new(*args)
-  end
-
-  # for backward compatibility in devutils for the rspec helpers, this method is not used
-  # in the pipeline anymore.
-  def filter(event, &block)
-    # filter_func returns all filtered events, including cancelled ones
-    filter_func(event).each { |e| block.call(e) }
-  end
-
-  # perform filters flush and yeild flushed event to the passed block
-  # @param options [Hash]
-  # @option options [Boolean] :final => true to signal a final shutdown flush
-  def flush_filters(options = {}, &block)
-    flushers = options[:final] ? @shutdown_flushers : @periodic_flushers
-
-    flushers.each do |flusher|
-      flusher.call(options, &block)
-    end
-  end
-
-  # perform filters flush into the output queue
-  # @param options [Hash]
-  # @option options [Boolean] :final => true to signal a final shutdown flush
-  def flush_filters_to_output!(options = {})
-    flush_filters(options) do |event|
-      unless event.cancelled?
-        @logger.debug? and @logger.debug("Pushing flushed events", :event => event)
-        @filter_to_output.push(event)
-      end
-    end
-  end # flush_filters_to_output!
-
-end # class Pipeline
diff --git a/lib/logstash/sized_queue.rb b/lib/logstash/sized_queue.rb
deleted file mode 100644
index d96e27aba02..00000000000
--- a/lib/logstash/sized_queue.rb
+++ /dev/null
@@ -1,8 +0,0 @@
-# encoding: utf-8
-require "logstash/namespace"
-require "logstash/logging"
-
-require "thread" # for SizedQueue
-class LogStash::SizedQueue < SizedQueue
-  # TODO(sissel): Soon will implement push/pop stats, etc
-end
diff --git a/lib/logstash/util/reporter.rb b/lib/logstash/util/reporter.rb
deleted file mode 100644
index 4d983a25e3e..00000000000
--- a/lib/logstash/util/reporter.rb
+++ /dev/null
@@ -1,28 +0,0 @@
-# encoding: utf-8
-class InflightEventsReporter
-  def self.logger=(logger)
-    @logger = logger
-  end
-
-  def self.start(input_to_filter, filter_to_output, outputs)
-    Thread.new do
-      loop do
-        sleep 5
-        report(input_to_filter, filter_to_output, outputs)
-      end
-    end
-  end
-
-  def self.report(input_to_filter, filter_to_output, outputs)
-    report = {
-      "input_to_filter" => input_to_filter.size,
-      "filter_to_output" => filter_to_output.size,
-      "outputs" => []
-    }
-    outputs.each do |output|
-      next unless output.worker_queue && output.worker_queue.size > 0
-      report["outputs"] << [output.inspect, output.worker_queue.size]
-    end
-    @logger.warn ["INFLIGHT_EVENTS_REPORT", Time.now.iso8601, report]
-  end
-end
diff --git a/lib/logstash/util/worker_threads_default_printer.rb b/lib/logstash/util/worker_threads_default_printer.rb
deleted file mode 100644
index c8b086635cb..00000000000
--- a/lib/logstash/util/worker_threads_default_printer.rb
+++ /dev/null
@@ -1,17 +0,0 @@
-# encoding: utf-8
-require "logstash/namespace"
-require "logstash/util"
-
-# This class exists to format the settings for default worker threads
-module LogStash module Util class WorkerThreadsDefaultPrinter
-
-  def initialize(settings)
-    @setting = settings.fetch('filter-workers', 1)
-  end
-
-  def visit(collector)
-    collector.push "Filter workers: #{@setting}"
-  end
-
-end end end
-
diff --git a/lib/pluginmanager/gemfile.rb b/lib/pluginmanager/gemfile.rb
index b1648187764..68bf88334f1 100644
--- a/lib/pluginmanager/gemfile.rb
+++ b/lib/pluginmanager/gemfile.rb
@@ -41,13 +41,20 @@ def add(name, *requirements)
       @gemset.add_gem(Gem.parse(name, *requirements))
     end
 
-    # update existing or add new
+    # update existing or add new and merge passed options with current gem options if it exists
     # @param name [String] gem name
     # @param *requirements params following name use the same notation as the Gemfile gem DSL statement
     def update(name, *requirements)
       @gemset.update_gem(Gem.parse(name, *requirements))
     end
 
+    # overwrite existing or add new
+    # @param name [String] gem name
+    # @param *requirements params following name use the same notation as the Gemfile gem DSL statement
+    def overwrite(name, *requirements)
+      @gemset.overwrite_gem(Gem.parse(name, *requirements))
+    end
+
     # @return [Gem] removed gem or nil if not found
     def remove(name)
       @gemset.remove_gem(name)
@@ -99,6 +106,19 @@ def add_gem(_gem)
 
     # update existing or add new
     def update_gem(_gem)
+      if old = find_gem(_gem.name)
+        # always overwrite requirements if specified
+        old.requirements = _gem.requirements unless no_constrains?(_gem.requirements)
+        # but merge options
+        old.options = old.options.merge(_gem.options)
+      else
+        @gems << _gem
+        @gems_by_name[_gem.name.downcase] = _gem
+      end
+    end
+
+    # update existing or add new
+    def overwrite_gem(_gem)
       if old = find_gem(_gem.name)
         @gems[@gems.index(old)] = _gem
       else
@@ -119,8 +139,19 @@ def remove_gem(name)
     def copy
       Marshal.load(Marshal.dump(self))
     end
+
     private
 
+    def no_constrains?(requirements)
+      return true if requirements.nil? || requirements.empty?
+
+      # check for the dummy ">= 0" version constrain or any variations thereof
+      # which is in fact a "no constrain" constrain which we should discard
+      return true if requirements.size == 1 && requirements.first.to_s.gsub(/\s+/, "") == ">=0"
+
+      false
+    end
+
     def sources_to_s
       return "" if @sources.empty?
       @sources.map{|source| "source #{source.inspect}"}.join("\n")
diff --git a/lib/pluginmanager/install.rb b/lib/pluginmanager/install.rb
index bbc486ab236..11e3ad0bbc2 100644
--- a/lib/pluginmanager/install.rb
+++ b/lib/pluginmanager/install.rb
@@ -9,7 +9,9 @@ class LogStash::PluginManager::Install < LogStash::PluginManager::Command
   parameter "[PLUGIN] ...", "plugin name(s) or file", :attribute_name => :plugins_arg
   option "--version", "VERSION", "version of the plugin to install"
   option "--[no-]verify", :flag, "verify plugin validity before installation", :default => true
+  option "--preserve", :flag, "preserve current gem options", :default => false
   option "--development", :flag, "install all development dependencies of currently installed plugins", :default => false
+  option "--local", :flag, "force local-only plugin installation. see bin/plugin package|unpack", :default => false
 
   # the install logic below support installing multiple plugins with each a version specification
   # but the argument parsing does not support it for now so currently if specifying --version only
@@ -23,7 +25,7 @@ def execute
       gems = plugins_development_gems
     else
       gems = plugins_gems
-      verify_remote!(gems) if verify?
+      verify_remote!(gems) if !local? && verify?
     end
 
     install_gems_list!(gems)
@@ -45,12 +47,20 @@ def validate_cli_options!
   # Check if the specified gems contains
   # the logstash `metadata`
   def verify_remote!(gems)
+    options = { :rubygems_source => gemfile.gemset.sources }
     gems.each do |plugin, version|
       puts("Validating #{[plugin, version].compact.join("-")}")
-      signal_error("Installation aborted, verification failed for #{plugin} #{version}") unless LogStash::PluginManager.logstash_plugin?(plugin, version)
+      next if validate_plugin(plugin, version, options)
+      signal_error("Installation aborted, verification failed for #{plugin} #{version}")
     end
   end
 
+  def validate_plugin(plugin, version, options)
+    LogStash::PluginManager.logstash_plugin?(plugin, version, options)
+  rescue SocketError
+    false
+  end
+
   def plugins_development_gems
     # Get currently defined gems and their dev dependencies
     specs = []
@@ -81,7 +91,15 @@ def install_gems_list!(install_list)
 
     # Add plugins/gems to the current gemfile
     puts("Installing" + (install_list.empty? ? "..." : " " + install_list.collect(&:first).join(", ")))
-    install_list.each { |plugin, version, options| gemfile.update(plugin, version, options) }
+    install_list.each do |plugin, version, options|
+      if preserve?
+        plugin_gem = gemfile.find(plugin)
+        puts("Preserving Gemfile gem options for plugin #{plugin}") if plugin_gem && !plugin_gem.options.empty?
+        gemfile.update(plugin, version, options)
+      else
+        gemfile.overwrite(plugin, version, options)
+      end
+    end
 
     # Sync gemfiles changes to disk to make them available to the `bundler install`'s API
     gemfile.save
@@ -89,6 +107,7 @@ def install_gems_list!(install_list)
     bundler_options = {:install => true}
     bundler_options[:without] = [] if development?
     bundler_options[:rubygems_source] = gemfile.gemset.sources
+    bundler_options[:local] = true if local?
 
     output = LogStash::Bundler.invoke!(bundler_options)
 
diff --git a/lib/pluginmanager/main.rb b/lib/pluginmanager/main.rb
index a2004e4d6be..15841b107e3 100644
--- a/lib/pluginmanager/main.rb
+++ b/lib/pluginmanager/main.rb
@@ -18,6 +18,8 @@ module PluginManager
 require "pluginmanager/uninstall"
 require "pluginmanager/list"
 require "pluginmanager/update"
+require "pluginmanager/pack"
+require "pluginmanager/unpack"
 
 module LogStash
   module PluginManager
@@ -27,6 +29,8 @@ class Main < Clamp::Command
       subcommand "install", "Install a plugin", LogStash::PluginManager::Install
       subcommand "uninstall", "Uninstall a plugin", LogStash::PluginManager::Uninstall
       subcommand "update", "Update a plugin", LogStash::PluginManager::Update
+      subcommand "pack", "Package currently installed plugins", LogStash::PluginManager::Pack
+      subcommand "unpack", "Unpack packaged plugins", LogStash::PluginManager::Unpack
       subcommand "list", "List all installed plugins", LogStash::PluginManager::List
     end
   end
@@ -34,7 +38,7 @@ class Main < Clamp::Command
 
 if $0 == __FILE__
   begin
-    LogStash::PluginManager::Main.run("bin/plugin", ARGV)
+    LogStash::PluginManager::Main.run("bin/logstash-plugin", ARGV)
   rescue LogStash::PluginManager::Error => e
     $stderr.puts(e.message)
     exit(1)
diff --git a/lib/pluginmanager/pack.rb b/lib/pluginmanager/pack.rb
new file mode 100644
index 00000000000..18b46e18511
--- /dev/null
+++ b/lib/pluginmanager/pack.rb
@@ -0,0 +1,43 @@
+# encoding: utf-8
+require_relative "pack_command"
+
+class LogStash::PluginManager::Pack < LogStash::PluginManager::PackCommand
+  option "--tgz", :flag, "compress package as a tar.gz file", :default => !LogStash::Environment.windows?
+  option "--zip", :flag, "compress package as a zip file", :default => LogStash::Environment.windows?
+  option "--[no-]clean", :flag, "clean up the generated dump of plugins", :default => true
+  option "--overwrite", :flag, "Overwrite a previously generated package file", :default => false
+
+  def execute
+    puts("Packaging plugins for offline usage")
+
+    validate_target_file
+    LogStash::Bundler.invoke!({:package => true, :all => true})
+    archive_manager.compress(LogStash::Environment::CACHE_PATH, target_file)
+    FileUtils.rm_rf(LogStash::Environment::CACHE_PATH) if clean?
+
+    puts("Generated at #{target_file}")
+  end
+
+  private
+
+  def delete_target_file?
+    return true if overwrite?
+    puts("File #{target_file} exist, do you want to overwrite it? (Y/N)")
+    ( "y" == STDIN.gets.strip.downcase ? true : false)
+  end
+
+  def validate_target_file
+    if File.exist?(target_file)
+      if  delete_target_file?
+        File.delete(target_file)
+      else
+        signal_error("Package creation cancelled, a previously generated package exist at location: #{target_file}, move this file to safe place and run the command again")
+      end
+    end
+  end
+
+  def target_file
+    target_file = File.join(LogStash::Environment::LOGSTASH_HOME, "plugins_package")
+    "#{target_file}#{file_extension}"
+  end
+end
diff --git a/lib/pluginmanager/pack_command.rb b/lib/pluginmanager/pack_command.rb
new file mode 100644
index 00000000000..2409b212f97
--- /dev/null
+++ b/lib/pluginmanager/pack_command.rb
@@ -0,0 +1,13 @@
+# encoding: utf-8
+require "bootstrap/util/compress"
+require "fileutils"
+
+class LogStash::PluginManager::PackCommand < LogStash::PluginManager::Command
+  def archive_manager
+    zip? ? LogStash::Util::Zip : LogStash::Util::Tar
+  end
+
+  def file_extension
+    zip? ? ".zip" : ".tar.gz"
+  end
+end
diff --git a/lib/pluginmanager/unpack.rb b/lib/pluginmanager/unpack.rb
new file mode 100644
index 00000000000..4e7da6fb94e
--- /dev/null
+++ b/lib/pluginmanager/unpack.rb
@@ -0,0 +1,35 @@
+# encoding: utf-8
+require_relative "pack_command"
+
+class LogStash::PluginManager::Unpack < LogStash::PluginManager::PackCommand
+  option "--tgz", :flag, "unpack a packaged tar.gz file", :default => !LogStash::Environment.windows?
+  option "--zip", :flag, "unpack a packaged  zip file", :default => LogStash::Environment.windows?
+
+  parameter "file", "the package file name", :attribute_name => :package_file, :required => true
+
+  def execute
+    puts("Unpacking #{package_file}")
+
+    FileUtils.rm_rf(LogStash::Environment::CACHE_PATH)
+    validate_cache_location
+    archive_manager.extract(package_file, LogStash::Environment::CACHE_PATH)
+    puts("Unpacked at #{LogStash::Environment::CACHE_PATH}")
+    puts("The unpacked plugins can now be installed in local-only mode using bin/plugin install --local [plugin name]")
+  end
+
+  private
+
+  def validate_cache_location
+    cache_location = LogStash::Environment::CACHE_PATH
+    if File.exist?(cache_location)
+      puts("Directory #{cache_location} is going to be overwritten, do you want to continue? (Y/N)")
+      override = ( "y" == STDIN.gets.strip.downcase ? true : false)
+      if override
+        FileUtils.rm_rf(cache_location)
+      else
+        puts("Unpack cancelled: file #{cache_location} already exists, please delete or move it")
+        exit
+      end
+    end
+  end
+end
diff --git a/lib/pluginmanager/update.rb b/lib/pluginmanager/update.rb
index 3fc8b6b12a7..64c9767ea57 100644
--- a/lib/pluginmanager/update.rb
+++ b/lib/pluginmanager/update.rb
@@ -8,6 +8,8 @@ class LogStash::PluginManager::Update < LogStash::PluginManager::Command
   REJECTED_OPTIONS = [:path, :git, :github]
 
   parameter "[PLUGIN] ...", "Plugin name(s) to upgrade to latest version", :attribute_name => :plugins_arg
+  option "--[no-]verify", :flag, "verify plugin validity before installation", :default => true
+  option "--local", :flag, "force local-only plugin update. see bin/plugin package|unpack", :default => false
 
   def execute
     local_gems = gemfile.locally_installed_gems
@@ -21,7 +23,6 @@ def execute
 
       warn_local_gems(plugins_with_path)
     end
-
     update_gems!
   end
 
@@ -41,10 +42,12 @@ def update_gems!
     # remove any version constrain from the Gemfile so the plugin(s) can be updated to latest version
     # calling update without requiremend will remove any previous requirements
     plugins = plugins_to_update(previous_gem_specs_map)
+    # Skipping the major version validation when using a local cache as we can have situations
+    # without internet connection.
     filtered_plugins = plugins.map { |plugin| gemfile.find(plugin) }
       .compact
       .reject { |plugin| REJECTED_OPTIONS.any? { |key| plugin.options.has_key?(key) } }
-      .select { |plugin| validates_version(plugin.name) }
+      .select { |plugin| local? || (verify? ? validates_version(plugin.name) : true) }
       .each   { |plugin| gemfile.update(plugin.name) }
 
     # force a disk sync before running bundler
@@ -54,9 +57,10 @@ def update_gems!
 
     # any errors will be logged to $stderr by invoke!
     # Bundler cannot update and clean gems in one operation so we have to call the CLI twice.
-    output = LogStash::Bundler.invoke!(:update => plugins)
+    options = {:update => plugins, :rubygems_source => gemfile.gemset.sources}
+    options[:local] = true if local?
+    output = LogStash::Bundler.invoke!(options)
     output = LogStash::Bundler.invoke!(:clean => true)
-
     display_updated_plugins(previous_gem_specs_map)
   rescue => exception
     gemfile.restore!
diff --git a/lib/pluginmanager/util.rb b/lib/pluginmanager/util.rb
index 78bb7d38926..149ff6256d4 100644
--- a/lib/pluginmanager/util.rb
+++ b/lib/pluginmanager/util.rb
@@ -2,12 +2,18 @@
 require "rubygems/package"
 
 module LogStash::PluginManager
+
+  class ValidationError < StandardError; end
+
   # check for valid logstash plugin gem name & version or .gem file, logs errors to $stdout
   # uses Rubygems API and will remotely validated agains the current Gem.sources
   # @param plugin [String] plugin name or .gem file path
   # @param version [String] gem version requirement string
+  # @param [Hash] options the options used to setup external components
+  # @option options [Array<String>] :rubygems_source Gem sources to lookup for the verification
   # @return [Boolean] true if valid logstash plugin gem name & version or a .gem file
-  def self.logstash_plugin?(plugin, version = nil)
+  def self.logstash_plugin?(plugin, version = nil, options={})
+
     if plugin_file?(plugin)
       begin
         return logstash_plugin_gem_spec?(plugin_file_spec(plugin))
@@ -18,6 +24,7 @@ def self.logstash_plugin?(plugin, version = nil)
       end
     else
       dep = Gem::Dependency.new(plugin, version || Gem::Requirement.default)
+      Gem.sources = Gem::SourceList.from(options[:rubygems_source]) if options[:rubygems_source]
       specs, errors = Gem::SpecFetcher.fetcher.spec_for_dependency(dep)
 
       # dump errors
@@ -46,6 +53,7 @@ def self.fetch_latest_version_info(plugin, options={})
     require "gems"
     exclude_prereleases =  options.fetch(:pre, false)
     versions = Gems.versions(plugin)
+    raise ValidationError.new("Something went wrong with the validation. You can skip the validation with the --no-verify option") if !versions.is_a?(Array) || versions.empty?
     versions = versions.select { |version| !version["prerelease"] } if !exclude_prereleases
     versions.first
   end
diff --git a/logstash-core-event-java/.gitignore b/logstash-core-event-java/.gitignore
new file mode 100644
index 00000000000..a453cb95034
--- /dev/null
+++ b/logstash-core-event-java/.gitignore
@@ -0,0 +1,9 @@
+*.class
+
+# build dirs
+build
+.gradle
+
+# Intellij
+.idea
+*.iml
diff --git a/logstash-core-event-java/README.md b/logstash-core-event-java/README.md
new file mode 100644
index 00000000000..7b12d19f135
--- /dev/null
+++ b/logstash-core-event-java/README.md
@@ -0,0 +1,63 @@
+# logstash-core-event-java
+
+## dev install
+
+1- build code with
+
+```
+$ cd logstash-core-event-java
+$ gradle build
+```
+
+A bunch of warning are expected, it should end with:
+
+```
+BUILD SUCCESSFUL
+```
+
+2- update root logstash `Gemfile` to use this gem with:
+
+```
+# gem "logstash-core-event", "x.y.z", :path => "./logstash-core-event"
+gem "logstash-core-event-java", "x.y.z", :path => "./logstash-core-event-java"
+```
+
+3- update `logstash-core/logstash-core.gemspec` with:
+
+```
+# gem.add_runtime_dependency "logstash-core-event", "x.y.z"
+gem.add_runtime_dependency "logstash-core-event-java", "x.y.z"
+```
+
+4- and install:
+
+```
+$ bin/bundle
+```
+
+- install core plugins for tests
+
+```
+$ rake test:install-core
+```
+
+## specs
+
+```
+$ bin/rspec spec
+$ bin/rspec logstash-core/spec
+$ bin/rspec logstash-core-event/spec
+$ bin/rspec logstash-core-event-java/spec
+```
+
+or
+
+```
+$ rake test:core
+```
+
+also
+
+```
+$ rake test:plugins
+```
\ No newline at end of file
diff --git a/logstash-core-event-java/build.gradle b/logstash-core-event-java/build.gradle
new file mode 100644
index 00000000000..b2a4a55ec43
--- /dev/null
+++ b/logstash-core-event-java/build.gradle
@@ -0,0 +1,107 @@
+buildscript {
+    repositories {
+        mavenLocal()
+        mavenCentral()
+        jcenter()
+    }
+    dependencies {
+        classpath 'net.saliman:gradle-cobertura-plugin:2.2.8'
+    }
+}
+
+repositories {
+    mavenLocal()
+    mavenCentral()
+    jcenter()
+}
+
+gradle.projectsEvaluated {
+    tasks.withType(JavaCompile) {
+        options.compilerArgs << "-Xlint:deprecation"
+//        options.compilerArgs << "-Xlint:unchecked" << "-Xlint:deprecation"
+    }
+}
+
+apply plugin: 'java'
+apply plugin: 'idea'
+
+group = 'org.logstash'
+
+project.sourceCompatibility = 1.7
+
+task sourcesJar(type: Jar, dependsOn: classes) {
+    from sourceSets.main.allSource
+    classifier 'sources'
+    extension 'jar'
+}
+
+task javadocJar(type: Jar, dependsOn: javadoc) {
+    from javadoc.destinationDir
+    classifier 'javadoc'
+    extension 'jar'
+}
+
+task copyGemjar(type: Copy, dependsOn: sourcesJar) {
+    from project.jar
+    into project.file('lib/logstash-core-event-java/')
+}
+
+task cleanGemjar {
+    delete fileTree(project.file('lib/logstash-core-event-java/')) {
+        include '*.jar'
+    }
+}
+
+clean.dependsOn(cleanGemjar)
+jar.finalizedBy(copyGemjar)
+
+configurations.create('sources')
+configurations.create('javadoc')
+configurations.archives {
+    extendsFrom configurations.sources
+    extendsFrom configurations.javadoc
+}
+
+artifacts {
+    sources(sourcesJar) {
+        // Weird Gradle quirk where type will be used for the extension, but only for sources
+        type 'jar'
+    }
+
+    javadoc(javadocJar) {
+        type 'javadoc'
+    }
+}
+
+configurations {
+    provided
+}
+
+project.sourceSets {
+    main.compileClasspath += project.configurations.provided
+    main.runtimeClasspath += project.configurations.provided
+    test.compileClasspath += project.configurations.provided
+    test.runtimeClasspath += project.configurations.provided
+}
+project.javadoc.classpath += project.configurations.provided
+
+idea {
+    module {
+        scopes.PROVIDED.plus += [project.configurations.provided]
+    }
+}
+
+dependencies {
+    compile 'com.fasterxml.jackson.core:jackson-core:2.7.1'
+    compile 'com.fasterxml.jackson.core:jackson-databind:2.7.1-1'
+    provided 'org.jruby:jruby-core:1.7.22'
+    testCompile 'junit:junit:4.12'
+    testCompile 'net.javacrumbs.json-unit:json-unit:1.9.0'
+}
+
+// See http://www.gradle.org/docs/current/userguide/gradle_wrapper.html
+task wrapper(type: Wrapper) {
+    description = 'Install Gradle wrapper'
+    gradleVersion = '2.8'
+}
+
diff --git a/logstash-core-event-java/gradle.properties b/logstash-core-event-java/gradle.properties
new file mode 100644
index 00000000000..b5cdaba6a69
--- /dev/null
+++ b/logstash-core-event-java/gradle.properties
@@ -0,0 +1 @@
+VERSION=0.0.1-SNAPSHOT
diff --git a/logstash-core-event-java/gradle/wrapper/gradle-wrapper.jar b/logstash-core-event-java/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000000..13372aef5e2
Binary files /dev/null and b/logstash-core-event-java/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/logstash-core-event-java/gradle/wrapper/gradle-wrapper.properties b/logstash-core-event-java/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000000..25611753f15
--- /dev/null
+++ b/logstash-core-event-java/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Fri Jan 22 14:29:02 EST 2016
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.8-bin.zip
diff --git a/logstash-core-event-java/gradlew b/logstash-core-event-java/gradlew
new file mode 100755
index 00000000000..9d82f789151
--- /dev/null
+++ b/logstash-core-event-java/gradlew
@@ -0,0 +1,160 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/logstash-core-event-java/gradlew.bat b/logstash-core-event-java/gradlew.bat
new file mode 100644
index 00000000000..aec99730b4e
--- /dev/null
+++ b/logstash-core-event-java/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/logstash-core-event-java/lib/logstash-core-event-java.rb b/logstash-core-event-java/lib/logstash-core-event-java.rb
new file mode 100644
index 00000000000..29b487aa192
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash-core-event-java.rb
@@ -0,0 +1 @@
+require "logstash-core-event-java/logstash-core-event-java"
\ No newline at end of file
diff --git a/logstash-core-event-java/lib/logstash-core-event-java/logstash-core-event-java.rb b/logstash-core-event-java/lib/logstash-core-event-java/logstash-core-event-java.rb
new file mode 100644
index 00000000000..cf86fec4d16
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash-core-event-java/logstash-core-event-java.rb
@@ -0,0 +1,28 @@
+# encoding: utf-8
+
+require "java"
+
+module LogStash
+end
+
+require "logstash-core-event-java_jars"
+
+# local dev setup
+classes_dir = File.expand_path("../../../build/classes/main", __FILE__)
+
+if File.directory?(classes_dir)
+  # if in local dev setup, add target to classpath
+  $CLASSPATH << classes_dir unless $CLASSPATH.include?(classes_dir)
+else
+  # otherwise use included jar
+  begin
+    require "logstash-core-event-java/logstash-core-event-java.jar"
+  rescue Exception => e
+    raise("Error loading logstash-core-event-java/logstash-core-event-java.jar file, cause: #{e.message}")
+  end
+end
+
+require "jruby_event_ext"
+require "jruby_timestamp_ext"
+require "logstash/event"
+require "logstash/timestamp"
\ No newline at end of file
diff --git a/logstash-core-event-java/lib/logstash-core-event-java/version.rb b/logstash-core-event-java/lib/logstash-core-event-java/version.rb
new file mode 100644
index 00000000000..6c297b7c2fd
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash-core-event-java/version.rb
@@ -0,0 +1,8 @@
+# encoding: utf-8
+
+# The version of logstash core event java gem.
+#
+# Note to authors: this should not include dashes because 'gem' barfs if
+# you include a dash in the version string.
+
+LOGSTASH_CORE_EVENT_JAVA_VERSION = "3.0.0.dev"
diff --git a/logstash-core-event-java/lib/logstash-core-event-java_jars.rb b/logstash-core-event-java/lib/logstash-core-event-java_jars.rb
new file mode 100644
index 00000000000..143d7a3e068
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash-core-event-java_jars.rb
@@ -0,0 +1,6 @@
+# this is a generated file, to avoid over-writing it just delete this comment
+require 'jar_dependencies'
+
+require_jar( 'com.fasterxml.jackson.core', 'jackson-core', '2.7.1' )
+require_jar( 'com.fasterxml.jackson.core', 'jackson-annotations', '2.7.0' )
+require_jar( 'com.fasterxml.jackson.core', 'jackson-databind', '2.7.1-1' )
diff --git a/logstash-core-event-java/lib/logstash-core-event.rb b/logstash-core-event-java/lib/logstash-core-event.rb
new file mode 100644
index 00000000000..29b487aa192
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash-core-event.rb
@@ -0,0 +1 @@
+require "logstash-core-event-java/logstash-core-event-java"
\ No newline at end of file
diff --git a/logstash-core-event-java/lib/logstash/event.rb b/logstash-core-event-java/lib/logstash/event.rb
new file mode 100644
index 00000000000..8f6a1908901
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash/event.rb
@@ -0,0 +1,26 @@
+# encoding: utf-8
+
+require "logstash/namespace"
+require "logstash/json"
+require "logstash/string_interpolation"
+require "cabin"
+
+# transcient pipeline events for normal in-flow signaling as opposed to
+# flow altering exceptions. for now having base classes is adequate and
+# in the future it might be necessary to refactor using like a BaseEvent
+# class to have a common interface for all pileline events to support
+# eventual queueing persistence for example, TBD.
+class LogStash::ShutdownEvent; end
+class LogStash::FlushEvent; end
+
+module LogStash
+  FLUSH = LogStash::FlushEvent.new
+
+  # LogStash::SHUTDOWN is used by plugins
+  SHUTDOWN = LogStash::ShutdownEvent.new
+end
+
+# for backward compatibility, require "logstash/event" is used a lots of places so let's bootstrap the
+# Java code loading from here.
+# TODO: (colin) I think we should mass replace require "logstash/event" with require "logstash-core-event"
+require "logstash-core-event"
\ No newline at end of file
diff --git a/logstash-core-event-java/lib/logstash/string_interpolation.rb b/logstash-core-event-java/lib/logstash/string_interpolation.rb
new file mode 100644
index 00000000000..7baf091f304
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash/string_interpolation.rb
@@ -0,0 +1,18 @@
+# encoding: utf-8
+
+module LogStash
+  module StringInterpolation
+    extend self
+
+    # clear the global compiled templates cache
+    def clear_cache
+      Java::ComLogstash::StringInterpolation.get_instance.clear_cache;
+    end
+
+    # @return [Fixnum] the compiled templates cache size
+    def cache_size
+      Java::ComLogstash::StringInterpolation.get_instance.cache_size;
+    end
+  end
+end
+
diff --git a/logstash-core-event-java/lib/logstash/timestamp.rb b/logstash-core-event-java/lib/logstash/timestamp.rb
new file mode 100644
index 00000000000..0a4661a2d19
--- /dev/null
+++ b/logstash-core-event-java/lib/logstash/timestamp.rb
@@ -0,0 +1,28 @@
+# encoding: utf-8
+
+require "logstash/namespace"
+require "logstash-core-event"
+
+module LogStash
+  class TimestampParserError < StandardError; end
+
+  class Timestamp
+    include Comparable
+
+    # TODO (colin) implement in Java
+    def <=>(other)
+      self.time <=> other.time
+    end
+
+    # TODO (colin) implement in Java
+    def +(other)
+      self.time + other
+    end
+
+    # TODO (colin) implement in Java
+    def -(value)
+      self.time - (value.is_a?(Timestamp) ? value.time : value)
+    end
+
+  end
+end
diff --git a/logstash-core-event-java/logstash-core-event-java.gemspec b/logstash-core-event-java/logstash-core-event-java.gemspec
new file mode 100644
index 00000000000..10beff6d4bb
--- /dev/null
+++ b/logstash-core-event-java/logstash-core-event-java.gemspec
@@ -0,0 +1,31 @@
+# -*- encoding: utf-8 -*-
+lib = File.expand_path('../lib', __FILE__)
+$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
+require 'logstash-core-event-java/version'
+
+Gem::Specification.new do |gem|
+  gem.authors       = ["Jordan Sissel", "Pete Fritchman", "Elasticsearch"]
+  gem.email         = ["jls@semicomplete.com", "petef@databits.net", "info@elasticsearch.com"]
+  gem.description   = %q{The core event component of logstash, the scalable log and event management tool}
+  gem.summary       = %q{logstash-core-event-java - The core event component of logstash}
+  gem.homepage      = "http://www.elastic.co/guide/en/logstash/current/index.html"
+  gem.license       = "Apache License (2.0)"
+
+  gem.files         = Dir.glob(["logstash-core-event-java.gemspec", "lib/**/*.jar", "lib/**/*.rb", "spec/**/*.rb"])
+  gem.test_files    = gem.files.grep(%r{^(test|spec|features)/})
+  gem.name          = "logstash-core-event-java"
+  gem.require_paths = ["lib"]
+  gem.version       = LOGSTASH_CORE_EVENT_JAVA_VERSION
+
+  gem.platform = "java"
+
+  gem.add_runtime_dependency "jar-dependencies"
+
+  # as of Feb 3rd 2016, the ruby-maven gem is resolved to version 3.3.3 and that version
+  # has an rdoc problem that causes a bundler exception. 3.3.9 is the current latest version
+  # which does not have this problem.
+  gem.add_runtime_dependency "ruby-maven", "~> 3.3.9"
+
+  gem.requirements << "jar com.fasterxml.jackson.core:jackson-core, 2.7.1"
+  gem.requirements << "jar com.fasterxml.jackson.core:jackson-databind, 2.7.1-1"
+end
diff --git a/logstash-core-event-java/settings.gradle b/logstash-core-event-java/settings.gradle
new file mode 100644
index 00000000000..3885bfa1686
--- /dev/null
+++ b/logstash-core-event-java/settings.gradle
@@ -0,0 +1,2 @@
+rootProject.name = 'logstash-core-event-java'
+
diff --git a/logstash-core-event-java/spec/event_spec.rb b/logstash-core-event-java/spec/event_spec.rb
new file mode 100644
index 00000000000..03cbffa73c6
--- /dev/null
+++ b/logstash-core-event-java/spec/event_spec.rb
@@ -0,0 +1,289 @@
+# encoding: utf-8
+
+require "spec_helper"
+require "logstash/util"
+require "logstash/event"
+require "json"
+
+TIMESTAMP = "@timestamp"
+
+describe LogStash::Event do
+  context "to_json" do
+    it "should serialize simple values" do
+      e = LogStash::Event.new({"foo" => "bar", "bar" => 1, "baz" => 1.0, TIMESTAMP => "2015-05-28T23:02:05.350Z"})
+      expect(JSON.parse(e.to_json)).to eq(JSON.parse("{\"foo\":\"bar\",\"bar\":1,\"baz\":1.0,\"@timestamp\":\"2015-05-28T23:02:05.350Z\",\"@version\":\"1\"}"))
+    end
+
+    it "should serialize deep hash values" do
+      e = LogStash::Event.new({"foo" => {"bar" => 1, "baz" => 1.0, "biz" => "boz"}, TIMESTAMP => "2015-05-28T23:02:05.350Z"})
+      expect(JSON.parse(e.to_json)).to eq(JSON.parse("{\"foo\":{\"bar\":1,\"baz\":1.0,\"biz\":\"boz\"},\"@timestamp\":\"2015-05-28T23:02:05.350Z\",\"@version\":\"1\"}"))
+    end
+
+    it "should serialize deep array values" do
+      e = LogStash::Event.new({"foo" => ["bar", 1, 1.0], TIMESTAMP => "2015-05-28T23:02:05.350Z"})
+      expect(JSON.parse(e.to_json)).to eq(JSON.parse("{\"foo\":[\"bar\",1,1.0],\"@timestamp\":\"2015-05-28T23:02:05.350Z\",\"@version\":\"1\"}"))
+    end
+
+    it "should serialize deep hash from field reference assignments" do
+      e = LogStash::Event.new({TIMESTAMP => "2015-05-28T23:02:05.350Z"})
+      e["foo"] = "bar"
+      e["bar"] = 1
+      e["baz"] = 1.0
+      e["[fancy][pants][socks]"] = "shoes"
+      expect(JSON.parse(e.to_json)).to eq(JSON.parse("{\"@timestamp\":\"2015-05-28T23:02:05.350Z\",\"@version\":\"1\",\"foo\":\"bar\",\"bar\":1,\"baz\":1.0,\"fancy\":{\"pants\":{\"socks\":\"shoes\"}}}"))
+    end
+  end
+
+  context "[]" do
+    it "should get simple values" do
+      e = LogStash::Event.new({"foo" => "bar", "bar" => 1, "baz" => 1.0, TIMESTAMP => "2015-05-28T23:02:05.350Z"})
+      expect(e["foo"]).to eq("bar")
+      expect(e["[foo]"]).to eq("bar")
+      expect(e["bar"]).to eq(1)
+      expect(e["[bar]"]).to eq(1)
+      expect(e["baz"]).to eq(1.0)
+      expect(e["[baz]"]).to eq(1.0)
+      expect(e[TIMESTAMP].to_s).to eq("2015-05-28T23:02:05.350Z")
+      expect(e["[#{TIMESTAMP}]"].to_s).to eq("2015-05-28T23:02:05.350Z")
+    end
+
+    it "should get deep hash values" do
+      e = LogStash::Event.new({"foo" => {"bar" => 1, "baz" => 1.0}})
+      expect(e["[foo][bar]"]).to eq(1)
+      expect(e["[foo][baz]"]).to eq(1.0)
+    end
+
+    it "should get deep array values" do
+      e = LogStash::Event.new({"foo" => ["bar", 1, 1.0]})
+      expect(e["[foo][0]"]).to eq("bar")
+      expect(e["[foo][1]"]).to eq(1)
+      expect(e["[foo][2]"]).to eq(1.0)
+      expect(e["[foo][3]"]).to be_nil
+    end
+  end
+
+  context "[]=" do
+    it "should set simple values" do
+      e = LogStash::Event.new()
+      expect(e["foo"] = "bar").to eq("bar")
+      expect(e["foo"]).to eq("bar")
+
+      e = LogStash::Event.new({"foo" => "test"})
+      expect(e["foo"] = "bar").to eq("bar")
+      expect(e["foo"]).to eq("bar")
+    end
+
+    it "should set deep hash values" do
+      e = LogStash::Event.new()
+      expect(e["[foo][bar]"] = "baz").to eq("baz")
+      expect(e["[foo][bar]"]).to eq("baz")
+      expect(e["[foo][baz]"]).to be_nil
+    end
+
+    it "should set deep array values" do
+      e = LogStash::Event.new()
+      expect(e["[foo][0]"] = "bar").to eq("bar")
+      expect(e["[foo][0]"]).to eq("bar")
+      expect(e["[foo][1]"] = 1).to eq(1)
+      expect(e["[foo][1]"]).to eq(1)
+      expect(e["[foo][2]"] = 1.0 ).to eq(1.0)
+      expect(e["[foo][2]"]).to eq(1.0)
+      expect(e["[foo][3]"]).to be_nil
+    end
+
+    it "should add key when setting nil value" do
+      e = LogStash::Event.new()
+      e["[foo]"] = nil
+      expect(e.to_hash).to include("foo" => nil)
+    end
+
+    # BigDecinal is now natively converted by JRuby, see https://github.com/elastic/logstash/pull/4838
+    it "should set BigDecimal" do
+      e = LogStash::Event.new()
+      e["[foo]"] = BigDecimal.new(1)
+      expect(e["foo"]).to be_kind_of(BigDecimal)
+      expect(e["foo"]).to eq(BigDecimal.new(1))
+    end
+
+    it "should set RubyBignum" do
+      e = LogStash::Event.new()
+      e["[foo]"] = -9223372036854776000
+      expect(e["foo"]).to be_kind_of(Bignum)
+      expect(e["foo"]).to eq(-9223372036854776000)
+    end
+  end
+
+  context "timestamp" do
+    it "getters should present a Ruby LogStash::Timestamp" do
+      e = LogStash::Event.new()
+      expect(e.timestamp.class).to eq(LogStash::Timestamp)
+      expect(e[TIMESTAMP].class).to eq(LogStash::Timestamp)
+    end
+
+    it "to_hash should inject a Ruby LogStash::Timestamp" do
+      e = LogStash::Event.new()
+
+      expect(e.to_java).to be_kind_of(Java::ComLogstash::Event)
+      expect(e.to_java.get_field(TIMESTAMP)).to be_kind_of(Java::ComLogstash::Timestamp)
+
+      expect(e.to_hash[TIMESTAMP]).to be_kind_of(LogStash::Timestamp)
+      # now make sure the original map was not touched
+      expect(e.to_java.get_field(TIMESTAMP)).to be_kind_of(Java::ComLogstash::Timestamp)
+    end
+
+    it "should set timestamp" do
+      e = LogStash::Event.new
+      now = Time.now
+      e["@timestamp"] = LogStash::Timestamp.at(now.to_i)
+      expect(e.timestamp.to_i).to eq(now.to_i)
+      expect(e["@timestamp"].to_i).to eq(now.to_i)
+    end
+  end
+
+  context "append" do
+    it "should append" do
+      event = LogStash::Event.new("message" => "hello world")
+      event.append(LogStash::Event.new("message" => "another thing"))
+      expect(event["message"]).to eq(["hello world", "another thing"])
+    end
+  end
+
+  context "tags" do
+    it "should tag" do
+      event = LogStash::Event.new("message" => "hello world")
+      expect(event["tags"]).to be_nil
+      event["tags"] = ["foo"]
+      expect(event["tags"]).to eq(["foo"])
+    end
+  end
+
+
+  # noop logger used to test the injectable logger in Event
+  # this implementation is not complete because only the warn
+  # method is used in Event.
+  module DummyLogger
+    def self.warn(message)
+      # do nothing
+    end
+  end
+
+  context "logger" do
+
+    let(:logger) { double("Logger") }
+    after(:each) {  LogStash::Event.logger = LogStash::Event::DEFAULT_LOGGER }
+
+    # the following 2 specs are using both a real module (DummyLogger)
+    # and a mock. both tests are needed to make sure the implementation
+    # supports both types of objects.
+
+    it "should set logger using a module" do
+      LogStash::Event.logger = DummyLogger
+      expect(DummyLogger).to receive(:warn).once
+      LogStash::Event.new(TIMESTAMP => "invalid timestamp")
+    end
+
+    it "should set logger using a mock" do
+      LogStash::Event.logger = logger
+      expect(logger).to receive(:warn).once
+      LogStash::Event.new(TIMESTAMP => "invalid timestamp")
+    end
+
+    it "should unset logger" do
+      # first set
+      LogStash::Event.logger = logger
+      expect(logger).to receive(:warn).once
+      LogStash::Event.new(TIMESTAMP => "invalid timestamp")
+
+      # then unset
+      LogStash::Event.logger = LogStash::Event::DEFAULT_LOGGER
+      expect(logger).to receive(:warn).never
+      # this will produce a log line in stdout by the Java Event
+      LogStash::Event.new(TIMESTAMP => "ignore this log")
+    end
+
+
+    it "should warn on parsing error" do
+      LogStash::Event.logger = logger
+      expect(logger).to receive(:warn).once.with(/^Error parsing/)
+      LogStash::Event.new(TIMESTAMP => "invalid timestamp")
+    end
+
+    it "should warn on invalid timestamp object" do
+      LogStash::Event.logger = logger
+      expect(logger).to receive(:warn).once.with(/^Unrecognized/)
+      LogStash::Event.new(TIMESTAMP => Array.new)
+    end
+  end
+
+  context "to_hash" do
+    let (:source_hash) {  {"a" => 1, "b" => [1, 2, 3, {"h" => 1, "i" => "baz"}], "c" => {"d" => "foo", "e" => "bar", "f" => [4, 5, "six"]}} }
+    let (:source_hash_with_matada) {  source_hash.merge({"@metadata" => {"a" => 1, "b" => 2}}) }
+    subject { LogStash::Event.new(source_hash_with_matada) }
+
+    it "should include @timestamp and @version" do
+      h = subject.to_hash
+      expect(h).to include("@timestamp")
+      expect(h).to include("@version")
+      expect(h).not_to include("@metadata")
+    end
+
+    it "should include @timestamp and @version and @metadata" do
+      h = subject.to_hash_with_metadata
+      expect(h).to include("@timestamp")
+      expect(h).to include("@version")
+      expect(h).to include("@metadata")
+    end
+
+    it "should produce valid deep Ruby hash without metadata" do
+      h = subject.to_hash
+      h.delete("@timestamp")
+      h.delete("@version")
+      expect(h).to eq(source_hash)
+    end
+
+    it "should produce valid deep Ruby hash with metadata" do
+      h = subject.to_hash_with_metadata
+      h.delete("@timestamp")
+      h.delete("@version")
+      expect(h).to eq(source_hash_with_matada)
+    end
+  end
+
+  context "from_json" do
+    let (:source_json) { "{\"foo\":1, \"bar\":\"baz\"}" }
+    let (:blank_strings) {["", "  ",  "   "]}
+    let (:bare_strings) {["aa", "  aa", "aa  "]}
+
+    it "should produce a new event from json" do
+      expect(LogStash::Event.from_json(source_json).size).to eq(1)
+
+      event = LogStash::Event.from_json(source_json)[0]
+      expect(event["[foo]"]).to eq(1)
+      expect(event["[bar]"]).to eq("baz")
+    end
+
+    it "should ignore blank strings" do
+      blank_strings.each do |s|
+        expect(LogStash::Event.from_json(s).size).to eq(0)
+      end
+    end
+
+    it "should raise TypeError on nil string" do
+      expect{LogStash::Event.from_json(nil)}.to raise_error TypeError
+    end
+
+    it "should consistently handle nil" do
+      blank_strings.each do |s|
+        expect{LogStash::Event.from_json(nil)}.to raise_error
+        expect{LogStash::Event.new(LogStash::Json.load(nil))}.to raise_error
+      end
+    end
+
+    it "should consistently handle bare string" do
+      bare_strings.each do |s|
+        expect{LogStash::Event.from_json(s)}.to raise_error LogStash::Json::ParserError
+        expect{LogStash::Event.new(LogStash::Json.load(s))}.to raise_error LogStash::Json::ParserError
+       end
+    end
+  end
+end
diff --git a/logstash-core-event-java/spec/timestamp_spec.rb b/logstash-core-event-java/spec/timestamp_spec.rb
new file mode 100644
index 00000000000..1c092696389
--- /dev/null
+++ b/logstash-core-event-java/spec/timestamp_spec.rb
@@ -0,0 +1,29 @@
+# encoding: utf-8
+
+require "spec_helper"
+require "logstash/timestamp"
+
+describe LogStash::Timestamp do
+  context "constructors" do
+    it "should work" do
+      t = LogStash::Timestamp.new
+      expect(t.time.to_i).to be_within(1).of Time.now.to_i
+
+      t = LogStash::Timestamp.now
+      expect(t.time.to_i).to be_within(1).of Time.now.to_i
+
+      now = Time.now.utc
+      t = LogStash::Timestamp.new(now)
+      expect(t.time).to eq(now)
+
+      t = LogStash::Timestamp.at(now.to_i)
+      expect(t.time.to_i).to eq(now.to_i)
+    end
+
+    it "should raise exception on invalid format" do
+      expect{LogStash::Timestamp.new("foobar")}.to raise_error
+    end
+
+  end
+
+end
diff --git a/logstash-core-event-java/src/main/java/JrubyEventExtService.java b/logstash-core-event-java/src/main/java/JrubyEventExtService.java
new file mode 100644
index 00000000000..306a45f3971
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/JrubyEventExtService.java
@@ -0,0 +1,14 @@
+import com.logstash.ext.JrubyEventExtLibrary;
+import org.jruby.Ruby;
+import org.jruby.runtime.load.BasicLibraryService;
+
+import java.io.IOException;
+
+public class JrubyEventExtService implements BasicLibraryService {
+    public boolean basicLoad(final Ruby runtime)
+        throws IOException
+    {
+        new JrubyEventExtLibrary().load(runtime, false);
+        return true;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/JrubyTimestampExtService.java b/logstash-core-event-java/src/main/java/JrubyTimestampExtService.java
new file mode 100644
index 00000000000..32d8eb2bf98
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/JrubyTimestampExtService.java
@@ -0,0 +1,15 @@
+import com.logstash.ext.JrubyEventExtLibrary;
+import com.logstash.ext.JrubyTimestampExtLibrary;
+import org.jruby.Ruby;
+import org.jruby.runtime.load.BasicLibraryService;
+
+import java.io.IOException;
+
+public class JrubyTimestampExtService implements BasicLibraryService {
+    public boolean basicLoad(final Ruby runtime)
+            throws IOException
+    {
+        new JrubyTimestampExtLibrary().load(runtime, false);
+        return true;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Accessors.java b/logstash-core-event-java/src/main/java/com/logstash/Accessors.java
new file mode 100644
index 00000000000..9a9506f934a
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Accessors.java
@@ -0,0 +1,177 @@
+package com.logstash;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.List;
+
+public class Accessors {
+
+    private Map<String, Object> data;
+    protected Map<String, Object> lut;
+
+    public Accessors(Map<String, Object> data) {
+        this.data = data;
+        this.lut = new HashMap<>(); // reference -> target LUT
+    }
+
+    public Object get(String reference) {
+        FieldReference field = PathCache.getInstance().cache(reference);
+        Object target = findTarget(field);
+        return (target == null) ? null : fetch(target, field.getKey());
+    }
+
+    public Object set(String reference, Object value) {
+        FieldReference field = PathCache.getInstance().cache(reference);
+        Object target = findCreateTarget(field);
+        return store(target, field.getKey(), value);
+    }
+
+    public Object del(String reference) {
+        FieldReference field = PathCache.getInstance().cache(reference);
+        Object target = findTarget(field);
+        if (target != null) {
+            if (target instanceof Map) {
+                return ((Map<String, Object>) target).remove(field.getKey());
+            } else if (target instanceof List) {
+                int i = Integer.parseInt(field.getKey());
+                if (i < 0 || i >= ((List) target).size()) {
+                    return null;
+                }
+                return ((List<Object>) target).remove(i);
+            } else {
+                throw newCollectionException(target);
+            }
+        }
+        return null;
+    }
+
+    public boolean includes(String reference) {
+        FieldReference field = PathCache.getInstance().cache(reference);
+        Object target = findTarget(field);
+        if (target instanceof Map && foundInMap((Map<String, Object>) target, field.getKey())) {
+            return true;
+        } else if (target instanceof List && foundInList((List<Object>) target, Integer.parseInt(field.getKey()))) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private Object findTarget(FieldReference field) {
+        Object target;
+
+        if ((target = this.lut.get(field.getReference())) != null) {
+            return target;
+        }
+
+        target = this.data;
+        for (String key : field.getPath()) {
+            target = fetch(target, key);
+            if (! isCollection(target)) {
+                return null;
+            }
+        }
+
+        this.lut.put(field.getReference(), target);
+
+        return target;
+    }
+
+    private Object findCreateTarget(FieldReference field) {
+        Object target;
+
+        // flush the @lut to prevent stale cached fieldref which may point to an old target
+        // which was overwritten with a new value. for example, if "[a][b]" is cached and we
+        // set a new value for "[a]" then reading again "[a][b]" would point in a stale target.
+        // flushing the complete @lut is suboptimal, but a hierarchical lut would be required
+        // to be able to invalidate fieldrefs from a common root.
+        // see https://github.com/elastic/logstash/pull/5132
+        this.lut.clear();
+
+        target = this.data;
+        for (String key : field.getPath()) {
+            Object result = fetch(target, key);
+            if (result == null) {
+                result = new HashMap<String, Object>();
+                if (target instanceof Map) {
+                    ((Map<String, Object>)target).put(key, result);
+                } else if (target instanceof List) {
+                    int i = Integer.parseInt(key);
+                    // TODO: what about index out of bound?
+                    ((List<Object>)target).set(i, result);
+                } else if (target != null) {
+                    throw newCollectionException(target);
+                }
+            }
+            target = result;
+        }
+
+        this.lut.put(field.getReference(), target);
+
+        return target;
+    }
+
+    private boolean foundInList(List<Object> target, int index) {
+        if (index < 0 || index >= target.size()) {
+            return false;
+        }
+        return target.get(index) != null;
+    }
+
+    private boolean foundInMap(Map<String, Object> target, String key) {
+        return target.containsKey(key);
+    }
+
+    private Object fetch(Object target, String key) {
+        if (target instanceof Map) {
+            Object result = ((Map<String, Object>) target).get(key);
+            return result;
+        } else if (target instanceof List) {
+            int i = Integer.parseInt(key);
+            if (i < 0 || i >= ((List) target).size()) {
+                return null;
+            }
+            Object result = ((List<Object>) target).get(i);
+            return result;
+        } else if (target == null) {
+            return null;
+        } else {
+            throw newCollectionException(target);
+        }
+    }
+
+    private Object store(Object target, String key, Object value) {
+        if (target instanceof Map) {
+            ((Map<String, Object>) target).put(key, value);
+        } else if (target instanceof List) {
+            int i = Integer.parseInt(key);
+            int size = ((List<Object>) target).size();
+            if (i >= size) {
+                // grow array by adding trailing null items
+                // this strategy reflects legacy Ruby impl behaviour and is backed by specs
+                // TODO: (colin) this is potentially dangerous, and could produce OOM using arbritary big numbers
+                // TODO: (colin) should be guard against this?
+                for (int j = size; j < i; j++) {
+                    ((List<Object>) target).add(null);
+                }
+                ((List<Object>) target).add(value);
+            } else {
+                ((List<Object>) target).set(i, value);
+            }
+        } else {
+            throw newCollectionException(target);
+        }
+        return value;
+    }
+
+    private boolean isCollection(Object target) {
+        if (target == null) {
+            return false;
+        }
+        return (target instanceof Map || target instanceof List);
+    }
+
+    private ClassCastException newCollectionException(Object target) {
+        return new ClassCastException("expecting List or Map, found "  + target.getClass());
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Cloner.java b/logstash-core-event-java/src/main/java/com/logstash/Cloner.java
new file mode 100644
index 00000000000..4823f10726a
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Cloner.java
@@ -0,0 +1,56 @@
+package com.logstash;
+
+import java.util.*;
+
+public final class Cloner {
+
+    private Cloner(){}
+
+    public static <T> T deep(final T input) {
+        if (input instanceof Map<?, ?>) {
+            return (T) deepMap((Map<?, ?>) input);
+        } else if (input instanceof List<?>) {
+            return (T) deepList((List<?>) input);
+        } else if (input instanceof Collection<?>) {
+            throw new ClassCastException("unexpected Collection type " + input.getClass());
+        }
+
+        return input;
+    }
+
+    private static <E> List<E> deepList(final List<E> list) {
+        List<E> clone;
+        if (list instanceof LinkedList<?>) {
+            clone = new LinkedList<E>();
+        } else if (list instanceof ArrayList<?>) {
+            clone = new ArrayList<E>();
+        } else {
+            throw new ClassCastException("unexpected List type " + list.getClass());
+        }
+
+        for (E item : list) {
+            clone.add(deep(item));
+        }
+
+        return clone;
+    }
+
+    private static <K, V> Map<K, V> deepMap(final Map<K, V> map) {
+        Map<K, V> clone;
+        if (map instanceof LinkedHashMap<?, ?>) {
+            clone = new LinkedHashMap<K, V>();
+        } else if (map instanceof TreeMap<?, ?>) {
+            clone = new TreeMap<K, V>();
+        } else if (map instanceof HashMap<?, ?>) {
+            clone = new HashMap<K, V>();
+        } else {
+            throw new ClassCastException("unexpected Map type " + map.getClass());
+        }
+
+        for (Map.Entry<K, V> entry : map.entrySet()) {
+            clone.put(entry.getKey(), deep(entry.getValue()));
+        }
+
+        return clone;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/DateNode.java b/logstash-core-event-java/src/main/java/com/logstash/DateNode.java
new file mode 100644
index 00000000000..560d9f53d3c
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/DateNode.java
@@ -0,0 +1,24 @@
+package com.logstash;
+
+import org.joda.time.DateTimeZone;
+import org.joda.time.format.DateTimeFormat;
+import org.joda.time.format.DateTimeFormatter;
+
+import java.io.IOError;
+import java.io.IOException;
+
+/**
+ * Created by ph on 15-05-22.
+ */
+public class DateNode implements TemplateNode {
+    private DateTimeFormatter formatter;
+
+    public DateNode(String format) {
+        this.formatter = DateTimeFormat.forPattern(format).withZone(DateTimeZone.UTC);
+    }
+
+    @Override
+    public String evaluate(Event event) throws IOException {
+        return event.getTimestamp().getTime().toString(this.formatter);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/EpochNode.java b/logstash-core-event-java/src/main/java/com/logstash/EpochNode.java
new file mode 100644
index 00000000000..4451ffa73c4
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/EpochNode.java
@@ -0,0 +1,15 @@
+package com.logstash;
+
+import java.io.IOException;
+
+/**
+ * Created by ph on 15-05-22.
+ */
+public class EpochNode implements TemplateNode {
+    public EpochNode(){ }
+
+    @Override
+    public String evaluate(Event event) throws IOException {
+        return String.valueOf(event.getTimestamp().getTime().getMillis() / 1000);
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Event.java b/logstash-core-event-java/src/main/java/com/logstash/Event.java
new file mode 100644
index 00000000000..bf62eb4ea3b
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Event.java
@@ -0,0 +1,296 @@
+package com.logstash;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.logstash.ext.JrubyTimestampExtLibrary;
+import org.joda.time.DateTime;
+import org.jruby.RubySymbol;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.*;
+
+
+public class Event implements Cloneable, Serializable {
+
+    private boolean cancelled;
+    private Map<String, Object> data;
+    private Map<String, Object> metadata;
+    private Timestamp timestamp;
+    private Accessors accessors;
+    private Accessors metadata_accessors;
+
+    public static final String METADATA = "@metadata";
+    public static final String METADATA_BRACKETS = "[" + METADATA + "]";
+    public static final String TIMESTAMP = "@timestamp";
+    public static final String TIMESTAMP_FAILURE_TAG = "_timestampparsefailure";
+    public static final String TIMESTAMP_FAILURE_FIELD = "_@timestamp";
+    public static final String VERSION = "@version";
+    public static final String VERSION_ONE = "1";
+
+    private static final Logger DEFAULT_LOGGER = new StdioLogger();
+    private static final ObjectMapper mapper = new ObjectMapper();
+
+    // logger is static since once set there is no point in changing it at runtime
+    // for other reasons than in tests/specs.
+    private transient static Logger logger = DEFAULT_LOGGER;
+
+    public Event()
+    {
+        this.metadata = new HashMap<String, Object>();
+        this.data = new HashMap<String, Object>();
+        this.data.put(VERSION, VERSION_ONE);
+        this.cancelled = false;
+        this.timestamp = new Timestamp();
+        this.data.put(TIMESTAMP, this.timestamp);
+        this.accessors = new Accessors(this.data);
+        this.metadata_accessors = new Accessors(this.metadata);
+    }
+
+    public Event(Map data)
+    {
+        this.data = data;
+        if (!this.data.containsKey(VERSION)) {
+            this.data.put(VERSION, VERSION_ONE);
+        }
+
+        if (this.data.containsKey(METADATA)) {
+            this.metadata = (HashMap<String, Object>) this.data.remove(METADATA);
+        } else {
+            this.metadata = new HashMap<String, Object>();
+        }
+        this.metadata_accessors = new Accessors(this.metadata);
+
+        this.cancelled = false;
+        this.timestamp = initTimestamp(data.get(TIMESTAMP));
+        this.data.put(TIMESTAMP, this.timestamp);
+        this.accessors = new Accessors(this.data);
+    }
+
+    public Map<String, Object> getData() {
+        return this.data;
+    }
+
+    public Map<String, Object> getMetadata() {
+        return this.metadata;
+    }
+
+    public void setData(Map<String, Object> data) {
+        this.data = data;
+    }
+
+    public Accessors getAccessors() {
+        return this.accessors;
+    }
+
+    public Accessors getMetadataAccessors() {
+        return this.metadata_accessors;
+    }
+
+    public void setAccessors(Accessors accessors) {
+        this.accessors = accessors;
+    }
+
+    public void setMetadataAccessors(Accessors accessors) {
+        this.metadata_accessors = accessors;
+    }
+
+    public void cancel() {
+        this.cancelled = true;
+    }
+
+    public void uncancel() {
+        this.cancelled = false;
+    }
+
+    public boolean isCancelled() {
+        return this.cancelled;
+    }
+
+    public Timestamp getTimestamp() throws IOException {
+        if (this.data.containsKey(TIMESTAMP)) {
+            return this.timestamp;
+        } else {
+            throw new IOException("fails");
+        }
+    }
+
+    public void setTimestamp(Timestamp t) {
+        this.timestamp = t;
+        this.data.put(TIMESTAMP, this.timestamp);
+    }
+
+    public Object getField(String reference) {
+        if (reference.equals(METADATA)) {
+            return this.metadata;
+        } else if (reference.startsWith(METADATA_BRACKETS)) {
+            return this.metadata_accessors.get(reference.substring(METADATA_BRACKETS.length()));
+        } else {
+            return this.accessors.get(reference);
+        }
+    }
+
+    public void setField(String reference, Object value) {
+        if (reference.equals(TIMESTAMP)) {
+            // TODO(talevy): check type of timestamp
+            this.accessors.set(reference, value);
+        } else if (reference.equals(METADATA_BRACKETS) || reference.equals(METADATA)) {
+            this.metadata = (HashMap<String, Object>) value;
+            this.metadata_accessors = new Accessors(this.metadata);
+        } else if (reference.startsWith(METADATA_BRACKETS)) {
+            this.metadata_accessors.set(reference.substring(METADATA_BRACKETS.length()), value);
+        } else {
+            this.accessors.set(reference, value);
+        }
+    }
+
+    public boolean includes(String reference) {
+        if (reference.equals(METADATA_BRACKETS) || reference.equals(METADATA)) {
+            return true;
+        } else if (reference.startsWith(METADATA_BRACKETS)) {
+            return this.metadata_accessors.includes(reference.substring(METADATA_BRACKETS.length()));
+        } else {
+            return this.accessors.includes(reference);
+        }
+    }
+
+    public String toJson()
+            throws IOException
+    {
+        return mapper.writeValueAsString((Map<String, Object>)this.data);
+    }
+
+    public static Event[] fromJson(String json)
+            throws IOException
+    {
+        // empty/blank json string does not generate an event
+        if (json == null || json.trim().isEmpty()) {
+            return new Event[]{ };
+        }
+
+        Event[] result;
+        Object o = mapper.readValue(json, Object.class);
+        // we currently only support Map or Array json objects
+        if (o instanceof Map) {
+            result = new Event[]{ new Event((Map)o) };
+        } else if (o instanceof List) {
+            result = new Event[((List) o).size()];
+            int i = 0;
+            for (Object e : (List)o) {
+                if (!(e instanceof Map)) {
+                    throw new IOException("incompatible inner json array object type=" + e.getClass().getName() + " , only hash map is suppoted");
+                }
+                result[i++] = new Event((Map)e);
+            }
+        } else {
+            throw new IOException("incompatible json object type=" + o.getClass().getName() + " , only hash map or arrays are suppoted");
+        }
+
+        return result;
+    }
+
+    public Map toMap() {
+        return this.data;
+    }
+
+    public Event overwrite(Event e) {
+        this.data = e.getData();
+        this.accessors = e.getAccessors();
+        this.cancelled = e.isCancelled();
+        try {
+            this.timestamp = e.getTimestamp();
+        } catch (IOException exception) {
+            this.timestamp = new Timestamp();
+        }
+
+        return this;
+    }
+
+
+    public Event append(Event e) {
+        Util.mapMerge(this.data, e.data);
+
+        return this;
+    }
+
+    public Object remove(String path) {
+        return this.accessors.del(path);
+    }
+
+    public String sprintf(String s) throws IOException {
+        return StringInterpolation.getInstance().evaluate(this, s);
+    }
+
+    public Event clone()
+            throws CloneNotSupportedException
+    {
+//        Event clone = (Event)super.clone();
+//        clone.setAccessors(new Accessors(clone.getData()));
+
+        Event clone = new Event(Cloner.deep(getData()));
+        return clone;
+    }
+
+    public String toString() {
+        // TODO: (colin) clean this IOException handling, not sure why we bubble IOException here
+        try {
+            return (getTimestamp().toIso8601() + " " + this.sprintf("%{host} %{message}"));
+        } catch (IOException e) {
+            String host = (String)this.data.get("host");
+            host = (host != null ? host : "%{host}");
+
+            String message = (String)this.data.get("message");
+            message = (message != null ? message : "%{message}");
+
+            return (host + " " + message);
+        }
+    }
+
+    private Timestamp initTimestamp(Object o) {
+        try {
+            if (o == null) {
+                // most frequent
+                return new Timestamp();
+            } else if (o instanceof String) {
+                // second most frequent
+                return new Timestamp((String) o);
+            } else if (o instanceof JrubyTimestampExtLibrary.RubyTimestamp) {
+                return new Timestamp(((JrubyTimestampExtLibrary.RubyTimestamp) o).getTimestamp());
+            } else if (o instanceof Timestamp) {
+                return new Timestamp((Timestamp) o);
+            } else if (o instanceof DateTime) {
+                return new Timestamp((DateTime) o);
+            } else if (o instanceof Date) {
+                return new Timestamp((Date) o);
+            } else if (o instanceof RubySymbol) {
+                return new Timestamp(((RubySymbol) o).asJavaString());
+            } else {
+                Event.logger.warn("Unrecognized " + TIMESTAMP + " value type=" + o.getClass().toString());
+            }
+        } catch (IllegalArgumentException e) {
+            Event.logger.warn("Error parsing " + TIMESTAMP + " string value=" + o.toString());
+        }
+
+        tag(TIMESTAMP_FAILURE_TAG);
+        this.data.put(TIMESTAMP_FAILURE_FIELD, o);
+
+        return Timestamp.now();
+    }
+
+    public void tag(String tag) {
+        List<Object> tags = (List<Object>) this.data.get("tags");
+        if (tags == null) {
+            tags = new ArrayList<>();
+            this.data.put("tags", tags);
+        }
+
+        if (!tags.contains(tag)) {
+            tags.add(tag);
+        }
+    }
+
+    // Event.logger is static since once set there is no point in changing it at runtime
+    // for other reasons than in tests/specs.
+    public static void setLogger(Logger logger) {
+        Event.logger = logger;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/FieldReference.java b/logstash-core-event-java/src/main/java/com/logstash/FieldReference.java
new file mode 100644
index 00000000000..e0d7e3ee969
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/FieldReference.java
@@ -0,0 +1,40 @@
+package com.logstash;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+// TODO: implement thread-safe path cache singleton to avoid parsing
+
+public class FieldReference {
+
+    private List<String> path;
+    private String key;
+    private String reference;
+    private static List<String> EMPTY_STRINGS = Arrays.asList("");
+
+    public FieldReference(List<String> path, String key, String reference) {
+        this.path = path;
+        this.key = key;
+        this.reference = reference;
+    }
+
+    public List<String> getPath() {
+        return path;
+    }
+
+    public String getKey() {
+        return key;
+    }
+
+    public String getReference() {
+        return reference;
+    }
+
+    public static FieldReference parse(String reference) {
+        List<String> path = new ArrayList(Arrays.asList(reference.split("[\\[\\]]")));
+        path.removeAll(EMPTY_STRINGS);
+        String key = path.remove(path.size() - 1);
+        return new FieldReference(path, key, reference);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Javafier.java b/logstash-core-event-java/src/main/java/com/logstash/Javafier.java
new file mode 100644
index 00000000000..e1e03156be7
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Javafier.java
@@ -0,0 +1,161 @@
+package com.logstash;
+
+import org.jruby.RubyArray;
+import org.jruby.RubyHash;
+import org.jruby.RubyString;
+import org.jruby.RubyObject;
+import org.jruby.RubyBoolean;
+import org.jruby.RubyArray;
+import org.jruby.RubyFloat;
+import org.jruby.RubyInteger;
+import org.jruby.RubyNil;
+import org.jruby.RubyBoolean;
+import org.jruby.RubyFixnum;
+import org.jruby.RubyTime;
+import org.jruby.RubySymbol;
+import org.jruby.RubyBignum;
+import org.jruby.ext.bigdecimal.RubyBigDecimal;
+import com.logstash.ext.JrubyTimestampExtLibrary;
+import org.jruby.runtime.builtin.IRubyObject;
+import java.math.BigDecimal;
+import org.joda.time.DateTime;
+
+import java.math.BigInteger;
+import java.util.*;
+
+public class Javafier {
+
+    private Javafier(){}
+
+    public static List<Object> deep(RubyArray a) {
+        final ArrayList<Object> result = new ArrayList();
+
+        // TODO: (colin) investagate why .toJavaArrayUnsafe() which should be faster by avoiding copying produces nil values spec errors in arrays
+        for (IRubyObject o : a.toJavaArray()) {
+            result.add(deep(o));
+        }
+        return result;
+    }
+
+    public static HashMap<String, Object> deep(RubyHash h) {
+        final HashMap result = new HashMap();
+
+        h.visitAll(new RubyHash.Visitor() {
+            @Override
+            public void visit(IRubyObject key, IRubyObject value) {
+                result.put(deep(key).toString(), deep(value));
+            }
+        });
+        return result;
+    }
+
+    public static String deep(RubyString s) {
+        return s.asJavaString();
+    }
+
+    public static long deep(RubyInteger i) {
+        return i.getLongValue();
+    }
+
+    public static long deep(RubyFixnum n) {
+        return n.getLongValue();
+    }
+
+    public static double deep(RubyFloat f) {
+        return f.getDoubleValue();
+    }
+
+    public static BigDecimal deep(RubyBigDecimal bd) {
+        return bd.getBigDecimalValue();
+    }
+
+    public static BigInteger deep(RubyBignum bn) {
+        return bn.getBigIntegerValue();
+    }
+
+    public static Timestamp deep(JrubyTimestampExtLibrary.RubyTimestamp t) {
+        return t.getTimestamp();
+    }
+
+    public static boolean deep(RubyBoolean b) {
+        return b.isTrue();
+    }
+
+    public static Object deep(RubyNil n) {
+        return null;
+    }
+
+    public static DateTime deep(RubyTime t) {
+        return t.getDateTime();
+    }
+
+    public static String deep(RubySymbol s) {
+        return s.asJavaString();
+    }
+
+    public static Object deep(RubyBoolean.True b) {
+        return true;
+    }
+
+    public static Object deep(RubyBoolean.False b) {
+        return false;
+    }
+
+    public static Object deep(IRubyObject o) {
+        // TODO: (colin) this enum strategy is cleaner but I am hoping that is not slower than using a instanceof cascade
+
+        RUBYCLASS clazz;
+        try {
+            clazz = RUBYCLASS.valueOf(o.getClass().getSimpleName());
+        } catch (IllegalArgumentException e) {
+            throw new IllegalArgumentException("Missing Ruby class handling for full class name=" + o.getClass().getName() + ", simple name=" + o.getClass().getSimpleName());
+        }
+
+        switch(clazz) {
+            case RubyArray: return deep((RubyArray)o);
+            case RubyHash: return deep((RubyHash)o);
+            case RubyString: return deep((RubyString)o);
+            case RubyInteger: return deep((RubyInteger)o);
+            case RubyFloat: return deep((RubyFloat)o);
+            case RubyBigDecimal: return deep((RubyBigDecimal)o);
+            case RubyTimestamp: return deep((JrubyTimestampExtLibrary.RubyTimestamp)o);
+            case RubyBoolean: return deep((RubyBoolean)o);
+            case RubyFixnum: return deep((RubyFixnum)o);
+            case RubyBignum: return deep((RubyBignum)o);
+            case RubyTime: return deep((RubyTime)o);
+            case RubySymbol: return deep((RubySymbol)o);
+            case RubyNil: return deep((RubyNil)o);
+            case True: return deep((RubyBoolean.True)o);
+            case False: return deep((RubyBoolean.False)o);
+        }
+
+        if (o.isNil()) {
+            return null;
+        }
+
+        // TODO: (colin) temporary trace to spot any unhandled types
+        System.out.println("***** WARN: UNHANDLED IRubyObject full class name=" + o.getMetaClass().getRealClass().getName() + ", simple name=" + o.getClass().getSimpleName() + " java class=" + o.getJavaClass().toString() + " toString=" + o.toString());
+
+        return o.toJava(o.getJavaClass());
+    }
+
+    enum RUBYCLASS {
+        RubyString,
+        RubyInteger,
+        RubyFloat,
+        RubyBigDecimal,
+        RubyTimestamp,
+        RubyArray,
+        RubyHash,
+        RubyBoolean,
+        RubyFixnum,
+        RubyBignum,
+        RubyObject,
+        RubyNil,
+        RubyTime,
+        RubySymbol,
+        True,
+        False;
+    }
+}
+
diff --git a/logstash-core-event-java/src/main/java/com/logstash/KeyNode.java b/logstash-core-event-java/src/main/java/com/logstash/KeyNode.java
new file mode 100644
index 00000000000..cfc46861f69
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/KeyNode.java
@@ -0,0 +1,63 @@
+package com.logstash;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Created by ph on 15-05-22.
+ */
+public class KeyNode implements TemplateNode {
+    private String key;
+
+    public KeyNode(String key) {
+        this.key = key;
+    }
+
+    /**
+     This will be more complicated with hash and array.
+     leverage jackson lib to do the actual.
+     */
+    @Override
+    public String evaluate(Event event) throws IOException {
+        Object value = event.getField(this.key);
+
+        if (value != null) {
+            if (value instanceof List) {
+                return join((List)value, ",");
+            } else if (value instanceof Map) {
+                ObjectMapper mapper = new ObjectMapper();
+                return mapper.writeValueAsString((Map<String, Object>)value);
+            } else {
+                return event.getField(this.key).toString();
+            }
+
+        } else {
+            return "%{" + this.key + "}";
+        }
+    }
+
+    // TODO: (colin) this should be moved somewhere else to make it reusable
+    //   this is a quick fix to compile on JDK7 a not use String.join that is
+    //   only available in JDK8
+    public static String join(List<?> list, String delim) {
+        int len = list.size();
+
+        if (len == 0) return "";
+
+        StringBuilder result = new StringBuilder(toString(list.get(0), delim));
+        for (int i = 1; i < len; i++) {
+            result.append(delim);
+            result.append(toString(list.get(i), delim));
+        }
+        return result.toString();
+    }
+
+    private static String toString(Object value, String delim) {
+        if (value == null) return "";
+        if (value instanceof List) return join((List)value, delim);
+        return value.toString();
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Logger.java b/logstash-core-event-java/src/main/java/com/logstash/Logger.java
new file mode 100644
index 00000000000..fc425542715
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Logger.java
@@ -0,0 +1,13 @@
+package com.logstash;
+
+// minimalist Logger interface to wire a logger callback in the Event class
+// for now only warn is defined because this is the only method that's required
+// in the Event class.
+// TODO: (colin) generalize this
+
+public interface Logger {
+
+    // TODO: (colin) complete interface beyond warn when needed
+
+    void warn(String message);
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/PathCache.java b/logstash-core-event-java/src/main/java/com/logstash/PathCache.java
new file mode 100644
index 00000000000..b7beff95b89
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/PathCache.java
@@ -0,0 +1,47 @@
+package com.logstash;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+public class PathCache {
+
+    private static PathCache instance = null;
+    private static ConcurrentHashMap<String, FieldReference> cache = new ConcurrentHashMap<>();
+
+    private FieldReference timestamp;
+
+    // TODO: dry with Event
+    public static final String TIMESTAMP = "@timestamp";
+    public static final String BRACKETS_TIMESTAMP = "[" + TIMESTAMP + "]";
+
+    protected PathCache() {
+        // inject @timestamp
+        this.timestamp = cache(TIMESTAMP);
+        cache(BRACKETS_TIMESTAMP, this.timestamp);
+    }
+
+    public static PathCache getInstance() {
+        if (instance == null) {
+            instance = new PathCache();
+        }
+        return instance;
+    }
+
+    public boolean isTimestamp(String reference) {
+        return (cache(reference) == this.timestamp);
+    }
+
+    public FieldReference cache(String reference) {
+        // atomicity between the get and put is not important
+        FieldReference result = cache.get(reference);
+        if (result == null) {
+            result = FieldReference.parse(reference);
+            cache.put(reference, result);
+        }
+        return result;
+    }
+
+    public FieldReference cache(String reference, FieldReference field) {
+        cache.put(reference, field);
+        return field;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Rubyfier.java b/logstash-core-event-java/src/main/java/com/logstash/Rubyfier.java
new file mode 100644
index 00000000000..0bafab8c9da
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Rubyfier.java
@@ -0,0 +1,65 @@
+package com.logstash;
+
+import com.logstash.ext.JrubyTimestampExtLibrary;
+import org.jruby.Ruby;
+import org.jruby.RubyArray;
+import org.jruby.RubyHash;
+import org.jruby.ext.bigdecimal.RubyBigDecimal;
+import org.jruby.javasupport.JavaUtil;
+import org.jruby.runtime.builtin.IRubyObject;
+
+import java.math.BigDecimal;
+import java.util.*;
+
+public final class Rubyfier {
+
+    private Rubyfier(){}
+
+    public static IRubyObject deep(Ruby runtime, final Object input) {
+        if (input instanceof IRubyObject) return (IRubyObject)input;
+        if (input instanceof Map) return deepMap(runtime, (Map) input);
+        if (input instanceof List) return deepList(runtime, (List) input);
+        if (input instanceof Timestamp) return JrubyTimestampExtLibrary.RubyTimestamp.newRubyTimestamp(runtime, (Timestamp)input);
+        if (input instanceof Collection) throw new ClassCastException("unexpected Collection type " + input.getClass());
+
+        // BigDecimal is not currenly handled by JRuby and this is the type Jackson uses for floats
+        if (input instanceof BigDecimal) return new RubyBigDecimal(runtime, runtime.getClass("BigDecimal"), (BigDecimal)input);
+
+        return JavaUtil.convertJavaToUsableRubyObject(runtime, input);
+    }
+
+    public static Object deepOnly(Ruby runtime, final Object input) {
+        if (input instanceof Map) return deepMap(runtime, (Map) input);
+        if (input instanceof List) return deepList(runtime, (List) input);
+        if (input instanceof Timestamp) return JrubyTimestampExtLibrary.RubyTimestamp.newRubyTimestamp(runtime, (Timestamp)input);
+        if (input instanceof Collection) throw new ClassCastException("unexpected Collection type " + input.getClass());
+
+        // BigDecimal is not currenly handled by JRuby and this is the type Jackson uses for floats
+        if (input instanceof BigDecimal) return new RubyBigDecimal(runtime, runtime.getClass("BigDecimal"), (BigDecimal)input);
+
+        return input;
+    }
+
+    private static RubyArray deepList(Ruby runtime, final List list) {
+        final int length = list.size();
+        final RubyArray array = runtime.newArray(length);
+
+        for (Object item : list) {
+            // use deepOnly because RubyArray.add already calls JavaUtil.convertJavaToUsableRubyObject on item
+            array.add(deepOnly(runtime, item));
+        }
+
+        return array;
+    }
+
+    private static RubyHash deepMap(Ruby runtime, final Map<?, ?> map) {
+        RubyHash hash = RubyHash.newHash(runtime);
+
+        for (Map.Entry<?, ?> entry : map.entrySet()) {
+            // use deepOnly on value because RubyHash.put already calls JavaUtil.convertJavaToUsableRubyObject on items
+            hash.put(entry.getKey(), deepOnly(runtime, entry.getValue()));
+        }
+
+        return hash;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/StaticNode.java b/logstash-core-event-java/src/main/java/com/logstash/StaticNode.java
new file mode 100644
index 00000000000..73b5c160440
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/StaticNode.java
@@ -0,0 +1,19 @@
+package com.logstash;
+
+import java.io.IOException;
+
+/**
+ * Created by ph on 15-05-22.
+ */
+public class StaticNode implements TemplateNode {
+    private String content;
+
+    public StaticNode(String content) {
+        this.content = content;
+    }
+
+    @Override
+    public String evaluate(Event event) throws IOException {
+        return this.content;
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/main/java/com/logstash/StdioLogger.java b/logstash-core-event-java/src/main/java/com/logstash/StdioLogger.java
new file mode 100644
index 00000000000..c12bb3e0573
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/StdioLogger.java
@@ -0,0 +1,10 @@
+package com.logstash;
+
+public class StdioLogger implements Logger {
+
+    // TODO: (colin) complete implementation beyond warn when needed
+
+    public void warn(String message) {
+        System.out.println(message);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/StringInterpolation.java b/logstash-core-event-java/src/main/java/com/logstash/StringInterpolation.java
new file mode 100644
index 00000000000..5830cc89672
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/StringInterpolation.java
@@ -0,0 +1,101 @@
+package com.logstash;
+
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class StringInterpolation {
+    static Pattern TEMPLATE_TAG = Pattern.compile("%\\{([^}]+)\\}");
+    static Map cache;
+
+    protected static class HoldCurrent {
+        private static final StringInterpolation INSTANCE = new StringInterpolation();
+    }
+
+    private StringInterpolation() {
+        // TODO:
+        // This may need some tweaking for the concurrency level to get better memory usage.
+        // The current implementation doesn't allow the keys to expire, I think under normal usage
+        // the keys will converge to a fixed number.
+        //
+        // If this code make logstash goes OOM, we have the following options:
+        //  - If the key doesn't contains a `%` do not cache it, this will reduce the key size at a performance cost.
+        //  - Use some kind LRU cache
+        //  - Create a new data structure that use weakref or use Google Guava for the cache https://code.google.com/p/guava-libraries/
+        this.cache = new ConcurrentHashMap<>();
+    }
+
+    public void clearCache() {
+        this.cache.clear();
+    }
+
+    public int cacheSize() {
+        return this.cache.size();
+    }
+
+    public String evaluate(Event event, String template) throws IOException {
+        TemplateNode compiledTemplate = (TemplateNode) this.cache.get(template);
+
+        if (compiledTemplate == null) {
+            compiledTemplate = this.compile(template);
+            this.cache.put(template, compiledTemplate);
+        }
+
+        return compiledTemplate.evaluate(event);
+    }
+
+    public TemplateNode compile(String template) {
+        Template compiledTemplate = new Template();
+
+        if (template.indexOf('%') == -1) {
+            // Move the nodes to a custom instance
+            // so we can remove the iterator and do one `.evaluate`
+            compiledTemplate.add(new StaticNode(template));
+        } else {
+            Matcher matcher = TEMPLATE_TAG.matcher(template);
+            String tag;
+            int pos = 0;
+
+            while (matcher.find()) {
+                if (matcher.start() > 0) {
+                    compiledTemplate.add(new StaticNode(template.substring(pos, matcher.start())));
+                }
+
+                tag = matcher.group(1);
+                compiledTemplate.add(identifyTag(tag));
+                pos = matcher.end();
+            }
+
+            if(pos <= template.length() - 1) {
+                compiledTemplate.add(new StaticNode(template.substring(pos)));
+            }
+        }
+
+        // if we only have one node return the node directly
+        // and remove the need to loop.
+        if(compiledTemplate.size() == 1) {
+            return compiledTemplate.get(0);
+        } else {
+            return compiledTemplate;
+        }
+    }
+
+    public TemplateNode identifyTag(String tag) {
+        if(tag.equals("+%s")) {
+            return new EpochNode();
+        } else if(tag.charAt(0) == '+') {
+                return new DateNode(tag.substring(1));
+
+        } else {
+            return new KeyNode(tag);
+        }
+    }
+
+    static StringInterpolation getInstance() {
+        return HoldCurrent.INSTANCE;
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Template.java b/logstash-core-event-java/src/main/java/com/logstash/Template.java
new file mode 100644
index 00000000000..a17e69b3946
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Template.java
@@ -0,0 +1,32 @@
+package com.logstash;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class Template implements TemplateNode {
+    public List nodes = new ArrayList<>();
+    public Template() {}
+
+    public void add(TemplateNode node) {
+        nodes.add(node);
+    }
+
+    public int size() {
+        return nodes.size();
+    }
+
+    public TemplateNode get(int index) {
+        return (TemplateNode) nodes.get(index);
+    }
+
+    @Override
+    public String evaluate(Event event) throws IOException {
+        StringBuffer results = new StringBuffer();
+
+        for (int i = 0; i < nodes.size(); i++) {
+            results.append(((TemplateNode) nodes.get(i)).evaluate(event));
+        }
+        return results.toString();
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/main/java/com/logstash/TemplateNode.java b/logstash-core-event-java/src/main/java/com/logstash/TemplateNode.java
new file mode 100644
index 00000000000..942bbc1ee03
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/TemplateNode.java
@@ -0,0 +1,10 @@
+package com.logstash;
+
+import java.io.IOException;
+
+/**
+ * Created by ph on 15-05-22.
+ */
+public interface TemplateNode {
+    String evaluate(Event event) throws IOException;
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Timestamp.java b/logstash-core-event-java/src/main/java/com/logstash/Timestamp.java
new file mode 100644
index 00000000000..434dc93a13c
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Timestamp.java
@@ -0,0 +1,84 @@
+package com.logstash;
+
+import com.fasterxml.jackson.databind.annotation.JsonSerialize;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeZone;
+import org.joda.time.LocalDateTime;
+import org.joda.time.Duration;
+import org.joda.time.format.DateTimeFormatter;
+import org.joda.time.format.ISODateTimeFormat;
+
+import java.util.Date;
+
+@JsonSerialize(using = TimestampSerializer.class)
+public class Timestamp implements Cloneable {
+
+    // all methods setting the time object must set it in the UTC timezone
+    private DateTime time;
+
+    // TODO: is this DateTimeFormatter thread safe?
+    private static DateTimeFormatter iso8601Formatter = ISODateTimeFormat.dateTime();
+
+    private static final LocalDateTime JAN_1_1970 = new LocalDateTime(1970, 1, 1, 0, 0);
+
+    public Timestamp() {
+        this.time = new DateTime(DateTimeZone.UTC);
+    }
+
+    public Timestamp(String iso8601) {
+        this.time = ISODateTimeFormat.dateTimeParser().parseDateTime(iso8601).toDateTime(DateTimeZone.UTC);
+    }
+
+    public Timestamp(Timestamp t) {
+        this.time = t.getTime();
+    }
+
+    public Timestamp(long epoch_milliseconds) {
+        this.time = new DateTime(epoch_milliseconds, DateTimeZone.UTC);
+    }
+
+    public Timestamp(Long epoch_milliseconds) {
+        this.time = new DateTime(epoch_milliseconds, DateTimeZone.UTC);
+    }
+
+    public Timestamp(Date date) {
+        this.time = new DateTime(date, DateTimeZone.UTC);
+    }
+
+    public Timestamp(DateTime date) {
+        this.time = date.toDateTime(DateTimeZone.UTC);
+    }
+
+    public DateTime getTime() {
+        return time;
+    }
+
+    public void setTime(DateTime time) {
+        this.time = time.toDateTime(DateTimeZone.UTC);
+    }
+
+    public static Timestamp now() {
+        return new Timestamp();
+    }
+
+    public String toIso8601() {
+        return this.iso8601Formatter.print(this.time);
+    }
+
+    public String toString() {
+        return toIso8601();
+    }
+
+    public long usec() {
+        // JodaTime only supports milliseconds precision we can only return usec at millisec precision.
+        // note that getMillis() return millis since epoch
+        return (new Duration(JAN_1_1970.toDateTime(DateTimeZone.UTC), this.time).getMillis() % 1000) * 1000;
+    }
+
+    @Override
+    public Timestamp clone() throws CloneNotSupportedException {
+        Timestamp clone = (Timestamp)super.clone();
+        clone.setTime(this.getTime());
+        return clone;
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/TimestampSerializer.java b/logstash-core-event-java/src/main/java/com/logstash/TimestampSerializer.java
new file mode 100644
index 00000000000..c90afdd9227
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/TimestampSerializer.java
@@ -0,0 +1,17 @@
+package com.logstash;
+
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.databind.JsonSerializer;
+import com.fasterxml.jackson.databind.SerializerProvider;
+
+import java.io.IOException;
+
+public class TimestampSerializer extends JsonSerializer<Timestamp> {
+
+    @Override
+    public void serialize(Timestamp value, JsonGenerator jgen, SerializerProvider provider)
+            throws IOException
+    {
+        jgen.writeString(value.toIso8601());
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Util.java b/logstash-core-event-java/src/main/java/com/logstash/Util.java
new file mode 100644
index 00000000000..907fd5489b1
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Util.java
@@ -0,0 +1,49 @@
+package com.logstash;
+
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+
+public class Util {
+    private Util() {}
+
+    public static void mapMerge(Map<String, Object> target, Map<String, Object> add) {
+        for (Map.Entry<String, Object> e : add.entrySet()) {
+            if (target.containsKey(e.getKey())) {
+                if (target.get(e.getKey()) instanceof Map && e.getValue() instanceof Map) {
+                    mapMerge((Map<String, Object>) target.get(e.getKey()), (Map<String, Object>) e.getValue());
+                } else if (e.getValue() instanceof List) {
+                    if (target.get(e.getKey()) instanceof List) {
+                        // needs optimizing
+                        List targetList = (List) target.get(e.getKey());
+                        targetList.addAll((List) e.getValue());
+                        target.put(e.getKey(), new ArrayList<Object>(new LinkedHashSet<Object>(targetList)));
+                    } else {
+                        Object targetValue = target.get(e.getKey());
+                        List targetValueList = new ArrayList();
+                        targetValueList.add(targetValue);
+                        for (Object o : (List) e.getValue()) {
+                            if (!targetValue.equals(o)) {
+                                targetValueList.add(o);
+                            }
+                        }
+                        target.put(e.getKey(), targetValueList);
+                    }
+                } else if (target.get(e.getKey()) instanceof List) {
+                    List t = ((List) target.get(e.getKey()));
+                    if (!t.contains(e.getValue())) {
+                        t.add(e.getValue());
+                    }
+                } else if (!target.get(e.getKey()).equals(e.getValue())) {
+                    List targetValue = new ArrayList();
+                    targetValue.add(target.get(e.getKey()));
+                    ((List) targetValue).add(e.getValue());
+                    target.put(e.getKey(), targetValue);
+                }
+            } else {
+                target.put(e.getKey(), e.getValue());
+            }
+        }
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyEventExtLibrary.java b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyEventExtLibrary.java
new file mode 100644
index 00000000000..1cb630d5a75
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyEventExtLibrary.java
@@ -0,0 +1,343 @@
+package com.logstash.ext;
+
+import com.logstash.Logger;
+import com.logstash.Event;
+import com.logstash.PathCache;
+import com.logstash.Javafier;
+import com.logstash.Timestamp;
+import com.logstash.Rubyfier;
+import com.logstash.Javafier;
+import org.jruby.Ruby;
+import org.jruby.RubyObject;
+import org.jruby.RubyClass;
+import org.jruby.RubyModule;
+import org.jruby.RubyString;
+import org.jruby.RubyHash;
+import org.jruby.RubyBoolean;
+import org.jruby.RubyArray;
+import org.jruby.RubyFloat;
+import org.jruby.RubyInteger;
+import org.jruby.anno.JRubyClass;
+import org.jruby.anno.JRubyMethod;
+import org.jruby.exceptions.RaiseException;
+import org.jruby.javasupport.JavaUtil;
+import org.jruby.runtime.Arity;
+import org.jruby.runtime.ObjectAllocator;
+import org.jruby.runtime.ThreadContext;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.jruby.runtime.load.Library;
+import org.jruby.ext.bigdecimal.RubyBigDecimal;
+import java.io.IOException;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.List;
+
+
+public class JrubyEventExtLibrary implements Library {
+
+    private static RubyClass PARSER_ERROR = null;
+    private static RubyClass GENERATOR_ERROR = null;
+    private static RubyClass LOGSTASH_ERROR = null;
+
+    public void load(Ruby runtime, boolean wrap) throws IOException {
+        RubyModule module = runtime.defineModule("LogStash");
+
+        RubyClass clazz = runtime.defineClassUnder("Event", runtime.getObject(), new ObjectAllocator() {
+            public IRubyObject allocate(Ruby runtime, RubyClass rubyClass) {
+                return new RubyEvent(runtime, rubyClass);
+            }
+        }, module);
+
+        clazz.setConstant("METADATA", runtime.newString(Event.METADATA));
+        clazz.setConstant("METADATA_BRACKETS", runtime.newString(Event.METADATA_BRACKETS));
+        clazz.setConstant("TIMESTAMP", runtime.newString(Event.TIMESTAMP));
+        clazz.setConstant("TIMESTAMP_FAILURE_TAG", runtime.newString(Event.TIMESTAMP_FAILURE_TAG));
+        clazz.setConstant("TIMESTAMP_FAILURE_FIELD", runtime.newString(Event.TIMESTAMP_FAILURE_FIELD));
+        clazz.setConstant("DEFAULT_LOGGER", runtime.getModule("Cabin").getClass("Channel").callMethod("get", runtime.getModule("LogStash")));
+        clazz.setConstant("VERSION", runtime.newString(Event.VERSION));
+        clazz.setConstant("VERSION_ONE", runtime.newString(Event.VERSION_ONE));
+        clazz.defineAnnotatedMethods(RubyEvent.class);
+        clazz.defineAnnotatedConstants(RubyEvent.class);
+
+        PARSER_ERROR = runtime.getModule("LogStash").defineOrGetModuleUnder("Json").getClass("ParserError");
+        if (PARSER_ERROR == null) {
+            throw new RaiseException(runtime, runtime.getClass("StandardError"), "Could not find LogStash::Json::ParserError class", true);
+        }
+        GENERATOR_ERROR = runtime.getModule("LogStash").defineOrGetModuleUnder("Json").getClass("GeneratorError");
+        if (GENERATOR_ERROR == null) {
+            throw new RaiseException(runtime, runtime.getClass("StandardError"), "Could not find LogStash::Json::GeneratorError class", true);
+        }
+        LOGSTASH_ERROR = runtime.getModule("LogStash").getClass("Error");
+        if (LOGSTASH_ERROR == null) {
+            throw new RaiseException(runtime, runtime.getClass("StandardError"), "Could not find LogStash::Error class", true);
+        }
+    }
+
+    public static class ProxyLogger implements Logger {
+        private RubyObject logger;
+
+        public ProxyLogger(RubyObject logger) {
+             this.logger = logger;
+        }
+
+        // TODO: (colin) complete implementation beyond warn when needed
+
+        public void warn(String message) {
+            logger.callMethod("warn", RubyString.newString(logger.getRuntime(), message));
+        }
+    }
+
+    @JRubyClass(name = "Event", parent = "Object")
+    public static class RubyEvent extends RubyObject {
+        private Event event;
+        private static RubyObject logger;
+
+        public RubyEvent(Ruby runtime, RubyClass klass) {
+            super(runtime, klass);
+        }
+
+        public RubyEvent(Ruby runtime) {
+            this(runtime, runtime.getModule("LogStash").getClass("Event"));
+        }
+
+        public RubyEvent(Ruby runtime, Event event) {
+            this(runtime);
+            this.event = event;
+        }
+
+        public static RubyEvent newRubyEvent(Ruby runtime, Event event) {
+            return new RubyEvent(runtime, event);
+        }
+
+        public Event getEvent() {
+            return event;
+        }
+
+        public void setEvent(Event event) {
+            this.event = event;
+        }
+
+        // def initialize(data = {})
+        @JRubyMethod(name = "initialize", optional = 1)
+        public IRubyObject ruby_initialize(ThreadContext context, IRubyObject[] args)
+        {
+            args = Arity.scanArgs(context.runtime, args, 0, 1);
+            IRubyObject data = args[0];
+
+            if (data == null || data.isNil()) {
+                this.event = new Event();
+            } else if (data instanceof RubyHash) {
+                HashMap<String, Object>  newObj = Javafier.deep((RubyHash) data);
+                this.event = new Event(newObj);
+            } else if (data instanceof Map) {
+                this.event = new Event((Map) data);
+            } else if (Map.class.isAssignableFrom(data.getJavaClass())) {
+                this.event = new Event((Map)data.toJava(Map.class));
+            } else {
+                throw context.runtime.newTypeError("wrong argument type " + data.getMetaClass() + " (expected Hash)");
+            }
+
+            return context.nil;
+        }
+
+        @JRubyMethod(name = "[]", required = 1)
+        public IRubyObject ruby_get_field(ThreadContext context, RubyString reference)
+        {
+            Object value = this.event.getField(reference.asJavaString());
+            return Rubyfier.deep(context.runtime, value);
+        }
+
+        @JRubyMethod(name = "[]=", required = 2)
+        public IRubyObject ruby_set_field(ThreadContext context, RubyString reference, IRubyObject value)
+        {
+            String r = reference.asJavaString();
+
+            if (PathCache.getInstance().isTimestamp(r)) {
+                if (!(value instanceof JrubyTimestampExtLibrary.RubyTimestamp)) {
+                    throw context.runtime.newTypeError("wrong argument type " + value.getMetaClass() + " (expected LogStash::Timestamp)");
+                }
+                this.event.setTimestamp(((JrubyTimestampExtLibrary.RubyTimestamp)value).getTimestamp());
+            } else {
+                this.event.setField(r, Javafier.deep(value));
+            }
+            return value;
+        }
+
+        @JRubyMethod(name = "cancel")
+        public IRubyObject ruby_cancel(ThreadContext context)
+        {
+            this.event.cancel();
+            return RubyBoolean.createTrueClass(context.runtime);
+        }
+
+        @JRubyMethod(name = "uncancel")
+        public IRubyObject ruby_uncancel(ThreadContext context)
+        {
+            this.event.uncancel();
+            return RubyBoolean.createFalseClass(context.runtime);
+        }
+
+        @JRubyMethod(name = "cancelled?")
+        public IRubyObject ruby_cancelled(ThreadContext context)
+        {
+            return RubyBoolean.newBoolean(context.runtime, this.event.isCancelled());
+        }
+
+        @JRubyMethod(name = "include?", required = 1)
+        public IRubyObject ruby_includes(ThreadContext context, RubyString reference)
+        {
+            return RubyBoolean.newBoolean(context.runtime, this.event.includes(reference.asJavaString()));
+        }
+
+        @JRubyMethod(name = "remove", required = 1)
+        public IRubyObject ruby_remove(ThreadContext context, RubyString reference)
+        {
+            return Rubyfier.deep(context.runtime, this.event.remove(reference.asJavaString()));
+        }
+
+        @JRubyMethod(name = "clone")
+        public IRubyObject ruby_clone(ThreadContext context)
+        {
+            try {
+                return RubyEvent.newRubyEvent(context.runtime, this.event.clone());
+            } catch (CloneNotSupportedException e) {
+                throw context.runtime.newRuntimeError(e.getMessage());
+            }
+        }
+
+        @JRubyMethod(name = "overwrite", required = 1)
+        public IRubyObject ruby_overwrite(ThreadContext context, IRubyObject value)
+        {
+            if (!(value instanceof RubyEvent)) {
+                throw context.runtime.newTypeError("wrong argument type " + value.getMetaClass() + " (expected LogStash::Event)");
+            }
+
+            return RubyEvent.newRubyEvent(context.runtime, this.event.overwrite(((RubyEvent) value).event));
+        }
+
+        @JRubyMethod(name = "append", required = 1)
+        public IRubyObject ruby_append(ThreadContext context, IRubyObject value)
+        {
+            if (!(value instanceof RubyEvent)) {
+                throw context.runtime.newTypeError("wrong argument type " + value.getMetaClass() + " (expected LogStash::Event)");
+            }
+
+            this.event.append(((RubyEvent) value).getEvent());
+
+            return this;
+        }
+
+        @JRubyMethod(name = "sprintf", required = 1)
+        public IRubyObject ruby_sprintf(ThreadContext context, IRubyObject format) throws IOException {
+            try {
+                return RubyString.newString(context.runtime, event.sprintf(format.toString()));
+            } catch (IOException e) {
+                throw new RaiseException(getRuntime(), LOGSTASH_ERROR, "timestamp field is missing", true);
+            }
+        }
+
+        @JRubyMethod(name = "to_s")
+        public IRubyObject ruby_to_s(ThreadContext context)
+        {
+            return RubyString.newString(context.runtime, event.toString());
+        }
+
+        @JRubyMethod(name = "to_hash")
+        public IRubyObject ruby_to_hash(ThreadContext context) throws IOException
+        {
+            return Rubyfier.deep(context.runtime, this.event.toMap());
+        }
+
+        @JRubyMethod(name = "to_hash_with_metadata")
+        public IRubyObject ruby_to_hash_with_metadata(ThreadContext context) throws IOException
+        {
+            Map data = this.event.toMap();
+            Map metadata = this.event.getMetadata();
+
+            if (!metadata.isEmpty()) {
+                data.put(Event.METADATA, metadata);
+            }
+            return Rubyfier.deep(context.runtime, data);
+        }
+
+        @JRubyMethod(name = "to_java")
+        public IRubyObject ruby_to_java(ThreadContext context)
+        {
+            return JavaUtil.convertJavaToUsableRubyObject(context.runtime, this.event);
+        }
+
+        @JRubyMethod(name = "to_json", rest = true)
+        public IRubyObject ruby_to_json(ThreadContext context, IRubyObject[] args)
+        {
+            try {
+                return RubyString.newString(context.runtime, event.toJson());
+            } catch (Exception e) {
+                throw new RaiseException(context.runtime, GENERATOR_ERROR, e.getMessage(), true);
+            }
+        }
+
+        // @param value [String] the json string. A json object/map will convert to an array containing a single Event.
+        // and a json array will convert each element into individual Event
+        // @return Array<Event> array of events
+        @JRubyMethod(name = "from_json", required = 1, meta = true)
+        public static IRubyObject ruby_from_json(ThreadContext context, IRubyObject recv, RubyString value)
+        {
+            Event[] events;
+            try {
+                events = Event.fromJson(value.asJavaString());
+            } catch (Exception e) {
+                throw new RaiseException(context.runtime, PARSER_ERROR, e.getMessage(), true);
+            }
+
+            RubyArray result = RubyArray.newArray(context.runtime, events.length);
+
+            if (events.length == 1) {
+                // micro optimization for the 1 event more common use-case.
+                result.set(0, RubyEvent.newRubyEvent(context.runtime, events[0]));
+            } else {
+                for (int i = 0; i < events.length; i++) {
+                    result.set(i, RubyEvent.newRubyEvent(context.runtime, events[i]));
+                }
+            }
+            return result;
+        }
+
+        @JRubyMethod(name = "validate_value", required = 1, meta = true)
+        public static IRubyObject ruby_validate_value(ThreadContext context, IRubyObject recv, IRubyObject value)
+        {
+            // TODO: add UTF-8 validation
+            return value;
+        }
+
+        @JRubyMethod(name = "tag", required = 1)
+        public IRubyObject ruby_tag(ThreadContext context, RubyString value)
+        {
+            this.event.tag(((RubyString) value).asJavaString());
+            return context.runtime.getNil();
+        }
+
+        @JRubyMethod(name = "timestamp")
+        public IRubyObject ruby_timestamp(ThreadContext context) throws IOException {
+            return new JrubyTimestampExtLibrary.RubyTimestamp(context.getRuntime(), this.event.getTimestamp());
+        }
+
+        @JRubyMethod(name = "timestamp=", required = 1)
+        public IRubyObject ruby_set_timestamp(ThreadContext context, IRubyObject value)
+        {
+            if (!(value instanceof JrubyTimestampExtLibrary.RubyTimestamp)) {
+                throw context.runtime.newTypeError("wrong argument type " + value.getMetaClass() + " (expected LogStash::Timestamp)");
+            }
+            this.event.setTimestamp(((JrubyTimestampExtLibrary.RubyTimestamp)value).getTimestamp());
+            return value;
+        }
+
+        // set a new logger for all Event instances
+        // there is no point in changing it at runtime for other reasons than in tests/specs.
+        @JRubyMethod(name = "logger=", required = 1, meta = true)
+        public static IRubyObject ruby_set_logger(ThreadContext context, IRubyObject recv, IRubyObject value)
+        {
+            Event.setLogger(new ProxyLogger((RubyObject)value));
+            return value;
+        }
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyTimestampExtLibrary.java b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyTimestampExtLibrary.java
new file mode 100644
index 00000000000..9748a815ccb
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyTimestampExtLibrary.java
@@ -0,0 +1,246 @@
+package com.logstash.ext;
+
+import com.logstash.*;
+import org.jruby.*;
+import org.jruby.anno.JRubyClass;
+import org.jruby.anno.JRubyMethod;
+import org.jruby.exceptions.RaiseException;
+import org.jruby.ext.bigdecimal.RubyBigDecimal;
+import org.jruby.javasupport.JavaUtil;
+import org.jruby.runtime.Arity;
+import org.jruby.runtime.ObjectAllocator;
+import org.jruby.runtime.ThreadContext;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.jruby.runtime.load.Library;
+
+import java.io.IOException;
+
+public class JrubyTimestampExtLibrary implements Library {
+    public void load(Ruby runtime, boolean wrap) throws IOException {
+        RubyModule module = runtime.defineModule("LogStash");
+        RubyClass clazz = runtime.defineClassUnder("Timestamp", runtime.getObject(), new ObjectAllocator() {
+            public IRubyObject allocate(Ruby runtime, RubyClass rubyClass) {
+                return new RubyTimestamp(runtime, rubyClass);
+            }
+        }, module);
+        clazz.defineAnnotatedMethods(RubyTimestamp.class);
+    }
+
+    @JRubyClass(name = "Timestamp", parent = "Object")
+    public static class RubyTimestamp extends RubyObject {
+
+        private Timestamp timestamp;
+
+        public RubyTimestamp(Ruby runtime, RubyClass klass) {
+            super(runtime, klass);
+        }
+
+        public RubyTimestamp(Ruby runtime, RubyClass klass, Timestamp timestamp) {
+            this(runtime, klass);
+            this.timestamp = timestamp;
+        }
+
+        public RubyTimestamp(Ruby runtime, Timestamp timestamp) {
+            this(runtime, runtime.getModule("LogStash").getClass("Timestamp"), timestamp);
+        }
+
+        public RubyTimestamp(Ruby runtime) {
+            this(runtime, new Timestamp());
+        }
+
+        public static RubyTimestamp newRubyTimestamp(Ruby runtime) {
+            return new RubyTimestamp(runtime);
+        }
+
+        public static RubyTimestamp newRubyTimestamp(Ruby runtime, long epoch) {
+            // Ruby epoch is in seconds, Java in milliseconds
+            return new RubyTimestamp(runtime, new Timestamp(epoch * 1000));
+        }
+
+        public static RubyTimestamp newRubyTimestamp(Ruby runtime, Timestamp timestamp) {
+            return new RubyTimestamp(runtime, timestamp);
+        }
+
+        public Timestamp getTimestamp() {
+            return timestamp;
+        }
+
+        public void setTimestamp(Timestamp timestamp) {
+            this.timestamp = timestamp;
+        }
+
+        // def initialize(time = Time.new)
+        @JRubyMethod(name = "initialize", optional = 1)
+        public IRubyObject ruby_initialize(ThreadContext context, IRubyObject[] args)
+        {
+            args = Arity.scanArgs(context.runtime, args, 0, 1);
+            IRubyObject time = args[0];
+
+            if (time.isNil()) {
+                this.timestamp = new Timestamp();
+            } else if (time instanceof RubyTime) {
+                this.timestamp = new Timestamp(((RubyTime)time).getDateTime());
+            } else if (time instanceof RubyString) {
+                try {
+                    this.timestamp = new Timestamp(((RubyString) time).toString());
+                } catch (IllegalArgumentException e) {
+                    throw new RaiseException(
+                            getRuntime(),
+                            getRuntime().getModule("LogStash").getClass("TimestampParserError"),
+                            "invalid timestamp string format " + time,
+                            true
+                    );
+
+                }
+            } else {
+                throw context.runtime.newTypeError("wrong argument type " + time.getMetaClass() + " (expected Time)");
+            }
+            return context.nil;
+        }
+
+        @JRubyMethod(name = "time")
+        public IRubyObject ruby_time(ThreadContext context)
+        {
+            return RubyTime.newTime(context.runtime, this.timestamp.getTime());
+        }
+
+        @JRubyMethod(name = "to_i")
+        public IRubyObject ruby_to_i(ThreadContext context)
+        {
+            return RubyFixnum.newFixnum(context.runtime, this.timestamp.getTime().getMillis() / 1000);
+        }
+
+        @JRubyMethod(name = "to_f")
+        public IRubyObject ruby_to_f(ThreadContext context)
+        {
+            return RubyFloat.newFloat(context.runtime, this.timestamp.getTime().getMillis() / 1000.0d);
+        }
+
+        @JRubyMethod(name = "to_s")
+        public IRubyObject ruby_to_s(ThreadContext context)
+        {
+            return ruby_to_iso8601(context);
+        }
+
+        @JRubyMethod(name = "to_iso8601")
+        public IRubyObject ruby_to_iso8601(ThreadContext context)
+        {
+            return RubyString.newString(context.runtime, this.timestamp.toIso8601());
+        }
+
+        @JRubyMethod(name = "to_java")
+        public IRubyObject ruby_to_java(ThreadContext context)
+        {
+            return JavaUtil.convertJavaToUsableRubyObject(context.runtime, this.timestamp);
+        }
+
+        @JRubyMethod(name = "to_json", rest = true)
+        public IRubyObject ruby_to_json(ThreadContext context, IRubyObject[] args)
+        {
+            return RubyString.newString(context.runtime,  "\"" + this.timestamp.toIso8601() + "\"");
+        }
+
+        public static Timestamp newTimestamp(IRubyObject time)
+        {
+            if (time.isNil()) {
+                return new Timestamp();
+            } else if (time instanceof RubyTime) {
+                return new Timestamp(((RubyTime)time).getDateTime());
+            } else if (time instanceof RubyString) {
+                return new Timestamp(((RubyString) time).toString());
+            } else if (time instanceof RubyTimestamp) {
+                return new Timestamp(((RubyTimestamp) time).timestamp);
+            } else {
+               return null;
+            }
+        }
+
+
+        @JRubyMethod(name = "coerce", required = 1, meta = true)
+        public static IRubyObject ruby_coerce(ThreadContext context, IRubyObject recv, IRubyObject time)
+        {
+            try {
+                Timestamp ts = newTimestamp(time);
+                return (ts == null) ? context.runtime.getNil() : RubyTimestamp.newRubyTimestamp(context.runtime, ts);
+             } catch (IllegalArgumentException e) {
+                throw new RaiseException(
+                        context.runtime,
+                        context.runtime.getModule("LogStash").getClass("TimestampParserError"),
+                        "invalid timestamp format " + e.getMessage(),
+                        true
+                );
+
+            }
+         }
+
+        @JRubyMethod(name = "parse_iso8601", required = 1, meta = true)
+        public static IRubyObject ruby_parse_iso8601(ThreadContext context, IRubyObject recv, IRubyObject time)
+        {
+            if (time instanceof RubyString) {
+                try {
+                    return RubyTimestamp.newRubyTimestamp(context.runtime, newTimestamp(time));
+                } catch (IllegalArgumentException e) {
+                    throw new RaiseException(
+                            context.runtime,
+                            context.runtime.getModule("LogStash").getClass("TimestampParserError"),
+                            "invalid timestamp format " + e.getMessage(),
+                            true
+                    );
+
+                }
+            } else {
+                throw context.runtime.newTypeError("wrong argument type " + time.getMetaClass() + " (expected String)");
+            }
+        }
+
+        @JRubyMethod(name = "at", required = 1, optional = 1, meta = true)
+        public static IRubyObject ruby_at(ThreadContext context, IRubyObject recv, IRubyObject[] args)
+        {
+            RubyTime t;
+            if (args.length == 1) {
+                IRubyObject epoch = args[0];
+
+                if (epoch instanceof RubyBigDecimal) {
+                    // bug in JRuby prevents correcly parsing a BigDecimal fractional part, see https://github.com/elastic/logstash/issues/4565
+                    double usec = ((RubyBigDecimal)epoch).frac().convertToFloat().getDoubleValue() * 1000000;
+                    t = (RubyTime)RubyTime.at(context, context.runtime.getTime(), ((RubyBigDecimal)epoch).to_int(), new RubyFloat(context.runtime, usec));
+                } else {
+                    t = (RubyTime)RubyTime.at(context, context.runtime.getTime(), epoch);
+                }
+            } else {
+                t = (RubyTime)RubyTime.at(context, context.runtime.getTime(), args[0], args[1]);
+            }
+            return RubyTimestamp.newRubyTimestamp(context.runtime, new Timestamp(t.getDateTime()));
+        }
+
+        @JRubyMethod(name = "now", meta = true)
+        public static IRubyObject ruby_now(ThreadContext context, IRubyObject recv)
+        {
+            return RubyTimestamp.newRubyTimestamp(context.runtime);
+        }
+
+        @JRubyMethod(name = "utc")
+        public IRubyObject ruby_utc(ThreadContext context)
+        {
+            return this;
+        }
+
+        @JRubyMethod(name = "gmtime")
+        public IRubyObject ruby_gmtime(ThreadContext context)
+        {
+            return this;
+        }
+
+        @JRubyMethod(name = {"usec", "tv_usec"})
+        public IRubyObject ruby_usec(ThreadContext context)
+        {
+            return RubyFixnum.newFixnum(context.runtime, this.timestamp.usec());
+        }
+
+        @JRubyMethod(name = "year")
+        public IRubyObject ruby_year(ThreadContext context)
+        {
+            return RubyFixnum.newFixnum(context.runtime, this.timestamp.getTime().getYear());
+        }
+    }
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/AccessorsTest.java b/logstash-core-event-java/src/test/java/com/logstash/AccessorsTest.java
new file mode 100644
index 00000000000..4e7192c70b4
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/AccessorsTest.java
@@ -0,0 +1,209 @@
+package com.logstash;
+
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class AccessorsTest {
+
+    public class TestableAccessors extends Accessors {
+
+        public TestableAccessors(Map data) {
+            super(data);
+        }
+
+        public Map<String, Object> getLut() {
+            return lut;
+        }
+
+        public Object lutGet(String reference) {
+            return this.lut.get(reference);
+        }
+    }
+
+    @Test
+    public void testBareGet() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", "bar");
+        String reference = "foo";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), "bar");
+        assertEquals(accessors.lutGet(reference), data);
+    }
+
+    @Test
+    public void testAbsentBareGet() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", "bar");
+        String reference = "baz";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), null);
+        assertEquals(accessors.lutGet(reference), data);
+    }
+
+    @Test
+    public void testBareBracketsGet() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", "bar");
+        String reference = "[foo]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), "bar");
+        assertEquals(accessors.lutGet(reference), data);
+    }
+
+    @Test
+    public void testDeepMapGet() throws Exception {
+        Map data = new HashMap();
+        Map inner = new HashMap();
+        data.put("foo", inner);
+        inner.put("bar", "baz");
+
+        String reference = "[foo][bar]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), "baz");
+        assertEquals(accessors.lutGet(reference), inner);
+    }
+
+    @Test
+    public void testAbsentDeepMapGet() throws Exception {
+        Map data = new HashMap();
+        Map inner = new HashMap();
+        data.put("foo", inner);
+        inner.put("bar", "baz");
+
+        String reference = "[foo][foo]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), null);
+        assertEquals(accessors.lutGet(reference), inner);
+    }
+
+    @Test
+    public void testDeepListGet() throws Exception {
+        Map data = new HashMap();
+        List inner = new ArrayList();
+        data.put("foo", inner);
+        inner.add("bar");
+
+        String reference = "[foo][0]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), "bar");
+        assertEquals(accessors.lutGet(reference), inner);
+    }
+
+    @Test
+    public void testAbsentDeepListGet() throws Exception {
+        Map data = new HashMap();
+        List inner = new ArrayList();
+        data.put("foo", inner);
+        inner.add("bar");
+
+        String reference = "[foo][1]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.get(reference), null);
+        assertEquals(accessors.lutGet(reference), inner);
+    }
+
+    @Test
+    public void testBarePut() throws Exception {
+        Map data = new HashMap();
+        String reference = "foo";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.set(reference, "bar"), "bar");
+        assertEquals(accessors.lutGet(reference), data);
+        assertEquals(accessors.get(reference), "bar");
+    }
+
+    @Test
+    public void testBareBracketsPut() throws Exception {
+        Map data = new HashMap();
+        String reference = "[foo]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.set(reference, "bar"), "bar");
+        assertEquals(accessors.lutGet(reference), data);
+        assertEquals(accessors.get(reference), "bar");
+    }
+
+    @Test
+    public void testDeepMapSet() throws Exception {
+        Map data = new HashMap();
+
+        String reference = "[foo][bar]";
+
+        TestableAccessors accessors = new TestableAccessors(data);
+        assertEquals(accessors.lutGet(reference), null);
+        assertEquals(accessors.set(reference, "baz"), "baz");
+        assertEquals(accessors.lutGet(reference), data.get("foo"));
+        assertEquals(accessors.get(reference), "baz");
+    }
+
+    @Test
+    public void testDel() throws Exception {
+        Map data = new HashMap();
+        List inner = new ArrayList();
+        data.put("foo", inner);
+        inner.add("bar");
+        data.put("bar", "baz");
+        TestableAccessors accessors = new TestableAccessors(data);
+
+        assertEquals(accessors.del("[foo][0]"), "bar");
+        assertEquals(accessors.del("[foo][0]"), null);
+        assertEquals(accessors.get("[foo]"), new ArrayList<>());
+        assertEquals(accessors.del("[bar]"), "baz");
+        assertEquals(accessors.get("[bar]"), null);
+    }
+
+    @Test
+    public void testNilInclude() throws Exception {
+        Map data = new HashMap();
+        data.put("nilfield", null);
+        TestableAccessors accessors = new TestableAccessors(data);
+
+        assertEquals(accessors.includes("nilfield"), true);
+    }
+
+    @Test
+    public void testInvalidPath() throws Exception {
+        Map data = new HashMap();
+        Accessors accessors = new Accessors(data);
+
+        assertEquals(accessors.set("[foo]", 1), 1);
+        assertEquals(accessors.get("[foo][bar]"), null);
+    }
+
+    @Test
+    public void testStaleTargetCache() throws Exception {
+        Map data = new HashMap();
+
+        Accessors accessors = new Accessors(data);
+
+        assertEquals(accessors.get("[foo][bar]"), null);
+        assertEquals(accessors.set("[foo][bar]", "baz"), "baz");
+        assertEquals(accessors.get("[foo][bar]"), "baz");
+
+        assertEquals(accessors.set("[foo]", "boom"), "boom");
+        assertEquals(accessors.get("[foo][bar]"), null);
+        assertEquals(accessors.get("[foo]"), "boom");
+    }
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/EventTest.java b/logstash-core-event-java/src/test/java/com/logstash/EventTest.java
new file mode 100644
index 00000000000..505a0593535
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/EventTest.java
@@ -0,0 +1,189 @@
+package com.logstash;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.*;
+import static org.junit.Assert.*;
+import static net.javacrumbs.jsonunit.JsonAssert.assertJsonEquals;
+
+public class EventTest {
+    @Test
+    public void testBareToJson() throws Exception {
+        Event e = new Event();
+        assertJsonEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"@version\":\"1\"}", e.toJson());
+    }
+
+    @Test
+    public void testSimpleStringFieldToJson() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", "bar");
+        Event e = new Event(data);
+        assertJsonEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":\"bar\",\"@version\":\"1\"}", e.toJson());
+    }
+
+    @Test
+    public void testSimpleIntegerFieldToJson() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", 1);
+        Event e = new Event(data);
+        assertJsonEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":1,\"@version\":\"1\"}", e.toJson());
+    }
+
+    @Test
+    public void testSimpleDecimalFieldToJson() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", 1.0);
+        Event e = new Event(data);
+        assertJsonEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":1.0,\"@version\":\"1\"}", e.toJson());
+    }
+
+    @Test
+    public void testSimpleMultipleFieldToJson() throws Exception {
+        Map data = new HashMap();
+        data.put("foo", 1.0);
+        data.put("bar", "bar");
+        data.put("baz", 1);
+        Event e = new Event(data);
+        assertJsonEquals("{\"bar\":\"bar\",\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":1.0,\"@version\":\"1\",\"baz\":1}", e.toJson());
+    }
+
+    @Test
+    public void testDeepMapFieldToJson() throws Exception {
+        Event e = new Event();
+        e.setField("[foo][bar][baz]", 1);
+        assertJsonEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":{\"bar\":{\"baz\":1}},\"@version\":\"1\"}", e.toJson());
+
+        e = new Event();
+        e.setField("[foo][0][baz]", 1);
+        assertJsonEquals("{\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"foo\":{\"0\":{\"baz\":1}},\"@version\":\"1\"}", e.toJson());
+    }
+
+    @Test
+    public void testGetFieldList() throws Exception {
+        Map data = new HashMap();
+        List l = new ArrayList();
+        data.put("foo", l);
+        l.add(1);
+        Event e = new Event(data);
+        assertEquals(1, e.getField("[foo][0]"));
+    }
+
+    @Test
+    public void testDeepGetField() throws Exception {
+        Map data = new HashMap();
+        List l = new ArrayList();
+        data.put("foo", l);
+        Map m = new HashMap();
+        m.put("bar", "baz");
+        l.add(m);
+        Event e = new Event(data);
+        assertEquals("baz", e.getField("[foo][0][bar]"));
+    }
+
+
+    @Test
+    public void testClone() throws Exception {
+        Map data = new HashMap();
+        List l = new ArrayList();
+        data.put("array", l);
+
+        Map m = new HashMap();
+        m.put("foo", "bar");
+        l.add(m);
+
+        data.put("foo", 1.0);
+        data.put("bar", "bar");
+        data.put("baz", 1);
+
+        Event e = new Event(data);
+
+        Event f = e.clone();
+
+        assertJsonEquals("{\"bar\":\"bar\",\"@timestamp\":\"" + e.getTimestamp().toIso8601() + "\",\"array\":[{\"foo\":\"bar\"}],\"foo\":1.0,\"@version\":\"1\",\"baz\":1}", f.toJson());
+        assertJsonEquals(f.toJson(), e.toJson());
+    }
+
+    @Test
+    public void testAppend() throws Exception {
+        Map data1 = new HashMap();
+        data1.put("field1", Arrays.asList("original1", "original2"));
+
+        Map data2 = new HashMap();
+        data2.put("field1", "original1");
+
+        Event e = new Event(data1);
+        Event e2 = new Event(data2);
+        e.append(e2);
+
+        assertEquals(Arrays.asList("original1", "original2"), e.getField("field1"));
+    }
+
+    @Test
+    public void testFromJsonWithNull() throws Exception {
+        Event[] events = Event.fromJson(null);
+        assertEquals(0, events.length);
+    }
+
+    @Test
+    public void testFromJsonWithEmptyString() throws Exception {
+        Event[] events = Event.fromJson("");
+        assertEquals(0, events.length);
+    }
+
+    @Test
+    public void testFromJsonWithBlankString() throws Exception {
+        Event[] events = Event.fromJson("   ");
+        assertEquals(0, events.length);
+    }
+
+    @Test
+    public void testFromJsonWithValidJsonMap() throws Exception {
+        Event e = Event.fromJson("{\"@timestamp\":\"2015-05-28T23:02:05.350Z\",\"foo\":\"bar\"}")[0];
+
+        assertEquals("bar", e.getField("[foo]"));
+        assertEquals("2015-05-28T23:02:05.350Z", e.getTimestamp().toIso8601());
+    }
+
+    @Test
+    public void testFromJsonWithValidJsonArrayOfMap() throws Exception {
+        Event[] l = Event.fromJson("[{\"@timestamp\":\"2015-05-28T23:02:05.350Z\",\"foo\":\"bar\"}]");
+
+        assertEquals(1, l.length);
+        assertEquals("bar", l[0].getField("[foo]"));
+        assertEquals("2015-05-28T23:02:05.350Z", l[0].getTimestamp().toIso8601());
+
+        l = Event.fromJson("[{}]");
+
+        assertEquals(1, l.length);
+        assertEquals(null, l[0].getField("[foo]"));
+
+        l = Event.fromJson("[{\"@timestamp\":\"2015-05-28T23:02:05.350Z\",\"foo\":\"bar\"}, {\"@timestamp\":\"2016-05-28T23:02:05.350Z\",\"foo\":\"baz\"}]");
+
+        assertEquals(2, l.length);
+        assertEquals("bar", l[0].getField("[foo]"));
+        assertEquals("2015-05-28T23:02:05.350Z", l[0].getTimestamp().toIso8601());
+        assertEquals("baz", l[1].getField("[foo]"));
+        assertEquals("2016-05-28T23:02:05.350Z", l[1].getTimestamp().toIso8601());
+    }
+
+    @Test(expected=IOException.class)
+    public void testFromJsonWithInvalidJsonString() throws Exception {
+        Event.fromJson("gabeutch");
+    }
+
+    @Test(expected=IOException.class)
+    public void testFromJsonWithInvalidJsonArray1() throws Exception {
+        Event.fromJson("[1,2]");
+    }
+
+    @Test(expected=IOException.class)
+    public void testFromJsonWithInvalidJsonArray2() throws Exception {
+        Event.fromJson("[\"gabeutch\"]");
+    }
+
+    @Test(expected=IOException.class)
+    public void testFromJsonWithPartialInvalidJsonArray() throws Exception {
+        Event.fromJson("[{\"foo\":\"bar\"}, 1]");
+    }
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/FieldReferenceTest.java b/logstash-core-event-java/src/test/java/com/logstash/FieldReferenceTest.java
new file mode 100644
index 00000000000..73f04e3a7c4
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/FieldReferenceTest.java
@@ -0,0 +1,40 @@
+package com.logstash;
+
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.*;
+
+public class FieldReferenceTest {
+
+    @Test
+    public void testParseSingleBareField() throws Exception {
+        FieldReference f = FieldReference.parse("foo");
+        assertTrue(f.getPath().isEmpty());
+        assertEquals(f.getKey(), "foo");
+    }
+
+    @Test
+    public void testParseSingleFieldPath() throws Exception {
+        FieldReference f = FieldReference.parse("[foo]");
+        assertTrue(f.getPath().isEmpty());
+        assertEquals(f.getKey(), "foo");
+    }
+
+    @Test
+    public void testParse2FieldsPath() throws Exception {
+        FieldReference f = FieldReference.parse("[foo][bar]");
+        assertArrayEquals(f.getPath().toArray(), new String[]{"foo"});
+        assertEquals(f.getKey(), "bar");
+    }
+
+    @Test
+    public void testParse3FieldsPath() throws Exception {
+        FieldReference f = FieldReference.parse("[foo][bar]]baz]");
+        assertArrayEquals(f.getPath().toArray(), new String[]{"foo", "bar"});
+        assertEquals(f.getKey(), "baz");
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/test/java/com/logstash/JavafierTest.java b/logstash-core-event-java/src/test/java/com/logstash/JavafierTest.java
new file mode 100644
index 00000000000..40aaa7b6c53
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/JavafierTest.java
@@ -0,0 +1,18 @@
+package com.logstash;
+
+import org.jruby.Ruby;
+import org.jruby.RubyBignum;
+import java.math.BigInteger;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+public class JavafierTest {
+    @Test
+    public void testRubyBignum() {
+        RubyBignum v = RubyBignum.newBignum(Ruby.getGlobalRuntime(), "-9223372036854776000");
+
+        Object result = Javafier.deep(v);
+        assertEquals(BigInteger.class, result.getClass());
+        assertEquals( "-9223372036854776000", result.toString());
+    }
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/KeyNodeTest.java b/logstash-core-event-java/src/test/java/com/logstash/KeyNodeTest.java
new file mode 100644
index 00000000000..23cb27ac997
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/KeyNodeTest.java
@@ -0,0 +1,47 @@
+package com.logstash;
+
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import static org.junit.Assert.assertEquals;
+
+public class KeyNodeTest {
+
+    @Test
+    public void testNoElementJoin() throws IOException {
+        assertEquals("", KeyNode.join(new ArrayList(), ","));
+    }
+
+    @Test
+    public void testOneElementJoin() throws IOException {
+        assertEquals("foo", KeyNode.join(Arrays.asList("foo"), ","));
+    }
+
+    @Test
+    public void testOneNullElementJoin() throws IOException {
+        assertEquals("", KeyNode.join(Arrays.asList(new Object[] { null }), ","));
+    }
+
+    @Test
+    public void testTwoElementJoin() throws IOException {
+        assertEquals("foo,bar", KeyNode.join(Arrays.asList("foo", "bar"), ","));
+    }
+
+    @Test
+    public void testTwoElementWithLeadingNullJoin() throws IOException {
+        assertEquals(",foo", KeyNode.join(Arrays.asList(null, "foo"), ","));
+    }
+
+    @Test
+    public void testTwoElementWithTailingNullJoin() throws IOException {
+        assertEquals("foo,", KeyNode.join(Arrays.asList("foo", null), ","));
+    }
+
+    @Test
+    public void testListInListJoin() throws IOException {
+        assertEquals("foo,bar,", KeyNode.join(Arrays.asList("foo", Arrays.asList("bar", null)), ","));
+    }
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/RubyfierTest.java b/logstash-core-event-java/src/test/java/com/logstash/RubyfierTest.java
new file mode 100644
index 00000000000..5773ce65ae5
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/RubyfierTest.java
@@ -0,0 +1,230 @@
+package com.logstash;
+
+import org.jruby.*;
+import org.jruby.ext.bigdecimal.RubyBigDecimal;
+import org.jruby.javasupport.JavaUtil;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.junit.Test;
+
+import java.lang.reflect.Method;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.junit.Assert.*;
+
+public class RubyfierTest {
+
+    @Test
+    public void testDeepWithString() {
+        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), "foo");
+        assertEquals(RubyString.class, result.getClass());
+        assertEquals("foo", result.toString());
+    }
+
+    @Test
+    public void testDeepMapWithString()
+            throws Exception
+    {
+        Map data = new HashMap();
+        data.put("foo", "bar");
+        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+
+        // Hack to be able to retrieve the original, unconverted Ruby object from Map
+        // it seems the only method providing this is internalGet but it is declared protected.
+        // I know this is bad practice but I think this is practically acceptable.
+        Method internalGet = RubyHash.class.getDeclaredMethod("internalGet", IRubyObject.class);
+        internalGet.setAccessible(true);
+        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(Ruby.getGlobalRuntime(), "foo"));
+
+        assertEquals(RubyString.class, result.getClass());
+        assertEquals("bar", result.toString());
+    }
+
+    @Test
+    public void testDeepListWithString()
+            throws Exception
+    {
+        List data = new ArrayList();
+        data.add("foo");
+
+        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+
+        // toJavaArray does not convert inner elemenst to Java types \o/
+        assertEquals(RubyString.class, rubyArray.toJavaArray()[0].getClass());
+        assertEquals("foo", rubyArray.toJavaArray()[0].toString());
+    }
+
+    @Test
+    public void testDeepWithInteger() {
+        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), 1);
+        assertEquals(RubyFixnum.class, result.getClass());
+        assertEquals(1L, ((RubyFixnum)result).getLongValue());
+    }
+
+    @Test
+    public void testDeepMapWithInteger()
+            throws Exception
+    {
+        Map data = new HashMap();
+        data.put("foo", 1);
+        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+
+        // Hack to be able to retrieve the original, unconverted Ruby object from Map
+        // it seems the only method providing this is internalGet but it is declared protected.
+        // I know this is bad practice but I think this is practically acceptable.
+        Method internalGet = RubyHash.class.getDeclaredMethod("internalGet", IRubyObject.class);
+        internalGet.setAccessible(true);
+        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(Ruby.getGlobalRuntime(), "foo"));
+
+        assertEquals(RubyFixnum.class, result.getClass());
+        assertEquals(1L, ((RubyFixnum)result).getLongValue());
+    }
+
+    @Test
+    public void testDeepListWithInteger()
+            throws Exception
+    {
+        List data = new ArrayList();
+        data.add(1);
+
+        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+
+        // toJavaArray does not convert inner elemenst to Java types \o/
+        assertEquals(RubyFixnum.class, rubyArray.toJavaArray()[0].getClass());
+        assertEquals(1L, ((RubyFixnum)rubyArray.toJavaArray()[0]).getLongValue());
+    }
+
+    @Test
+    public void testDeepWithFloat() {
+        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), 1.0F);
+        assertEquals(RubyFloat.class, result.getClass());
+        assertEquals(1.0D, ((RubyFloat)result).getDoubleValue(), 0);
+    }
+
+    @Test
+    public void testDeepMapWithFloat()
+            throws Exception
+    {
+        Map data = new HashMap();
+        data.put("foo", 1.0F);
+        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+
+        // Hack to be able to retrieve the original, unconverted Ruby object from Map
+        // it seems the only method providing this is internalGet but it is declared protected.
+        // I know this is bad practice but I think this is practically acceptable.
+        Method internalGet = RubyHash.class.getDeclaredMethod("internalGet", IRubyObject.class);
+        internalGet.setAccessible(true);
+        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(Ruby.getGlobalRuntime(), "foo"));
+
+        assertEquals(RubyFloat.class, result.getClass());
+        assertEquals(1.0D, ((RubyFloat)result).getDoubleValue(), 0);
+    }
+
+    @Test
+    public void testDeepListWithFloat()
+            throws Exception
+    {
+        List data = new ArrayList();
+        data.add(1.0F);
+
+        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+
+        // toJavaArray does not convert inner elemenst to Java types \o/
+        assertEquals(RubyFloat.class, rubyArray.toJavaArray()[0].getClass());
+        assertEquals(1.0D, ((RubyFloat)rubyArray.toJavaArray()[0]).getDoubleValue(), 0);
+    }
+
+    @Test
+    public void testDeepWithDouble() {
+        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), 1.0D);
+        assertEquals(RubyFloat.class, result.getClass());
+        assertEquals(1.0D, ((RubyFloat)result).getDoubleValue(), 0);
+    }
+
+    @Test
+    public void testDeepMapWithDouble()
+            throws Exception
+    {
+        Map data = new HashMap();
+        data.put("foo", 1.0D);
+        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+
+        // Hack to be able to retrieve the original, unconverted Ruby object from Map
+        // it seems the only method providing this is internalGet but it is declared protected.
+        // I know this is bad practice but I think this is practically acceptable.
+        Method internalGet = RubyHash.class.getDeclaredMethod("internalGet", IRubyObject.class);
+        internalGet.setAccessible(true);
+        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(Ruby.getGlobalRuntime(), "foo"));
+
+        assertEquals(RubyFloat.class, result.getClass());
+        assertEquals(1.0D, ((RubyFloat)result).getDoubleValue(), 0);
+    }
+
+    @Test
+    public void testDeepListWithDouble()
+            throws Exception
+    {
+        List data = new ArrayList();
+        data.add(1.0D);
+
+        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+
+        // toJavaArray does not convert inner elemenst to Java types \o/
+        assertEquals(RubyFloat.class, rubyArray.toJavaArray()[0].getClass());
+        assertEquals(1.0D, ((RubyFloat)rubyArray.toJavaArray()[0]).getDoubleValue(), 0);
+    }
+
+    @Test
+    public void testDeepWithBigDecimal() {
+        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), new BigDecimal(1));
+        assertEquals(RubyBigDecimal.class, result.getClass());
+        assertEquals(1.0D, ((RubyBigDecimal)result).getDoubleValue(), 0);
+    }
+
+    @Test
+    public void testDeepMapWithBigDecimal()
+            throws Exception
+    {
+        Map data = new HashMap();
+        data.put("foo", new BigDecimal(1));
+
+        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+
+        // Hack to be able to retrieve the original, unconverted Ruby object from Map
+        // it seems the only method providing this is internalGet but it is declared protected.
+        // I know this is bad practice but I think this is practically acceptable.
+        Method internalGet = RubyHash.class.getDeclaredMethod("internalGet", IRubyObject.class);
+        internalGet.setAccessible(true);
+        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(Ruby.getGlobalRuntime(), "foo"));
+
+        assertEquals(RubyBigDecimal.class, result.getClass());
+        assertEquals(1.0D, ((RubyBigDecimal)result).getDoubleValue(), 0);
+    }
+
+    @Test
+    public void testDeepListWithBigDecimal()
+            throws Exception
+    {
+        List data = new ArrayList();
+        data.add(new BigDecimal(1));
+
+        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+
+        // toJavaArray does not convert inner elemenst to Java types \o/
+        assertEquals(RubyBigDecimal.class, rubyArray.toJavaArray()[0].getClass());
+        assertEquals(1.0D, ((RubyBigDecimal)rubyArray.toJavaArray()[0]).getDoubleValue(), 0);
+    }
+
+
+    @Test
+    public void testDeepWithBigInteger() {
+        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), new BigInteger("1"));
+        assertEquals(RubyBignum.class, result.getClass());
+        assertEquals(1L, ((RubyBignum)result).getLongValue());
+    }
+
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/StringInterpolationTest.java b/logstash-core-event-java/src/test/java/com/logstash/StringInterpolationTest.java
new file mode 100644
index 00000000000..52d4563db4b
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/StringInterpolationTest.java
@@ -0,0 +1,143 @@
+package com.logstash;
+
+
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeZone;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.junit.Assert.*;
+
+
+public class StringInterpolationTest {
+    @Test
+    public void testCompletelyStaticTemplate() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/path/awesome";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals(path, si.evaluate(event, path));
+    }
+
+    @Test
+    public void testOneLevelField() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{bar}/awesome";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/foo/awesome", si.evaluate(event, path));
+    }
+
+    @Test
+    public void testMultipleLevelField() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{bar}/%{awesome}";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/foo/logstash", si.evaluate(event, path));
+    }
+
+    @Test
+    public void testMissingKey() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{do-not-exist}";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/%{do-not-exist}", si.evaluate(event, path));
+    }
+
+    @Test
+    public void testDateFormater() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{+YYYY}";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/2015", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestMixDateAndFields() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{+YYYY}/weeee/%{bar}";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/2015/weeee/foo", si.evaluate(event, path));
+    }
+
+    @Test
+    public void testUnclosedTag() throws IOException {
+        Event event = getTestEvent();
+        String path = "/full/%{+YYY/web";
+        StringInterpolation si = StringInterpolation.getInstance();
+
+        assertEquals("/full/%{+YYY/web", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestStringIsOneDateTag() throws IOException {
+        Event event = getTestEvent();
+        String path = "%{+YYYY}";
+        StringInterpolation si = StringInterpolation.getInstance();
+        assertEquals("2015", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestFieldRef() throws IOException {
+        Event event = getTestEvent();
+        String path = "%{[j][k1]}";
+        StringInterpolation si = StringInterpolation.getInstance();
+        assertEquals("v", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestEpoch() throws IOException {
+        Event event = getTestEvent();
+        String path = "%{+%s}";
+        StringInterpolation si = StringInterpolation.getInstance();
+        assertEquals("1443657600", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestValueIsArray() throws IOException {
+        ArrayList l = new ArrayList();
+        l.add("Hello");
+        l.add("world");
+
+        Event event = getTestEvent();
+        event.setField("message", l);
+
+        String path = "%{message}";
+        StringInterpolation si = StringInterpolation.getInstance();
+        assertEquals("Hello,world", si.evaluate(event, path));
+    }
+
+    @Test
+    public void TestValueIsHash() throws IOException {
+        Event event = getTestEvent();
+
+        String path = "%{j}";
+        StringInterpolation si = StringInterpolation.getInstance();
+        assertEquals("{\"k1\":\"v\"}", si.evaluate(event, path));
+    }
+
+    public Event getTestEvent() {
+        Map data = new HashMap();
+        Map inner = new HashMap();
+
+        inner.put("k1", "v");
+
+        data.put("bar", "foo");
+        data.put("awesome", "logstash");
+        data.put("j", inner);
+        data.put("@timestamp", new DateTime(2015, 10, 1, 0, 0, 0, DateTimeZone.UTC));
+
+
+        Event event = new Event(data);
+
+        return event;
+    }
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/TimestampTest.java b/logstash-core-event-java/src/test/java/com/logstash/TimestampTest.java
new file mode 100644
index 00000000000..539fbe227cb
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/TimestampTest.java
@@ -0,0 +1,46 @@
+package com.logstash;
+
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeZone;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+public class TimestampTest {
+
+
+    @Test
+    public void testCircularIso8601() throws Exception {
+        Timestamp t1 = new Timestamp();
+        Timestamp t2 = new Timestamp(t1.toIso8601());
+        assertEquals(t1.getTime(), t2.getTime());
+    }
+
+    @Test
+    public void testToIso8601() throws Exception {
+        Timestamp t = new Timestamp("2014-09-23T00:00:00-0800");
+        assertEquals("2014-09-23T08:00:00.000Z", t.toIso8601());
+    }
+
+    // Timestamp should always be in a UTC representation
+    @Test
+    public void testUTC() throws Exception {
+        Timestamp t;
+
+        t = new Timestamp();
+        assertEquals(DateTimeZone.UTC, t.getTime().getZone());
+
+        t = new Timestamp("2014-09-23T00:00:00-0800");
+        assertEquals(DateTimeZone.UTC, t.getTime().getZone());
+
+        t = new Timestamp("2014-09-23T08:00:00.000Z");
+        assertEquals(DateTimeZone.UTC, t.getTime().getZone());
+
+        t = new Timestamp(new Timestamp());
+        assertEquals(DateTimeZone.UTC, t.getTime().getZone());
+
+        long ms = DateTime.now(DateTimeZone.forID("EST")).getMillis();
+        t = new Timestamp(ms);
+        assertEquals(DateTimeZone.UTC, t.getTime().getZone());
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core-event/lib/logstash-core-event.rb b/logstash-core-event/lib/logstash-core-event.rb
new file mode 100644
index 00000000000..b2979326dac
--- /dev/null
+++ b/logstash-core-event/lib/logstash-core-event.rb
@@ -0,0 +1 @@
+require "logstash-core-event/logstash-core-event"
\ No newline at end of file
diff --git a/logstash-core-event/lib/logstash-core-event/logstash-core-event.rb b/logstash-core-event/lib/logstash-core-event/logstash-core-event.rb
new file mode 100644
index 00000000000..b0f773e203c
--- /dev/null
+++ b/logstash-core-event/lib/logstash-core-event/logstash-core-event.rb
@@ -0,0 +1,5 @@
+# encoding: utf-8
+module LogStash
+end
+
+require "logstash/event"
\ No newline at end of file
diff --git a/logstash-core-event/lib/logstash-core-event/version.rb b/logstash-core-event/lib/logstash-core-event/version.rb
new file mode 100644
index 00000000000..18e991d6b0c
--- /dev/null
+++ b/logstash-core-event/lib/logstash-core-event/version.rb
@@ -0,0 +1,8 @@
+# encoding: utf-8
+
+# The version of logstash core event gem.
+#
+# Note to authors: this should not include dashes because 'gem' barfs if
+# you include a dash in the version string.
+
+LOGSTASH_CORE_EVENT_VERSION = "3.0.0.dev"
diff --git a/lib/logstash/event.rb b/logstash-core-event/lib/logstash/event.rb
similarity index 85%
rename from lib/logstash/event.rb
rename to logstash-core-event/lib/logstash/event.rb
index c00d5531305..b1eb9d46cdb 100644
--- a/lib/logstash/event.rb
+++ b/logstash-core-event/lib/logstash/event.rb
@@ -63,9 +63,9 @@ class DeprecatedMethod < StandardError; end
   MIN_FLOAT_BEFORE_SCI_NOT = 0.0001
   MAX_FLOAT_BEFORE_SCI_NOT = 1000000000000000.0
 
-  LOGGER = Cabin::Channel.get(LogStash)
+  DEFAULT_LOGGER = Cabin::Channel.get(LogStash)
+  @@logger = DEFAULT_LOGGER
 
-  public
   def initialize(data = {})
     @cancelled = false
     @data = data
@@ -76,52 +76,43 @@ def initialize(data = {})
 
     @metadata = @data.delete(METADATA) || {}
     @metadata_accessors = LogStash::Util::Accessors.new(@metadata)
-  end # def initialize
+  end
 
-  public
   def cancel
     @cancelled = true
-  end # def cancel
+  end
 
-  public
   def uncancel
     @cancelled = false
-  end # def uncancel
+  end
 
-  public
   def cancelled?
-    return @cancelled
-  end # def cancelled?
+    @cancelled
+  end
 
   # Create a deep-ish copy of this event.
-  public
   def clone
     copy = {}
     @data.each do |k,v|
       # TODO(sissel): Recurse if this is a hash/array?
       copy[k] = begin v.clone rescue v end
     end
-    return self.class.new(copy)
-  end # def clone
 
-  public
-  def to_s
-    self.sprintf("#{timestamp.to_iso8601} %{host} %{message}")
-  end # def to_s
+    self.class.new(copy)
+  end
 
-  public
-  def timestamp; return @data[TIMESTAMP]; end # def timestamp
-  def timestamp=(val); return @data[TIMESTAMP] = val; end # def timestamp=
+  def to_s
+    "#{timestamp.to_iso8601} #{self.sprintf("%{host} %{message}")}"
+  end
 
-  def unix_timestamp
-    raise DeprecatedMethod
-  end # def unix_timestamp
+  def timestamp
+    @data[TIMESTAMP]
+  end
 
-  def ruby_timestamp
-    raise DeprecatedMethod
-  end # def unix_timestamp
+  def timestamp=(val)
+    @data[TIMESTAMP] = val
+  end
 
-  public
   def [](fieldref)
     if fieldref.start_with?(METADATA_BRACKETS)
       @metadata_accessors.get(fieldref[METADATA_BRACKETS.length .. -1])
@@ -130,9 +121,8 @@ def [](fieldref)
     else
       @accessors.get(fieldref)
     end
-  end # def []
+  end
 
-  public
   def []=(fieldref, value)
     if fieldref == TIMESTAMP && !value.is_a?(LogStash::Timestamp)
       raise TypeError, "The field '@timestamp' must be a (LogStash::Timestamp, not a #{value.class} (#{value})"
@@ -145,25 +135,17 @@ def []=(fieldref, value)
     else
       @accessors.set(fieldref, value)
     end
-  end # def []=
-
-  public
-  def fields
-    raise DeprecatedMethod
   end
 
-  public
   def to_json(*args)
     # ignore arguments to respect accepted to_json method signature
     LogStash::Json.dump(@data)
-  end # def to_json
+  end
 
-  public
   def to_hash
     @data
-  end # def to_hash
+  end
 
-  public
   def overwrite(event)
     # pickup new event @data and also pickup @accessors
     # otherwise it will be pointing on previous data
@@ -176,7 +158,6 @@ def overwrite(event)
     end
   end
 
-  public
   def include?(fieldref)
     if fieldref.start_with?(METADATA_BRACKETS)
       @metadata_accessors.include?(fieldref[METADATA_BRACKETS.length .. -1])
@@ -185,24 +166,21 @@ def include?(fieldref)
     else
       @accessors.include?(fieldref)
     end
-  end # def include?
+  end
 
   # Append an event to this one.
-  public
   def append(event)
     # non-destructively merge that event with ourselves.
 
     # no need to reset @accessors here because merging will not disrupt any existing field paths
     # and if new ones are created they will be picked up.
     LogStash::Util.hash_merge(@data, event.to_hash)
-  end # append
+  end
 
-  # Remove a field or field reference. Returns the value of that field when
-  # deleted
-  public
+  # Remove a field or field reference. Returns the value of that field when deleted
   def remove(fieldref)
     @accessors.del(fieldref)
-  end # def remove
+  end
 
   # sprintf. This could use a better method name.
   # The idea is to take an event and convert it to a string based on
@@ -217,7 +195,6 @@ def remove(fieldref)
   #
   # If a %{name} value is an array, then we will join by ','
   # If a %{name} value does not exist, then no substitution occurs.
-  public
   def sprintf(format)
     LogStash::StringInterpolation.evaluate(self, format)
   end
@@ -228,36 +205,18 @@ def tag(value)
     self["tags"] << value unless self["tags"].include?(value)
   end
 
-  private
-
-  def init_timestamp(o)
-    begin
-      timestamp = LogStash::Timestamp.coerce(o)
-      return timestamp if timestamp
-
-      LOGGER.warn("Unrecognized #{TIMESTAMP} value, setting current time to #{TIMESTAMP}, original in #{TIMESTAMP_FAILURE_FIELD}field", :value => o.inspect)
-    rescue LogStash::TimestampParserError => e
-      LOGGER.warn("Error parsing #{TIMESTAMP} string, setting current time to #{TIMESTAMP}, original in #{TIMESTAMP_FAILURE_FIELD} field", :value => o.inspect, :exception => e.message)
-    end
-
-    @data["tags"] ||= []
-    @data["tags"] << TIMESTAMP_FAILURE_TAG unless @data["tags"].include?(TIMESTAMP_FAILURE_TAG)
-    @data[TIMESTAMP_FAILURE_FIELD] = o
-
-    LogStash::Timestamp.now
-  end
-
-  public
   def to_hash_with_metadata
     @metadata.empty? ? to_hash : to_hash.merge(METADATA => @metadata)
   end
 
-  public
   def to_json_with_metadata(*args)
     # ignore arguments to respect accepted to_json method signature
     LogStash::Json.dump(to_hash_with_metadata)
-  end # def to_json
+  end
 
+  # this is used by logstash-devutils spec_helper.rb to monkey patch the Event field setter []=
+  # and add systematic encoding validation on every field set in specs.
+  # TODO: (colin) this should be moved, probably in logstash-devutils ?
   def self.validate_value(value)
     case value
     when String
@@ -272,4 +231,48 @@ def self.validate_value(value)
     end
   end
 
-end # class LogStash::Event
+  # depracated public methods
+  # TODO: (colin) since these depracated mothods are still exposed in 2.x we should remove them in 3.0
+
+  def unix_timestamp
+    raise DeprecatedMethod
+  end
+
+  def ruby_timestamp
+    raise DeprecatedMethod
+  end
+
+  def fields
+    raise DeprecatedMethod
+  end
+
+  # set a new logger for all Event instances
+  # there is no point in changing it at runtime for other reasons than in tests/specs.
+  # @param logger [Cabin::Channel] logger instance that will be used by all Event instances
+  def self.logger=(logger)
+    @@logger = logger
+  end
+
+  private
+
+  def logger
+    @@logger
+  end
+
+  def init_timestamp(o)
+    begin
+      timestamp = LogStash::Timestamp.coerce(o)
+      return timestamp if timestamp
+
+      logger.warn("Unrecognized #{TIMESTAMP} value, setting current time to #{TIMESTAMP}, original in #{TIMESTAMP_FAILURE_FIELD}field", :value => o.inspect)
+    rescue LogStash::TimestampParserError => e
+      logger.warn("Error parsing #{TIMESTAMP} string, setting current time to #{TIMESTAMP}, original in #{TIMESTAMP_FAILURE_FIELD} field", :value => o.inspect, :exception => e.message)
+    end
+
+    @data["tags"] ||= []
+    @data["tags"] << TIMESTAMP_FAILURE_TAG unless @data["tags"].include?(TIMESTAMP_FAILURE_TAG)
+    @data[TIMESTAMP_FAILURE_FIELD] = o
+
+    LogStash::Timestamp.now
+  end
+end
diff --git a/lib/logstash/string_interpolation.rb b/logstash-core-event/lib/logstash/string_interpolation.rb
similarity index 87%
rename from lib/logstash/string_interpolation.rb
rename to logstash-core-event/lib/logstash/string_interpolation.rb
index fc357f67515..1eac92789d4 100644
--- a/lib/logstash/string_interpolation.rb
+++ b/logstash-core-event/lib/logstash/string_interpolation.rb
@@ -4,7 +4,7 @@
 
 module LogStash
   module StringInterpolation
-    extend self 
+    extend self
 
     # Floats outside of these upper and lower bounds are forcibly converted
     # to scientific notation by Float#to_s
@@ -27,6 +27,16 @@ def evaluate(event, template)
       compiled.evaluate(event)
     end
 
+    # clear the global compiled templates cache
+    def clear_cache
+      CACHE.clear
+    end
+
+    # @return [Fixnum] the compiled templates cache size
+    def cache_size
+      CACHE.size
+    end
+
     private
     def not_cachable?(template)
       template.index("%").nil?
@@ -114,8 +124,16 @@ def evaluate(event)
         value.join(",")
       when Hash
         LogStash::Json.dump(value)
-      else
+      when Numeric
+        value
+      when TrueClass
         value
+      when FalseClass
+        value
+      else
+        # If we dont know how to deal with the type we return a string
+        # to make sure we don't return a reference.
+        "#{value}"
       end
     end
   end
diff --git a/lib/logstash/timestamp.rb b/logstash-core-event/lib/logstash/timestamp.rb
similarity index 88%
rename from lib/logstash/timestamp.rb
rename to logstash-core-event/lib/logstash/timestamp.rb
index fb75c5f2538..ab6b6edb3bc 100644
--- a/lib/logstash/timestamp.rb
+++ b/logstash-core-event/lib/logstash/timestamp.rb
@@ -24,7 +24,13 @@ def initialize(time = Time.new)
     end
 
     def self.at(*args)
-      Timestamp.new(::Time.at(*args))
+      epoch = args.first
+      if epoch.is_a?(BigDecimal)
+        # bug in JRuby prevents correcly parsing a BigDecimal fractional part, see https://github.com/elastic/logstash/issues/4565
+        Timestamp.new(::Time.at(epoch.to_i, epoch.frac.to_f * 1000000))
+      else
+        Timestamp.new(::Time.at(*args))
+      end
     end
 
     def self.parse(*args)
diff --git a/lib/logstash/util/accessors.rb b/logstash-core-event/lib/logstash/util/accessors.rb
similarity index 90%
rename from lib/logstash/util/accessors.rb
rename to logstash-core-event/lib/logstash/util/accessors.rb
index 01c16910855..23248f2c3ea 100644
--- a/lib/logstash/util/accessors.rb
+++ b/logstash-core-event/lib/logstash/util/accessors.rb
@@ -95,7 +95,14 @@ def lookup(field_reference)
     # @param field_reference [String] the field referece
     # @return [[Object, String]] the  [target, key] tuple associated with this field reference
     def lookup_or_create(field_reference)
-      @lut[field_reference] ||= find_or_create_target(field_reference)
+      # flush the @lut to prevent stale cached fieldref which may point to an old target
+      # which was overwritten with a new value. for example, if "[a][b]" is cached and we
+      # set a new value for "[a]" then reading again "[a][b]" would point in a stale target.
+      # flushing the complete @lut is suboptimal, but a hierarchical lut would be required
+      # to be able to invalidate fieldrefs from a common root.
+      # see https://github.com/elastic/logstash/pull/5132
+      @lut.clear
+      @lut[field_reference] = find_or_create_target(field_reference)
     end
 
     # find the target container object in store for this field reference
diff --git a/logstash-core-event/logstash-core-event.gemspec b/logstash-core-event/logstash-core-event.gemspec
new file mode 100644
index 00000000000..9e0a757a870
--- /dev/null
+++ b/logstash-core-event/logstash-core-event.gemspec
@@ -0,0 +1,23 @@
+# -*- encoding: utf-8 -*-
+lib = File.expand_path('../lib', __FILE__)
+$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
+require 'logstash-core-event/version'
+
+Gem::Specification.new do |gem|
+  gem.authors       = ["Elastic"]
+  gem.email         = ["info@elastic.co"]
+  gem.description   = %q{The core event component of logstash, the scalable log and event management tool}
+  gem.summary       = %q{logstash-core-event - The core event component of logstash}
+  gem.homepage      = "http://www.elastic.co/guide/en/logstash/current/index.html"
+  gem.license       = "Apache License (2.0)"
+
+  gem.files         = Dir.glob(["logstash-core-event.gemspec", "lib/**/*.rb", "spec/**/*.rb"])
+  gem.test_files    = gem.files.grep(%r{^(test|spec|features)/})
+  gem.name          = "logstash-core-event"
+  gem.require_paths = ["lib"]
+  gem.version       = LOGSTASH_CORE_EVENT_VERSION
+
+  if RUBY_PLATFORM == 'java'
+    gem.platform = RUBY_PLATFORM
+  end
+end
diff --git a/spec/core/event_spec.rb b/logstash-core-event/spec/logstash/event_spec.rb
similarity index 70%
rename from spec/core/event_spec.rb
rename to logstash-core-event/spec/logstash/event_spec.rb
index 52b22c3115c..de89419ffca 100644
--- a/spec/core/event_spec.rb
+++ b/logstash-core-event/spec/logstash/event_spec.rb
@@ -1,5 +1,7 @@
 # encoding: utf-8
 require "spec_helper"
+require "logstash/util/decorators"
+require "json"
 
 describe LogStash::Event do
 
@@ -43,9 +45,79 @@
         subject["@metadata"] = { "action" => "index" }
         expect(subject["[@metadata][action]"]).to eq("index")
       end
+
+      it "should add key when setting nil value" do
+        subject["[baz]"] = nil
+        expect(subject.to_hash).to include("baz" => nil)
+      end
+
+      it "should set nil element within existing array value" do
+        subject["[foo]"] = ["bar", "baz"]
+
+        expect(subject["[foo][0]"] = nil).to eq(nil)
+        expect(subject["[foo]"]).to eq([nil, "baz"])
+      end
+
+      it "should set nil in first element within empty array" do
+        subject["[foo]"] = []
+
+        expect(subject["[foo][0]"] = nil).to eq(nil)
+        expect(subject["[foo]"]).to eq([nil])
+      end
+
+      it "should set nil in second element within empty array" do
+        subject["[foo]"] = []
+
+        expect(subject["[foo][1]"] = nil).to eq(nil)
+        expect(subject["[foo]"]).to eq([nil, nil])
+      end
     end
 
     context "#sprintf" do
+      it "should not return a String reference" do
+        data = "NOT-A-REFERENCE"
+        event = LogStash::Event.new({ "reference" => data })
+        LogStash::Util::Decorators.add_fields({"reference_test" => "%{reference}"}, event, "dummy-plugin")
+        data.downcase!
+        expect(event["reference_test"]).not_to eq(data)
+      end
+
+      # TODO: This was a bug and should only be true in the context of 2.3.X
+      # see https://github.com/elastic/logstash/issues/5114 for more details.
+      it "should return a Fixnum" do
+        data = 1
+        event = LogStash::Event.new({ "reference" => data })
+        LogStash::Util::Decorators.add_fields({"reference_test" => "%{reference}"}, event, "dummy-plugin")
+        expect(event["reference_test"]).to eq(1)
+      end
+
+      # TODO: This was a bug and should only be true in the context of 2.3.X
+      # see https://github.com/elastic/logstash/issues/5114 for more details.
+      it "should return a Float" do
+        data = 1.999
+        event = LogStash::Event.new({ "reference" => data })
+        LogStash::Util::Decorators.add_fields({"reference_test" => "%{reference}"}, event, "dummy-plugin")
+        expect(event["reference_test"]).to eq(1.999)
+      end
+
+      # TODO: This was a bug and should only be true in the context of 2.3.X
+      # see https://github.com/elastic/logstash/issues/5114 for more details.
+      it "should return true" do
+        data = true
+        event = LogStash::Event.new({ "reference" => data })
+        LogStash::Util::Decorators.add_fields({"reference_test" => "%{reference}"}, event, "dummy-plugin")
+        expect(event["reference_test"]).to be_kind_of(TrueClass)
+      end
+
+      # TODO: This was a bug and should only be true in the context of 2.3.X
+      # see https://github.com/elastic/logstash/issues/5114 for more details.
+      it "should return false" do
+        data = false
+        event = LogStash::Event.new({ "reference" => data })
+        LogStash::Util::Decorators.add_fields({"reference_test" => "%{reference}"}, event, "dummy-plugin")
+        expect(event["reference_test"]).to be_kind_of(FalseClass)
+      end
+
       it "should report a unix timestamp for %{+%s}" do
         expect(subject.sprintf("%{+%s}")).to eq("1356998400")
       end
@@ -108,6 +180,39 @@
         expect(subject.sprintf("%{type}%{message}|")).to eq("sprintfhello world|")
       end
 
+      it "should render nil array values as leading empty string" do
+        expect(subject["foo"] = [nil, "baz"]).to eq([nil, "baz"])
+
+        expect(subject["[foo][0]"]).to be_nil
+        expect(subject["[foo][1]"]).to eq("baz")
+
+        expect(subject.sprintf("%{[foo]}")).to eq(",baz")
+      end
+
+      it "should render nil array values as middle empty string" do
+        expect(subject["foo"] = ["bar", nil, "baz"]).to eq(["bar", nil, "baz"])
+
+        expect(subject["[foo][0]"]).to eq("bar")
+        expect(subject["[foo][1]"]).to be_nil
+        expect(subject["[foo][2]"]).to eq("baz")
+
+        expect(subject.sprintf("%{[foo]}")).to eq("bar,,baz")
+      end
+
+     it "should render nil array values as trailing empty string" do
+        expect(subject["foo"] = ["bar", nil]).to eq(["bar", nil])
+
+        expect(subject["[foo][0]"]).to eq("bar")
+        expect(subject["[foo][1]"]).to be_nil
+
+        expect(subject.sprintf("%{[foo]}")).to eq("bar,")
+     end
+
+      it "should render deep arrays with nil value" do
+        subject["[foo]"] = [[12, nil], 56]
+        expect(subject.sprintf("%{[foo]}")).to eq("12,,56")
+      end
+
       context "#encoding" do
         it "should return known patterns as UTF-8" do
           expect(subject.sprintf("%{message}").encoding).to eq(Encoding::UTF_8)
@@ -256,6 +361,7 @@
           expect(subject[ "field1" ]).to eq([ "original1", "original2", "append1" ])
         end
       end
+
     end
 
     it "timestamp parsing speed", :performance => true do
@@ -313,48 +419,57 @@
     end
 
     context "timestamp initialization" do
-      let(:logger) { double("logger") }
+      let(:logger_mock) { double("logger") }
+
+      after(:each) do
+        LogStash::Event.logger = LogStash::Event::DEFAULT_LOGGER
+      end
 
       it "should coerce timestamp" do
         t = Time.iso8601("2014-06-12T00:12:17.114Z")
-        expect(LogStash::Timestamp).to receive(:coerce).exactly(3).times.and_call_original
         expect(LogStash::Event.new("@timestamp" => t).timestamp.to_i).to eq(t.to_i)
         expect(LogStash::Event.new("@timestamp" => LogStash::Timestamp.new(t)).timestamp.to_i).to eq(t.to_i)
         expect(LogStash::Event.new("@timestamp" => "2014-06-12T00:12:17.114Z").timestamp.to_i).to eq(t.to_i)
       end
 
       it "should assign current time when no timestamp" do
-        ts = LogStash::Timestamp.now
-        expect(LogStash::Timestamp).to receive(:now).and_return(ts)
-        expect(LogStash::Event.new({}).timestamp.to_i).to eq(ts.to_i)
+        expect(LogStash::Event.new({}).timestamp.to_i).to be_within(1).of (Time.now.to_i)
       end
 
-      it "should tag and warn for invalid value" do
-        ts = LogStash::Timestamp.now
-        expect(LogStash::Timestamp).to receive(:now).twice.and_return(ts)
-        expect(LogStash::Event::LOGGER).to receive(:warn).twice
-
-        event = LogStash::Event.new("@timestamp" => :foo)
-        expect(event.timestamp.to_i).to eq(ts.to_i)
+      it "should tag for invalid value" do
+        event = LogStash::Event.new("@timestamp" => "foo")
+        expect(event.timestamp.to_i).to be_within(1).of Time.now.to_i
         expect(event["tags"]).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
-        expect(event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]).to eq(:foo)
+        expect(event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]).to eq("foo")
 
         event = LogStash::Event.new("@timestamp" => 666)
-        expect(event.timestamp.to_i).to eq(ts.to_i)
+        expect(event.timestamp.to_i).to be_within(1).of Time.now.to_i
         expect(event["tags"]).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
         expect(event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]).to eq(666)
       end
 
-      it "should tag and warn for invalid string format" do
-        ts = LogStash::Timestamp.now
-        expect(LogStash::Timestamp).to receive(:now).and_return(ts)
-        expect(LogStash::Event::LOGGER).to receive(:warn)
+      it "should warn for invalid value" do
+        LogStash::Event.logger = logger_mock
+
+        expect(logger_mock).to receive(:warn).twice
+
+        LogStash::Event.new("@timestamp" => :foo)
+        LogStash::Event.new("@timestamp" => 666)
+      end
 
+      it "should tag for invalid string format" do
         event = LogStash::Event.new("@timestamp" => "foo")
-        expect(event.timestamp.to_i).to eq(ts.to_i)
+        expect(event.timestamp.to_i).to be_within(1).of Time.now.to_i
         expect(event["tags"]).to eq([LogStash::Event::TIMESTAMP_FAILURE_TAG])
         expect(event[LogStash::Event::TIMESTAMP_FAILURE_FIELD]).to eq("foo")
       end
+
+      it "should warn for invalid string format" do
+        LogStash::Event.logger = logger_mock
+
+        expect(logger_mock).to receive(:warn)
+        LogStash::Event.new("@timestamp" => "foo")
+      end
     end
 
     context "to_json" do
@@ -365,7 +480,7 @@
         )
         json = new_event.to_json
 
-        expect(json).to eq( "{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}")
+        expect(JSON.parse(json)).to eq( JSON.parse("{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}"))
       end
 
       it "should support to_json and ignore arguments" do
@@ -375,7 +490,7 @@
         )
         json = new_event.to_json(:foo => 1, :bar => "baz")
 
-        expect(json).to eq( "{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}")
+        expect(JSON.parse(json)).to eq( JSON.parse("{\"@timestamp\":\"2014-09-23T19:26:15.832Z\",\"message\":\"foo bar\",\"@version\":\"1\"}"))
       end
     end
 
@@ -496,4 +611,52 @@
       subject{LogStash::Event.new(LogStash::Json.load(LogStash::Json.dump(event_hash)))}
     end
   end
+
+
+  describe "#to_s" do
+    let(:timestamp) { LogStash::Timestamp.new }
+    let(:event1) { LogStash::Event.new({ "@timestamp" => timestamp, "host" => "foo", "message" => "bar"}) }
+    let(:event2) { LogStash::Event.new({ "host" => "bar", "message" => "foo"}) }
+
+    it "should cache only one template" do
+      LogStash::StringInterpolation.clear_cache
+      expect {
+        event1.to_s
+        event2.to_s
+      }.to change { LogStash::StringInterpolation.cache_size }.by(1)
+    end
+
+    it "return the string containing the timestamp, the host and the message" do
+      expect(event1.to_s).to eq("#{timestamp.to_iso8601} #{event1["host"]} #{event1["message"]}")
+    end
+  end
+
+  describe "Event accessors" do
+    let(:event) { LogStash::Event.new({ "message" => "foo" }) }
+
+    it "should invalidate target caching" do
+      expect(event["[a][0]"]).to be_nil
+
+      expect(event["[a][0]"] = 42).to eq(42)
+      expect(event["[a][0]"]).to eq(42)
+      expect(event["[a]"]).to eq({"0" => 42})
+
+      expect(event["[a]"] = [42, 24]).to eq([42, 24])
+      expect(event["[a]"]).to eq([42, 24])
+
+      expect(event["[a][0]"]).to eq(42)
+
+      expect(event["[a]"] = [24, 42]).to eq([24, 42])
+      expect(event["[a][0]"]).to eq(24)
+
+      expect(event["[a][0]"] = {"a "=> 99, "b" => 98}).to eq({"a "=> 99, "b" => 98})
+      expect(event["[a][0]"]).to eq({"a "=> 99, "b" => 98})
+
+      expect(event["[a]"]).to eq([{"a "=> 99, "b" => 98}, 42])
+      expect(event["[a][0]"]).to eq({"a "=> 99, "b" => 98})
+      expect(event["[a][1]"]).to eq(42)
+      expect(event["[a][0][b]"]).to eq(98)
+    end
+  end
 end
+
diff --git a/logstash-core-event/spec/logstash/timestamp_spec.rb b/logstash-core-event/spec/logstash/timestamp_spec.rb
new file mode 100644
index 00000000000..196b895c39e
--- /dev/null
+++ b/logstash-core-event/spec/logstash/timestamp_spec.rb
@@ -0,0 +1,170 @@
+# encoding: utf-8
+require "spec_helper"
+require "logstash/timestamp"
+require "bigdecimal"
+
+describe LogStash::Timestamp do
+
+  it "should parse its own iso8601 output" do
+    t = Time.now
+    ts = LogStash::Timestamp.new(t)
+    expect(LogStash::Timestamp.parse_iso8601(ts.to_iso8601).to_i).to eq(t.to_i)
+  end
+
+  it "should coerce iso8601 string" do
+    t = Time.now
+    ts = LogStash::Timestamp.new(t)
+    expect(LogStash::Timestamp.coerce(ts.to_iso8601).to_i).to eq(t.to_i)
+  end
+
+  it "should coerce Time" do
+    t = Time.now
+    expect(LogStash::Timestamp.coerce(t).to_i).to eq(t.to_i)
+  end
+
+  it "should coerce Timestamp" do
+    t = LogStash::Timestamp.now
+    expect(LogStash::Timestamp.coerce(t).to_i).to eq(t.to_i)
+  end
+
+  it "should raise on invalid string coerce" do
+    expect{LogStash::Timestamp.coerce("foobar")}.to raise_error LogStash::TimestampParserError
+  end
+
+  it "should return nil on invalid object coerce" do
+    expect(LogStash::Timestamp.coerce(:foobar)).to be_nil
+  end
+
+  it "should support to_json" do
+    expect(LogStash::Timestamp.parse_iso8601("2014-09-23T00:00:00-0800").to_json).to eq("\"2014-09-23T08:00:00.000Z\"")
+  end
+
+  it "should support to_json and ignore arguments" do
+    expect(LogStash::Timestamp.parse_iso8601("2014-09-23T00:00:00-0800").to_json(:some => 1, :argumnents => "test")).to eq("\"2014-09-23T08:00:00.000Z\"")
+  end
+
+  it "should support timestamp comparaison" do
+   current = LogStash::Timestamp.new(Time.now) 
+   future = LogStash::Timestamp.new(Time.now + 100)
+
+   expect(future > current).to eq(true)
+   expect(future < current).to eq(false)
+   expect(current == current).to eq(true)
+
+   expect(current <=> current).to eq(0)
+   expect(current <=> future).to eq(-1)
+   expect(future <=> current).to eq(1)
+  end
+
+  it "should allow unary operation +" do
+    current = Time.now
+    t = LogStash::Timestamp.new(current) + 10
+    expect(t).to eq(current + 10)
+  end
+
+  describe "subtraction" do
+    it "should work on a timestamp object" do
+      t = Time.now
+      current = LogStash::Timestamp.new(t)
+      future = LogStash::Timestamp.new(t + 10)
+      expect(future - current).to eq(10)
+    end
+
+    it "should work on with time object" do
+      current = Time.now
+      t = LogStash::Timestamp.new(current + 10)
+      expect(t - current).to eq(10)
+    end
+
+    it "should work with numeric value" do
+      current = Time.now
+      t = LogStash::Timestamp.new(current + 10)
+      expect(t - 10).to eq(current)
+    end
+  end
+
+  context "identity methods" do
+    subject { LogStash::Timestamp.new }
+
+    it "should support utc" do
+      expect(subject.utc).to eq(subject)
+    end
+
+    it "should support gmtime" do
+      expect(subject.gmtime).to eq(subject)
+    end
+  end
+
+  context "numeric casting methods" do
+    let (:now) {Time.now}
+    subject { LogStash::Timestamp.new(now) }
+
+    it "should support to_i" do
+      expect(subject.to_i).to eq(now.to_i)
+    end
+
+    it "should support to_f" do
+      expect(subject.to_f).to eq(now.to_f)
+    end
+  end
+
+  context "at" do
+    context "with integer epoch" do
+      it "should convert to correct date" do
+        expect(LogStash::Timestamp.at(946702800).to_iso8601).to eq("2000-01-01T05:00:00.000Z")
+      end
+
+      it "should return zero usec" do
+        expect(LogStash::Timestamp.at(946702800).usec).to eq(0)
+      end
+
+      it "should return prior to epoch date on negative input" do
+        expect(LogStash::Timestamp.at(-1).to_iso8601).to eq("1969-12-31T23:59:59.000Z")
+      end
+    end
+
+    context "with float epoch" do
+      it "should convert to correct date" do
+        expect(LogStash::Timestamp.at(946702800.123456.to_f).to_iso8601).to eq("2000-01-01T05:00:00.123Z")
+      end
+
+      it "should return usec with a minimum of millisec precision" do
+        expect(LogStash::Timestamp.at(946702800.123456.to_f).usec).to be_within(1000).of(123456)
+      end
+    end
+
+    context "with BigDecimal epoch" do
+      it "should convert to correct date" do
+        expect(LogStash::Timestamp.at(BigDecimal.new("946702800.123456")).to_iso8601).to eq("2000-01-01T05:00:00.123Z")
+      end
+
+      it "should return usec with a minimum of millisec precision" do
+        # since Java Timestamp relies on JodaTime which supports only milliseconds precision
+        # the usec method will only be precise up to milliseconds.
+        expect(LogStash::Timestamp.at(BigDecimal.new("946702800.123456")).usec).to be_within(1000).of(123456)
+      end
+    end
+
+    context "with illegal parameters" do
+      it "should raise exception on nil input" do
+        expect{LogStash::Timestamp.at(nil)}.to raise_error
+      end
+
+      it "should raise exception on invalid input type" do
+        expect{LogStash::Timestamp.at(:foo)}.to raise_error
+      end
+    end
+  end
+
+  context "usec" do
+    it "should support millisecond precision" do
+      expect(LogStash::Timestamp.at(946702800.123).usec).to eq(123000)
+    end
+
+    it "should try to preserve and report microseconds precision if possible" do
+      # since Java Timestamp relies on JodaTime which supports only milliseconds precision
+      # the usec method will only be precise up to milliseconds.
+      expect(LogStash::Timestamp.at(946702800.123456).usec).to be_within(1000).of(123456)
+    end
+  end
+end
diff --git a/spec/util/accessors_spec.rb b/logstash-core-event/spec/logstash/util/accessors_spec.rb
similarity index 93%
rename from spec/util/accessors_spec.rb
rename to logstash-core-event/spec/logstash/util/accessors_spec.rb
index af719a32999..e3c1a73e60e 100644
--- a/spec/util/accessors_spec.rb
+++ b/logstash-core-event/spec/logstash/util/accessors_spec.rb
@@ -1,8 +1,17 @@
 # encoding: utf-8
 require "spec_helper"
-require "logstash/util/accessors"
 
-describe LogStash::Util::Accessors, :if => true do
+# this is to skip specs when running agains an alternate logstash-core-event implementation
+# that does not define the Accessors class. For example, in logstash-core-event-java
+# the Accessors class does not exists in the Ruby namespace.
+class_exists = begin
+  require "logstash/util/accessors"
+  true
+rescue LoadError
+  false
+end
+
+describe "LogStash::Util::Accessors", :if => class_exists do
 
   context "using simple field" do
 
diff --git a/logstash-core-plugin-api/lib/logstash-core-plugin-api/version.rb b/logstash-core-plugin-api/lib/logstash-core-plugin-api/version.rb
new file mode 100644
index 00000000000..e83d1586c2e
--- /dev/null
+++ b/logstash-core-plugin-api/lib/logstash-core-plugin-api/version.rb
@@ -0,0 +1,2 @@
+# encoding: utf-8
+LOGSTASH_CORE_PLUGIN_API = "1.0.0"
diff --git a/logstash-core-plugin-api/logstash-core-plugin-api.gemspec b/logstash-core-plugin-api/logstash-core-plugin-api.gemspec
new file mode 100644
index 00000000000..08efcb63abf
--- /dev/null
+++ b/logstash-core-plugin-api/logstash-core-plugin-api.gemspec
@@ -0,0 +1,29 @@
+# -*- encoding: utf-8 -*-
+lib = File.expand_path('../lib', __FILE__)
+$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
+require "logstash-core-plugin-api/version"
+
+Gem::Specification.new do |gem|
+  gem.authors       = ["Elastic"]
+  gem.email         = ["info@elastic.co"]
+  gem.description   = %q{Logstash plugin API}
+  gem.summary       = %q{Define the plugin API that the plugin need to follow.}
+  gem.homepage      = "http://www.elastic.co/guide/en/logstash/current/index.html"
+  gem.license       = "Apache License (2.0)"
+
+  gem.files         = Dir.glob(["logstash-core-event.gemspec", "lib/**/*.rb", "spec/**/*.rb"])
+  gem.test_files    = gem.files.grep(%r{^(test|spec|features)/})
+  gem.name          = "logstash-core-plugin-api"
+  gem.require_paths = ["lib"]
+  gem.version       = LOGSTASH_CORE_PLUGIN_API
+
+  gem.add_runtime_dependency "logstash-core", ">= 2.0.0", "<= 3.0.0.dev"
+
+  # Make sure we dont build this gem from a non jruby
+  # environment.
+  if RUBY_PLATFORM == "java"
+    gem.platform = "java"
+  else
+    raise "The logstash-core-api need to be build on jruby"
+  end
+end
diff --git a/logstash-core/lib/logstash-core.rb b/logstash-core/lib/logstash-core.rb
new file mode 100644
index 00000000000..c2e4557afa8
--- /dev/null
+++ b/logstash-core/lib/logstash-core.rb
@@ -0,0 +1 @@
+require "logstash-core/logstash-core"
diff --git a/lib/logstash-core.rb b/logstash-core/lib/logstash-core/logstash-core.rb
similarity index 100%
rename from lib/logstash-core.rb
rename to logstash-core/lib/logstash-core/logstash-core.rb
diff --git a/lib/logstash/version.rb b/logstash-core/lib/logstash-core/version.rb
similarity index 64%
rename from lib/logstash/version.rb
rename to logstash-core/lib/logstash-core/version.rb
index 17a5cd8c15b..fdc9d13f1a4 100644
--- a/lib/logstash/version.rb
+++ b/logstash-core/lib/logstash-core/version.rb
@@ -1,6 +1,8 @@
 # encoding: utf-8
-# The version of logstash.
-LOGSTASH_VERSION = "3.0.0.dev"
 
+# The version of logstash core gem.
+#
 # Note to authors: this should not include dashes because 'gem' barfs if
 # you include a dash in the version string.
+
+LOGSTASH_CORE_VERSION = "3.0.0.dev"
diff --git a/logstash-core/lib/logstash/agent.rb b/logstash-core/lib/logstash/agent.rb
new file mode 100644
index 00000000000..7995492b7b5
--- /dev/null
+++ b/logstash-core/lib/logstash/agent.rb
@@ -0,0 +1,532 @@
+# encoding: utf-8
+require "clamp" # gem 'clamp'
+require "logstash/environment"
+require "logstash/errors"
+require "logstash/config/cpu_core_strategy"
+require "stud/trap"
+require "logstash/config/loader"
+require "uri"
+require "net/http"
+require "logstash/pipeline"
+
+class LogStash::Agent < Clamp::Command
+
+  attr_reader :pipelines, :config_loader
+
+  DEFAULT_INPUT = "input { stdin { type => stdin } }"
+  DEFAULT_OUTPUT = "output { stdout { codec => rubydebug } }"
+
+  option ["-f", "--config"], "CONFIG_PATH",
+    I18n.t("logstash.agent.flag.config"),
+    :attribute_name => :config_path
+
+  option "-e", "CONFIG_STRING",
+    I18n.t("logstash.agent.flag.config-string",
+           :default_input => DEFAULT_INPUT, :default_output => DEFAULT_OUTPUT),
+    :default => "", :attribute_name => :config_string
+
+  option ["-w", "--pipeline-workers"], "COUNT",
+         I18n.t("logstash.agent.flag.pipeline-workers"),
+         :attribute_name => :pipeline_workers,
+         :default => LogStash::Pipeline::DEFAULT_SETTINGS[:default_pipeline_workers]
+
+
+  option ["-b", "--pipeline-batch-size"], "SIZE",
+         I18n.t("logstash.agent.flag.pipeline-batch-size"),
+         :attribute_name => :pipeline_batch_size,
+         :default => LogStash::Pipeline::DEFAULT_SETTINGS[:pipeline_batch_size]
+
+  option ["-u", "--pipeline-batch-delay"], "DELAY_IN_MS",
+         I18n.t("logstash.agent.flag.pipeline-batch-delay"),
+         :attribute_name => :pipeline_batch_delay,
+         :default => LogStash::Pipeline::DEFAULT_SETTINGS[:pipeline_batch_delay]
+
+  option ["--filterworkers"], "COUNT",
+         I18n.t("logstash.agent.flag.filterworkers"),
+         :attribute_name => :filter_workers
+
+  option ["-l", "--log"], "FILE",
+    I18n.t("logstash.agent.flag.log"),
+    :attribute_name => :log_file
+
+  # Old support for the '-v' flag'
+  option "-v", :flag,
+    I18n.t("logstash.agent.flag.verbosity"),
+    :attribute_name => :verbosity, :multivalued => true
+
+  option "--quiet", :flag, I18n.t("logstash.agent.flag.quiet")
+  option "--verbose", :flag, I18n.t("logstash.agent.flag.verbose")
+  option "--debug", :flag, I18n.t("logstash.agent.flag.debug")
+
+  option ["--debug-config"], :flag,
+         I18n.t("logstash.agent.flag.debug_config"),
+         :attribute_name => :debug_config, :default => false
+
+  option ["-V", "--version"], :flag,
+    I18n.t("logstash.agent.flag.version")
+
+ option ["-p", "--pluginpath"] , "PATH",
+   I18n.t("logstash.agent.flag.pluginpath"),
+   :multivalued => true,
+   :attribute_name => :plugin_paths
+
+  option ["-t", "--configtest"], :flag,
+    I18n.t("logstash.agent.flag.configtest"),
+    :attribute_name => :config_test
+
+  option "--[no-]allow-unsafe-shutdown", :flag,
+    I18n.t("logstash.agent.flag.unsafe_shutdown"),
+    :attribute_name => :unsafe_shutdown,
+    :default => false
+
+  option ["-r", "--[no-]auto-reload"], :flag,
+    I18n.t("logstash.agent.flag.auto_reload"),
+    :attribute_name => :auto_reload, :default => false
+
+  option ["--reload-interval"], "RELOAD_INTERVAL",
+    I18n.t("logstash.agent.flag.reload_interval"),
+    :attribute_name => :reload_interval, :default => 3, &:to_i
+
+  option ["--allow-env"], :flag,
+    I18n.t("logstash.agent.flag.allow-env"),
+    :attribute_name => :allow_env, :default => false
+
+  option ["--[no-]log-in-json"], :flag,
+    I18n.t("logstash.agent.flag.log-in-json"),
+    :default => false
+
+  def initialize(*params)
+    super(*params)
+    @logger = Cabin::Channel.get(LogStash)
+    @pipelines = {}
+    @pipeline_settings ||= { :pipeline_id => "main" }
+    @upgrade_mutex = Mutex.new
+    @config_loader = LogStash::Config::Loader.new(@logger)
+  end
+
+  def pipeline_workers=(pipeline_workers_value)
+    @pipeline_settings[:pipeline_workers] = validate_positive_integer(pipeline_workers_value)
+  end
+
+  def pipeline_batch_size=(pipeline_batch_size_value)
+    @pipeline_settings[:pipeline_batch_size] = validate_positive_integer(pipeline_batch_size_value)
+  end
+
+  def pipeline_batch_delay=(pipeline_batch_delay_value)
+    @pipeline_settings[:pipeline_batch_delay] = validate_positive_integer(pipeline_batch_delay_value)
+  end
+
+  def debug_config=(debug_config)
+    @config_loader.debug_config = debug_config
+    @debug_config = true
+  end
+
+  def validate_positive_integer(str_arg)
+    int_arg = str_arg.to_i
+    if str_arg !~ /^\d+$/ || int_arg < 1
+      raise ArgumentError, "Expected a positive integer, got '#{str_arg}'"
+    end
+
+    int_arg
+  end
+
+  # Emit a warning message.
+  def warn(message)
+    # For now, all warnings are fatal.
+    raise LogStash::ConfigurationError, message
+  end # def warn
+
+  def fail(message)
+    raise LogStash::ConfigurationError, message
+  end # def fail
+
+  # Run the agent. This method is invoked after clamp parses the
+  # flags given to this program.
+  def execute
+    require "logstash/pipeline"
+    require "cabin" # gem 'cabin'
+    require "logstash/plugin"
+    require "logstash/logging/json"
+
+    LogStash::ShutdownWatcher.unsafe_shutdown = unsafe_shutdown?
+    LogStash::ShutdownWatcher.logger = @logger
+
+    if version?
+      show_version
+      return 0
+    end
+
+    # temporarily send logs to stdout as well if a --log is specified
+    # and stdout appears to be a tty
+    show_startup_errors = log_file && STDOUT.tty?
+
+    if show_startup_errors
+      stdout_logs = @logger.subscribe(STDOUT)
+    end
+    configure
+
+
+    if filter_workers
+      @logger.warn("--filter-workers is deprecated! Please use --pipeline-workers or -w. This setting will be removed in the next major version!")
+      self.pipeline_workers = filter_workers
+    end
+
+    # You must specify a config_string or config_path
+    if config_string.nil? && config_path.nil?
+      fail(I18n.t("logstash.agent.missing-configuration"))
+    end
+
+    if auto_reload? && config_path.nil?
+      # there's nothing to reload
+      fail(I18n.t("logstash.agent.reload-without-config-path"))
+    end
+
+    if config_test?
+      config_loader = LogStash::Config::Loader.new(@logger)
+      config_str = config_loader.format_config(config_path, config_string)
+      begin
+        # currently the best strategy to validate the configuration
+        # is creating a pipeline instance and checking for exceptions
+        LogStash::Pipeline.new(config_str)
+        @logger.terminal "Configuration OK"
+        return 0
+      rescue => e
+        @logger.fatal I18n.t("logstash.agent.invalid-configuration", :error => e.message)
+        return 1
+      end
+    end
+
+    register_pipeline("main", @pipeline_settings.merge({
+                          :config_string => config_string,
+                          :config_path => config_path,
+                          :debug_config => debug_config?,
+                          :allow_env => allow_env?
+                          }))
+
+    sigint_id = trap_sigint()
+    sigterm_id = trap_sigterm()
+    sighup_id = trap_sighup()
+
+    @logger.unsubscribe(stdout_logs) if show_startup_errors
+
+    @logger.info("starting agent")
+
+    start_pipelines
+
+    return 1 if clean_state?
+
+    @thread = Thread.current # this var is implicilty used by Stud.stop?
+
+    Stud.stoppable_sleep(reload_interval) # sleep before looping
+
+    if auto_reload?
+      Stud.interval(reload_interval) { reload_state! }
+    else
+      while !Stud.stop?
+        if clean_state? || running_pipelines?
+          sleep 0.5
+        else
+          break
+        end
+      end
+    end
+
+    shutdown
+
+    return 0
+  rescue LogStash::ConfigurationError => e
+    @logger.unsubscribe(stdout_logs) if show_startup_errors
+    @logger.error I18n.t("logstash.agent.error", :error => e)
+    if !config_test?
+      @logger.info I18n.t("logstash.agent.configtest-flag-information")
+    end
+    return 1
+  rescue => e
+    @logger.unsubscribe(stdout_logs) if show_startup_errors
+    @logger.warn(I18n.t("oops"), :error => e, :class => e.class.name, :backtrace => e.backtrace)
+    return 1
+  ensure
+    @log_fd.close if @log_fd
+    Stud::untrap("INT", sigint_id) unless sigint_id.nil?
+    Stud::untrap("TERM", sigterm_id) unless sigterm_id.nil?
+    Stud::untrap("HUP", sighup_id) unless sighup_id.nil?
+  end # def execute
+
+
+  # Do any start-time configuration.
+  #
+  # Log file stuff, plugin path checking, etc.
+  def configure
+    configure_logging(log_file)
+    configure_plugin_paths(plugin_paths)
+  end # def configure
+
+  # Point logging at a specific path.
+  def configure_logging(path)
+    # Set with the -v (or -vv...) flag
+    if quiet?
+      @logger.level = :error
+    elsif verbose?
+      @logger.level = :info
+    elsif debug?
+      @logger.level = :debug
+    else
+      # Old support for the -v and -vv stuff.
+      if verbosity? && verbosity?.any?
+        # this is an array with length of how many times the flag is given
+        if verbosity?.length == 1
+          @logger.warn("The -v flag is deprecated and will be removed in a future release. You should use --verbose instead.")
+          @logger.level = :info
+        else
+          @logger.warn("The -vv flag is deprecated and will be removed in a future release. You should use --debug instead.")
+          @logger.level = :debug
+        end
+      else
+        @logger.level = :warn
+      end
+    end
+
+    if log_file
+      # TODO(sissel): Implement file output/rotation in Cabin.
+      # TODO(sissel): Catch exceptions, report sane errors.
+      begin
+        @log_fd.close if @log_fd
+        @log_fd = File.new(path, "a")
+      rescue => e
+        fail(I18n.t("logstash.agent.configuration.log_file_failed",
+                    :path => path, :error => e))
+      end
+
+      puts "Sending logstash logs to #{path}."
+      @logger.unsubscribe(@logger_subscription) if @logger_subscription
+      if log_in_json?
+        @logger_subscription = @logger.subscribe(LogStash::Logging::JSON.new(@log_fd))
+        @logger.subscribe(LogStash::Logging::JSON.new(STDOUT), :level => :fatal)
+      else
+        @logger_subscription = @logger.subscribe(@log_fd)
+        @logger.subscribe(STDOUT, :level => :fatal)
+      end
+    else
+      if log_in_json?
+        @logger.subscribe(LogStash::Logging::JSON.new(STDOUT))
+      else
+        @logger.subscribe(STDOUT)
+      end
+    end
+
+
+    # TODO(sissel): redirect stdout/stderr to the log as well
+    # http://jira.codehaus.org/browse/JRUBY-7003
+  end # def configure_logging
+
+  # add the given paths for ungemified/bare plugins lookups
+  # @param paths [String, Array<String>] plugins path string or list of path strings to add
+  def configure_plugin_paths(paths)
+    Array(paths).each do |path|
+      fail(I18n.t("logstash.agent.configuration.plugin_path_missing", :path => path)) unless File.directory?(path)
+      LogStash::Environment.add_plugin_path(path)
+    end
+  end
+
+  ## Signal Trapping ##
+  def trap_sigint
+    Stud::trap("INT") do
+      if @interrupted_once
+        @logger.fatal(I18n.t("logstash.agent.forced_sigint"))
+        exit
+      else
+        @logger.warn(I18n.t("logstash.agent.sigint"))
+        Thread.new(@logger) {|logger| sleep 5; logger.warn(I18n.t("logstash.agent.slow_shutdown")) }
+        @interrupted_once = true
+        Stud.stop!(@thread)
+      end
+    end
+  end
+
+  def trap_sigterm
+    Stud::trap("TERM") do
+      @logger.warn(I18n.t("logstash.agent.sigterm"))
+      Stud.stop!(@thread)
+    end
+  end
+
+  def trap_sighup
+    Stud::trap("HUP") do
+      @logger.warn(I18n.t("logstash.agent.sighup"))
+      reload_state!
+    end
+  end
+
+  ## Pipeline CRUD ##
+  def shutdown(pipeline)
+    pipeline.shutdown do
+      ::LogStash::ShutdownWatcher.start(pipeline)
+    end
+  end
+  #
+  # register_pipeline - adds a pipeline to the agent's state
+  # @param pipeline_id [String] pipeline string identifier
+  # @param settings [Hash] settings that will be passed when creating the pipeline.
+  #   keys should be symbols such as :pipeline_workers and :pipeline_batch_delay
+  def register_pipeline(pipeline_id, settings)
+    pipeline = create_pipeline(settings.merge(:pipeline_id => pipeline_id))
+    return unless pipeline.is_a?(LogStash::Pipeline)
+    if @auto_reload && pipeline.non_reloadable_plugins.any?
+      @logger.error(I18n.t("logstash.agent.non_reloadable_config_register"),
+                    :pipeline_id => pipeline_id,
+                    :plugins => pipeline.non_reloadable_plugins.map(&:class))
+      return
+    end
+    @pipelines[pipeline_id] = pipeline
+  end
+
+  def reload_state!
+    @upgrade_mutex.synchronize do
+      @pipelines.each do |pipeline_id, _|
+        begin
+          reload_pipeline!(pipeline_id)
+        rescue => e
+          @logger.error(I18n.t("oops"), :error => e, :backtrace => e.backtrace)
+        end
+      end
+    end
+  end
+
+  def create_pipeline(settings)
+    begin
+      config = fetch_config(settings)
+    rescue => e
+      @logger.error("failed to fetch pipeline configuration", :message => e.message)
+      return
+    end
+
+    begin
+      LogStash::Pipeline.new(config, settings)
+    rescue => e
+      @logger.error("fetched an invalid config", :config => config, :reason => e.message)
+      return
+    end
+  end
+
+  def start_pipelines
+    @pipelines.each { |id, _| start_pipeline(id) }
+  end
+
+  def shutdown
+    shutdown_pipelines
+  end
+
+  def shutdown_pipelines
+    @pipelines.each { |id, _| stop_pipeline(id) }
+  end
+
+  def stop_pipeline(id)
+    pipeline = @pipelines[id]
+    return unless pipeline
+    @logger.log("stopping pipeline", :id => id)
+    pipeline.shutdown { LogStash::ShutdownWatcher.start(pipeline) }
+    @pipelines[id].thread.join
+  end
+
+  def running_pipelines?
+    @upgrade_mutex.synchronize do
+      @pipelines.select {|pipeline_id, _| running_pipeline?(pipeline_id) }.any?
+    end
+  end
+
+  def running_pipeline?(pipeline_id)
+    thread = @pipelines[pipeline_id].thread
+    thread.is_a?(Thread) && thread.alive?
+  end
+
+  def upgrade_pipeline(pipeline_id, new_pipeline)
+    stop_pipeline(pipeline_id)
+    @pipelines[pipeline_id] = new_pipeline
+    start_pipeline(pipeline_id)
+  end
+
+  def clean_state?
+    @pipelines.empty?
+  end
+
+  # since this method modifies the @pipelines hash it is
+  # wrapped in @upgrade_mutex in the parent call `reload_state!`
+  def reload_pipeline!(id)
+    old_pipeline = @pipelines[id]
+    new_pipeline = create_pipeline(old_pipeline.original_settings)
+    return if new_pipeline.nil?
+
+    if old_pipeline.config_str == new_pipeline.config_str
+      @logger.debug("no configuration change for pipeline",
+                    :pipeline => id, :config => old_pipeline.config_str)
+    elsif new_pipeline.non_reloadable_plugins.any?
+      @logger.error(I18n.t("logstash.agent.non_reloadable_config_reload"),
+                    :pipeline_id => id,
+                    :plugins => new_pipeline.non_reloadable_plugins.map(&:class))
+    else
+      @logger.log("fetched new config for pipeline. upgrading..",
+                   :pipeline => id, :config => new_pipeline.config_str)
+      upgrade_pipeline(id, new_pipeline)
+    end
+  end
+
+  def start_pipeline(id)
+    pipeline = @pipelines[id]
+    return unless pipeline.is_a?(LogStash::Pipeline)
+    return if pipeline.ready?
+    @logger.info("starting pipeline", :id => id)
+    Thread.new do
+      LogStash::Util.set_thread_name("pipeline.#{id}")
+      begin
+        pipeline.run
+      rescue => e
+        @logger.error("Pipeline aborted due to error", :exception => e, :backtrace => e.backtrace)
+      end
+    end
+    sleep 0.01 until pipeline.ready?
+  end
+
+  ## Pipeline Aux methods ##
+  def fetch_config(settings)
+    @config_loader.format_config(settings[:config_path], settings[:config_string])
+  end
+
+  private
+  def node_uuid
+    @node_uuid ||= SecureRandom.uuid
+  end
+
+  ### Version actions ###
+  def show_version
+    show_version_logstash
+
+    if [:info, :debug].include?(verbosity?) || debug? || verbose?
+      show_version_ruby
+      show_version_java if LogStash::Environment.jruby?
+      show_gems if [:debug].include?(verbosity?) || debug?
+    end
+  end # def show_version
+
+  def show_version_logstash
+    require "logstash/version"
+    puts "logstash #{LOGSTASH_VERSION}"
+  end # def show_version_logstash
+
+  def show_version_ruby
+    puts RUBY_DESCRIPTION
+  end # def show_version_ruby
+
+  def show_version_java
+    properties = java.lang.System.getProperties
+    puts "java #{properties["java.version"]} (#{properties["java.vendor"]})"
+    puts "jvm #{properties["java.vm.name"]} / #{properties["java.vm.version"]}"
+  end # def show_version_java
+
+  def show_gems
+    require "rubygems"
+    Gem::Specification.each do |spec|
+      puts "gem #{spec.name} #{spec.version}"
+    end
+  end # def show_gems
+
+end # class LogStash::Agent
diff --git a/lib/logstash/certs/cacert.pem b/logstash-core/lib/logstash/certs/cacert.pem
similarity index 100%
rename from lib/logstash/certs/cacert.pem
rename to logstash-core/lib/logstash/certs/cacert.pem
diff --git a/lib/logstash/codecs/base.rb b/logstash-core/lib/logstash/codecs/base.rb
similarity index 96%
rename from lib/logstash/codecs/base.rb
rename to logstash-core/lib/logstash/codecs/base.rb
index 25fad9da702..4d10950f534 100644
--- a/lib/logstash/codecs/base.rb
+++ b/logstash-core/lib/logstash/codecs/base.rb
@@ -11,7 +11,7 @@ module LogStash::Codecs; class Base < LogStash::Plugin
 
   def initialize(params={})
     super
-    config_init(params)
+    config_init(@params)
     register if respond_to?(:register)
   end
 
@@ -27,7 +27,7 @@ def encode(event)
     raise "#{self.class}#encode must be overidden"
   end # def encode
 
-  public 
+  public
   def close; end;
 
   # @param block [Proc(event, data)] the callback proc passing the original event and the encoded event
diff --git a/lib/logstash/config/config_ast.rb b/logstash-core/lib/logstash/config/config_ast.rb
similarity index 96%
rename from lib/logstash/config/config_ast.rb
rename to logstash-core/lib/logstash/config/config_ast.rb
index ace7322fedb..8f8c4ef060d 100644
--- a/lib/logstash/config/config_ast.rb
+++ b/logstash-core/lib/logstash/config/config_ast.rb
@@ -107,7 +107,11 @@ def compile
       ["filter", "output"].each do |type|
         # defines @filter_func and @output_func
 
-        definitions << "def #{type}_func(event)"
+        # This need to be defined as a singleton method
+        # so each instance of the pipeline has his own implementation
+        # of the output/filter function
+        definitions << "define_singleton_method :#{type}_func do |event|"
+        definitions << "  targeted_outputs = []" if type == "output"
         definitions << "  events = [event]" if type == "filter"
         definitions << "  @logger.debug? && @logger.debug(\"#{type} received\", :event => event.to_hash)"
 
@@ -116,6 +120,7 @@ def compile
         end
 
         definitions << "  events" if type == "filter"
+        definitions << "  targeted_outputs" if type == "output"
         definitions << "end"
       end
 
@@ -237,7 +242,7 @@ def compile
           events = #{variable_name}.multi_filter(events)
         CODE
       when "output"
-        return "#{variable_name}.handle(event)\n"
+        return "targeted_outputs << #{variable_name}\n"
       when "codec"
         settings = attributes.recursive_select(Attribute).collect(&:compile).reject(&:empty?)
         attributes_code = "LogStash::Util.hash_merge_many(#{settings.map { |c| "{ #{c} }" }.join(", ")})"
@@ -386,7 +391,7 @@ def compile
       if type == "filter"
         i = LogStash::Config::AST.defered_conditionals_index += 1
         source = <<-CODE
-          def cond_func_#{i}(input_events)
+          define_singleton_method :cond_func_#{i} do |input_events|
             result = []
             input_events.each do |event|
               events = [event]
@@ -402,7 +407,7 @@ def cond_func_#{i}(input_events)
         <<-CODE
           events = cond_func_#{i}(events)
         CODE
-      else
+      else # Output
         <<-CODE
           #{super}
           end
diff --git a/lib/logstash/config/cpu_core_strategy.rb b/logstash-core/lib/logstash/config/cpu_core_strategy.rb
similarity index 100%
rename from lib/logstash/config/cpu_core_strategy.rb
rename to logstash-core/lib/logstash/config/cpu_core_strategy.rb
diff --git a/lib/logstash/config/defaults.rb b/logstash-core/lib/logstash/config/defaults.rb
similarity index 60%
rename from lib/logstash/config/defaults.rb
rename to logstash-core/lib/logstash/config/defaults.rb
index ac3466f771d..c0c18fd7c04 100644
--- a/lib/logstash/config/defaults.rb
+++ b/logstash-core/lib/logstash/config/defaults.rb
@@ -6,6 +6,14 @@ module LogStash module Config module Defaults
 
   extend self
 
+  def input
+    "input { stdin { type => stdin } }"
+  end
+
+  def output
+    "output { stdout { codec => rubydebug } }"
+  end
+
   def cpu_cores
     Concurrent.processor_count
   end
diff --git a/lib/logstash/config/file.rb b/logstash-core/lib/logstash/config/file.rb
similarity index 100%
rename from lib/logstash/config/file.rb
rename to logstash-core/lib/logstash/config/file.rb
diff --git a/lib/logstash/config/grammar.rb b/logstash-core/lib/logstash/config/grammar.rb
similarity index 100%
rename from lib/logstash/config/grammar.rb
rename to logstash-core/lib/logstash/config/grammar.rb
diff --git a/lib/logstash/config/grammar.treetop b/logstash-core/lib/logstash/config/grammar.treetop
similarity index 100%
rename from lib/logstash/config/grammar.treetop
rename to logstash-core/lib/logstash/config/grammar.treetop
diff --git a/logstash-core/lib/logstash/config/loader.rb b/logstash-core/lib/logstash/config/loader.rb
new file mode 100644
index 00000000000..f35a8fe1acc
--- /dev/null
+++ b/logstash-core/lib/logstash/config/loader.rb
@@ -0,0 +1,97 @@
+require "logstash/config/defaults"
+
+module LogStash; module Config; class Loader
+  attr_accessor :debug_config
+
+  def initialize(logger, debug_config=false)
+    @logger = logger
+    @debug_config = debug_config
+  end
+
+  def format_config(config_path, config_string)
+    config_string = config_string.to_s
+    if config_path
+      # Append the config string.
+      # This allows users to provide both -f and -e flags. The combination
+      # is rare, but useful for debugging.
+      config_string = config_string + load_config(config_path)
+    else
+      # include a default stdin input if no inputs given
+      if config_string !~ /input *{/
+        config_string += LogStash::Config::Defaults.input
+      end
+      # include a default stdout output if no outputs given
+      if config_string !~ /output *{/
+        config_string += LogStash::Config::Defaults.output
+      end
+    end
+    config_string
+  end
+
+  def load_config(path)
+    begin
+      uri = URI.parse(path)
+
+      case uri.scheme
+      when nil then
+        local_config(path)
+      when /http/ then
+        fetch_config(uri)
+      when "file" then
+        local_config(uri.path)
+      else
+        fail(I18n.t("logstash.agent.configuration.scheme-not-supported", :path => path))
+      end
+    rescue URI::InvalidURIError
+      # fallback for windows.
+      # if the parsing of the file failed we assume we can reach it locally.
+      # some relative path on windows arent parsed correctly (.\logstash.conf)
+      local_config(path)
+    end
+  end
+
+  def local_config(path)
+    path = ::File.expand_path(path)
+    path = ::File.join(path, "*") if ::File.directory?(path)
+
+    if Dir.glob(path).length == 0
+      fail(I18n.t("logstash.agent.configuration.file-not-found", :path => path))
+    end
+
+    config = ""
+    encoding_issue_files = []
+    Dir.glob(path).sort.each do |file|
+      next unless ::File.file?(file)
+      if file.match(/~$/)
+        @logger.debug("NOT reading config file because it is a temp file", :config_file => file)
+        next
+      end
+      @logger.debug("Reading config file", :config_file => file)
+      cfg = ::File.read(file)
+      if !cfg.ascii_only? && !cfg.valid_encoding?
+        encoding_issue_files << file
+      end
+      config << cfg + "\n"
+      if @debug_config
+        @logger.debug? && @logger.debug("\nThe following is the content of a file", :config_file => file.to_s)
+        @logger.debug? && @logger.debug("\n" + cfg + "\n\n")
+      end
+    end
+    if encoding_issue_files.any?
+      fail("The following config files contains non-ascii characters but are not UTF-8 encoded #{encoding_issue_files}")
+    end
+    if @debug_config
+      @logger.debug? && @logger.debug("\nThe following is the merged configuration")
+      @logger.debug? && @logger.debug("\n" + config + "\n\n")
+    end
+    return config
+  end # def load_config
+
+  def fetch_config(uri)
+    begin
+      Net::HTTP.get(uri) + "\n"
+    rescue Exception => e
+      fail(I18n.t("logstash.agent.configuration.fetch-failed", :path => uri.to_s, :message => e.message))
+    end
+  end
+end end end
diff --git a/lib/logstash/config/mixin.rb b/logstash-core/lib/logstash/config/mixin.rb
similarity index 86%
rename from lib/logstash/config/mixin.rb
rename to logstash-core/lib/logstash/config/mixin.rb
index cbfdcf62331..3c93b899c58 100644
--- a/lib/logstash/config/mixin.rb
+++ b/logstash-core/lib/logstash/config/mixin.rb
@@ -38,6 +38,9 @@ module LogStash::Config::Mixin
   PLUGIN_VERSION_1_0_0 = LogStash::Util::PluginVersion.new(1, 0, 0)
   PLUGIN_VERSION_0_9_0 = LogStash::Util::PluginVersion.new(0, 9, 0)
 
+  ALLOW_ENV_FLAG = "__ALLOW_ENV__"
+  ENV_PLACEHOLDER_REGEX = /\$\{(?<name>\w+)(\:(?<default>[^}]*))?\}/
+
   # This method is called when someone does 'include LogStash::Config'
   def self.included(base)
     # Add the DSL methods to the 'base' given.
@@ -45,13 +48,21 @@ def self.included(base)
   end
 
   def config_init(params)
+    # HACK(talevy): https://github.com/elastic/logstash/issues/4958
+    # Currently, the regular plugins params argument is hijacked
+    # to pass along the `allow_env` configuration variable. This was done as to 
+    # not change the method signature of Plugin. This also makes it difficul to 
+    # reason about at the same time. ALLOW_ENV_FLAG is a special param that users 
+    # are now forbidden to set in their configuration definitions.
+    allow_env = params.delete(LogStash::Config::Mixin::ALLOW_ENV_FLAG) { false }
+
     # Validation will modify the values inside params if necessary.
     # For example: converting a string to a number, etc.
     
     # Keep a copy of the original config params so that we can later
     # differentiate between explicit configuration and implicit (default)
     # configuration.
-    @original_params = params.clone
+    original_params = params.clone
     
     # store the plugin type, turns LogStash::Inputs::Base into 'input'
     @plugin_type = self.class.ancestors.find { |a| a.name =~ /::Base$/ }.config_name
@@ -99,6 +110,26 @@ def config_init(params)
       end
     end
 
+    # Resolve environment variables references
+    if allow_env
+        params.each do |name, value|
+        if (value.is_a?(Hash))
+          value.each do |valueHashKey, valueHashValue|
+            value[valueHashKey.to_s] = replace_env_placeholders(valueHashValue)
+          end
+        else
+          if (value.is_a?(Array))
+            value.each_index do |valueArrayIndex|
+              value[valueArrayIndex] = replace_env_placeholders(value[valueArrayIndex])
+            end
+          else
+            params[name.to_s] = replace_env_placeholders(value)
+          end
+        end
+      end
+    end
+
+
     if !self.class.validate(params)
       raise LogStash::ConfigurationError,
         I18n.t("logstash.agent.configuration.invalid_plugin_settings")
@@ -123,9 +154,35 @@ def config_init(params)
       instance_variable_set("@#{key}", value)
     end
 
+    # now that we know the parameters are valid, we can obfuscate the original copy
+    # of the parameters before storing them as an instance variable
+    self.class.secure_params!(original_params)
+    @original_params = original_params
+
     @config = params
   end # def config_init
 
+  # Replace all environment variable references in 'value' param by environment variable value and return updated value
+  # Process following patterns : $VAR, ${VAR}, ${VAR:defaultValue}
+  def replace_env_placeholders(value)
+    return value unless value.is_a?(String)
+
+    value.gsub(ENV_PLACEHOLDER_REGEX) do |placeholder|
+      # Note: Ruby docs claim[1] Regexp.last_match is thread-local and scoped to
+      # the call, so this should be thread-safe.
+      #
+      # [1] http://ruby-doc.org/core-2.1.1/Regexp.html#method-c-last_match
+      name = Regexp.last_match(:name)
+      default = Regexp.last_match(:default)
+
+      replacement = ENV.fetch(name, default)
+      if replacement.nil?
+        raise LogStash::ConfigurationError, "Cannot evaluate `#{placeholder}`. Environment variable `#{name}` is not set and there is no default value given."
+      end
+      replacement
+    end
+  end # def replace_env_placeholders
+
   module DSL
     attr_accessor :flags
 
@@ -147,7 +204,7 @@ def plugin_status(status = nil)
     # inside the gemspec.
     def milestone(m = nil)
       @logger = Cabin::Channel.get(LogStash)
-      @logger.warn(I18n.t('logstash.plugin.deprecated_milestone', :plugin => config_name))
+      @logger.debug(I18n.t('logstash.plugin.deprecated_milestone', :plugin => config_name))
     end
 
     # Define a new configuration setting
@@ -495,6 +552,14 @@ def validate_value(value, validator)
       return true, result
     end # def validate_value
 
+    def secure_params!(params)
+      params.each do |key, value|
+        if @config[key][:validate] == :password && !value.is_a?(::LogStash::Util::Password)
+          params[key] = ::LogStash::Util::Password.new(value)
+        end
+      end
+    end
+
     def hash_or_array(value)
       if !value.is_a?(Hash)
         value = [*value] # coerce scalar to array if necessary
diff --git a/lib/logstash/config/registry.rb b/logstash-core/lib/logstash/config/registry.rb
similarity index 100%
rename from lib/logstash/config/registry.rb
rename to logstash-core/lib/logstash/config/registry.rb
diff --git a/lib/logstash/environment.rb b/logstash-core/lib/logstash/environment.rb
similarity index 81%
rename from lib/logstash/environment.rb
rename to logstash-core/lib/logstash/environment.rb
index 8f710eed088..79e7f24d86c 100644
--- a/lib/logstash/environment.rb
+++ b/logstash-core/lib/logstash/environment.rb
@@ -1,18 +1,10 @@
 # encoding: utf-8
 require "logstash/errors"
-require "logstash/version"
 
 module LogStash
   module Environment
     extend self
 
-    # rehydrate the bootstrap environment if the startup was not done by executing bootstrap.rb
-    # and we are in the context of the logstash package
-    if !LogStash::Environment.const_defined?("LOGSTASH_HOME") &&  !ENV["LOGSTASH_HOME"].to_s.empty?
-      $LOAD_PATH << ::File.join(ENV["LOGSTASH_HOME"], "lib")
-      require "bootstrap/environment"
-    end
-
     LOGSTASH_CORE = ::File.expand_path(::File.join(::File.dirname(__FILE__), "..", ".."))
     LOGSTASH_ENV = (ENV["LS_ENV"] || 'production').to_s.freeze
 
@@ -81,14 +73,6 @@ def windows?
       ::Gem.win_platform?
     end
 
-    def vendor_path(path)
-      return ::File.join(LOGSTASH_HOME, "vendor", path)
-    end
-
-    def pattern_path(path)
-      return ::File.join(LOGSTASH_HOME, "patterns", path)
-    end
-
     def locales_path(path)
       return ::File.join(LOGSTASH_CORE, "locales", path)
     end
diff --git a/lib/logstash/errors.rb b/logstash-core/lib/logstash/errors.rb
similarity index 100%
rename from lib/logstash/errors.rb
rename to logstash-core/lib/logstash/errors.rb
diff --git a/lib/logstash/filters/base.rb b/logstash-core/lib/logstash/filters/base.rb
similarity index 92%
rename from lib/logstash/filters/base.rb
rename to logstash-core/lib/logstash/filters/base.rb
index 4ce752a0e33..ae6616ddf01 100644
--- a/lib/logstash/filters/base.rb
+++ b/logstash-core/lib/logstash/filters/base.rb
@@ -120,7 +120,7 @@ class LogStash::Filters::Base < LogStash::Plugin
   public
   def initialize(params)
     super
-    config_init(params)
+    config_init(@params)
     @threadsafe = true
   end # def initialize
 
@@ -143,6 +143,7 @@ def filter(event)
   # @return [Array<LogStash::Event] filtered events and any new events generated by the filter
   public
   def multi_filter(events)
+    LogStash::Util.set_thread_plugin(self)
     result = []
     events.each do |event|
       unless event.cancelled?
@@ -178,12 +179,16 @@ def filter_matched(event)
 
     LogStash::Util::Decorators.add_tags(@add_tag,event,"filters/#{self.class.name}")
 
+    # note below that the tags array field needs to be updated then reassigned to the event.
+    # this is important because a construct like event["tags"].delete(tag) will not work
+    # in the current Java event implementation. see https://github.com/elastic/logstash/issues/4140
     @remove_tag.each do |tag|
-      break if event["tags"].nil?
+      tags = event["tags"]
+      break if tags.nil? || tags.empty?
       tag = event.sprintf(tag)
-      @logger.debug? and @logger.debug("filters/#{self.class.name}: removing tag",
-                                       :tag => tag)
-      event["tags"].delete(tag)
+      @logger.debug? and @logger.debug("filters/#{self.class.name}: removing tag", :tag => tag)
+      tags.delete(tag)
+      event["tags"] = tags
     end
   end # def filter_matched
 
diff --git a/lib/logstash/inputs/base.rb b/logstash-core/lib/logstash/inputs/base.rb
similarity index 97%
rename from lib/logstash/inputs/base.rb
rename to logstash-core/lib/logstash/inputs/base.rb
index f72dfd743ac..1cf29abd472 100644
--- a/lib/logstash/inputs/base.rb
+++ b/logstash-core/lib/logstash/inputs/base.rb
@@ -53,7 +53,7 @@ def initialize(params={})
     super
     @threadable = false
     @stop_called = Concurrent::AtomicBoolean.new(false)
-    config_init(params)
+    config_init(@params)
     @tags ||= []
   end # def initialize
 
@@ -78,7 +78,7 @@ def stop
 
   public
   def do_stop
-    @logger.debug("stopping", :plugin => self)
+    @logger.debug("stopping", :plugin => self.class.name)
     @stop_called.make_true
     stop
   end
diff --git a/lib/logstash/inputs/threadable.rb b/logstash-core/lib/logstash/inputs/threadable.rb
similarity index 100%
rename from lib/logstash/inputs/threadable.rb
rename to logstash-core/lib/logstash/inputs/threadable.rb
diff --git a/lib/logstash/java_integration.rb b/logstash-core/lib/logstash/java_integration.rb
similarity index 100%
rename from lib/logstash/java_integration.rb
rename to logstash-core/lib/logstash/java_integration.rb
diff --git a/lib/logstash/json.rb b/logstash-core/lib/logstash/json.rb
similarity index 100%
rename from lib/logstash/json.rb
rename to logstash-core/lib/logstash/json.rb
diff --git a/lib/logstash/logging.rb b/logstash-core/lib/logstash/logging.rb
similarity index 100%
rename from lib/logstash/logging.rb
rename to logstash-core/lib/logstash/logging.rb
diff --git a/logstash-core/lib/logstash/logging/json.rb b/logstash-core/lib/logstash/logging/json.rb
new file mode 100644
index 00000000000..1637fa11ce4
--- /dev/null
+++ b/logstash-core/lib/logstash/logging/json.rb
@@ -0,0 +1,21 @@
+# encoding: utf-8
+require "logstash/namespace"
+require "logstash/logging"
+require "logstash/json"
+
+module LogStash; class Logging; class JSON
+  def initialize(io)
+    raise ArgumentError, "Expected IO, got #{io.class.name}" unless io.is_a?(IO)
+
+    @io = io
+    @lock = Mutex.new
+  end
+
+  def <<(obj)
+    serialized = LogStash::Json.dump(obj)
+    @lock.synchronize do
+      @io.puts(serialized)
+      @io.flush
+    end
+  end
+end; end; end
diff --git a/lib/logstash/namespace.rb b/logstash-core/lib/logstash/namespace.rb
similarity index 100%
rename from lib/logstash/namespace.rb
rename to logstash-core/lib/logstash/namespace.rb
diff --git a/logstash-core/lib/logstash/output_delegator.rb b/logstash-core/lib/logstash/output_delegator.rb
new file mode 100644
index 00000000000..dcac7ae8a40
--- /dev/null
+++ b/logstash-core/lib/logstash/output_delegator.rb
@@ -0,0 +1,172 @@
+# encoding: utf-8
+require "concurrent/atomic/atomic_fixnum"
+java_import "java.util.concurrent.CopyOnWriteArrayList"
+
+# This class goes hand in hand with the pipeline to provide a pool of
+# free workers to be used by pipeline worker threads. The pool is
+# internally represented with a SizedQueue set the the size of the number
+# of 'workers' the output plugin is configured with.
+#
+# This plugin also records some basic statistics
+module LogStash class OutputDelegator
+  attr_reader :workers, :config, :threadsafe
+
+  # The *args this takes are the same format that a Outputs::Base takes. A list of hashes with parameters in them
+  # Internally these just get merged together into a single hash
+  def initialize(logger, klass, default_worker_count, *plugin_args)
+    @logger = logger
+    @threadsafe = klass.threadsafe?
+    @config = plugin_args.reduce({}, :merge)
+    @klass = klass
+    @workers = java.util.concurrent.CopyOnWriteArrayList.new
+    @default_worker_count = default_worker_count
+    @registered = false
+    @events_received = Concurrent::AtomicFixnum.new(0)
+  end
+
+  def threadsafe?
+    !!@threadsafe
+  end
+
+  def warn_on_worker_override!
+    # The user has configured extra workers, but this plugin doesn't support it :(
+    if worker_limits_overriden?
+      message = @klass.workers_not_supported_message
+      warning_meta = {:plugin => @klass.config_name, :worker_count => @config["workers"]}
+      if message
+        warning_meta[:message] = message
+        @logger.warn(I18n.t("logstash.pipeline.output-worker-unsupported-with-message", warning_meta))
+      else
+        @logger.warn(I18n.t("logstash.pipeline.output-worker-unsupported", warning_meta))
+      end
+    end
+  end
+
+  def worker_limits_overriden?
+    @config["workers"] && @config["workers"] > 1 && @klass.workers_not_supported?
+  end
+
+  def target_worker_count
+    # Remove in 5.0 after all plugins upgraded to use class level declarations
+    raise ArgumentError, "Attempted to detect target worker count before instantiating a worker to test for legacy workers_not_supported!" if @workers.size == 0
+
+    if @threadsafe || @klass.workers_not_supported?
+      1
+    else
+      @config["workers"] || @default_worker_count
+    end
+  end
+
+  def config_name
+    @klass.config_name
+  end
+
+  def register
+    raise ArgumentError, "Attempted to register #{self} twice!" if @registered
+    @registered = true
+    # We define this as an array regardless of threadsafety
+    # to make reporting simpler, even though a threadsafe plugin will just have
+    # a single instance
+    #
+    # Older plugins invoke the instance method Outputs::Base#workers_not_supported
+    # To detect these we need an instance to be created first :()
+    # TODO: In the next major version after 2.x remove support for this
+    @workers << @klass.new(@config)
+    @workers.first.register # Needed in case register calls `workers_not_supported`
+
+    @logger.debug("Will start workers for output", :worker_count => target_worker_count, :class => @klass.name)
+
+    # Threadsafe versions don't need additional workers
+    setup_additional_workers!(target_worker_count) unless @threadsafe
+    # We skip the first worker because that's pre-registered to deal with legacy workers_not_supported
+    @workers.subList(1,@workers.size).each(&:register)
+    setup_multi_receive!
+  end
+
+  def setup_additional_workers!(target_worker_count)
+    warn_on_worker_override!
+
+    (target_worker_count - 1).times do
+      inst = @klass.new(@config)
+      @workers << inst
+    end
+
+    # This queue is used to manage sharing across threads
+    @worker_queue = SizedQueue.new(target_worker_count)
+    @workers.each {|w| @worker_queue << w }
+  end
+
+  def setup_multi_receive!
+    # One might wonder why we don't use something like
+    # define_singleton_method(:multi_receive, method(:threadsafe_multi_receive)
+    # and the answer is this is buggy on Jruby 1.7.x . It works 98% of the time!
+    # The other 2% you get weird errors about rebinding to the same object
+    # Until we switch to Jruby 9.x keep the define_singleton_method parts
+    # the way they are, with a block
+    # See https://github.com/jruby/jruby/issues/3582
+    if threadsafe?
+      @threadsafe_worker = @workers.first
+      define_singleton_method(:multi_receive) do |events|
+        threadsafe_multi_receive(events)
+      end
+    else
+      define_singleton_method(:multi_receive) do |events|
+        worker_multi_receive(events)
+      end
+    end
+  end
+
+  def threadsafe_multi_receive(events)
+    @events_received.increment(events.length)
+
+    @threadsafe_worker.multi_receive(events)
+  end
+
+  def worker_multi_receive(events)
+    @events_received.increment(events.length)
+
+    worker = @worker_queue.pop
+    begin
+      worker.multi_receive(events)
+    ensure
+      @worker_queue.push(worker)
+    end
+  end
+
+  def do_close
+    @logger.debug("closing output delegator", :klass => @klass.name)
+
+    if @threadsafe
+      @workers.each(&:do_close)
+    else
+      worker_count.times do
+        worker = @worker_queue.pop
+        worker.do_close
+      end
+    end
+  end
+
+  def events_received
+    @events_received.value
+  end
+
+  # There's no concept of 'busy' workers for a threadsafe plugin!
+  def busy_workers
+    if @threadsafe
+      0
+    else
+      # The pipeline reporter can run before the outputs are registered trying to pull a value here
+      # In that case @worker_queue is empty, we just return 0
+      return 0 unless @worker_queue
+      @workers.size - @worker_queue.size
+    end
+  end
+
+  def worker_count
+    @workers.size
+  end
+
+  private
+  # Needed for testing, so private
+  attr_reader :threadsafe_worker, :worker_queue
+end end
diff --git a/lib/logstash/outputs/base.rb b/logstash-core/lib/logstash/outputs/base.rb
similarity index 59%
rename from lib/logstash/outputs/base.rb
rename to logstash-core/lib/logstash/outputs/base.rb
index d3c49899860..3f59cc0e715 100644
--- a/lib/logstash/outputs/base.rb
+++ b/logstash-core/lib/logstash/outputs/base.rb
@@ -4,6 +4,8 @@
 require "logstash/plugin"
 require "logstash/namespace"
 require "logstash/config/mixin"
+require "logstash/util/wrapped_synchronous_queue"
+require "concurrent/atomic/atomic_fixnum"
 
 class LogStash::Outputs::Base < LogStash::Plugin
   include LogStash::Config::Mixin
@@ -23,23 +25,46 @@ class LogStash::Outputs::Base < LogStash::Plugin
   # Note that this setting may not be useful for all outputs.
   config :workers, :validate => :number, :default => 1
 
-  attr_reader :worker_plugins, :worker_queue
+  attr_reader :worker_plugins, :available_workers, :workers, :worker_plugins, :workers_not_supported
+
+  def self.declare_threadsafe!
+    declare_workers_not_supported!
+    @threadsafe = true
+  end
+
+  def self.threadsafe?
+    @threadsafe == true
+  end
+
+  def self.declare_workers_not_supported!(message=nil)
+    @workers_not_supported_message = message
+    @workers_not_supported = true
+  end
+
+  def self.workers_not_supported_message
+    @workers_not_supported_message
+  end
+
+  def self.workers_not_supported?
+    !!@workers_not_supported
+  end
 
   public
+  # TODO: Remove this in the next major version after Logstash 2.x
+  # Post 2.x it should raise an error and tell people to use the class level
+  # declaration
   def workers_not_supported(message=nil)
-    return if @workers == 1
-    if message
-      @logger.warn(I18n.t("logstash.pipeline.output-worker-unsupported-with-message", :plugin => self.class.config_name, :worker_count => @workers, :message => message))
-    else
-      @logger.warn(I18n.t("logstash.pipeline.output-worker-unsupported", :plugin => self.class.config_name, :worker_count => @workers))
-    end
-    @workers = 1
+    self.class.declare_workers_not_supported!(message)
   end
 
   public
   def initialize(params={})
     super
-    config_init(params)
+    config_init(@params)
+
+    # If we're running with a single thread we must enforce single-threaded concurrency by default
+    # Maybe in a future version we'll assume output plugins are threadsafe
+    @single_worker_mutex = Mutex.new
   end
 
   public
@@ -53,33 +78,9 @@ def receive(event)
   end # def receive
 
   public
-  def worker_setup
-    if @workers == 1
-      @worker_plugins = [self]
-    else
-      define_singleton_method(:handle, method(:handle_worker))
-      @worker_queue = SizedQueue.new(20)
-      @worker_plugins = @workers.times.map { self.class.new(@original_params.merge("workers" => 1)) }
-      @worker_plugins.map.with_index do |plugin, i|
-        Thread.new(original_params, @worker_queue) do |params, queue|
-          LogStash::Util::set_thread_name(">#{self.class.config_name}.#{i}")
-          plugin.register
-          while true
-            event = queue.pop
-            plugin.handle(event)
-          end
-        end
-      end
-    end
-  end
-
-  public
-  def handle(event)
-    receive(event)
-  end # def handle
-
-  def handle_worker(event)
-    @worker_queue.push(event)
+  # To be overriden in implementations
+  def multi_receive(events)
+    events.each {|event| receive(event) }
   end
 
   private
diff --git a/lib/logstash/patches.rb b/logstash-core/lib/logstash/patches.rb
similarity index 100%
rename from lib/logstash/patches.rb
rename to logstash-core/lib/logstash/patches.rb
diff --git a/lib/logstash/patches/bugfix_jruby_2558.rb b/logstash-core/lib/logstash/patches/bugfix_jruby_2558.rb
similarity index 100%
rename from lib/logstash/patches/bugfix_jruby_2558.rb
rename to logstash-core/lib/logstash/patches/bugfix_jruby_2558.rb
diff --git a/lib/logstash/patches/cabin.rb b/logstash-core/lib/logstash/patches/cabin.rb
similarity index 100%
rename from lib/logstash/patches/cabin.rb
rename to logstash-core/lib/logstash/patches/cabin.rb
diff --git a/lib/logstash/patches/profile_require_calls.rb b/logstash-core/lib/logstash/patches/profile_require_calls.rb
similarity index 100%
rename from lib/logstash/patches/profile_require_calls.rb
rename to logstash-core/lib/logstash/patches/profile_require_calls.rb
diff --git a/lib/logstash/patches/rubygems.rb b/logstash-core/lib/logstash/patches/rubygems.rb
similarity index 100%
rename from lib/logstash/patches/rubygems.rb
rename to logstash-core/lib/logstash/patches/rubygems.rb
diff --git a/lib/logstash/patches/stronger_openssl_defaults.rb b/logstash-core/lib/logstash/patches/stronger_openssl_defaults.rb
similarity index 100%
rename from lib/logstash/patches/stronger_openssl_defaults.rb
rename to logstash-core/lib/logstash/patches/stronger_openssl_defaults.rb
diff --git a/logstash-core/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
new file mode 100644
index 00000000000..cdda242581d
--- /dev/null
+++ b/logstash-core/lib/logstash/pipeline.rb
@@ -0,0 +1,510 @@
+# encoding: utf-8
+require "thread"
+require "stud/interval"
+require "concurrent"
+require "logstash/namespace"
+require "logstash/errors"
+require "logstash/event"
+require "logstash/config/file"
+require "logstash/filters/base"
+require "logstash/inputs/base"
+require "logstash/outputs/base"
+require "logstash/config/cpu_core_strategy"
+require "logstash/util/defaults_printer"
+require "logstash/shutdown_watcher"
+require "logstash/util/wrapped_synchronous_queue"
+require "logstash/pipeline_reporter"
+require "logstash/output_delegator"
+
+module LogStash; class Pipeline
+  attr_reader :inputs, :filters, :outputs, :worker_threads, :events_consumed, :events_filtered, :reporter, :pipeline_id, :logger, :thread, :config_str, :original_settings
+
+  DEFAULT_OUTPUT_WORKERS = 1
+
+  DEFAULT_SETTINGS = {
+    :default_pipeline_workers => LogStash::Config::CpuCoreStrategy.maximum,
+    :pipeline_batch_size => 125,
+    :pipeline_batch_delay => 5, # in milliseconds
+    :flush_interval => 5, # in seconds
+    :flush_timeout_interval => 60, # in seconds
+    :debug_config => false,
+    :allow_env => false
+  }
+  MAX_INFLIGHT_WARN_THRESHOLD = 10_000
+
+  RELOAD_INCOMPATIBLE_PLUGINS = [
+    "LogStash::Inputs::Stdin"
+  ]
+
+  def initialize(config_str, settings = {})
+    @config_str = config_str
+    @original_settings = settings
+    @logger = Cabin::Channel.get(LogStash)
+    @pipeline_id = settings[:pipeline_id] || self.object_id
+    @settings = DEFAULT_SETTINGS.clone
+    settings.each {|setting, value| configure(setting, value) }
+    @reporter = LogStash::PipelineReporter.new(@logger, self)
+    @allow_env = settings[:allow_env]
+
+    @inputs = nil
+    @filters = nil
+    @outputs = nil
+
+    @worker_threads = []
+
+    grammar = LogStashConfigParser.new
+    @config = grammar.parse(config_str)
+    if @config.nil?
+      raise LogStash::ConfigurationError, grammar.failure_reason
+    end
+    # This will compile the config to ruby and evaluate the resulting code.
+    # The code will initialize all the plugins and define the
+    # filter and output methods.
+    code = @config.compile
+    # The config code is hard to represent as a log message...
+    # So just print it.
+    if @settings[:debug_config]
+      @logger.debug? && @logger.debug("Compiled pipeline code:\n#{code}")
+    end
+    begin
+      eval(code)
+    rescue => e
+      raise
+    end
+
+    @input_queue = LogStash::Util::WrappedSynchronousQueue.new
+    @events_filtered = Concurrent::AtomicFixnum.new(0)
+    @events_consumed = Concurrent::AtomicFixnum.new(0)
+
+    # We generally only want one thread at a time able to access pop/take/poll operations
+    # from this queue. We also depend on this to be able to block consumers while we snapshot
+    # in-flight buffers
+    @input_queue_pop_mutex = Mutex.new
+    @input_threads = []
+    # @ready requires thread safety since it is typically polled from outside the pipeline thread
+    @ready = Concurrent::AtomicBoolean.new(false)
+    @running = Concurrent::AtomicBoolean.new(false)
+    @flushing = Concurrent::AtomicReference.new(false)
+  end # def initialize
+
+  def ready?
+    @ready.value
+  end
+
+  def configure(setting, value)
+    @settings[setting] = value
+  end
+
+  def safe_pipeline_worker_count
+    default = DEFAULT_SETTINGS[:default_pipeline_workers]
+    thread_count = @settings[:pipeline_workers] #override from args "-w 8" or config
+    safe_filters, unsafe_filters = @filters.partition(&:threadsafe?)
+
+    if unsafe_filters.any?
+      plugins = unsafe_filters.collect { |f| f.class.config_name }
+      case thread_count
+      when nil
+        # user did not specify a worker thread count
+        # warn if the default is multiple
+
+        if default > 1
+          @logger.warn("Defaulting pipeline worker threads to 1 because there are some filters that might not work with multiple worker threads",
+                       :count_was => default, :filters => plugins)
+        end
+
+        1 # can't allow the default value to propagate if there are unsafe filters
+      when 0, 1
+        1
+      else
+        @logger.warn("Warning: Manual override - there are filters that might not work with multiple worker threads",
+                     :worker_threads => thread_count, :filters => plugins)
+        thread_count # allow user to force this even if there are unsafe filters
+      end
+    else
+      thread_count || default
+    end
+  end
+
+  def filters?
+    return @filters.any?
+  end
+
+  def run
+    @logger.terminal(LogStash::Util::DefaultsPrinter.print(@settings))
+    @thread = Thread.current
+
+    start_workers
+
+    @logger.log("Pipeline #{@pipeline_id} started")
+
+    # Block until all inputs have stopped
+    # Generally this happens if SIGINT is sent and `shutdown` is called from an external thread
+
+    transition_to_running
+    start_flusher # Launches a non-blocking thread for flush events
+    wait_inputs
+    transition_to_stopped
+
+    @logger.info("Input plugins stopped! Will shutdown filter/output workers.")
+
+    shutdown_flusher
+    shutdown_workers
+
+    @logger.log("Pipeline #{@pipeline_id} has been shutdown")
+
+    # exit code
+    return 0
+  end # def run
+
+  def transition_to_running
+    @running.make_true
+  end
+
+  def transition_to_stopped
+    @running.make_false
+  end
+
+  def running?
+    @running.true?
+  end
+
+  def stopped?
+    @running.false?
+  end
+
+  def start_workers
+    @inflight_batches = {}
+
+    @worker_threads.clear # In case we're restarting the pipeline
+    begin
+      start_inputs
+      @outputs.each {|o| o.register }
+      @filters.each {|f| f.register}
+
+      pipeline_workers = safe_pipeline_worker_count
+      batch_size = @settings[:pipeline_batch_size]
+      batch_delay = @settings[:pipeline_batch_delay]
+      max_inflight = batch_size * pipeline_workers
+      @logger.info("Starting pipeline",
+                   :id => self.pipeline_id,
+                   :pipeline_workers => pipeline_workers,
+                   :batch_size => batch_size,
+                   :batch_delay => batch_delay,
+                   :max_inflight => max_inflight)
+      if max_inflight > MAX_INFLIGHT_WARN_THRESHOLD
+        @logger.warn "CAUTION: Recommended inflight events max exceeded! Logstash will run with up to #{max_inflight} events in memory in your current configuration. If your message sizes are large this may cause instability with the default heap size. Please consider setting a non-standard heap size, changing the batch size (currently #{batch_size}), or changing the number of pipeline workers (currently #{pipeline_workers})"
+      end
+
+      pipeline_workers.times do |t|
+        @worker_threads << Thread.new do
+          LogStash::Util.set_thread_name("[#{pipeline_id}]>worker#{t}")
+          worker_loop(batch_size, batch_delay)
+        end
+      end
+    ensure
+      # it is important to garantee @ready to be true after the startup sequence has been completed
+      # to potentially unblock the shutdown method which may be waiting on @ready to proceed
+      @ready.make_true
+    end
+  end
+
+  # Main body of what a worker thread does
+  # Repeatedly takes batches off the queu, filters, then outputs them
+  def worker_loop(batch_size, batch_delay)
+    running = true
+
+    while running
+      # To understand the purpose behind this synchronize please read the body of take_batch
+      input_batch, signal = @input_queue_pop_mutex.synchronize { take_batch(batch_size, batch_delay) }
+      running = false if signal == LogStash::SHUTDOWN
+
+      @events_consumed.increment(input_batch.size)
+
+      filtered_batch = filter_batch(input_batch)
+
+      if signal # Flush on SHUTDOWN or FLUSH
+        flush_options = (signal == LogStash::SHUTDOWN) ? {:final => true} : {}
+        flush_filters_to_batch(filtered_batch, flush_options)
+      end
+
+      @events_filtered.increment(filtered_batch.size)
+
+      output_batch(filtered_batch)
+
+      inflight_batches_synchronize { set_current_thread_inflight_batch(nil) }
+    end
+  end
+
+  def take_batch(batch_size, batch_delay)
+    batch = []
+    # Since this is externally synchronized in `worker_look` wec can guarantee that the visibility of an insight batch
+    # guaranteed to be a full batch not a partial batch
+    set_current_thread_inflight_batch(batch)
+
+    signal = false
+    batch_size.times do |t|
+      event = (t == 0) ? @input_queue.take : @input_queue.poll(batch_delay)
+
+      if event.nil?
+        next
+      elsif event == LogStash::SHUTDOWN || event == LogStash::FLUSH
+        # We MUST break here. If a batch consumes two SHUTDOWN events
+        # then another worker may have its SHUTDOWN 'stolen', thus blocking
+        # the pipeline. We should stop doing work after flush as well.
+        signal = event
+        break
+      else
+        batch << event
+      end
+    end
+
+    [batch, signal]
+  end
+
+  def filter_batch(batch)
+    batch.reduce([]) do |acc,e|
+      if e.is_a?(LogStash::Event)
+        filtered = filter_func(e)
+        filtered.each {|fe| acc << fe unless fe.cancelled?}
+      end
+      acc
+    end
+  rescue Exception => e
+    # Plugins authors should manage their own exceptions in the plugin code
+    # but if an exception is raised up to the worker thread they are considered
+    # fatal and logstash will not recover from this situation.
+    #
+    # Users need to check their configuration or see if there is a bug in the
+    # plugin.
+    @logger.error("Exception in pipelineworker, the pipeline stopped processing new events, please check your filter configuration and restart Logstash.",
+                  "exception" => e, "backtrace" => e.backtrace)
+    raise
+  end
+
+  # Take an array of events and send them to the correct output
+  def output_batch(batch)
+    # Build a mapping of { output_plugin => [events...]}
+    outputs_events = batch.reduce(Hash.new { |h, k| h[k] = [] }) do |acc, event|
+      # We ask the AST to tell us which outputs to send each event to
+      # Then, we stick it in the correct bin
+
+      # output_func should never return anything other than an Array but we have lots of legacy specs
+      # that monkeypatch it and return nil. We can deprecate  "|| []" after fixing these specs
+      outputs_for_event = output_func(event) || []
+
+      outputs_for_event.each { |output| acc[output] << event }
+      acc
+    end
+
+    # Now that we have our output to event mapping we can just invoke each output
+    # once with its list of events
+    outputs_events.each { |output, events| output.multi_receive(events) }
+  end
+
+  def set_current_thread_inflight_batch(batch)
+    @inflight_batches[Thread.current] = batch
+  end
+
+  def inflight_batches_synchronize
+    @input_queue_pop_mutex.synchronize do
+      yield(@inflight_batches)
+    end
+  end
+
+  def wait_inputs
+    @input_threads.each(&:join)
+  end
+
+  def start_inputs
+    moreinputs = []
+    @inputs.each do |input|
+      if input.threadable && input.threads > 1
+        (input.threads - 1).times do |i|
+          moreinputs << input.clone
+        end
+      end
+    end
+    @inputs += moreinputs
+
+    @inputs.each do |input|
+      input.register
+      start_input(input)
+    end
+  end
+
+  def start_input(plugin)
+    @input_threads << Thread.new { inputworker(plugin) }
+  end
+
+  def inputworker(plugin)
+    LogStash::Util::set_thread_name("[#{pipeline_id}]<#{plugin.class.config_name}")
+    begin
+      plugin.run(@input_queue)
+    rescue => e
+      if plugin.stop?
+        @logger.debug("Input plugin raised exception during shutdown, ignoring it.",
+                      :plugin => plugin.class.config_name, :exception => e,
+                      :backtrace => e.backtrace)
+        return
+      end
+
+      # otherwise, report error and restart
+      if @logger.debug?
+        @logger.error(I18n.t("logstash.pipeline.worker-error-debug",
+                             :plugin => plugin.inspect, :error => e.to_s,
+                             :exception => e.class,
+                             :stacktrace => e.backtrace.join("\n")))
+      else
+        @logger.error(I18n.t("logstash.pipeline.worker-error",
+                             :plugin => plugin.inspect, :error => e))
+      end
+
+      # Assuming the failure that caused this exception is transient,
+      # let's sleep for a bit and execute #run again
+      sleep(1)
+      retry
+    ensure
+      plugin.do_close
+    end
+  end # def inputworker
+
+  # initiate the pipeline shutdown sequence
+  # this method is intended to be called from outside the pipeline thread
+  # @param before_stop [Proc] code block called before performing stop operation on input plugins
+  def shutdown(&before_stop)
+    # shutdown can only start once the pipeline has completed its startup.
+    # avoid potential race conditoon between the startup sequence and this
+    # shutdown method which can be called from another thread at any time
+    sleep(0.1) while !ready?
+
+    # TODO: should we also check against calling shutdown multiple times concurently?
+
+    before_stop.call if block_given?
+
+    @logger.info "Closing inputs"
+    @inputs.each(&:do_stop)
+    @logger.info "Closed inputs"
+  end # def shutdown
+
+  # After `shutdown` is called from an external thread this is called from the main thread to
+  # tell the worker threads to stop and then block until they've fully stopped
+  # This also stops all filter and output plugins
+  def shutdown_workers
+    # Each worker thread will receive this exactly once!
+    @worker_threads.each do |t|
+      @logger.debug("Pushing shutdown", :thread => t.inspect)
+      @input_queue.push(LogStash::SHUTDOWN)
+    end
+
+    @worker_threads.each do |t|
+      @logger.debug("Shutdown waiting for worker thread #{t}")
+      t.join
+    end
+
+    @filters.each(&:do_close)
+    @outputs.each(&:do_close)
+  end
+
+  def plugin(plugin_type, name, *args)
+    args << {} if args.empty?
+    args.first.merge!(LogStash::Config::Mixin::ALLOW_ENV_FLAG => @allow_env)
+
+    klass = LogStash::Plugin.lookup(plugin_type, name)
+
+    if plugin_type == "output"
+      LogStash::OutputDelegator.new(@logger, klass, DEFAULT_OUTPUT_WORKERS, *args)
+    else
+      klass.new(*args)
+    end
+  end
+
+  # for backward compatibility in devutils for the rspec helpers, this method is not used
+  # in the pipeline anymore.
+  def filter(event, &block)
+    # filter_func returns all filtered events, including cancelled ones
+    filter_func(event).each { |e| block.call(e) }
+  end
+
+
+  # perform filters flush and yeild flushed event to the passed block
+  # @param options [Hash]
+  # @option options [Boolean] :final => true to signal a final shutdown flush
+  def flush_filters(options = {}, &block)
+    flushers = options[:final] ? @shutdown_flushers : @periodic_flushers
+
+    flushers.each do |flusher|
+      flusher.call(options, &block)
+    end
+  end
+
+  def start_flusher
+    # Invariant to help detect improper initialization
+    raise "Attempted to start flusher on a stopped pipeline!" if stopped?
+
+    @flusher_thread = Thread.new do
+      while Stud.stoppable_sleep(5, 0.1) { stopped? }
+        flush
+        break if stopped?
+      end
+    end
+  end
+
+  def shutdown_flusher
+    @flusher_thread.join
+  end
+
+  def flush
+    if @flushing.compare_and_set(false, true)
+      @logger.debug? && @logger.debug("Pushing flush onto pipeline")
+      @input_queue.push(LogStash::FLUSH)
+    end
+  end
+
+  # perform filters flush into the output queue
+  # @param options [Hash]
+  # @option options [Boolean] :final => true to signal a final shutdown flush
+  def flush_filters_to_batch(batch, options = {})
+    flush_filters(options) do |event|
+      unless event.cancelled?
+        @logger.debug? and @logger.debug("Pushing flushed events", :event => event)
+        batch << event
+      end
+    end
+
+    @flushing.set(false)
+  end # flush_filters_to_output!
+
+  def plugin_threads_info
+    input_threads = @input_threads.select {|t| t.alive? }
+    worker_threads = @worker_threads.select {|t| t.alive? }
+    (input_threads + worker_threads).map {|t| LogStash::Util.thread_info(t) }
+  end
+
+  def stalling_threads_info
+    plugin_threads_info
+      .reject {|t| t["blocked_on"] } # known benign blocking statuses
+      .each {|t| t.delete("backtrace") }
+      .each {|t| t.delete("blocked_on") }
+      .each {|t| t.delete("status") }
+  end
+
+  def non_reloadable_plugins
+    (inputs + filters + outputs).select do |plugin|
+      RELOAD_INCOMPATIBLE_PLUGINS.include?(plugin.class.name)
+    end
+  end
+
+  # Sometimes we log stuff that will dump the pipeline which may contain
+  # sensitive information (like the raw syntax tree which can contain passwords)
+  # We want to hide most of what's in here
+  def inspect
+    {
+      :pipeline_id => @pipeline_id,
+      :settings => @settings.inspect,
+      :ready => @ready,
+      :running => @running,
+      :flushing => @flushing
+    }
+  end
+
+end end
diff --git a/logstash-core/lib/logstash/pipeline_reporter.rb b/logstash-core/lib/logstash/pipeline_reporter.rb
new file mode 100644
index 00000000000..c7ae6ca847c
--- /dev/null
+++ b/logstash-core/lib/logstash/pipeline_reporter.rb
@@ -0,0 +1,114 @@
+# encoding: utf-8
+require 'ostruct'
+
+module LogStash; class PipelineReporter
+  attr_reader :logger, :pipeline
+
+  # This is an immutable copy of the pipeline state,
+  # It is a proxy to a hash to allow us to add methods dynamically to the hash
+  class Snapshot
+    def initialize(data)
+      @data = data
+    end
+
+    def to_hash
+      @data
+    end
+
+    def to_simple_hash
+      {"inflight_count" => inflight_count, "stalling_thread_info" => format_threads_by_plugin}
+    end
+
+    def to_str
+      to_simple_hash.to_s
+    end
+    alias_method :to_s, :to_str
+
+    def method_missing(meth)
+      @data[meth]
+    end
+
+    def format_threads_by_plugin
+      stalled_plugins = {}
+      stalling_threads_info.each do |thr|
+        key = (thr.delete("plugin") || "other")
+        stalled_plugins[key] ||= []
+        stalled_plugins[key] << thr
+      end
+      stalled_plugins
+    end
+  end
+
+  def initialize(logger,pipeline)
+    @logger = logger
+    @pipeline = pipeline
+  end
+
+  # The main way of accessing data from the reporter,,
+  # this provides a (more or less) consistent snapshot of what's going on in the
+  # pipeline with some extra decoration
+  def snapshot
+    Snapshot.new(self.to_hash)
+  end
+
+  def to_hash
+    pipeline.inflight_batches_synchronize do |batch_map|
+      worker_states_snap = worker_states(batch_map) # We only want to run this once
+      inflight_count = worker_states_snap.map {|s| s[:inflight_count] }.reduce(0, :+)
+
+      {
+        :events_filtered => events_filtered,
+        :events_consumed => events_consumed,
+        :worker_count => pipeline.worker_threads.size,
+        :inflight_count => inflight_count,
+        :worker_states => worker_states_snap,
+        :output_info => output_info,
+        :thread_info => pipeline.plugin_threads_info,
+        :stalling_threads_info => pipeline.stalling_threads_info
+      }
+    end
+  end
+
+  private
+
+  def events_filtered
+    pipeline.events_filtered.value
+  end
+
+  def events_consumed
+    pipeline.events_consumed.value
+  end
+
+  def plugin_threads
+    pipeline.plugin_threads
+  end
+
+  # Not threadsafe! must be called within an `inflight_batches_synchronize` block
+  def worker_states(batch_map)
+      pipeline.worker_threads.map.with_index do |thread,idx|
+        status = thread.status || "dead"
+        inflight_count = batch_map[thread] ? batch_map[thread].size : 0
+        {
+          :status => status,
+          :alive => thread.alive?,
+          :index => idx,
+          :inflight_count => inflight_count
+        }
+    end
+  end
+
+  def output_info
+    pipeline.outputs.map do |output_delegator|
+      is_multi_worker = output_delegator.worker_count > 1
+
+      {
+        :type => output_delegator.config_name,
+        :config => output_delegator.config,
+        :is_multi_worker => is_multi_worker,
+        :events_received => output_delegator.events_received,
+        :workers => output_delegator.workers,
+        :busy_workers => output_delegator.busy_workers
+      }
+    end
+  end
+end end
\ No newline at end of file
diff --git a/lib/logstash/plugin.rb b/logstash-core/lib/logstash/plugin.rb
similarity index 95%
rename from lib/logstash/plugin.rb
rename to logstash-core/lib/logstash/plugin.rb
index e4ed6171ecc..73431b1b811 100644
--- a/lib/logstash/plugin.rb
+++ b/logstash-core/lib/logstash/plugin.rb
@@ -24,7 +24,7 @@ def eql?(other)
 
   public
   def initialize(params=nil)
-    @params = params
+    @params = LogStash::Util.deep_clone(params)
     @logger = Cabin::Channel.get(LogStash)
   end
 
@@ -32,7 +32,7 @@ def initialize(params=nil)
   # main task terminates
   public
   def do_close
-    @logger.debug("closing", :plugin => self)
+    @logger.debug("closing", :plugin => self.class.name)
     close
   end
 
@@ -59,6 +59,11 @@ def inspect
     end
   end
 
+  public
+  def debug_info
+    [self.class.to_s, original_params]
+  end
+
   # Look up a plugin by type and name.
   public
   def self.lookup(type, name)
diff --git a/lib/logstash/program.rb b/logstash-core/lib/logstash/program.rb
similarity index 100%
rename from lib/logstash/program.rb
rename to logstash-core/lib/logstash/program.rb
diff --git a/lib/logstash/runner.rb b/logstash-core/lib/logstash/runner.rb
similarity index 98%
rename from lib/logstash/runner.rb
rename to logstash-core/lib/logstash/runner.rb
index 4831d533025..6d64f0fca6f 100644
--- a/lib/logstash/runner.rb
+++ b/logstash-core/lib/logstash/runner.rb
@@ -9,11 +9,15 @@
 
 require "logstash/namespace"
 require "logstash/program"
+require "logstash/config/defaults"
 
 class LogStash::Runner
   include LogStash::Program
 
+  attr_reader :agent
+
   def main(args)
+
     require "logstash/util"
     require "logstash/util/java_version"
     require "stud/trap"
@@ -121,4 +125,5 @@ def run(args)
   def show_help(command)
     puts command.help
   end
+
 end # class LogStash::Runner
diff --git a/logstash-core/lib/logstash/shutdown_watcher.rb b/logstash-core/lib/logstash/shutdown_watcher.rb
new file mode 100644
index 00000000000..fa0d1f01fd4
--- /dev/null
+++ b/logstash-core/lib/logstash/shutdown_watcher.rb
@@ -0,0 +1,101 @@
+# encoding: utf-8
+
+module LogStash
+  class ShutdownWatcher
+
+    CHECK_EVERY = 1 # second
+    REPORT_EVERY = 5 # checks
+    ABORT_AFTER = 3 # stalled reports
+
+    attr_reader :cycle_period, :report_every, :abort_threshold
+
+    def initialize(pipeline, cycle_period=CHECK_EVERY, report_every=REPORT_EVERY, abort_threshold=ABORT_AFTER)
+      @pipeline = pipeline
+      @cycle_period = cycle_period
+      @report_every = report_every
+      @abort_threshold = abort_threshold
+      @reports = []
+    end
+
+    def self.unsafe_shutdown=(boolean)
+      @unsafe_shutdown = boolean
+    end
+
+    def self.unsafe_shutdown?
+      @unsafe_shutdown
+    end
+
+    def self.logger=(logger)
+      @logger = logger
+    end
+
+    def self.logger
+      @logger ||= Cabin::Channel.get(LogStash)
+    end
+
+    def self.start(pipeline, cycle_period=CHECK_EVERY, report_every=REPORT_EVERY, abort_threshold=ABORT_AFTER)
+      controller = self.new(pipeline, cycle_period, report_every, abort_threshold)
+      Thread.new(controller) { |controller| controller.start }
+    end
+
+    def logger
+      self.class.logger
+    end
+
+    def start
+      sleep(@cycle_period)
+      cycle_number = 0
+      stalled_count = 0
+      Stud.interval(@cycle_period) do
+        break unless @pipeline.thread.alive?
+        @reports << pipeline_report_snapshot
+        @reports.delete_at(0) if @reports.size > @report_every # expire old report
+        if cycle_number == (@report_every - 1) # it's report time!
+          logger.warn(@reports.last)
+
+          if shutdown_stalled?
+            logger.error("The shutdown process appears to be stalled due to busy or blocked plugins. Check the logs for more information.") if stalled_count == 0
+            stalled_count += 1
+
+            if self.class.unsafe_shutdown? && @abort_threshold == stalled_count
+              logger.fatal("Forcefully quitting logstash..")
+              force_exit()
+              break
+            end
+          else
+            stalled_count = 0
+          end
+        end
+        cycle_number = (cycle_number + 1) % @report_every
+      end
+    end
+
+    def pipeline_report_snapshot
+      @pipeline.reporter.snapshot
+    end
+
+    # A pipeline shutdown is stalled if
+    # * at least REPORT_EVERY reports have been created
+    # * the inflight event count is in monotonically increasing
+    # * there are worker threads running which aren't blocked on SizedQueue pop/push
+    # * the stalled thread list is constant in the previous REPORT_EVERY reports
+    def shutdown_stalled?
+      return false unless @reports.size == @report_every #
+      # is stalled if inflight count is either constant or increasing
+      stalled_event_count = @reports.each_cons(2).all? do |prev_report, next_report|
+        prev_report.inflight_count <= next_report.inflight_count
+      end
+      if stalled_event_count
+        @reports.each_cons(2).all? do |prev_report, next_report|
+          prev_report.stalling_threads == next_report.stalling_threads
+        end
+      else
+        false
+      end
+    end
+
+    def force_exit
+      exit(-1)
+    end
+  end
+end
diff --git a/logstash-core/lib/logstash/special_agent.rb b/logstash-core/lib/logstash/special_agent.rb
new file mode 100644
index 00000000000..ada28849e1d
--- /dev/null
+++ b/logstash-core/lib/logstash/special_agent.rb
@@ -0,0 +1,8 @@
+# encoding: utf-8
+require "logstash/agent"
+
+class LogStash::SpecialAgent < LogStash::Agent
+  def fetch_config(settings)
+    Net::HTTP.get(settings["remote.url"])
+  end
+end
diff --git a/lib/logstash/util.rb b/logstash-core/lib/logstash/util.rb
similarity index 75%
rename from lib/logstash/util.rb
rename to logstash-core/lib/logstash/util.rb
index 2034803f43c..fc0ba6c9eeb 100644
--- a/lib/logstash/util.rb
+++ b/logstash-core/lib/logstash/util.rb
@@ -24,6 +24,41 @@ def self.set_thread_name(name)
     end
   end # def set_thread_name
 
+  def self.set_thread_plugin(plugin)
+    Thread.current[:plugin] = plugin
+  end
+
+  def self.get_thread_id(thread)
+    if RUBY_ENGINE == "jruby"
+      JRuby.reference(thread).native_thread.id
+    else
+      raise Exception.new("Native thread IDs aren't supported outside of JRuby")
+    end
+  end
+
+  def self.thread_info(thread)
+    backtrace = thread.backtrace.map do |line|
+      line.gsub(LogStash::Environment::LOGSTASH_HOME, "[...]")
+    end
+
+    blocked_on = case backtrace.first
+                 when /in `push'/ then "blocked_on_push"
+                 when /(?:pipeline|base).*pop/ then "waiting_for_events"
+                 else nil
+                 end
+
+    {
+      "thread_id" => get_thread_id(thread),
+      "name" => thread[:name],
+      "plugin" => (thread[:plugin] ? thread[:plugin].debug_info : nil),
+      "backtrace" => backtrace,
+      "blocked_on" => blocked_on,
+      "status" => thread.status,
+      "current_call" => backtrace.first
+    }
+  end
+
+
   # Merge hash 'src' into 'dst' nondestructively
   #
   # Duplicate keys will become array values
@@ -148,4 +183,21 @@ def self.stringify_symbols(o)
       o
     end
   end
+
+  def self.deep_clone(o)
+    case o
+    when Hash
+      o.inject({}) {|h, (k,v)| h[k] = deep_clone(v); h }
+    when Array
+      o.map {|v| deep_clone(v) }
+    when Fixnum, Symbol, IO, TrueClass, FalseClass, NilClass
+      o
+    when LogStash::Codecs::Base
+      o.clone
+    when String
+      o.clone #need to keep internal state e.g. frozen
+    else
+      Marshal.load(Marshal.dump(o))
+    end
+  end
 end # module LogStash::Util
diff --git a/lib/logstash/util/buftok.rb b/logstash-core/lib/logstash/util/buftok.rb
similarity index 100%
rename from lib/logstash/util/buftok.rb
rename to logstash-core/lib/logstash/util/buftok.rb
diff --git a/lib/logstash/util/charset.rb b/logstash-core/lib/logstash/util/charset.rb
similarity index 100%
rename from lib/logstash/util/charset.rb
rename to logstash-core/lib/logstash/util/charset.rb
diff --git a/lib/logstash/util/decorators.rb b/logstash-core/lib/logstash/util/decorators.rb
similarity index 56%
rename from lib/logstash/util/decorators.rb
rename to logstash-core/lib/logstash/util/decorators.rb
index 0ea2c021aca..265656e5ce9 100644
--- a/lib/logstash/util/decorators.rb
+++ b/logstash-core/lib/logstash/util/decorators.rb
@@ -19,13 +19,16 @@ def add_fields(fields,event, pluginname)
         value.each do |v|
           v = event.sprintf(v)
           if event.include?(field)
-            event[field] = Array(event[field])
-            event[field] << v
+            # note below that the array field needs to be updated then reassigned to the event.
+            # this is important because a construct like event[field] << v will not work
+            # in the current Java event implementation. see https://github.com/elastic/logstash/issues/4140
+            a = Array(event[field])
+            a << v
+            event[field] = a
           else
             event[field] = v
           end
-          @logger.debug? and @logger.debug("#{pluginname}: adding value to field",
-                                         :field => field, :value => value)
+          @logger.debug? and @logger.debug("#{pluginname}: adding value to field", :field => field, :value => value)
         end
       end
     end
@@ -34,9 +37,13 @@ def add_fields(fields,event, pluginname)
     def add_tags(tags, event, pluginname)
       tags.each do |tag|
         tag = event.sprintf(tag)
-        @logger.debug? and @logger.debug("#{pluginname}: adding tag",
-                                       :tag => tag)
-        (event["tags"] ||= []) << tag
+        @logger.debug? and @logger.debug("#{pluginname}: adding tag", :tag => tag)
+        # note below that the tags array field needs to be updated then reassigned to the event.
+        # this is important because a construct like event["tags"] << tag will not work
+        # in the current Java event implementation. see https://github.com/elastic/logstash/issues/4140
+        tags = event["tags"] || []
+        tags << tag
+        event["tags"] = tags
       end
     end
 
diff --git a/lib/logstash/util/defaults_printer.rb b/logstash-core/lib/logstash/util/defaults_printer.rb
similarity index 91%
rename from lib/logstash/util/defaults_printer.rb
rename to logstash-core/lib/logstash/util/defaults_printer.rb
index 13764e2414a..6dd850e1d50 100644
--- a/lib/logstash/util/defaults_printer.rb
+++ b/logstash-core/lib/logstash/util/defaults_printer.rb
@@ -20,7 +20,7 @@ def print
     @printers.each do |printer|
       printer.visit(collector)
     end
-    "Default settings used: " + collector.join(', ')
+    "Settings: " + collector.join(', ')
   end
 
   private
diff --git a/lib/logstash/util/filetools.rb b/logstash-core/lib/logstash/util/filetools.rb
similarity index 100%
rename from lib/logstash/util/filetools.rb
rename to logstash-core/lib/logstash/util/filetools.rb
diff --git a/lib/logstash/util/java_version.rb b/logstash-core/lib/logstash/util/java_version.rb
similarity index 100%
rename from lib/logstash/util/java_version.rb
rename to logstash-core/lib/logstash/util/java_version.rb
diff --git a/lib/logstash/util/password.rb b/logstash-core/lib/logstash/util/password.rb
similarity index 100%
rename from lib/logstash/util/password.rb
rename to logstash-core/lib/logstash/util/password.rb
diff --git a/lib/logstash/util/plugin_version.rb b/logstash-core/lib/logstash/util/plugin_version.rb
similarity index 100%
rename from lib/logstash/util/plugin_version.rb
rename to logstash-core/lib/logstash/util/plugin_version.rb
diff --git a/lib/logstash/util/prctl.rb b/logstash-core/lib/logstash/util/prctl.rb
similarity index 100%
rename from lib/logstash/util/prctl.rb
rename to logstash-core/lib/logstash/util/prctl.rb
diff --git a/lib/logstash/util/retryable.rb b/logstash-core/lib/logstash/util/retryable.rb
similarity index 100%
rename from lib/logstash/util/retryable.rb
rename to logstash-core/lib/logstash/util/retryable.rb
diff --git a/lib/logstash/util/socket_peer.rb b/logstash-core/lib/logstash/util/socket_peer.rb
similarity index 100%
rename from lib/logstash/util/socket_peer.rb
rename to logstash-core/lib/logstash/util/socket_peer.rb
diff --git a/lib/logstash/util/unicode_trimmer.rb b/logstash-core/lib/logstash/util/unicode_trimmer.rb
similarity index 100%
rename from lib/logstash/util/unicode_trimmer.rb
rename to logstash-core/lib/logstash/util/unicode_trimmer.rb
diff --git a/logstash-core/lib/logstash/util/worker_threads_default_printer.rb b/logstash-core/lib/logstash/util/worker_threads_default_printer.rb
new file mode 100644
index 00000000000..43869162865
--- /dev/null
+++ b/logstash-core/lib/logstash/util/worker_threads_default_printer.rb
@@ -0,0 +1,29 @@
+# encoding: utf-8
+require "logstash/namespace"
+require "logstash/util"
+
+# This class exists to format the settings for default worker threads
+module LogStash module Util class WorkerThreadsDefaultPrinter
+
+  def initialize(settings)
+    @setting = settings.fetch(:pipeline_workers, 0)
+    @default = settings.fetch(:default_pipeline_workers, 0)
+  end
+
+  def visit(collector)
+    visit_setting(collector)
+    visit_default(collector)
+  end
+
+  def visit_setting(collector)
+    return if @setting == 0
+    collector.push("User set pipeline workers: #{@setting}")
+  end
+
+  def visit_default(collector)
+    return if @default == 0
+    collector.push "Default pipeline workers: #{@default}"
+  end
+
+end end end
+
diff --git a/logstash-core/lib/logstash/util/wrapped_synchronous_queue.rb b/logstash-core/lib/logstash/util/wrapped_synchronous_queue.rb
new file mode 100644
index 00000000000..a8822ca0af5
--- /dev/null
+++ b/logstash-core/lib/logstash/util/wrapped_synchronous_queue.rb
@@ -0,0 +1,41 @@
+# encoding: utf-8
+
+module LogStash; module Util
+  class WrappedSynchronousQueue
+    java_import java.util.concurrent.SynchronousQueue
+    java_import java.util.concurrent.TimeUnit
+
+    def initialize()
+      @queue = java.util.concurrent.SynchronousQueue.new()
+    end
+
+    # Push an object to the queue if the queue is full
+    # it will block until the object can be added to the queue.
+    #
+    # @param [Object] Object to add to the queue
+    def push(obj)
+      @queue.put(obj)
+    end
+    alias_method(:<<, :push)
+
+    # Offer an object to the queue, wait for the specified amout of time.
+    # If adding to the queue was successfull it wil return true, false otherwise.
+    #
+    # @param [Object] Object to add to the queue
+    # @param [Integer] Time in milliseconds to wait before giving up
+    # @return [Boolean] True if adding was successfull if not it return false
+    def offer(obj, timeout_ms)
+      @queue.offer(obj, timeout_ms, TimeUnit::MILLISECONDS)
+    end
+
+    # Blocking
+    def take
+      @queue.take()
+    end
+
+    # Block for X millis
+    def poll(millis)
+      @queue.poll(millis, TimeUnit::MILLISECONDS)
+    end
+  end
+end end
diff --git a/logstash-core/lib/logstash/version.rb b/logstash-core/lib/logstash/version.rb
new file mode 100644
index 00000000000..70715b097cb
--- /dev/null
+++ b/logstash-core/lib/logstash/version.rb
@@ -0,0 +1,14 @@
+# encoding: utf-8
+
+# The version of the logstash package (not the logstash-core gem version).
+#
+# Note to authors: this should not include dashes because 'gem' barfs if
+# you include a dash in the version string.
+
+# TODO: (colin) the logstash-core gem uses it's own version number in logstash-core/lib/logstash-core/version.rb
+#       there are some dependencies in logstash-core on the LOGSTASH_VERSION constant this is why
+#       the logstash version is currently defined here in logstash-core/lib/logstash/version.rb but
+#       eventually this file should be in the root logstash lib fir and dependencies in logstash-core should be
+#       fixed.
+
+LOGSTASH_VERSION = "3.0.0.dev"
diff --git a/locales/en.yml b/logstash-core/locales/en.yml
similarity index 73%
rename from locales/en.yml
rename to logstash-core/locales/en.yml
index f89fb254fed..c627cf7dcbf 100644
--- a/locales/en.yml
+++ b/logstash-core/locales/en.yml
@@ -4,8 +4,7 @@
 #     for unformatted text.
 en:
   oops: |-
-    The error reported is: 
-      %{error}
+    An unexpected error occurred!
   logstash:
     environment:
       jruby-required:  >-
@@ -37,7 +36,7 @@ en:
       output-worker-unsupported-with-message: >-
         %{plugin} output plugin: setting 'workers => %{worker_count}' is not
         supported by this plugin. I will continue working as if you had not set
-        this setting.
+        this setting. Reason: %{message}
     plugin:
       deprecated_milestone: >-
         %{plugin} plugin is using the 'milestone' method to declare the version
@@ -60,18 +59,27 @@ en:
       missing-configuration: >-
         No configuration file was specified. Perhaps you forgot to provide
         the '-f yourlogstash.conf' flag?
+      invalid-configuration: >-
+        The given configuration is invalid. Reason: %{error}
+      reload-without-config-path: >-
+        Configuration reloading also requires passing a configuration path with '-f yourlogstash.conf'
       error: >-
         Error: %{error}
       sigint: >-
-        SIGINT received. Shutting down the pipeline.
+        SIGINT received. Shutting down the agent.
       sigterm: >-
-        SIGTERM received. Shutting down the pipeline.
+        SIGTERM received. Shutting down the agent.
       slow_shutdown: |-
         Received shutdown signal, but pipeline is still waiting for in-flight events
         to be processed. Sending another ^C will force quit Logstash, but this may cause
         data loss.
       forced_sigint: >-
         SIGINT received. Terminating immediately..
+      non_reloadable_config_reload: >-
+        Unable to reload configuration because it does not support dynamic reloading
+      non_reloadable_config_register: |-
+        Logstash was not able to load configuration since it does not support
+        dynamic reloading and -r or --auto-reload flag was enabled
       configtest-flag-information: |-
         You may be interested in the '--configtest' flag which you can
         use to validate logstash's configuration before you choose
@@ -155,8 +163,26 @@ en:
           the empty string for the '-e' flag.
         configtest: |+
           Check configuration for valid syntax and then exit.
+        allow-env: |+
+          EXPERIMENTAL. Enables templating of environment variable
+          values. Instances of "${VAR}" in strings will be replaced
+          with the respective environment variable value named "VAR".
+        pipeline-workers: |+
+          Sets the number of pipeline workers to run.
         filterworkers: |+
-          Sets the number of filter workers to run.
+          DEPRECATED. Now an alias for --pipeline-workers and -w
+        pipeline-batch-size: |+
+          Size of batches the pipeline is to work in.
+        pipeline-batch-delay: |+
+          When creating pipeline batches, how long to wait while polling
+          for the next event.
+        auto_reload: |+
+          Monitor configuration changes and reload
+          whenever it is changed.
+          NOTE: use SIGHUP to manually reload the config
+        reload_interval: |+
+          How frequently to poll the configuration location
+          for changes, in seconds.
         log: |+
           Write logstash internal logs to the given
           file. Without this flag, logstash will emit
@@ -187,3 +213,20 @@ en:
         debug: |+
           Most verbose logging. This causes 'debug'
           level logs to be emitted.
+        debug-config: |+
+          Print the compiled config ruby code out as a debug log (you must also have --debug enabled).
+          WARNING: This will include any 'password' options passed to plugin configs as plaintext, and may result
+          in plaintext passwords appearing in your logs!
+        unsafe_shutdown: |+
+          Force logstash to exit during shutdown even
+          if there are still inflight events in memory.
+          By default, logstash will refuse to quit until all
+          received events have been pushed to the outputs.
+        debug_config: |+
+          Print the compiled config ruby code out as a debug log (you must also have --debug enabled).
+          WARNING: This will include any 'password' options passed to plugin configs as plaintext, and may result
+          in plaintext passwords appearing in your logs!
+        log-in-json: |+
+          Specify that Logstash should write its own logs in JSON form - one
+          event per line. If false, Logstash will log using Ruby's
+          Object#inspect (not easy to machine-parse)
diff --git a/logstash-core.gemspec b/logstash-core/logstash-core.gemspec
similarity index 77%
rename from logstash-core.gemspec
rename to logstash-core/logstash-core.gemspec
index 35937a060a1..6c6bfb95e2b 100644
--- a/logstash-core.gemspec
+++ b/logstash-core/logstash-core.gemspec
@@ -1,30 +1,33 @@
 # -*- encoding: utf-8 -*-
 lib = File.expand_path('../lib', __FILE__)
 $LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
-require 'logstash/version'
+require 'logstash-core/version'
 
 Gem::Specification.new do |gem|
-  gem.authors       = ["Jordan Sissel", "Pete Fritchman", "Elasticsearch"]
-  gem.email         = ["jls@semicomplete.com", "petef@databits.net", "info@elasticsearch.com"]
+  gem.authors       = ["Elastic"]
+  gem.email         = ["info@elastic.co"]
   gem.description   = %q{The core components of logstash, the scalable log and event management tool}
   gem.summary       = %q{logstash-core - The core components of logstash}
   gem.homepage      = "http://www.elastic.co/guide/en/logstash/current/index.html"
   gem.license       = "Apache License (2.0)"
 
-  gem.files         = Dir.glob(["logstash-core.gemspec", "lib/logstash-core.rb", "lib/logstash/**/*.rb", "spec/**/*.rb", "locales/*"])
+  gem.files         = Dir.glob(["logstash-core.gemspec", "lib/**/*.rb", "spec/**/*.rb", "locales/*"])
   gem.test_files    = gem.files.grep(%r{^(test|spec|features)/})
   gem.name          = "logstash-core"
   gem.require_paths = ["lib"]
-  gem.version       = LOGSTASH_VERSION
+  gem.version       = LOGSTASH_CORE_VERSION
 
-  gem.add_runtime_dependency "cabin", "~> 0.7.0" #(Apache 2.0 license)
+  gem.add_runtime_dependency "logstash-core-event", "3.0.0.dev"
+  # gem.add_runtime_dependency "logstash-core-event-java", "3.0.0.dev"
+
+  gem.add_runtime_dependency "cabin", "~> 0.8.0" #(Apache 2.0 license)
   gem.add_runtime_dependency "pry", "~> 0.10.1"  #(Ruby license)
   gem.add_runtime_dependency "stud", "~> 0.0.19" #(Apache 2.0 license)
   gem.add_runtime_dependency "clamp", "~> 0.6.5" #(MIT license) for command line args/flags
   gem.add_runtime_dependency "filesize", "0.0.4" #(MIT license) for :bytes config validator
   gem.add_runtime_dependency "gems", "~> 0.8.3"  #(MIT license)
   gem.add_runtime_dependency "concurrent-ruby", "0.9.2"
-  gem.add_runtime_dependency "jruby-openssl", ">= 0.9.11" # Required to support TLSv1.2
+  gem.add_runtime_dependency "jruby-openssl", "0.9.16" # >= 0.9.13 Required to support TLSv1.2
 
   # TODO(sissel): Treetop 1.5.x doesn't seem to work well, but I haven't
   # investigated what the cause might be. -Jordan
@@ -35,6 +38,7 @@ Gem::Specification.new do |gem|
 
   # filetools and rakelib
   gem.add_runtime_dependency "minitar", "~> 0.5.4"
+  gem.add_runtime_dependency "rubyzip", "~> 1.1.7"
   gem.add_runtime_dependency "thread_safe", "~> 0.3.5" #(Apache 2.0 license)
 
   if RUBY_PLATFORM == 'java'
diff --git a/spec/core/conditionals_spec.rb b/logstash-core/spec/conditionals_spec.rb
similarity index 100%
rename from spec/core/conditionals_spec.rb
rename to logstash-core/spec/conditionals_spec.rb
diff --git a/logstash-core/spec/logstash/agent_spec.rb b/logstash-core/spec/logstash/agent_spec.rb
new file mode 100644
index 00000000000..c4811f99699
--- /dev/null
+++ b/logstash-core/spec/logstash/agent_spec.rb
@@ -0,0 +1,418 @@
+# encoding: utf-8
+require 'spec_helper'
+require 'stud/temporary'
+require 'stud/task'
+
+describe LogStash::Agent do
+
+  let(:logger) { double("logger") }
+  let(:agent_args) { [] }
+  subject { LogStash::Agent.new("", "") }
+
+  before :each do
+    [:log, :info, :warn, :error, :fatal, :debug, :terminal].each do |level|
+      allow(logger).to receive(level)
+    end
+    [:info?, :warn?, :error?, :fatal?, :debug?].each do |level|
+      allow(logger).to receive(level)
+    end
+    allow(logger).to receive(:level=)
+    allow(logger).to receive(:subscribe)
+    subject.parse(agent_args)
+    subject.instance_variable_set("@reload_interval", 0.01)
+    subject.instance_variable_set("@logger", logger)
+  end
+
+  describe "register_pipeline" do
+    let(:pipeline_id) { "main" }
+    let(:config_string) { "input { } filter { } output { }" }
+    let(:settings) { {
+      :config_string => config_string,
+      :pipeline_workers => 4
+    } }
+
+    it "should delegate settings to new pipeline" do
+      expect(LogStash::Pipeline).to receive(:new).with(settings[:config_string], hash_including(settings))
+      subject.register_pipeline(pipeline_id, settings)
+    end
+  end
+
+  describe "#execute" do
+    let(:sample_config) { "input { generator { count => 100000 } } output { }" }
+    let(:config_file) { Stud::Temporary.pathname }
+
+    before :each do
+      File.open(config_file, "w") {|f| f.puts sample_config }
+    end
+
+    after :each do
+      File.unlink(config_file)
+    end
+
+    context "when auto_reload is false" do
+      let(:agent_args) { [ "--config", config_file] } #reload_interval => 0.01, :config_path => } }
+      let(:pipeline_id) { "main" }
+      let(:pipeline_settings) { { :config_path => config_file } }
+
+      before(:each) do
+        subject.register_pipeline(pipeline_id, pipeline_settings)
+      end
+
+      context "if state is clean" do
+        before :each do
+          allow(subject).to receive(:running_pipelines?).and_return(true)
+          allow(subject).to receive(:sleep)
+          allow(subject).to receive(:clean_state?).and_return(false)
+        end
+
+        it "should not reload_state!" do
+          expect(subject).to_not receive(:reload_state!)
+          t = Thread.new { subject.execute }
+          sleep 0.01 until subject.running_pipelines? && subject.pipelines.values.first.ready?
+          sleep 0.1
+          Stud.stop!(t)
+          t.join
+        end
+      end
+
+      context "when calling reload_state!" do
+        context "with a config that contains reload incompatible plugins" do
+          let(:second_pipeline_config) { "input { stdin {} } filter { } output { }" }
+
+          it "does not reload if new config contains reload incompatible plugins" do
+            t = Thread.new { subject.execute }
+            sleep 0.01 until subject.running_pipelines? && subject.pipelines.values.first.ready?
+            expect(subject).to_not receive(:upgrade_pipeline)
+            File.open(config_file, "w") { |f| f.puts second_pipeline_config }
+            subject.send(:reload_state!)
+            sleep 0.1
+            Stud.stop!(t)
+            t.join
+          end
+        end
+
+        context "with a config that does not contain reload incompatible plugins" do
+          let(:second_pipeline_config) { "input { generator { } } filter { } output { }" }
+
+          it "does not reload if new config contains reload incompatible plugins" do
+            t = Thread.new { subject.execute }
+            sleep 0.01 until subject.running_pipelines? && subject.pipelines.values.first.ready?
+            expect(subject).to receive(:upgrade_pipeline)
+            File.open(config_file, "w") { |f| f.puts second_pipeline_config }
+            subject.send(:reload_state!)
+            sleep 0.1
+            Stud.stop!(t)
+            t.join
+          end
+        end
+      end
+    end
+
+    context "when auto_reload is true" do
+      let(:agent_args) { [ "--auto-reload", "--config", config_file] } #reload_interval => 0.01, :config_path => } }
+      let(:pipeline_id) { "main" }
+      let(:pipeline_settings) { { :config_path => config_file } }
+
+      before(:each) do
+        subject.register_pipeline(pipeline_id, pipeline_settings)
+      end
+
+      context "if state is clean" do
+        it "should periodically reload_state" do
+          expect(subject).to receive(:reload_state!).at_least(3).times
+          t = Thread.new(subject) {|subject| subject.execute }
+          sleep 0.01 until (subject.running_pipelines? && subject.pipelines.values.first.ready?)
+          # now that the pipeline has started, give time for reload_state! to happen a few times
+          sleep 0.1
+          Stud.stop!(t)
+          t.join
+        end
+      end
+
+      context "when calling reload_state!" do
+        context "with a config that contains reload incompatible plugins" do
+          let(:second_pipeline_config) { "input { stdin {} } filter { } output { }" }
+
+          it "does not reload if new config contains reload incompatible plugins" do
+            t = Thread.new { subject.execute }
+            sleep 0.01 until subject.running_pipelines? && subject.pipelines.values.first.ready?
+            expect(subject).to_not receive(:upgrade_pipeline)
+            File.open(config_file, "w") { |f| f.puts second_pipeline_config }
+            sleep 0.1
+            Stud.stop!(t)
+            t.join
+          end
+        end
+
+        context "with a config that does not contain reload incompatible plugins" do
+          let(:second_pipeline_config) { "input { generator { } } filter { } output { }" }
+
+          it "does not reload if new config contains reload incompatible plugins" do
+            t = Thread.new { subject.execute }
+            sleep 0.01 until subject.running_pipelines? && subject.pipelines.values.first.ready?
+            expect(subject).to receive(:upgrade_pipeline).at_least(2).times
+            File.open(config_file, "w") { |f| f.puts second_pipeline_config }
+            sleep 0.1
+            Stud.stop!(t)
+            t.join
+          end
+        end
+      end
+    end
+  end
+
+  describe "#reload_state!" do
+    let(:pipeline_id) { "main" }
+    let(:first_pipeline_config) { "input { } filter { } output { }" }
+    let(:second_pipeline_config) { "input { generator {} } filter { } output { }" }
+    let(:pipeline_settings) { {
+      :config_string => first_pipeline_config,
+      :pipeline_workers => 4
+    } }
+
+    before(:each) do
+      subject.register_pipeline(pipeline_id, pipeline_settings)
+    end
+
+    context "when fetching a new state" do
+      it "upgrades the state" do
+        expect(subject).to receive(:fetch_config).and_return(second_pipeline_config)
+        expect(subject).to receive(:upgrade_pipeline).with(pipeline_id, kind_of(LogStash::Pipeline))
+        subject.send(:reload_state!)
+      end
+    end
+    context "when fetching the same state" do
+      it "doesn't upgrade the state" do
+        expect(subject).to receive(:fetch_config).and_return(first_pipeline_config)
+        expect(subject).to_not receive(:upgrade_pipeline)
+        subject.send(:reload_state!)
+      end
+    end
+  end
+
+
+  describe "#upgrade_pipeline" do
+    let(:pipeline_id) { "main" }
+    let(:pipeline_config) { "input { } filter { } output { }" }
+    let(:pipeline_settings) { {
+      :config_string => pipeline_config,
+      :pipeline_workers => 4
+    } }
+    let(:new_pipeline_config) { "input { generator {} } output { }" }
+
+    before(:each) do
+      subject.register_pipeline(pipeline_id, pipeline_settings)
+    end
+
+    context "when the upgrade fails" do
+      before :each do
+        allow(subject).to receive(:fetch_config).and_return(new_pipeline_config)
+        allow(subject).to receive(:create_pipeline).and_return(nil)
+        allow(subject).to receive(:stop_pipeline)
+      end
+
+      it "leaves the state untouched" do
+        subject.send(:reload_state!)
+        expect(subject.pipelines[pipeline_id].config_str).to eq(pipeline_config)
+      end
+
+      context "and current state is empty" do
+        it "should not start a pipeline" do
+          expect(subject).to_not receive(:start_pipeline)
+          subject.send(:reload_state!)
+        end
+      end
+    end
+
+    context "when the upgrade succeeds" do
+      let(:new_config) { "input { generator { count => 1 } } output { }" }
+      before :each do
+        allow(subject).to receive(:fetch_config).and_return(new_config)
+        allow(subject).to receive(:stop_pipeline)
+      end
+      it "updates the state" do
+        subject.send(:reload_state!)
+        expect(subject.pipelines[pipeline_id].config_str).to eq(new_config)
+      end
+      it "starts the pipeline" do
+        expect(subject).to receive(:stop_pipeline)
+        expect(subject).to receive(:start_pipeline)
+        subject.send(:reload_state!)
+      end
+    end
+  end
+
+  context "--pluginpath" do
+    let(:single_path) { "/some/path" }
+    let(:multiple_paths) { ["/some/path1", "/some/path2"] }
+
+    it "should add single valid dir path to the environment" do
+      expect(File).to receive(:directory?).and_return(true)
+      expect(LogStash::Environment).to receive(:add_plugin_path).with(single_path)
+      subject.configure_plugin_paths(single_path)
+    end
+
+    it "should fail with single invalid dir path" do
+      expect(File).to receive(:directory?).and_return(false)
+      expect(LogStash::Environment).not_to receive(:add_plugin_path)
+      expect{subject.configure_plugin_paths(single_path)}.to raise_error(LogStash::ConfigurationError)
+    end
+
+    it "should add multiple valid dir path to the environment" do
+      expect(File).to receive(:directory?).exactly(multiple_paths.size).times.and_return(true)
+      multiple_paths.each{|path| expect(LogStash::Environment).to receive(:add_plugin_path).with(path)}
+      subject.configure_plugin_paths(multiple_paths)
+    end
+  end
+
+  describe "#fetch_config" do
+    let(:file_config) { "input { generator { count => 100 } } output { }" }
+    let(:cli_config) { "filter { drop { } } " }
+    let(:tmp_config_path) { Stud::Temporary.pathname }
+    let(:agent_args) { [ "-e", "filter { drop { } } ", "-f", tmp_config_path ] }
+
+    before :each do
+      IO.write(tmp_config_path, file_config)
+    end
+
+    after :each do
+      File.unlink(tmp_config_path)
+    end
+
+    it "should join the config string and config path content" do
+      settings = { :config_path => tmp_config_path, :config_string => cli_config }
+      fetched_config = subject.send(:fetch_config, settings)
+      expect(fetched_config.strip).to eq(cli_config + IO.read(tmp_config_path))
+    end
+  end
+
+  context "--pluginpath" do
+    let(:single_path) { "/some/path" }
+    let(:multiple_paths) { ["/some/path1", "/some/path2"] }
+
+    it "should fail with single invalid dir path" do
+      expect(File).to receive(:directory?).and_return(false)
+      expect(LogStash::Environment).not_to receive(:add_plugin_path)
+      expect{subject.configure_plugin_paths(single_path)}.to raise_error(LogStash::ConfigurationError)
+    end
+  end
+
+  describe "--config-test" do
+    let(:cli_args) { ["-t", "-e", pipeline_string] }
+
+    context "with a good configuration" do
+      let(:pipeline_string) { "input { } filter { } output { }" }
+      it "should exit successfuly" do
+        expect(subject.run(cli_args)).to eq(0)
+      end
+    end
+
+    context "with a bad configuration" do
+      let(:pipeline_string) { "rlwekjhrewlqrkjh" }
+      it "should fail by returning a bad exit code" do
+        expect(subject.run(cli_args)).to eq(1)
+      end
+    end
+  end
+
+  describe "pipeline settings" do
+    let(:pipeline_string) { "input { stdin {} } output { stdout {} }" }
+    let(:main_pipeline_settings) { { :pipeline_id => "main" } }
+    let(:pipeline) { double("pipeline") }
+
+    before(:each) do
+      task = Stud::Task.new { 1 }
+      allow(pipeline).to receive(:run).and_return(task)
+      allow(pipeline).to receive(:shutdown)
+    end
+
+    context "when :pipeline_workers is not defined by the user" do
+      it "should not pass the value to the pipeline" do
+        expect(LogStash::Pipeline).to receive(:new).once.with(pipeline_string, hash_excluding(:pipeline_workers)).and_return(pipeline)
+        args = ["-e", pipeline_string]
+        subject.run(args)
+      end
+    end
+
+    context "when :pipeline_workers is defined by the user" do
+      it "should pass the value to the pipeline" do
+        main_pipeline_settings[:pipeline_workers] = 2
+        expect(LogStash::Pipeline).to receive(:new).with(pipeline_string, hash_including(main_pipeline_settings)).and_return(pipeline)
+        args = ["-w", "2", "-e", pipeline_string]
+        subject.run(args)
+      end
+    end
+  end
+
+  describe "debug_config" do
+    let(:pipeline_string) { "input {} output {}" }
+    let(:pipeline) { double("pipeline") }
+
+    it "should set 'debug_config' to false by default" do
+      expect(LogStash::Pipeline).to receive(:new).and_return(pipeline)
+      args = ["--debug", "-e", pipeline_string]
+      subject.run(args)
+
+      expect(subject.config_loader.debug_config).to be_falsey
+    end
+
+    it "should allow overriding debug_config" do
+      expect(LogStash::Pipeline).to receive(:new).and_return(pipeline)
+      args = ["--debug", "--debug-config",  "-e", pipeline_string]
+      subject.run(args)
+
+      expect(subject.config_loader.debug_config).to be_truthy
+    end
+  end
+
+  describe "allow_env param passing to pipeline" do
+    let(:pipeline_string) { "input {} output {}" }
+    let(:pipeline) { double("pipeline") }
+
+    it "should set 'allow_env' to false by default" do
+      args = ["-e", pipeline_string]
+      expect(LogStash::Pipeline).to receive(:new).with(pipeline_string, hash_including(:allow_env => false)).and_return(pipeline)
+      subject.run(args)
+    end
+
+    it "should support templating environment variables" do
+      args = ["-e", pipeline_string, "--allow-env"]
+      expect(LogStash::Pipeline).to receive(:new).with(pipeline_string, hash_including(:allow_env => true)).and_return(pipeline)
+      subject.run(args)
+    end
+  end
+
+  describe "Environment variables in config" do
+    let(:pipeline_id) { "main" }
+    let(:pipeline_config) { "input { generator { message => '${FOO}-bar' } } filter { } output { }" }
+    let(:pipeline_settings) { { :config_string => pipeline_config } }
+    let(:pipeline) { double("pipeline") }
+
+    context "when allow_env is false" do
+      it "does not interpolate environment variables" do
+        expect(subject).to receive(:fetch_config).and_return(pipeline_config)
+        subject.register_pipeline(pipeline_id, pipeline_settings)
+        expect(subject.pipelines[pipeline_id].inputs.first.message).to eq("${FOO}-bar")
+      end
+    end
+
+    context "when allow_env is true" do
+      before :each do
+        @foo_content = ENV["FOO"]
+        ENV["FOO"] = "foo"
+        pipeline_settings.merge!(:allow_env => true)
+      end
+
+      after :each do
+        ENV["FOO"] = @foo_content
+      end
+
+      it "doesn't upgrade the state" do
+        expect(subject).to receive(:fetch_config).and_return(pipeline_config)
+        subject.register_pipeline(pipeline_id, pipeline_settings)
+        expect(subject.pipelines[pipeline_id].inputs.first.message).to eq("foo-bar")
+      end
+    end
+  end
+end
+
diff --git a/spec/core/config_spec.rb b/logstash-core/spec/logstash/config/config_ast_spec.rb
similarity index 80%
rename from spec/core/config_spec.rb
rename to logstash-core/spec/logstash/config/config_ast_spec.rb
index 917e0575916..d4ba9af94d9 100644
--- a/spec/core/config_spec.rb
+++ b/logstash-core/spec/logstash/config/config_ast_spec.rb
@@ -143,4 +143,37 @@
       end
     end
   end
+
+  context "when creating two instances of the same configuration" do
+
+    let(:config_string) {
+      "input { generator { } }
+       filter {
+         if [type] == 'test' { filter1 { } }
+       }
+       output {
+         output1 { }
+       }"
+    }
+
+    let(:pipeline_klass) do
+      Class.new do
+        def initialize(config)
+          grammar = LogStashConfigParser.new
+          @config = grammar.parse(config)
+          @code = @config.compile
+          eval(@code)
+        end
+        def plugin(*args);end
+      end
+    end
+
+    describe "generated conditional functionals" do
+      it "should be defined at instance level" do
+        instance_1 = pipeline_klass.new(config_string)
+        instance_2 = pipeline_klass.new(config_string)
+        expect(instance_1.method(:cond_func_1).owner).to_not be(instance_2.method(:cond_func_1).owner)
+      end
+    end
+  end
 end
diff --git a/spec/core/config_cpu_core_strategy_spec.rb b/logstash-core/spec/logstash/config/cpu_core_strategy_spec.rb
similarity index 100%
rename from spec/core/config_cpu_core_strategy_spec.rb
rename to logstash-core/spec/logstash/config/cpu_core_strategy_spec.rb
diff --git a/spec/core/config_defaults_spec.rb b/logstash-core/spec/logstash/config/defaults_spec.rb
similarity index 100%
rename from spec/core/config_defaults_spec.rb
rename to logstash-core/spec/logstash/config/defaults_spec.rb
diff --git a/logstash-core/spec/logstash/config/loader_spec.rb b/logstash-core/spec/logstash/config/loader_spec.rb
new file mode 100644
index 00000000000..b51272ee13a
--- /dev/null
+++ b/logstash-core/spec/logstash/config/loader_spec.rb
@@ -0,0 +1,36 @@
+# encoding: utf-8
+require "spec_helper"
+require "logstash/config/loader"
+
+describe LogStash::Config::Loader do
+  subject { described_class.new(Cabin::Channel.get) }
+  context "when local" do
+    before { expect(subject).to receive(:local_config).with(path) }
+
+    context "unix" do
+      let(:path) { './test.conf' }
+      it 'works with relative path' do
+        subject.load_config(path)
+      end
+    end
+
+    context "windows" do
+      let(:path) { '.\test.conf' }
+      it 'work with relative windows path' do
+        subject.load_config(path)
+      end
+    end
+  end
+
+  context "when remote" do
+    context 'supported scheme' do
+      let(:path) { "http://test.local/superconfig.conf" }
+      let(:dummy_config) { 'input {}' }
+
+      before { expect(Net::HTTP).to receive(:get) { dummy_config } }
+      it 'works with http' do
+        expect(subject.load_config(path)).to eq("#{dummy_config}\n")
+      end
+    end
+  end
+end
diff --git a/spec/core/config_mixin_spec.rb b/logstash-core/spec/logstash/config/mixin_spec.rb
similarity index 62%
rename from spec/core/config_mixin_spec.rb
rename to logstash-core/spec/logstash/config/mixin_spec.rb
index 7c73b805d63..801b4bdf67e 100644
--- a/spec/core/config_mixin_spec.rb
+++ b/logstash-core/spec/logstash/config/mixin_spec.rb
@@ -96,6 +96,10 @@
       clone = subject.class.new(subject.params)
       expect(clone.password.value).to(be == secret)
     end
+
+    it "should obfuscate original_params" do
+      expect(subject.original_params['password']).to(be_a(LogStash::Util::Password))
+    end
   end
 
   describe "obsolete settings" do
@@ -151,4 +155,84 @@
       expect(subject.params).to include("password")
     end
   end
+
+  context "environment variable evaluation" do
+    let(:plugin_class) do
+      Class.new(LogStash::Filters::Base)  do
+        config_name "one_plugin"
+        config :oneString, :validate => :string
+        config :oneBoolean, :validate => :boolean
+        config :oneNumber, :validate => :number
+        config :oneArray, :validate => :array
+        config :oneHash, :validate => :hash
+
+        def initialize(params)
+          super(params.merge(LogStash::Config::Mixin::ALLOW_ENV_FLAG => true))
+        end
+      end
+    end
+
+    context "when an environment variable is not set" do
+      context "and no default is given" do
+        before do
+          # Canary. Just in case somehow this is set.
+          expect(ENV["NoSuchVariable"]).to be_nil
+        end
+
+        it "should raise a configuration error" do
+          expect do
+            plugin_class.new("oneString" => "${NoSuchVariable}")
+          end.to raise_error(LogStash::ConfigurationError)
+        end
+      end
+
+      context "and a default is given" do
+        subject do
+          plugin_class.new(
+            "oneString" => "${notExistingVar:foo}",
+            "oneBoolean" => "${notExistingVar:true}",
+            "oneArray" => [ "first array value", "${notExistingVar:foo}", "${notExistingVar:}", "${notExistingVar: }", "${notExistingVar:foo bar}" ],
+            "oneHash" => { "key" => "${notExistingVar:foo}" }
+          )
+        end
+
+        it "should use the default" do
+          expect(subject.oneString).to(be == "foo")
+          expect(subject.oneBoolean).to be_truthy
+          expect(subject.oneArray).to(be == ["first array value", "foo", "", " ", "foo bar"])
+          expect(subject.oneHash).to(be == { "key" => "foo" })
+        end
+      end
+    end
+
+    context "when an environment variable is set" do
+      before do
+        ENV["FunString"] = "fancy"
+        ENV["FunBool"] = "true"
+      end
+
+      after do
+        ENV.delete("FunString")
+        ENV.delete("FunBool")
+      end
+
+      subject do
+        plugin_class.new(
+          "oneString" => "${FunString:foo}",
+          "oneBoolean" => "${FunBool:false}",
+          "oneArray" => [ "first array value", "${FunString:foo}" ],
+          "oneHash" => { "key1" => "${FunString:foo}", "key2" => "${FunString} is ${FunBool}", "key3" => "${FunBool:false} or ${funbool:false}" }
+        )
+      end
+
+      it "should use the value in the variable" do
+        expect(subject.oneString).to(be == "fancy")
+        expect(subject.oneBoolean).to(be_truthy)
+        expect(subject.oneArray).to(be == [ "first array value", "fancy" ])
+        expect(subject.oneHash).to(be == { "key1" => "fancy", "key2" => "fancy is true", "key3" => "true or false" })
+      end
+
+    end
+  end
+
 end
diff --git a/spec/core/environment_spec.rb b/logstash-core/spec/logstash/environment_spec.rb
similarity index 100%
rename from spec/core/environment_spec.rb
rename to logstash-core/spec/logstash/environment_spec.rb
diff --git a/spec/filters/base_spec.rb b/logstash-core/spec/logstash/filters/base_spec.rb
similarity index 100%
rename from spec/filters/base_spec.rb
rename to logstash-core/spec/logstash/filters/base_spec.rb
diff --git a/spec/inputs/base_spec.rb b/logstash-core/spec/logstash/inputs/base_spec.rb
similarity index 100%
rename from spec/inputs/base_spec.rb
rename to logstash-core/spec/logstash/inputs/base_spec.rb
diff --git a/spec/lib/logstash/java_integration_spec.rb b/logstash-core/spec/logstash/java_integration_spec.rb
similarity index 100%
rename from spec/lib/logstash/java_integration_spec.rb
rename to logstash-core/spec/logstash/java_integration_spec.rb
diff --git a/spec/util/json_spec.rb b/logstash-core/spec/logstash/json_spec.rb
similarity index 88%
rename from spec/util/json_spec.rb
rename to logstash-core/spec/logstash/json_spec.rb
index f0304f219c8..68a1a6811eb 100644
--- a/spec/util/json_spec.rb
+++ b/logstash-core/spec/logstash/json_spec.rb
@@ -18,6 +18,9 @@
   let(:multi) {
     [
       {:ruby => "foo bar baz", :json => "\"foo bar baz\""},
+      {:ruby => "foo   ", :json => "\"foo   \""},
+      {:ruby => " ", :json => "\" \""},
+      {:ruby => "   ", :json => "\"   \""},
       {:ruby => "1", :json => "\"1\""},
       {:ruby => {"a" => true}, :json => "{\"a\":true}"},
       {:ruby => {"a" => nil}, :json => "{\"a\":null}"},
@@ -93,4 +96,16 @@
   it "should raise Json::ParserError on invalid json" do
     expect{LogStash::Json.load("abc")}.to raise_error LogStash::Json::ParserError
   end
+
+  it "should return nil on empty string" do
+    o = LogStash::Json.load("")
+    expect(o).to be_nil
+  end
+
+  it "should return nil on blank string" do
+    o = LogStash::Json.load(" ")
+    expect(o).to be_nil
+    o = LogStash::Json.load("  ")
+    expect(o).to be_nil
+  end
 end
diff --git a/logstash-core/spec/logstash/output_delegator_spec.rb b/logstash-core/spec/logstash/output_delegator_spec.rb
new file mode 100644
index 00000000000..84c79926ff3
--- /dev/null
+++ b/logstash-core/spec/logstash/output_delegator_spec.rb
@@ -0,0 +1,145 @@
+# encoding: utf-8
+require 'spec_helper'
+
+describe LogStash::OutputDelegator do
+  let(:logger) { double("logger") }
+  let(:events) { 7.times.map { LogStash::Event.new }}
+  let(:default_worker_count) { 1 }
+
+  subject { described_class.new(logger, out_klass, default_worker_count) }
+
+  context "with a plain output plugin" do
+    let(:out_klass) { double("output klass") }
+    let(:out_inst) { double("output instance") }
+
+    before do
+      allow(out_klass).to receive(:new).with(any_args).and_return(out_inst)
+      allow(out_klass).to receive(:threadsafe?).and_return(false)
+      allow(out_klass).to receive(:workers_not_supported?).and_return(false)
+      allow(out_klass).to receive(:name).and_return("example")
+      allow(out_inst).to receive(:register)
+      allow(out_inst).to receive(:multi_receive)
+      allow(logger).to receive(:debug).with(any_args)
+    end
+
+    it "should initialize cleanly" do
+      expect { subject }.not_to raise_error
+    end
+
+    context "after having received a batch of events" do
+      before do
+        subject.register
+        subject.multi_receive(events)
+      end
+
+      it "should pass the events through" do
+        expect(out_inst).to have_received(:multi_receive).with(events)
+      end
+
+      it "should increment the number of events received" do
+        expect(subject.events_received).to eql(events.length)
+      end
+    end
+
+
+    describe "closing" do
+      before do
+        subject.register
+      end
+
+      it "should register all workers on register" do
+        expect(out_inst).to have_received(:register)
+      end
+
+      it "should close all workers when closing" do
+        expect(out_inst).to receive(:do_close)
+        subject.do_close
+      end
+    end
+
+    describe "concurrency and worker support" do
+      before do
+        allow(out_inst).to receive(:id).and_return("a-simple-plugin")
+        allow(out_inst).to receive(:metric=).with(any_args)
+        allow(out_klass).to receive(:workers_not_supported?).and_return(false)
+      end
+
+      describe "non-threadsafe outputs that allow workers" do
+        let(:default_worker_count) { 3 }
+
+        before do
+          allow(out_klass).to receive(:threadsafe?).and_return(false)
+          subject.register
+        end
+
+        it "should instantiate multiple workers" do
+          expect(subject.workers.length).to eql(default_worker_count)
+        end
+
+        it "should send received events to the worker" do
+          expect(out_inst).to receive(:multi_receive).with(events)
+          subject.multi_receive(events)
+        end
+      end
+
+      describe "threadsafe outputs" do
+        before do
+          allow(out_klass).to receive(:threadsafe?).and_return(true)
+          subject.register
+        end
+
+        it "should return true when threadsafe? is invoked" do
+          expect(subject.threadsafe?).to eql(true)
+        end
+
+        it "should define a threadsafe_worker" do
+          expect(subject.send(:threadsafe_worker)).to eql(out_inst)
+        end
+
+        it "should utilize threadsafe_multi_receive" do
+          expect(subject.send(:threadsafe_worker)).to receive(:multi_receive).with(events)
+          subject.multi_receive(events)
+        end
+
+        it "should not utilize the worker queue" do
+          expect(subject.send(:worker_queue)).to be_nil
+        end
+
+        it "should send received events to the worker" do
+          expect(out_inst).to receive(:multi_receive).with(events)
+          subject.multi_receive(events)
+        end
+
+        it "should close all workers when closing" do
+          expect(out_inst).to receive(:do_close)
+          subject.do_close
+        end
+      end
+    end
+  end
+
+  # This may seem suspiciously similar to the class in outputs/base_spec
+  # but, in fact, we need a whole new class because using this even once
+  # will immutably modify the base class
+  class LogStash::Outputs::NOOPDelLegacyNoWorkers < ::LogStash::Outputs::Base
+    LEGACY_WORKERS_NOT_SUPPORTED_REASON = "legacy reason"
+
+    def register
+      workers_not_supported(LEGACY_WORKERS_NOT_SUPPORTED_REASON)
+    end
+  end
+
+  describe "legacy output workers_not_supported" do
+    let(:default_worker_count) { 2 }
+    let(:out_klass) { LogStash::Outputs::NOOPDelLegacyNoWorkers }
+
+    before(:each) do
+      allow(logger).to receive(:debug).with(any_args)
+    end
+
+    it "should only setup one worker" do
+      subject.register
+      expect(subject.worker_count).to eql(1)
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/outputs/base_spec.rb b/logstash-core/spec/logstash/outputs/base_spec.rb
new file mode 100644
index 00000000000..44d49a60b99
--- /dev/null
+++ b/logstash-core/spec/logstash/outputs/base_spec.rb
@@ -0,0 +1,40 @@
+# encoding: utf-8
+require "spec_helper"
+
+# use a dummy NOOP output to test Outputs::Base
+class LogStash::Outputs::NOOP < LogStash::Outputs::Base
+  config_name "noop"
+  milestone 2
+
+  config :dummy_option, :validate => :string
+
+  def register; end
+
+  def receive(event)
+    return output?(event)
+  end
+end
+
+class LogStash::Outputs::NOOPLegacyNoWorkers < ::LogStash::Outputs::Base
+  LEGACY_WORKERS_NOT_SUPPORTED_REASON = "legacy reason"
+
+  def register
+    workers_not_supported(LEGACY_WORKERS_NOT_SUPPORTED_REASON)
+  end
+end
+
+describe "LogStash::Outputs::Base#new" do
+  it "should instantiate cleanly" do
+    params = { "dummy_option" => "potatoes", "codec" => "json", "workers" => 2 }
+    worker_params = params.dup; worker_params["workers"] = 1
+
+    expect do
+      LogStash::Outputs::NOOP.new(params.dup)
+    end.not_to raise_error
+  end
+
+  it "should move workers_not_supported declarations up to the class level" do
+    LogStash::Outputs::NOOPLegacyNoWorkers.new.register
+    expect(LogStash::Outputs::NOOPLegacyNoWorkers.workers_not_supported?).to eql(true)
+  end
+end
diff --git a/spec/logstash/patches_spec.rb b/logstash-core/spec/logstash/patches_spec.rb
similarity index 100%
rename from spec/logstash/patches_spec.rb
rename to logstash-core/spec/logstash/patches_spec.rb
diff --git a/logstash-core/spec/logstash/pipeline_reporter_spec.rb b/logstash-core/spec/logstash/pipeline_reporter_spec.rb
new file mode 100644
index 00000000000..bdd83d4ff24
--- /dev/null
+++ b/logstash-core/spec/logstash/pipeline_reporter_spec.rb
@@ -0,0 +1,85 @@
+# encoding: utf-8
+require "spec_helper"
+require "logstash/pipeline"
+require "logstash/pipeline_reporter"
+
+class DummyOutput < LogStash::Outputs::Base
+  config_name "dummyoutput"
+  milestone 2
+
+  attr_reader :num_closes, :events
+
+  def initialize(params={})
+    super
+    @num_closes = 0
+    @events = []
+  end
+
+  def register
+  end
+
+  def receive(event)
+    @events << event
+  end
+
+  def close
+    @num_closes += 1
+  end
+end
+
+#TODO: Figure out how to add more tests that actually cover inflight events
+#This will require some janky multithreading stuff
+describe LogStash::PipelineReporter do
+  let(:generator_count) { 5 }
+  let(:config) do
+    "input { generator { count => #{generator_count} } } output { dummyoutput {} } "
+  end
+  let(:pipeline) { LogStash::Pipeline.new(config)}
+  let(:reporter) { pipeline.reporter }
+
+  before do
+    allow(LogStash::Plugin).to receive(:lookup).with("output", "dummyoutput").and_return(DummyOutput)
+    allow(LogStash::Plugin).to receive(:lookup).with("input", "generator").and_call_original
+    allow(LogStash::Plugin).to receive(:lookup).with("codec", "plain").and_call_original
+
+    @pre_snapshot = reporter.snapshot
+    pipeline.run
+    @post_snapshot = reporter.snapshot
+  end
+
+  describe "events filtered" do
+    it "should start at zero" do
+      expect(@pre_snapshot.events_filtered).to eql(0)
+    end
+
+    it "should end at the number of generated events" do
+      expect(@post_snapshot.events_filtered).to eql(generator_count)
+    end
+  end
+
+  describe "events consumed" do
+    it "should start at zero" do
+      expect(@pre_snapshot.events_consumed).to eql(0)
+    end
+
+    it "should end at the number of generated events" do
+      expect(@post_snapshot.events_consumed).to eql(generator_count)
+    end
+  end
+
+  describe "inflight count" do
+    it "should be zero before running" do
+      expect(@pre_snapshot.inflight_count).to eql(0)
+    end
+
+    it "should be zero after running" do
+      expect(@post_snapshot.inflight_count).to eql(0)
+    end
+  end
+
+  describe "output states" do
+    it "should include the count of received events" do
+      expect(@post_snapshot.output_info.first[:events_received]).to eql(generator_count)
+    end
+  end
+end
\ No newline at end of file
diff --git a/logstash-core/spec/logstash/pipeline_spec.rb b/logstash-core/spec/logstash/pipeline_spec.rb
new file mode 100644
index 00000000000..c33a108c950
--- /dev/null
+++ b/logstash-core/spec/logstash/pipeline_spec.rb
@@ -0,0 +1,455 @@
+# encoding: utf-8
+require "spec_helper"
+require "logstash/inputs/generator"
+require "logstash/filters/multiline"
+
+class DummyInput < LogStash::Inputs::Base
+  config_name "dummyinput"
+  milestone 2
+
+  def register
+  end
+
+  def run(queue)
+  end
+
+  def close
+  end
+end
+
+class DummyCodec < LogStash::Codecs::Base
+  config_name "dummycodec"
+  milestone 2
+
+  def decode(data)
+    data
+  end
+
+  def encode(event)
+    event
+  end
+
+  def close
+  end
+end
+
+class DummyOutput < LogStash::Outputs::Base
+  config_name "dummyoutput"
+  milestone 2
+
+  attr_reader :num_closes, :events
+
+  def initialize(params={})
+    super
+    @num_closes = 0
+    @events = []
+  end
+
+  def register
+  end
+  
+  def receive(event)
+    @events << event
+  end
+
+  def close
+    @num_closes += 1
+  end
+end
+
+class DummyFilter < LogStash::Filters::Base
+  config_name "dummyfilter"
+  milestone 2
+
+  def register() end
+
+  def filter(event) end
+
+  def threadsafe?() false; end
+
+  def close() end
+end
+
+class DummySafeFilter < LogStash::Filters::Base
+  config_name "dummysafefilter"
+  milestone 2
+
+  def register() end
+
+  def filter(event) end
+
+  def threadsafe?() true; end
+
+  def close() end
+end
+
+class TestPipeline < LogStash::Pipeline
+  attr_reader :outputs, :settings, :logger
+end
+
+describe LogStash::Pipeline do
+  let(:worker_thread_count)     { LogStash::Pipeline::DEFAULT_SETTINGS[:default_pipeline_workers] }
+  let(:safe_thread_count)       { 1 }
+  let(:override_thread_count)   { 42 }
+
+  describe "defaulting the pipeline workers based on thread safety" do
+    before(:each) do
+      allow(LogStash::Plugin).to receive(:lookup).with("input", "dummyinput").and_return(DummyInput)
+      allow(LogStash::Plugin).to receive(:lookup).with("codec", "plain").and_return(DummyCodec)
+      allow(LogStash::Plugin).to receive(:lookup).with("output", "dummyoutput").and_return(DummyOutput)
+      allow(LogStash::Plugin).to receive(:lookup).with("filter", "dummyfilter").and_return(DummyFilter)
+      allow(LogStash::Plugin).to receive(:lookup).with("filter", "dummysafefilter").and_return(DummySafeFilter)
+    end
+
+    context "when there are some not threadsafe filters" do
+      let(:test_config_with_filters) {
+        <<-eos
+        input {
+          dummyinput {}
+        }
+
+        filter {
+          dummyfilter {}
+        }
+
+        output {
+          dummyoutput {}
+        }
+        eos
+      }
+
+      context "when there is no command line -w N set" do
+        it "starts one filter thread" do
+          msg = "Defaulting pipeline worker threads to 1 because there are some" +
+                " filters that might not work with multiple worker threads"
+          pipeline = TestPipeline.new(test_config_with_filters)
+          expect(pipeline.logger).to receive(:warn).with(msg,
+            {:count_was=>worker_thread_count, :filters=>["dummyfilter"]})
+          pipeline.run
+          expect(pipeline.worker_threads.size).to eq(safe_thread_count)
+        end
+      end
+
+      context "when there is command line -w N set" do
+        it "starts multiple filter thread" do
+          msg = "Warning: Manual override - there are filters that might" +
+                " not work with multiple worker threads"
+          pipeline = TestPipeline.new(test_config_with_filters)
+          expect(pipeline.logger).to receive(:warn).with(msg,
+            {:worker_threads=> override_thread_count, :filters=>["dummyfilter"]})
+          pipeline.configure(:pipeline_workers, override_thread_count)
+          pipeline.run
+          expect(pipeline.worker_threads.size).to eq(override_thread_count)
+        end
+      end
+    end
+
+    context "when there are threadsafe filters only" do
+      let(:test_config_with_filters) {
+        <<-eos
+        input {
+          dummyinput {}
+        }
+
+        filter {
+          dummysafefilter {}
+        }
+
+        output {
+          dummyoutput {}
+        }
+        eos
+      }
+
+      it "starts multiple filter threads" do
+        pipeline = TestPipeline.new(test_config_with_filters)
+        pipeline.run
+        expect(pipeline.worker_threads.size).to eq(worker_thread_count)
+      end
+    end
+  end
+
+  context "close" do
+    before(:each) do
+      allow(LogStash::Plugin).to receive(:lookup).with("input", "dummyinput").and_return(DummyInput)
+      allow(LogStash::Plugin).to receive(:lookup).with("codec", "plain").and_return(DummyCodec)
+      allow(LogStash::Plugin).to receive(:lookup).with("output", "dummyoutput").and_return(DummyOutput)
+    end
+
+
+    let(:test_config_without_output_workers) {
+      <<-eos
+      input {
+        dummyinput {}
+      }
+
+      output {
+        dummyoutput {}
+      }
+      eos
+    }
+
+    let(:test_config_with_output_workers) {
+      <<-eos
+      input {
+        dummyinput {}
+      }
+
+      output {
+        dummyoutput {
+          workers => 2
+        }
+      }
+      eos
+    }
+
+    context "output close" do
+      it "should call close of output without output-workers" do
+        pipeline = TestPipeline.new(test_config_without_output_workers)
+        pipeline.run
+
+        expect(pipeline.outputs.size ).to eq(1)
+        expect(pipeline.outputs.first.workers.size ).to eq(::LogStash::Pipeline::DEFAULT_OUTPUT_WORKERS)
+        expect(pipeline.outputs.first.workers.first.num_closes ).to eq(1)
+      end
+
+      it "should call output close correctly with output workers" do
+        pipeline = TestPipeline.new(test_config_with_output_workers)
+        pipeline.run
+
+        expect(pipeline.outputs.size ).to eq(1)
+        # We even close the parent output worker, even though it doesn't receive messages
+
+        output_delegator = pipeline.outputs.first
+        output = output_delegator.workers.first
+
+        expect(output.num_closes).to eq(1)
+        output_delegator.workers.each do |plugin|
+          expect(plugin.num_closes ).to eq(1)
+        end
+      end
+    end
+  end
+
+  context "compiled flush function" do
+    describe "flusher thread" do
+      before(:each) do
+        allow(LogStash::Plugin).to receive(:lookup).with("input", "dummyinput").and_return(DummyInput)
+        allow(LogStash::Plugin).to receive(:lookup).with("codec", "plain").and_return(DummyCodec)
+        allow(LogStash::Plugin).to receive(:lookup).with("output", "dummyoutput").and_return(DummyOutput)
+      end
+
+      let(:config) { "input { dummyinput {} } output { dummyoutput {} }"}
+
+      it "should start the flusher thread only after the pipeline is running" do
+        pipeline = TestPipeline.new(config)
+
+        expect(pipeline).to receive(:transition_to_running).ordered.and_call_original
+        expect(pipeline).to receive(:start_flusher).ordered.and_call_original
+
+        pipeline.run
+      end
+    end
+
+    context "cancelled events should not propagate down the filters" do
+      config <<-CONFIG
+        filter {
+          multiline {
+           pattern => "hello"
+           what => next
+          }
+          multiline {
+           pattern => "hello"
+           what => next
+          }
+        }
+      CONFIG
+
+      sample("hello") do
+        expect(subject["message"]).to eq("hello")
+      end
+    end
+
+    context "new events should propagate down the filters" do
+      config <<-CONFIG
+        filter {
+          clone {
+            clones => ["clone1"]
+          }
+          multiline {
+            pattern => "bar"
+            what => previous
+          }
+        }
+      CONFIG
+
+      sample(["foo", "bar"]) do
+        expect(subject.size).to eq(2)
+
+        expect(subject[0]["message"]).to eq("foo\nbar")
+        expect(subject[0]["type"]).to be_nil
+        expect(subject[1]["message"]).to eq("foo\nbar")
+        expect(subject[1]["type"]).to eq("clone1")
+      end
+    end
+  end
+
+  describe "max inflight warning" do
+    let(:config) { "input { dummyinput {} } output { dummyoutput {} }" }
+    let(:batch_size) { 1 }
+    let(:pipeline) { LogStash::Pipeline.new(config, :pipeline_batch_size => batch_size, :pipeline_workers => 1) }
+    let(:logger) { pipeline.logger }
+    let(:warning_prefix) { /CAUTION: Recommended inflight events max exceeded!/ }
+
+    before(:each) do
+      allow(LogStash::Plugin).to receive(:lookup).with("input", "dummyinput").and_return(DummyInput)
+      allow(LogStash::Plugin).to receive(:lookup).with("codec", "plain").and_return(DummyCodec)
+      allow(LogStash::Plugin).to receive(:lookup).with("output", "dummyoutput").and_return(DummyOutput)
+      allow(logger).to receive(:warn)
+      thread = Thread.new { pipeline.run }
+      pipeline.shutdown
+      thread.join
+    end
+
+    it "should not raise a max inflight warning if the max_inflight count isn't exceeded" do
+      expect(logger).not_to have_received(:warn).with(warning_prefix)
+    end
+
+    context "with a too large inflight count" do
+      let(:batch_size) { LogStash::Pipeline::MAX_INFLIGHT_WARN_THRESHOLD + 1 }
+
+      it "should raise a max inflight warning if the max_inflight count is exceeded" do
+        expect(logger).to have_received(:warn).with(warning_prefix)
+      end
+    end
+  end
+
+  context "compiled filter funtions" do
+
+    context "new events should propagate down the filters" do
+      config <<-CONFIG
+        filter {
+          clone {
+            clones => ["clone1", "clone2"]
+          }
+          mutate {
+            add_field => {"foo" => "bar"}
+          }
+        }
+      CONFIG
+
+      sample("hello") do
+        expect(subject.size).to eq(3)
+
+        expect(subject[0]["message"]).to eq("hello")
+        expect(subject[0]["type"]).to be_nil
+        expect(subject[0]["foo"]).to eq("bar")
+
+        expect(subject[1]["message"]).to eq("hello")
+        expect(subject[1]["type"]).to eq("clone1")
+        expect(subject[1]["foo"]).to eq("bar")
+
+        expect(subject[2]["message"]).to eq("hello")
+        expect(subject[2]["type"]).to eq("clone2")
+        expect(subject[2]["foo"]).to eq("bar")
+      end
+    end
+  end
+
+  describe "stalling_threads" do
+    before(:each) do
+      allow(LogStash::Plugin).to receive(:lookup).with("input", "dummyinput").and_return(DummyInput)
+      allow(LogStash::Plugin).to receive(:lookup).with("codec", "plain").and_return(DummyCodec)
+      allow(LogStash::Plugin).to receive(:lookup).with("output", "dummyoutput").and_return(DummyOutput)
+    end
+
+    context "when the pipeline doesn't have filters" do
+      let(:pipeline_with_no_filters) do
+        <<-eos
+        input { dummyinput {} }
+        output { dummyoutput {} }
+        eos
+      end
+
+      it "doesn't raise an error" do
+        pipeline = TestPipeline.new(pipeline_with_no_filters)
+        pipeline.run
+        expect { pipeline.stalling_threads_info }.to_not raise_error
+      end
+    end
+  end
+
+  context "Periodic Flush" do
+    let(:number_of_events) { 100 }
+    let(:config) do
+      <<-EOS
+      input {
+        generator {
+          count => #{number_of_events}
+        }
+      }
+      filter {
+        multiline { 
+          pattern => "^NeverMatch"
+          negate => true
+          what => "previous"
+        }
+      }
+      output {
+        dummyoutput {}
+      }
+      EOS
+    end
+    let(:output) { DummyOutput.new }
+    
+    before do
+      allow(DummyOutput).to receive(:new).with(any_args).and_return(output)
+      allow(LogStash::Plugin).to receive(:lookup).with("input", "generator").and_return(LogStash::Inputs::Generator)
+      allow(LogStash::Plugin).to receive(:lookup).with("codec", "plain").and_return(LogStash::Codecs::Plain)
+      allow(LogStash::Plugin).to receive(:lookup).with("filter", "multiline").and_return(LogStash::Filters::Multiline)
+      allow(LogStash::Plugin).to receive(:lookup).with("output", "dummyoutput").and_return(DummyOutput)
+    end
+
+    it "flushes the buffered contents of the filter" do
+      Thread.abort_on_exception = true
+      pipeline = LogStash::Pipeline.new(config, { :flush_interval => 1 })
+      Thread.new { pipeline.run }
+      sleep 0.1 while !pipeline.ready?
+      # give us a bit of time to flush the events
+      wait(5).for do
+        next unless output && output.events && output.events.first
+        output.events.first["message"].split("\n").count
+      end.to eq(number_of_events)
+      pipeline.shutdown
+    end
+  end
+
+  context "Multiple pipelines" do
+    before do
+      allow(LogStash::Plugin).to receive(:lookup).with("input", "generator").and_return(LogStash::Inputs::Generator)
+      allow(LogStash::Plugin).to receive(:lookup).with("codec", "plain").and_return(DummyCodec)
+      allow(LogStash::Plugin).to receive(:lookup).with("filter", "dummyfilter").and_return(DummyFilter)
+      allow(LogStash::Plugin).to receive(:lookup).with("output", "dummyoutput").and_return(DummyOutput)
+    end
+
+    let(:pipeline1) { LogStash::Pipeline.new("input { generator {} } filter { dummyfilter {} } output { dummyoutput {}}") }
+    let(:pipeline2) { LogStash::Pipeline.new("input { generator {} } filter { dummyfilter {} } output { dummyoutput {}}") }
+
+    it "should handle evaluating different config" do
+      # When the functions are compiled from the AST it will generate instance
+      # variables that are unique to the actual config, the intance are pointing
+      # to conditionals/plugins.
+      #
+      # Before the `defined_singleton_method`, the definition of the method was
+      # not unique per class, but the `instance variables` were unique per class.
+      #
+      # So the methods were trying to access instance variables that did not exist
+      # in the current instance and was returning an array containing nil values for
+      # the match.
+      expect(pipeline1.output_func(LogStash::Event.new)).not_to include(nil)
+      expect(pipeline1.filter_func(LogStash::Event.new)).not_to include(nil)
+      expect(pipeline2.output_func(LogStash::Event.new)).not_to include(nil)
+      expect(pipeline1.filter_func(LogStash::Event.new)).not_to include(nil)
+    end
+  end
+end
diff --git a/spec/core/plugin_spec.rb b/logstash-core/spec/logstash/plugin_spec.rb
similarity index 71%
rename from spec/core/plugin_spec.rb
rename to logstash-core/spec/logstash/plugin_spec.rb
index 8248c37b75e..b720fe49d27 100644
--- a/spec/core/plugin_spec.rb
+++ b/logstash-core/spec/logstash/plugin_spec.rb
@@ -4,12 +4,12 @@
 
 describe LogStash::Plugin do
   it "should fail lookup on inexisting type" do
-    expect_any_instance_of(Cabin::Channel).to receive(:debug).once
+    #expect_any_instance_of(Cabin::Channel).to receive(:debug).once
     expect { LogStash::Plugin.lookup("badbadtype", "badname") }.to raise_error(LogStash::PluginLoadingError)
   end
 
   it "should fail lookup on inexisting name" do
-    expect_any_instance_of(Cabin::Channel).to receive(:debug).once
+    #expect_any_instance_of(Cabin::Channel).to receive(:debug).once
     expect { LogStash::Plugin.lookup("filter", "badname") }.to raise_error(LogStash::PluginLoadingError)
   end
 
@@ -108,10 +108,10 @@ class LogStash::Filters::MyTestFilter < LogStash::Filters::Base
 
       subject.validate({})
     end
-    
+
 
     it 'logs a warning if the plugin use the milestone option' do
-      expect_any_instance_of(Cabin::Channel).to receive(:warn)
+      expect_any_instance_of(Cabin::Channel).to receive(:debug)
         .with(/stromae plugin is using the 'milestone' method/)
 
       class LogStash::Filters::Stromae < LogStash::Filters::Base
@@ -120,4 +120,50 @@ class LogStash::Filters::Stromae < LogStash::Filters::Base
       end
     end
   end
+
+  describe "subclass initialize" do
+    let(:args) { Hash.new }
+
+    [
+      StromaeCodec = Class.new(LogStash::Codecs::Base) do
+        config_name "stromae"
+        config :foo_tag, :validate => :string, :default => "bar"
+      end,
+      StromaeFilter = Class.new(LogStash::Filters::Base) do
+        config_name "stromae"
+        config :foo_tag, :validate => :string, :default => "bar"
+      end,
+      StromaeInput = Class.new(LogStash::Inputs::Base) do
+        config_name "stromae"
+        config :foo_tag, :validate => :string, :default => "bar"
+      end,
+      StromaeOutput = Class.new(LogStash::Outputs::Base) do
+        config_name "stromae"
+        config :foo_tag, :validate => :string, :default => "bar"
+      end
+    ].each do |klass|
+
+      it "subclass #{klass.name} does not modify params" do
+        klass.new(args)
+        expect(args).to be_empty
+      end
+    end
+
+    context "codec initialization" do
+
+      class LogStash::Codecs::Noop < LogStash::Codecs::Base
+        config_name "noop"
+
+        config :format, :validate => :string
+        def register; end
+      end
+
+      it "should only register once" do
+        args   = { "codec" => LogStash::Codecs::Noop.new("format" => ".") }
+        expect_any_instance_of(LogStash::Codecs::Noop).to receive(:register).once
+        LogStash::Plugin.new(args)
+      end
+
+    end
+  end
 end
diff --git a/logstash-core/spec/logstash/runner_spec.rb b/logstash-core/spec/logstash/runner_spec.rb
new file mode 100644
index 00000000000..07fff9a5a96
--- /dev/null
+++ b/logstash-core/spec/logstash/runner_spec.rb
@@ -0,0 +1,84 @@
+# encoding: utf-8
+require "spec_helper"
+require "logstash/runner"
+require "stud/task"
+require "stud/trap"
+require "stud/temporary"
+
+class NullRunner
+  def run(args); end
+end
+
+describe LogStash::Runner do
+
+  let(:channel) { Cabin::Channel.new }
+
+  before :each do
+    allow(Cabin::Channel).to receive(:get).with(LogStash).and_return(channel)
+    allow(channel).to receive(:subscribe).with(any_args).and_call_original
+  end
+
+  context "argument parsing" do
+    it "should run agent" do
+      expect(Stud::Task).to receive(:new).once.and_return(nil)
+      args = ["agent", "-e", ""]
+      expect(subject.run(args)).to eq(nil)
+    end
+
+    it "should run agent help" do
+      expect(subject).to receive(:show_help).once.and_return(nil)
+      args = ["agent", "-h"]
+      expect(subject.run(args).wait).to eq(0)
+    end
+
+    it "should show help with no arguments" do
+      expect($stderr).to receive(:puts).once.and_return("No command given")
+      expect($stderr).to receive(:puts).once
+      args = []
+      expect(subject.run(args).wait).to eq(1)
+    end
+
+    it "should show help for unknown commands" do
+      expect($stderr).to receive(:puts).once.and_return("No such command welp")
+      expect($stderr).to receive(:puts).once
+      args = ["welp"]
+      expect(subject.run(args).wait).to eq(1)
+    end
+  end
+
+  context "--auto-reload" do
+    context "when -f is not given" do
+
+      let(:args) { ["agent", "-r", "-e", "input {} output {}"] }
+
+      it "should exit immediately" do
+        expect(subject.run(args).wait).to eq(1)
+      end
+    end
+  end
+
+  context "--log-in-json" do
+    let(:logfile) { Stud::Temporary.file }
+    let(:args) { [ "agent", "--log-in-json", "-l", logfile.path, "-e", "some-invalid-config" ] }
+
+    after do
+      logfile.close
+      File.unlink(logfile.path)
+    end
+
+    before do
+      expect(channel).to receive(:subscribe).with(kind_of(LogStash::Logging::JSON)).and_call_original
+      subject.run(args).wait
+
+      # Log file should have stuff in it.
+      expect(logfile.stat.size).to be > 0
+    end
+
+    it "should log in valid json. One object per line." do
+      logfile.each_line do |line|
+        expect(line).not_to be_empty
+        expect { LogStash::Json.load(line) }.not_to raise_error
+      end
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/shutdown_watcher_spec.rb b/logstash-core/spec/logstash/shutdown_watcher_spec.rb
new file mode 100644
index 00000000000..fc799f3f69a
--- /dev/null
+++ b/logstash-core/spec/logstash/shutdown_watcher_spec.rb
@@ -0,0 +1,118 @@
+# encoding: utf-8
+require "spec_helper"
+require "logstash/shutdown_watcher"
+
+describe LogStash::ShutdownWatcher do
+  let(:channel) { Cabin::Channel.new }
+
+  let(:check_every) { 0.01 }
+  let(:check_threshold) { 100 }
+  subject { LogStash::ShutdownWatcher.new(pipeline, check_every) }
+  let(:pipeline) { double("pipeline") }
+  let(:reporter) { double("reporter") }
+  let(:reporter_snapshot) { double("reporter snapshot") }
+  report_count = 0
+
+  before :each do
+    LogStash::ShutdownWatcher.logger = channel
+
+    allow(pipeline).to receive(:reporter).and_return(reporter)
+    allow(pipeline).to receive(:thread).and_return(Thread.current)
+    allow(reporter).to receive(:snapshot).and_return(reporter_snapshot)
+    allow(reporter_snapshot).to receive(:o_simple_hash).and_return({})
+    allow(reporter_snapshot).to receive(:to_json_data).and_return("reporter-double")
+
+    allow(subject).to receive(:pipeline_report_snapshot).and_wrap_original do |m, *args|
+      report_count += 1
+      m.call(*args)
+    end
+  end
+
+  after :each do
+    report_count = 0
+  end
+
+  context "when pipeline is stalled" do
+    let(:increasing_count) { (1..5000).to_a }
+    before :each do
+      allow(reporter_snapshot).to receive(:inflight_count).and_return(*increasing_count)
+      allow(reporter_snapshot).to receive(:stalling_threads) { { } }
+    end
+
+    describe ".unsafe_shutdown = true" do
+      let(:abort_threshold) { subject.abort_threshold }
+      let(:report_every) { subject.report_every }
+
+      before :each do
+        subject.class.unsafe_shutdown = true
+      end
+
+      it "should force the shutdown" do
+        expect(subject).to receive(:force_exit).once
+        subject.start
+      end
+
+      it "should do exactly \"abort_threshold\" stall checks" do
+        allow(subject).to receive(:force_exit)
+        expect(subject).to receive(:shutdown_stalled?).exactly(abort_threshold).times.and_call_original
+        subject.start
+      end
+
+      it "should do exactly \"abort_threshold\"*\"report_every\" stall checks" do
+        allow(subject).to receive(:force_exit)
+        expect(subject).to receive(:pipeline_report_snapshot).exactly(abort_threshold*report_every).times.and_call_original
+        subject.start
+      end
+    end
+
+    describe ".unsafe_shutdown = false" do
+
+      before :each do
+        subject.class.unsafe_shutdown = false
+      end
+
+      it "shouldn't force the shutdown" do
+        expect(subject).to_not receive(:force_exit)
+        thread = Thread.new(subject) {|subject| subject.start }
+        sleep 0.1 until report_count > check_threshold
+        thread.kill
+      end
+    end
+  end
+
+  context "when pipeline is not stalled" do
+    let(:decreasing_count) { (1..5000).to_a.reverse }
+    before :each do
+      allow(reporter_snapshot).to receive(:inflight_count).and_return(*decreasing_count)
+      allow(reporter_snapshot).to receive(:stalling_threads) { { } }
+    end
+
+    describe ".unsafe_shutdown = true" do
+
+      before :each do
+        subject.class.unsafe_shutdown = true
+      end
+
+      it "should force the shutdown" do
+        expect(subject).to_not receive(:force_exit)
+        thread = Thread.new(subject) {|subject| subject.start }
+        sleep 0.1 until report_count > check_threshold
+        thread.kill
+      end
+    end
+
+    describe ".unsafe_shutdown = false" do
+
+      before :each do
+        subject.class.unsafe_shutdown = false
+      end
+
+      it "shouldn't force the shutdown" do
+        expect(subject).to_not receive(:force_exit)
+        thread = Thread.new(subject) {|subject| subject.start }
+        sleep 0.1 until report_count > check_threshold
+        thread.kill
+      end
+    end
+  end
+end
diff --git a/spec/util/buftok_spec.rb b/logstash-core/spec/logstash/util/buftok_spec.rb
similarity index 100%
rename from spec/util/buftok_spec.rb
rename to logstash-core/spec/logstash/util/buftok_spec.rb
diff --git a/spec/util/charset_spec.rb b/logstash-core/spec/logstash/util/charset_spec.rb
similarity index 100%
rename from spec/util/charset_spec.rb
rename to logstash-core/spec/logstash/util/charset_spec.rb
diff --git a/spec/util/defaults_printer_spec.rb b/logstash-core/spec/logstash/util/defaults_printer_spec.rb
similarity index 77%
rename from spec/util/defaults_printer_spec.rb
rename to logstash-core/spec/logstash/util/defaults_printer_spec.rb
index 3e50a7032cb..b3f0576a3a9 100644
--- a/spec/util/defaults_printer_spec.rb
+++ b/logstash-core/spec/logstash/util/defaults_printer_spec.rb
@@ -10,7 +10,7 @@
   end
 
   let(:workers)  { 1 }
-  let(:expected) { "Default settings used: Filter workers: #{workers}" }
+  let(:expected) { "Settings: User set pipeline workers: #{workers}" }
   let(:settings) { {} }
 
   describe 'class methods API' do
@@ -19,13 +19,13 @@
     end
 
     context 'when the settings hash is empty' do
+      let(:expected) { "Settings: " }
       it_behaves_like "a defaults printer"
     end
 
     context 'when the settings hash has content' do
-      let(:workers) { 42 }
-      let(:settings) { {'filter-workers' => workers} }
-
+      let(:worker_queue) { 42 }
+      let(:settings) { {:pipeline_workers => workers} }
       it_behaves_like "a defaults printer"
     end
   end
@@ -36,12 +36,13 @@
     end
 
     context 'when the settings hash is empty' do
+      let(:expected) { "Settings: " }
       it_behaves_like "a defaults printer"
     end
 
     context 'when the settings hash has content' do
       let(:workers) { 13 }
-      let(:settings) { {'filter-workers' => workers} }
+      let(:settings) { {:pipeline_workers => workers} }
 
       it_behaves_like "a defaults printer"
     end
diff --git a/spec/util/java_version_spec.rb b/logstash-core/spec/logstash/util/java_version_spec.rb
similarity index 100%
rename from spec/util/java_version_spec.rb
rename to logstash-core/spec/logstash/util/java_version_spec.rb
diff --git a/spec/util/plugin_version_spec.rb b/logstash-core/spec/logstash/util/plugin_version_spec.rb
similarity index 100%
rename from spec/util/plugin_version_spec.rb
rename to logstash-core/spec/logstash/util/plugin_version_spec.rb
diff --git a/spec/util/unicode_trimmer_spec.rb b/logstash-core/spec/logstash/util/unicode_trimmer_spec.rb
similarity index 100%
rename from spec/util/unicode_trimmer_spec.rb
rename to logstash-core/spec/logstash/util/unicode_trimmer_spec.rb
diff --git a/logstash-core/spec/logstash/util/worker_threads_default_printer_spec.rb b/logstash-core/spec/logstash/util/worker_threads_default_printer_spec.rb
new file mode 100644
index 00000000000..1842b4373ad
--- /dev/null
+++ b/logstash-core/spec/logstash/util/worker_threads_default_printer_spec.rb
@@ -0,0 +1,45 @@
+# encoding: utf-8
+require "spec_helper"
+require "logstash/util/worker_threads_default_printer"
+
+describe LogStash::Util::WorkerThreadsDefaultPrinter do
+  let(:settings)  { {} }
+  let(:collector) { [] }
+
+  subject { described_class.new(settings) }
+
+  before { subject.visit(collector) }
+
+  describe "the #visit method" do
+    context 'when the settings hash is empty' do
+      it 'adds nothing to the collector' do
+        subject.visit(collector)
+        expect(collector).to eq([])
+      end
+    end
+
+    context 'when the settings hash has both user and default content' do
+      let(:settings) { {:pipeline_workers => 42, :default_pipeline_workers => 5} }
+
+      it 'adds two strings' do
+        expect(collector).to eq(["User set pipeline workers: 42", "Default pipeline workers: 5"])
+      end
+    end
+
+    context 'when the settings hash has only user content' do
+      let(:settings) { {:pipeline_workers => 42} }
+
+      it 'adds a string with user set pipeline workers' do
+        expect(collector.first).to eq("User set pipeline workers: 42")
+      end
+    end
+
+    context 'when the settings hash has only default content' do
+      let(:settings) { {:default_pipeline_workers => 5} }
+
+      it 'adds a string with default pipeline workers' do
+        expect(collector.first).to eq("Default pipeline workers: 5")
+      end
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/util/wrapped_synchronous_queue_spec.rb b/logstash-core/spec/logstash/util/wrapped_synchronous_queue_spec.rb
new file mode 100644
index 00000000000..871952482aa
--- /dev/null
+++ b/logstash-core/spec/logstash/util/wrapped_synchronous_queue_spec.rb
@@ -0,0 +1,28 @@
+# encoding: utf-8
+require "spec_helper"
+require "logstash/util/wrapped_synchronous_queue"
+
+describe LogStash::Util::WrappedSynchronousQueue do
+ context "#offer" do
+   context "queue is blocked" do
+     it "fails and give feedback" do
+       expect(subject.offer("Bonjour", 2)).to be_falsey
+     end
+   end
+
+   context "queue is not blocked" do
+     before do
+       @consumer = Thread.new { loop { subject.take } }
+       sleep(0.1)
+     end
+
+     after do
+       @consumer.kill
+     end
+     
+     it "inserts successfully" do
+       expect(subject.offer("Bonjour", 20)).to be_truthy
+     end
+   end
+ end
+end
diff --git a/spec/util_spec.rb b/logstash-core/spec/logstash/util_spec.rb
similarity index 100%
rename from spec/util_spec.rb
rename to logstash-core/spec/logstash/util_spec.rb
diff --git a/logstash-core/spec/static/i18n_spec.rb b/logstash-core/spec/static/i18n_spec.rb
new file mode 100644
index 00000000000..b2cd76377d2
--- /dev/null
+++ b/logstash-core/spec/static/i18n_spec.rb
@@ -0,0 +1,25 @@
+# encoding: utf-8
+require "spec_helper"
+require "i18n"
+
+I18N_T_REGEX = Regexp.new('I18n.t.+?"(.+?)"')
+
+describe I18n do
+  context "when using en.yml" do
+    glob_path = File.join(LogStash::Environment::LOGSTASH_HOME, "logstash-*", "lib", "**", "*.rb")
+
+    Dir.glob(glob_path).each do |file_name|
+
+      context "in file \"#{file_name}\"" do
+        File.foreach(file_name) do |line|
+          next unless (match = line.match(I18N_T_REGEX))
+          line = $INPUT_LINE_NUMBER
+          key = match[1]
+          it "in line #{line} the \"#{key}\" key should exist" do
+            expect(I18n.exists?(key)).to be_truthy
+          end
+        end
+      end
+    end
+  end
+end
diff --git a/logstash-event.gemspec b/logstash-event.gemspec
deleted file mode 100644
index ea6cce87e1a..00000000000
--- a/logstash-event.gemspec
+++ /dev/null
@@ -1,41 +0,0 @@
-# -*- encoding: utf-8 -*-
-Gem::Specification.new do |gem|
-  gem.authors       = ["Jordan Sissel"]
-  gem.email         = ["jls@semicomplete.com"]
-  gem.description   = %q{Library that contains the classes required to create LogStash events}
-  gem.summary       = %q{Library that contains the classes required to create LogStash events}
-  gem.homepage      = "https://github.com/logstash/logstash"
-  gem.license       = "Apache License (2.0)"
-
-  gem.files = %w{
-    lib/logstash-event.rb
-    lib/logstash/environment.rb
-    lib/logstash/errors.rb
-    lib/logstash/event.rb
-    lib/logstash/java_integration.rb
-    lib/logstash/json.rb
-    lib/logstash/namespace.rb
-    lib/logstash/timestamp.rb
-    lib/logstash/version.rb
-    lib/logstash/util.rb
-    lib/logstash/util/accessors.rb
-    LICENSE
-  }
-
-  gem.test_files    = ["spec/core/event_spec.rb"]
-  gem.name          = "logstash-event"
-  gem.require_paths = ["lib"]
-  gem.version       = "1.3.0"
-
-  gem.add_runtime_dependency "cabin"
-  gem.add_development_dependency "rspec"
-  gem.add_development_dependency "guard"
-  gem.add_development_dependency "guard-rspec"
-
-  if RUBY_PLATFORM == 'java'
-    gem.platform = RUBY_PLATFORM
-    gem.add_runtime_dependency "jrjackson"
-  else
-    gem.add_runtime_dependency "oj"
-  end
-end
diff --git a/pkg/logstash.default b/pkg/logstash.default
index bf8ab6ca7df..c3415146761 100644
--- a/pkg/logstash.default
+++ b/pkg/logstash.default
@@ -12,7 +12,7 @@
 #LS_OPTS=""
 
 # Arguments to pass to java
-#LS_HEAP_SIZE="500m"
+#LS_HEAP_SIZE="1g"
 #LS_JAVA_OPTS="-Djava.io.tmpdir=$HOME"
 
 # pidfiles aren't used for upstart; this is for sysv users.
@@ -24,6 +24,7 @@
 # logstash logging
 #LS_LOG_FILE=/var/log/logstash/logstash.log
 #LS_USE_GC_LOGGING="true"
+#LS_GC_LOG_FILE=/var/log/logstash/gc.log
 
 # logstash configuration directory
 #LS_CONF_DIR=/etc/logstash/conf.d
diff --git a/pkg/logstash.sysv b/pkg/logstash.sysv
index fdfc8902ac4..005aec191cd 100755
--- a/pkg/logstash.sysv
+++ b/pkg/logstash.sysv
@@ -29,12 +29,13 @@ pidfile="/var/run/$name.pid"
 LS_USER=logstash
 LS_GROUP=logstash
 LS_HOME=/var/lib/logstash
-LS_HEAP_SIZE="500m"
+LS_HEAP_SIZE="1g"
 LS_LOG_DIR=/var/log/logstash
 LS_LOG_FILE="${LS_LOG_DIR}/$name.log"
 LS_CONF_DIR=/etc/logstash/conf.d
 LS_OPEN_FILES=16384
 LS_NICE=19
+KILL_ON_STOP_TIMEOUT=0
 LS_OPTS=""
 
 
@@ -53,7 +54,7 @@ start() {
 
   LS_JAVA_OPTS="${LS_JAVA_OPTS} -Djava.io.tmpdir=${LS_HOME}"
   HOME=${LS_HOME}
-  export PATH HOME LS_HEAP_SIZE LS_JAVA_OPTS LS_USE_GC_LOGGING
+  export PATH HOME LS_HEAP_SIZE LS_JAVA_OPTS LS_USE_GC_LOGGING LS_GC_LOG_FILE
 
   # chown doesn't grab the suplimental groups when setting the user:group - so we have to do it for it.
   # Boy, I hope we're root here.
@@ -90,18 +91,19 @@ stop() {
     echo "Killing $name (pid $pid) with SIGTERM"
     kill -TERM $pid
     # Wait for it to exit.
-    for i in 1 2 3 4 5 ; do
+    for i in 1 2 3 4 5 6 7 8 9 ; do
       echo "Waiting $name (pid $pid) to die..."
       status || break
       sleep 1
     done
     if status ; then
-      if [ "$KILL_ON_STOP_TIMEOUT" -eq 1 ] ; then
+      if [ "$KILL_ON_STOP_TIMEOUT" = 1 ] ; then
         echo "Timeout reached. Killing $name (pid $pid) with SIGKILL. This may result in data loss."
         kill -KILL $pid
         echo "$name killed with SIGKILL."
       else
         echo "$name stop failed; still running."
+        return 1 # stop timed out and not forced
       fi
     else
       echo "$name stopped."
@@ -127,6 +129,12 @@ status() {
   fi
 }
 
+reload() {
+  if status ; then
+    kill -HUP `cat "$pidfile"`
+  fi
+}
+
 force_stop() {
   if status ; then
     stop
@@ -137,15 +145,14 @@ force_stop() {
 configtest() {
   # Check if a config file exists
   if [ ! "$(ls -A ${LS_CONF_DIR}/* 2> /dev/null)" ]; then
-    log_failure_msg "There aren't any configuration files in ${LS_CONF_DIR}"
-    exit 1
+    echo "There aren't any configuration files in ${LS_CONF_DIR}"
+    return 1
   fi
 
-  JAVA_OPTS=${LS_JAVA_OPTS}
   HOME=${LS_HOME}
-  export PATH HOME JAVA_OPTS LS_HEAP_SIZE LS_JAVA_OPTS LS_USE_GC_LOGGING
+  export PATH HOME
 
-  test_args="-f ${LS_CONF_DIR} --configtest ${LS_OPTS}"
+  test_args="--configtest -f ${LS_CONF_DIR} ${LS_OPTS}"
   $program ${test_args}
   [ $? -eq 0 ] && return 0
   # Program not configured
@@ -176,6 +183,7 @@ case "$1" in
     fi
     exit $code
     ;;
+  reload) reload ;;
   restart)
 
     quiet configtest
@@ -191,7 +199,7 @@ case "$1" in
     exit $?
     ;;
   *)
-    echo "Usage: $SCRIPTNAME {start|stop|force-stop|status|restart|configtest}" >&2
+    echo "Usage: $SCRIPTNAME {start|stop|force-stop|status|reload|restart|configtest}" >&2
     exit 3
   ;;
 esac
diff --git a/pkg/logstash.sysv.debian b/pkg/logstash.sysv.debian
index 5795cdb991e..f83c468d81a 100644
--- a/pkg/logstash.sysv.debian
+++ b/pkg/logstash.sysv.debian
@@ -36,7 +36,7 @@ PATH=/bin:/usr/bin:/sbin:/usr/sbin
 LS_USER=logstash
 LS_GROUP=logstash
 LS_HOME=/var/lib/logstash
-LS_HEAP_SIZE="500m"
+LS_HEAP_SIZE="1g"
 LS_LOG_FILE=/var/log/logstash/$NAME.log
 LS_CONF_DIR=/etc/logstash/conf.d
 LS_OPEN_FILES=16384
@@ -87,7 +87,7 @@ case "$1" in
          LS_JAVA_OPTS="${LS_JAVA_OPTS} -Djava.io.tmpdir=${LS_HOME}"
          ulimit -n ${LS_OPEN_FILES}
 	 cd "${LS_HOME}"
-         export PATH HOME JAVACMD LS_HEAP_SIZE LS_JAVA_OPTS LS_USE_GC_LOGGING
+         export PATH HOME JAVACMD LS_HEAP_SIZE LS_JAVA_OPTS LS_USE_GC_LOGGING LS_GC_LOG_FILE
 
          # Start Daemon
          start-stop-daemon --start -b --user "$LS_USER" -c "$LS_USER":"$LS_GROUP" \
diff --git a/pkg/logstash.sysv.redhat b/pkg/logstash.sysv.redhat
index c228e355e9b..07f606e8d41 100755
--- a/pkg/logstash.sysv.redhat
+++ b/pkg/logstash.sysv.redhat
@@ -35,7 +35,7 @@ PATH=/bin:/usr/bin:/sbin:/usr/sbin
 LS_USER=logstash
 LS_GROUP=logstash
 LS_HOME=/var/lib/logstash
-LS_HEAP_SIZE="500m"
+LS_HEAP_SIZE="1g"
 LS_LOG_FILE=/var/log/logstash/$NAME.log
 LS_CONF_DIR=/etc/logstash/conf.d
 LS_OPEN_FILES=16384
@@ -75,7 +75,7 @@ do_start()
   LS_JAVA_OPTS="${LS_JAVA_OPTS} -Djava.io.tmpdir=${LS_HOME}"
   ulimit -n ${LS_OPEN_FILES}
   cd "${LS_HOME}"
-  export PATH HOME LS_HEAP_SIZE LS_JAVA_OPTS LS_USE_GC_LOGGING
+  export PATH HOME LS_HEAP_SIZE LS_JAVA_OPTS LS_USE_GC_LOGGING LS_GC_LOG_FILE
   test -n "${JAVACMD}" && export JAVACMD
 
   nice -n ${LS_NICE} runuser -s /bin/sh -c "exec $DAEMON $DAEMON_OPTS" ${LS_USER} >> $LS_LOG_FILE 2>&1 < /dev/null &
diff --git a/pkg/logstash.upstart.ubuntu b/pkg/logstash.upstart.ubuntu
index 68730ffe949..482c53d7bf3 100644
--- a/pkg/logstash.upstart.ubuntu
+++ b/pkg/logstash.upstart.ubuntu
@@ -22,9 +22,10 @@ script
   # Defaults
   PATH=/bin:/usr/bin
   LS_HOME=/var/lib/logstash
-  LS_HEAP_SIZE="500m"
+  LS_HEAP_SIZE="1g"
   LS_LOG_FILE=/var/log/logstash/logstash.log
   LS_USE_GC_LOGGING=""
+  LS_GC_LOG_FILE=""
   LS_CONF_DIR=/etc/logstash/conf.d
   LS_OPEN_FILES=16384
   LS_NICE=19
@@ -40,7 +41,7 @@ script
   cd "${LS_HOME}"
 
   # Export variables
-  export PATH HOME LS_HEAP_SIZE LS_JAVA_OPTS LS_USE_GC_LOGGING
+  export PATH HOME LS_HEAP_SIZE LS_JAVA_OPTS LS_USE_GC_LOGGING LS_GC_LOG_FILE
   test -n "${JAVACMD}" && export JAVACMD
 
   exec nice -n ${LS_NICE} /opt/logstash/bin/logstash agent -f "${LS_CONF_DIR}" -l "${LS_LOG_FILE}" ${LS_OPTS}
diff --git a/rakelib/artifacts.rake b/rakelib/artifacts.rake
index e2637f09995..fa8908a015f 100644
--- a/rakelib/artifacts.rake
+++ b/rakelib/artifacts.rake
@@ -13,6 +13,13 @@ namespace "artifact" do
       "lib/pluginmanager/**/*",
       "patterns/**/*",
       "vendor/??*/**/*",
+      # To include ruby-maven's hidden ".mvn" directory, we need to
+      # do add the line below. This directory contains a file called
+      # "extensions.xml", which loads the ruby DSL for POMs.
+      # Failing to include this file results in updates breaking for
+      # plugins which use jar-dependencies.
+      # See more in https://github.com/elastic/logstash/issues/4818
+      "vendor/??*/**/.mvn/**/*",
       "Gemfile",
       "Gemfile.jruby-1.9.lock",
     ]
@@ -54,27 +61,84 @@ namespace "artifact" do
     File.open(".bundle/config", "w") { }
   end
 
-  # locate the "gem "logstash-core" ..." line in Gemfile, and if the :path => "." option if specified
+  # locate the "gem "logstash-core" ..." line in Gemfile, and if the :path => "..." option if specified
   # build and install the local logstash-core gem otherwise just do nothing, bundler will deal with it.
   task "install-logstash-core" do
+    # regex which matches a Gemfile gem definition for the logstash-core gem and captures the :path option
+    gem_line_regex = /^\s*gem\s+["']logstash-core["'](?:\s*,\s*["'][^"^']+["'])?(?:\s*,\s*:path\s*=>\s*["']([^"^']+)["'])?/i
+
     lines = File.readlines("Gemfile")
-    matches = lines.select{|line| line[/^gem\s+["']logstash-core["']/i]}
+    matches = lines.select{|line| line[gem_line_regex]}
     abort("ERROR: Gemfile format error, need a single logstash-core gem specification") if matches.size != 1
-    if matches.first =~ /:path\s*=>\s*["']\.["']/
-      Rake::Task["plugin:install-local-logstash-core-gem"].invoke
+
+    path = matches.first[gem_line_regex, 1]
+
+    if path
+      Rake::Task["plugin:install-local-core-gem"].invoke("logstash-core", path)
     else
       puts("[artifact:install-logstash-core] using logstash-core from Rubygems")
     end
   end
 
-  task "prepare" => ["bootstrap", "plugin:install-default", "install-logstash-core", "clean-bundle-config"]
+  # # locate the "gem "logstash-core-event*" ..." line in Gemfile, and if the :path => "." option if specified
+  # # build and install the local logstash-core-event* gem otherwise just do nothing, bundler will deal with it.
+  task "install-logstash-core-event" do
+    # regex which matches a Gemfile gem definition for the logstash-core-event* gem and captures the gem name and :path option
+    gem_line_regex = /^\s*gem\s+["'](logstash-core-event[^"^']*)["'](?:\s*,\s*["'][^"^']+["'])?(?:\s*,\s*:path\s*=>\s*["']([^"^']+)["'])?/i
+
+    lines = File.readlines("Gemfile")
+    matches = lines.select{|line| line[gem_line_regex]}
+    abort("ERROR: Gemfile format error, need a single logstash-core-event gem specification") if matches.size != 1
+
+    name = matches.first[gem_line_regex, 1]
+    path = matches.first[gem_line_regex, 2]
+
+    if path
+      Rake::Task["plugin:install-local-core-gem"].invoke(name, path)
+    else
+      puts("[artifact:install-logstash-core] using #{name} from Rubygems")
+    end
+  end
+
+  # locate the "gem "logstash-core-plugin-api" ..." line in Gemfile, and if the :path => "..." option if specified
+  # build and install the local logstash-core-plugin-api gem otherwise just do nothing, bundler will deal with it.
+  task "install-logstash-core-plugin-api" do
+    # regex which matches a Gemfile gem definition for the logstash-core gem and captures the :path option
+    gem_line_regex = /^\s*gem\s+["']logstash-core-plugin-api["'](?:\s*,\s*["'][^"^']+["'])?(?:\s*,\s*:path\s*=>\s*["']([^"^']+)["'])?/i
+
+    lines = File.readlines("Gemfile")
+    matches = lines.select{|line| line[gem_line_regex]}
+    abort("ERROR: Gemfile format error, need a single logstash-core-plugin-api gem specification") if matches.size != 1
+
+    path = matches.first[gem_line_regex, 1]
 
-  desc "Build a tar.gz of logstash with all dependencies"
+    if path
+      Rake::Task["plugin:install-local-core-gem"].invoke("logstash-core-plugin-api", path)
+    else
+      puts("[artifact:install-logstash-core-plugin-api] using logstash-core from Rubygems")
+    end
+  end
+
+  task "prepare" => ["bootstrap", "plugin:install-default", "install-logstash-core", "install-logstash-core-event", "install-logstash-core-plugin-api", "clean-bundle-config"]
+  task "prepare-all" => ["bootstrap", "plugin:install-all", "install-logstash-core", "install-logstash-core-event", "install-logstash-core-plugin-api", "clean-bundle-config"]
+
+  desc "Build a tar.gz of default logstash plugins with all dependencies"
   task "tar" => ["prepare"] do
+    puts("[artifact:tar] Building tar.gz of default plugins")
+    build_tar
+  end
+
+  desc "Build a tar.gz of all logstash plugins from logstash-plugins github repo"
+  task "tar-all-plugins" => ["prepare-all"] do
+    puts("[artifact:tar] Building tar.gz of all plugins")
+    build_tar "-all-plugins"
+  end
+
+  def build_tar(tar_suffix = nil)
     require "zlib"
     require "archive/tar/minitar"
     require "logstash/version"
-    tarpath = "build/logstash-#{LOGSTASH_VERSION}.tar.gz"
+    tarpath = "build/logstash#{tar_suffix}-#{LOGSTASH_VERSION}.tar.gz"
     puts("[artifact:tar] building #{tarpath}")
     gz = Zlib::GzipWriter.new(File.new(tarpath, "wb"), Zlib::BEST_COMPRESSION)
     tar = Archive::Tar::Minitar::Output.new(gz)
@@ -106,9 +170,21 @@ namespace "artifact" do
     puts "Complete: #{tarpath}"
   end
 
+  desc "Build a zip of default logstash plugins with all dependencies"
   task "zip" => ["prepare"] do
+    puts("[artifact:zip] Building zip of default plugins")
+    build_zip
+  end
+
+  desc "Build a zip of all logstash plugins from logstash-plugins github repo"
+  task "zip-all-plugins" => ["prepare-all"] do
+    puts("[artifact:zip] Building zip of all plugins")
+    build_zip "-all-plugins"
+  end
+
+  def build_zip(zip_suffix = "")
     require 'zip'
-    zippath = "build/logstash-#{LOGSTASH_VERSION}.zip"
+    zippath = "build/logstash#{zip_suffix}-#{LOGSTASH_VERSION}.zip"
     puts("[artifact:zip] building #{zippath}")
     File.unlink(zippath) if File.exists?(zippath)
     Zip::File.open(zippath, Zip::File::CREATE) do |zipfile|
@@ -150,6 +226,9 @@ namespace "artifact" do
 
     case platform
       when "redhat", "centos"
+        # produce: logstash-5.0.0-alpha1.noarch.rpm
+        package_filename = "logstash-#{LOGSTASH_VERSION}.ARCH.TYPE"
+
         File.join(basedir, "pkg", "logrotate.conf").tap do |path|
           dir.input("#{path}=/etc/logrotate.d/logstash")
         end
@@ -165,10 +244,14 @@ namespace "artifact" do
         out.attributes[:rpm_use_file_permissions] = true
         out.attributes[:rpm_user] = "root"
         out.attributes[:rpm_group] = "root"
+        out.attributes[:rpm_os] = "linux"
         out.config_files << "etc/sysconfig/logstash"
         out.config_files << "etc/logrotate.d/logstash"
         out.config_files << "/etc/init.d/logstash"
       when "debian", "ubuntu"
+        # produce: logstash-5.0.0-alpha1_all.deb"
+        package_filename = "logstash-#{LOGSTASH_VERSION}_ARCH.TYPE"
+
         File.join(basedir, "pkg", "logstash.default").tap do |path|
           dir.input("#{path}=/etc/default/logstash")
         end
@@ -201,7 +284,7 @@ namespace "artifact" do
     # TODO(sissel): Invoke Pleaserun to generate the init scripts/whatever
 
     out.name = "logstash"
-    out.version = LOGSTASH_VERSION
+    out.version = LOGSTASH_VERSION.gsub(/[.-]([[:alpha:]])/, '~\1')
     out.architecture = "all"
     # TODO(sissel): Include the git commit hash?
     out.iteration = "1" # what revision?
@@ -233,7 +316,7 @@ namespace "artifact" do
 
     out.attributes[:force?] = true # overwrite the rpm/deb/etc being created
     begin
-      path = File.join(basedir, "build", out.to_s)
+      path = File.join(basedir, "build", out.to_s(package_filename))
       x = out.output(path)
       puts "Completed: #{path}"
     ensure
@@ -247,10 +330,9 @@ namespace "artifact" do
     package("centos", "5")
   end
 
-  desc "Build an RPM of logstash with all dependencies"
+  desc "Build a DEB of logstash with all dependencies"
   task "deb" => ["prepare"] do
     puts("[artifact:deb] building deb package")
     package("ubuntu", "12.04")
   end
 end
-
diff --git a/rakelib/compile.rake b/rakelib/compile.rake
index df572de21bc..aa20eb7091b 100644
--- a/rakelib/compile.rake
+++ b/rakelib/compile.rake
@@ -8,8 +8,14 @@ end
 
 namespace "compile" do
   desc "Compile the config grammar"
-  task "grammar" => "lib/logstash/config/grammar.rb"
+
+  task "grammar" => "logstash-core/lib/logstash/config/grammar.rb"
+
+  task "logstash-core-event-java" do
+    puts("Building logstash-core-event-java using gradle")
+    system("logstash-core-event-java/gradlew", "jar", "-p", "./logstash-core-event-java")
+  end
 
   desc "Build everything"
-  task "all" => "grammar"
+  task "all" => ["grammar", "logstash-core-event-java"]
 end
diff --git a/rakelib/default_plugins.rb b/rakelib/default_plugins.rb
index 4b0e3e2d35e..2001fa0d3e1 100644
--- a/rakelib/default_plugins.rb
+++ b/rakelib/default_plugins.rb
@@ -56,8 +56,10 @@ module RakeLib
       logstash-input-generator
       logstash-input-graphite
       logstash-input-http
+      logstash-input-http_poller
       logstash-input-imap
       logstash-input-irc
+      logstash-input-jdbc
       logstash-input-log4j
       logstash-input-lumberjack
       logstash-input-pipe
@@ -142,7 +144,13 @@ module RakeLib
       /^logstash-output-webhdfs$/,
       /^logstash-input-rackspace$/,
       /^logstash-output-rackspace$/,
-      /^logstash-input-dynamodb$/
+      /^logstash-input-dynamodb$/,
+      /^logstash-filter-language$/,
+      /^logstash-input-heroku$/,
+      /^logstash-output-google_cloud_storage$/,
+      /^logstash-input-journald$/,
+      /^logstash-input-log4j2$/,
+      /^logstash-codec-cloudtrail$/
     ])
 
 
diff --git a/rakelib/package.rake b/rakelib/package.rake
new file mode 100644
index 00000000000..d39578e0408
--- /dev/null
+++ b/rakelib/package.rake
@@ -0,0 +1,13 @@
+namespace "package" do
+
+  task "bundle" do
+    system("bin/plugin", "pack")
+    raise(RuntimeError, $!.to_s) unless $?.success?
+  end
+
+  desc "Build a package with the default plugins, including dependencies, to be installed offline"
+  task "plugins-default" => ["test:install-default", "bundle"]
+
+  desc "Build a package with all the plugins, including dependencies, to be installed offline"
+  task "plugins-all" => ["test:install-all", "bundle"]
+end
diff --git a/rakelib/plugin.rake b/rakelib/plugin.rake
index 9c2065c1f56..173f4b08f10 100644
--- a/rakelib/plugin.rake
+++ b/rakelib/plugin.rake
@@ -3,13 +3,13 @@ require_relative "default_plugins"
 namespace "plugin" do
 
   def install_plugins(*args)
-    system("bin/plugin", "install", *args)
+    system("bin/logstash-plugin", "install", *args)
     raise(RuntimeError, $!.to_s) unless $?.success?
   end
 
   task "install-development-dependencies" do
     puts("[plugin:install-development-dependencies] Installing development dependencies of all installed plugins")
-    install_plugins("--development")
+    install_plugins("--development",  "--preserve")
 
     task.reenable # Allow this task to be run again
   end
@@ -17,66 +17,91 @@ namespace "plugin" do
   task "install", :name do |task, args|
     name = args[:name]
     puts("[plugin:install] Installing plugin: #{name}")
-    install_plugins("--no-verify", name)
+    install_plugins("--no-verify", "--preserve", name)
 
     task.reenable # Allow this task to be run again
   end # task "install"
 
   task "install-default" do
     puts("[plugin:install-default] Installing default plugins")
-    install_plugins("--no-verify", *LogStash::RakeLib::DEFAULT_PLUGINS)
+    install_plugins("--no-verify", "--preserve", *LogStash::RakeLib::DEFAULT_PLUGINS)
 
     task.reenable # Allow this task to be run again
   end
 
   task "install-core" do
     puts("[plugin:install-core] Installing core plugins")
-    install_plugins("--no-verify", *LogStash::RakeLib::CORE_SPECS_PLUGINS)
+    install_plugins("--no-verify", "--preserve", *LogStash::RakeLib::CORE_SPECS_PLUGINS)
 
     task.reenable # Allow this task to be run again
   end
 
   task "install-jar-dependencies" do
     puts("[plugin:install-jar-dependencies] Installing jar_dependencies plugins for testing")
-    install_plugins("--no-verify", *LogStash::RakeLib::TEST_JAR_DEPENDENCIES_PLUGINS)
+    install_plugins("--no-verify", "--preserve", *LogStash::RakeLib::TEST_JAR_DEPENDENCIES_PLUGINS)
 
     task.reenable # Allow this task to be run again
   end
 
   task "install-vendor" do
     puts("[plugin:install-jar-dependencies] Installing vendor plugins for testing")
-    install_plugins("--no-verify", *LogStash::RakeLib::TEST_VENDOR_PLUGINS)
+    install_plugins("--no-verify", "--preserve", *LogStash::RakeLib::TEST_VENDOR_PLUGINS)
 
     task.reenable # Allow this task to be run again
   end
 
   task "install-all" do
     puts("[plugin:install-all] Installing all plugins from https://github.com/logstash-plugins")
-    install_plugins("--no-verify", *LogStash::RakeLib.fetch_all_plugins)
+    p = *LogStash::RakeLib.fetch_all_plugins
+    # Install plugin one by one, ignoring plugins that have issues. Otherwise, one bad plugin will
+    # blow up the entire install process.
+    # TODO Push this downstream to #install_plugins
+    p.each do |plugin|
+      begin
+        install_plugins("--no-verify", "--preserve", plugin)
+      rescue
+        puts "Unable to install #{plugin}. Skipping"
+        next
+      end
+    end
 
     task.reenable # Allow this task to be run again
   end
 
-  task "clean-logstash-core-gem" do
-    Dir["logstash-core*.gem"].each do |gem|
+  task "clean-local-core-gem", [:name, :path] do |task, args|
+    name = args[:name]
+    path = args[:path]
+
+    Dir[File.join(path, "#{name}*.gem")].each do |gem|
+      puts("[plugin:clean-local-core-gem] Cleaning #{gem}")
       rm(gem)
     end
 
     task.reenable # Allow this task to be run again
   end
 
-  task "build-logstash-core-gem" => [ "clean-logstash-core-gem" ] do
-    puts("[plugin:build-logstash-core-gem] Building logstash-core.gemspec")
+  task "build-local-core-gem", [:name, :path]  do |task, args|
+    name = args[:name]
+    path = args[:path]
+
+    Rake::Task["plugin:clean-local-core-gem"].invoke(name, path)
 
-    system("gem build logstash-core.gemspec")
+    puts("[plugin:build-local-core-gem] Building #{File.join(path, name)}.gemspec")
+
+    system("cd #{path}; gem build #{name}.gemspec")
 
     task.reenable # Allow this task to be run again
   end
 
-  task "install-local-logstash-core-gem" => [ "build-logstash-core-gem" ] do
-    gems = Dir["logstash-core*.gem"]
-    abort("ERROR: logstash-core gem not found") if gems.size != 1
-    puts("[plugin:install-local-logstash-core-gem] Installing #{gems.first}")
+  task "install-local-core-gem", [:name, :path] do |task, args|
+    name = args[:name]
+    path = args[:path]
+
+    Rake::Task["plugin:build-local-core-gem"].invoke(name, path)
+
+    gems = Dir[File.join(path, "#{name}*.gem")]
+    abort("ERROR: #{name} gem not found in #{path}") if gems.size != 1
+    puts("[plugin:install-local-core-gem] Installing #{gems.first}")
     install_plugins("--no-verify", gems.first)
 
     task.reenable # Allow this task to be run again
diff --git a/rakelib/test.rake b/rakelib/test.rake
index 9c25d819589..e53e6b8291b 100644
--- a/rakelib/test.rake
+++ b/rakelib/test.rake
@@ -19,18 +19,36 @@ namespace "test" do
     require 'ci/reporter/rake/rspec_loader'
   end
 
+  def core_specs
+    # note that regardless if which logstash-core-event-* gem is live, we will always run the
+    # logstash-core-event specs since currently this is the most complete Event and Timestamp specs
+    # which actually defines the Event contract and should pass regardless of the actuall underlying
+    # implementation.
+    specs = ["spec/**/*_spec.rb", "logstash-core/spec/**/*_spec.rb", "logstash-core-event/spec/**/*_spec.rb"]
+
+    # figure if the logstash-core-event-java gem is loaded and if so add its specific specs in the core specs to run
+    begin
+      require "logstash-core-event-java/version"
+      specs << "logstash-core-event-java/spec/**/*_spec.rb"
+    rescue LoadError
+      # logstash-core-event-java gem is not live, ignore and skip specs
+    end
+
+    Rake::FileList[*specs]
+  end
+
   desc "run core specs"
   task "core" => ["setup"] do
-    exit(RSpec::Core::Runner.run([Rake::FileList["spec/**/*_spec.rb"]]))
+    exit(RSpec::Core::Runner.run([core_specs]))
   end
 
   desc "run core specs in fail-fast mode"
   task "core-fail-fast" => ["setup"] do
-    exit(Spec::Core::Runner.run(["--fail-fast", Rake::FileList["spec/**/*_spec.rb"]]))
+    exit(RSpec::Core::Runner.run(["--fail-fast", core_specs]))
   end
 
   desc "run core specs on a single file"
-  task "core-single-file", [:specfile] => ["setup"] do |t,args|
+  task "core-single-file", [:specfile] => ["setup"] do |t, args|
     exit(RSpec::Core::Runner.run([Rake::FileList[args.specfile]]))
   end
 
diff --git a/rakelib/vendor.rake b/rakelib/vendor.rake
index f5ea8eb903c..b5cac5a353c 100644
--- a/rakelib/vendor.rake
+++ b/rakelib/vendor.rake
@@ -1,6 +1,6 @@
 namespace "vendor" do
   VERSIONS = {
-    "jruby" => { "version" => "1.7.22", "sha1" => "6b9e310a04ad8173d0d6dbe299da04c0ef85fc15" },
+    "jruby" => { "version" => "1.7.25", "sha1" => "cd15aef419f97cff274491e53fcfb8b88ec36785" },
   }
 
   def vendor(*args)
diff --git a/rakelib/z_rubycheck.rake b/rakelib/z_rubycheck.rake
index ed22ed016c7..bf077b8700b 100644
--- a/rakelib/z_rubycheck.rake
+++ b/rakelib/z_rubycheck.rake
@@ -32,7 +32,7 @@ if ENV['USE_RUBY'] != '1'
     # if required at this point system gems can be installed using the system_gem task, for example:
     # Rake::Task["vendor:system_gem"].invoke(jruby, "ffi", "1.9.6")
 
-    exec(jruby, "-S", rake, *ARGV)
+    exec(jruby, "-J-Xmx1g", "-S", rake, *ARGV)
   end
 end
 
diff --git a/require-analyze.rb b/require-analyze.rb
deleted file mode 100644
index f69d858aa45..00000000000
--- a/require-analyze.rb
+++ /dev/null
@@ -1,22 +0,0 @@
-require "csv"
-
-#0.003,psych/nodes/mapping,/Users/jls/.rvm/rubies/jruby-1.7.8/lib/ruby/shared/psych/nodes.rb:6:in `(root)'
-
-durations = {}
-durations.default = 0
-
-CSV.foreach(ARGV[0]) do |duration, path, source|
-  source, line, where = source.split(":")
-  #{"0.002"=>"/Users/jls/projects/logstash/vendor/bundle/jruby/1.9/gems/clamp-0.6.3/lib/clamp.rb"}
-  if source.include?("jruby/1.9/gems")
-    # Get the gem name
-    source = source.gsub(/.*\/jruby\/1.9\/gems/, "")[/[^\/]+/]
-  elsif source.include?("/lib/logstash/")
-    source = source.gsub(/^.*(\/lib\/logstash\/)/, "/lib/logstash/")
-  end
-  durations[source] += duration.to_f
-end
-
-durations.sort_by { |k,v| v }.each do |k,v| 
-  puts "#{v} #{k}"
-end
diff --git a/spec/lib/logstash/bundler_spec.rb b/spec/bootstrap/bundler_spec.rb
similarity index 100%
rename from spec/lib/logstash/bundler_spec.rb
rename to spec/bootstrap/bundler_spec.rb
diff --git a/spec/core/pipeline_spec.rb b/spec/core/pipeline_spec.rb
deleted file mode 100644
index d0021d4a396..00000000000
--- a/spec/core/pipeline_spec.rb
+++ /dev/null
@@ -1,196 +0,0 @@
-# encoding: utf-8
-require "spec_helper"
-
-class DummyInput < LogStash::Inputs::Base
-  config_name "dummyinput"
-  milestone 2
-
-  def register
-  end
-
-  def run(queue)
-  end
-
-  def close
-  end
-end
-
-class DummyCodec < LogStash::Codecs::Base
-  config_name "dummycodec"
-  milestone 2
-
-  def decode(data)
-    data
-  end
-
-  def encode(event)
-    event
-  end
-
-  def close
-  end
-end
-
-class DummyOutput < LogStash::Outputs::Base
-  config_name "dummyoutput"
-  milestone 2
-
-  attr_reader :num_closes
-
-  def initialize(params={})
-    super
-    @num_closes = 0
-  end
-
-  def register
-  end
-
-  def receive(event)
-  end
-
-  def close
-    @num_closes += 1
-  end
-end
-
-class TestPipeline < LogStash::Pipeline
-  attr_reader :outputs
-end
-
-describe LogStash::Pipeline do
-
-context "close" do
-
-  before(:each) do
-    allow(LogStash::Plugin).to receive(:lookup).with("input", "dummyinput").and_return(DummyInput)
-    allow(LogStash::Plugin).to receive(:lookup).with("codec", "plain").and_return(DummyCodec)
-    allow(LogStash::Plugin).to receive(:lookup).with("output", "dummyoutput").and_return(DummyOutput)
-  end
-
-    let(:test_config_without_output_workers) {
-      <<-eos
-      input {
-        dummyinput {}
-      }
-
-      output {
-        dummyoutput {}
-      }
-      eos
-    }
-
-    let(:test_config_with_output_workers) {
-      <<-eos
-      input {
-        dummyinput {}
-      }
-
-      output {
-        dummyoutput {
-          workers => 2
-        }
-      }
-      eos
-    }
-
-    context "output close" do
-      it "should call close of output without output-workers" do
-        pipeline = TestPipeline.new(test_config_without_output_workers)
-        pipeline.run
-
-        expect(pipeline.outputs.size ).to eq(1)
-        expect(pipeline.outputs.first.worker_plugins.size ).to eq(1)
-        expect(pipeline.outputs.first.worker_plugins.first.num_closes ).to eq(1)
-      end
-
-      it "should call output close correctly with output workers" do
-        pipeline = TestPipeline.new(test_config_with_output_workers)
-        pipeline.run
-
-        expect(pipeline.outputs.size ).to eq(1)
-        expect(pipeline.outputs.first.num_closes).to eq(0)
-        pipeline.outputs.first.worker_plugins.each do |plugin|
-          expect(plugin.num_closes ).to eq(1)
-        end
-      end
-    end
-  end
-
-  context "compiled flush function" do
-
-    context "cancelled events should not propagate down the filters" do
-      config <<-CONFIG
-        filter {
-          multiline {
-           pattern => "hello"
-           what => next
-          }
-          multiline {
-           pattern => "hello"
-           what => next
-          }
-        }
-      CONFIG
-
-      sample("hello") do
-        expect(subject["message"]).to eq("hello")
-      end
-    end
-
-    context "new events should propagate down the filters" do
-      config <<-CONFIG
-        filter {
-          clone {
-            clones => ["clone1"]
-          }
-          multiline {
-            pattern => "bar"
-            what => previous
-          }
-        }
-      CONFIG
-
-      sample(["foo", "bar"]) do
-        expect(subject.size).to eq(2)
-
-        expect(subject[0]["message"]).to eq("foo\nbar")
-        expect(subject[0]["type"]).to be_nil
-        expect(subject[1]["message"]).to eq("foo\nbar")
-        expect(subject[1]["type"]).to eq("clone1")
-      end
-    end
-  end
-
-  context "compiled filter funtions" do
-
-    context "new events should propagate down the filters" do
-      config <<-CONFIG
-        filter {
-          clone {
-            clones => ["clone1", "clone2"]
-          }
-          mutate {
-            add_field => {"foo" => "bar"}
-          }
-        }
-      CONFIG
-
-      sample("hello") do
-        expect(subject.size).to eq(3)
-
-        expect(subject[0]["message"]).to eq("hello")
-        expect(subject[0]["type"]).to be_nil
-        expect(subject[0]["foo"]).to eq("bar")
-
-        expect(subject[1]["message"]).to eq("hello")
-        expect(subject[1]["type"]).to eq("clone1")
-        expect(subject[1]["foo"]).to eq("bar")
-
-        expect(subject[2]["message"]).to eq("hello")
-        expect(subject[2]["type"]).to eq("clone2")
-        expect(subject[2]["foo"]).to eq("bar")
-      end
-    end
-
-  end
-end
diff --git a/spec/core/runner_spec.rb b/spec/core/runner_spec.rb
deleted file mode 100644
index b61cab7bf30..00000000000
--- a/spec/core/runner_spec.rb
+++ /dev/null
@@ -1,40 +0,0 @@
-# encoding: utf-8
-require "spec_helper"
-require "logstash/runner"
-require "stud/task"
-
-class NullRunner
-  def run(args); end
-end
-
-describe LogStash::Runner do
-
-  context "argument parsing" do
-    it "should run agent" do
-      expect(Stud::Task).to receive(:new).once.and_return(nil)
-      args = ["agent", "-e", ""]
-      expect(subject.run(args)).to eq(nil)
-    end
-
-    it "should run agent help" do
-      expect(subject).to receive(:show_help).once.and_return(nil)
-      args = ["agent", "-h"]
-      expect(subject.run(args).wait).to eq(0)
-    end
-
-    it "should show help with no arguments" do
-      expect($stderr).to receive(:puts).once.and_return("No command given")
-      expect($stderr).to receive(:puts).once
-      args = []
-      expect(subject.run(args).wait).to eq(1)
-    end
-
-    it "should show help for unknown commands" do
-      expect($stderr).to receive(:puts).once.and_return("No such command welp")
-      expect($stderr).to receive(:puts).once
-      args = ["welp"]
-      expect(subject.run(args).wait).to eq(1)
-    end
-
-  end
-end
diff --git a/spec/core/timestamp_spec.rb b/spec/core/timestamp_spec.rb
deleted file mode 100644
index 17f403ca009..00000000000
--- a/spec/core/timestamp_spec.rb
+++ /dev/null
@@ -1,84 +0,0 @@
-# encoding: utf-8
-require "spec_helper"
-require "logstash/timestamp"
-
-describe LogStash::Timestamp do
-
-  it "should parse its own iso8601 output" do
-    t = Time.now
-    ts = LogStash::Timestamp.new(t)
-    expect(LogStash::Timestamp.parse_iso8601(ts.to_iso8601).to_i).to eq(t.to_i)
-  end
-
-  it "should coerce iso8601 string" do
-    t = Time.now
-    ts = LogStash::Timestamp.new(t)
-    expect(LogStash::Timestamp.coerce(ts.to_iso8601).to_i).to eq(t.to_i)
-  end
-
-  it "should coerce Time" do
-    t = Time.now
-    expect(LogStash::Timestamp.coerce(t).to_i).to eq(t.to_i)
-  end
-
-  it "should coerce Timestamp" do
-    t = LogStash::Timestamp.now
-    expect(LogStash::Timestamp.coerce(t).to_i).to eq(t.to_i)
-  end
-
-  it "should raise on invalid string coerce" do
-    expect{LogStash::Timestamp.coerce("foobar")}.to raise_error LogStash::TimestampParserError
-  end
-
-  it "should return nil on invalid object coerce" do
-    expect(LogStash::Timestamp.coerce(:foobar)).to be_nil
-  end
-
-  it "should support to_json" do
-    expect(LogStash::Timestamp.parse_iso8601("2014-09-23T00:00:00-0800").to_json).to eq("\"2014-09-23T08:00:00.000Z\"")
-  end
-
-  it "should support to_json and ignore arguments" do
-    expect(LogStash::Timestamp.parse_iso8601("2014-09-23T00:00:00-0800").to_json(:some => 1, :argumnents => "test")).to eq("\"2014-09-23T08:00:00.000Z\"")
-  end
-
-  it "should support timestamp comparaison" do
-   current = LogStash::Timestamp.new(Time.now) 
-   future = LogStash::Timestamp.new(Time.now + 100)
-
-   expect(future > current).to eq(true)
-   expect(future < current).to eq(false)
-   expect(current == current).to eq(true)
-
-   expect(current <=> current).to eq(0)
-   expect(current <=> future).to eq(-1)
-   expect(future <=> current).to eq(1)
-  end
-
-  it "should allow unary operation +" do
-    current = Time.now
-    t = LogStash::Timestamp.new(current) + 10
-    expect(t).to eq(current + 10)
-  end
-
-  describe "subtraction" do
-    it "should work on a timestamp object" do
-      t = Time.now
-      current = LogStash::Timestamp.new(t)
-      future = LogStash::Timestamp.new(t + 10)
-      expect(future - current).to eq(10)
-    end
-
-    it "should work on with time object" do
-      current = Time.now
-      t = LogStash::Timestamp.new(current + 10)
-      expect(t - current).to eq(10)
-    end
-
-    it "should work with numeric value" do
-      current = Time.now
-      t = LogStash::Timestamp.new(current + 10)
-      expect(t - 10).to eq(current)
-    end
-  end
-end
diff --git a/spec/coverage_helper.rb b/spec/coverage_helper.rb
index 6ecb2f570eb..009f7fb5419 100644
--- a/spec/coverage_helper.rb
+++ b/spec/coverage_helper.rb
@@ -5,20 +5,19 @@ module CoverageHelper
 
   ##
   # Skip list used to avoid loading certain patterns within
-  # the logstash directories, this patterns are excluded becuause
+  # the logstash directories, this patterns are excluded because
   # of potential problems or because they are going to be loaded
   # in another way.
   ##
   SKIP_LIST = Regexp.union([
     /^lib\/bootstrap\/rspec.rb$/,
-    /^lib\/logstash\/util\/prctl.rb$/
+    /^logstash-core\/lib\/logstash\/util\/prctl.rb$/
   ])
 
   def self.eager_load
-    Dir.glob("lib/**/*.rb") do |file|
+    Dir.glob("{logstash-core{/,-event/},}lib/**/*.rb") do |file|
       next if file =~ SKIP_LIST
       require file
     end
   end
-
 end
diff --git a/spec/license_spec.rb b/spec/license_spec.rb
index 6a0ec7ba4b0..f37f29d0431 100644
--- a/spec/license_spec.rb
+++ b/spec/license_spec.rb
@@ -12,6 +12,7 @@
     Regexp.union([ /mit/,
                    /apache*/,
                    /bsd/,
+                   /artistic 2.*/,
                    /ruby/,
                    /lgpl/])
   }
diff --git a/spec/logstash/agent_spec.rb b/spec/logstash/agent_spec.rb
deleted file mode 100644
index 54f994d88f4..00000000000
--- a/spec/logstash/agent_spec.rb
+++ /dev/null
@@ -1,62 +0,0 @@
-# encoding: utf-8
-require 'spec_helper'
-
-describe LogStash::Agent do
-  subject { LogStash::Agent.new('') }
-  let(:dummy_config) { 'input {}' }
-
-  context "when loading the configuration" do
-    context "when local" do
-      before { expect(subject).to receive(:local_config).with(path) }
-
-      context "unix" do
-        let(:path) { './test.conf' }
-        it 'works with relative path' do
-          subject.load_config(path)
-        end
-      end
-
-      context "windows" do
-        let(:path) { '.\test.conf' }
-        it 'work with relative windows path' do
-          subject.load_config(path)
-        end
-      end
-    end
-
-    context "when remote" do
-      context 'supported scheme' do
-        let(:path) { "http://test.local/superconfig.conf" }
-
-        before { expect(Net::HTTP).to receive(:get) { dummy_config } }
-        it 'works with http' do
-          expect(subject.load_config(path)).to eq("#{dummy_config}\n")
-        end
-      end
-    end
-  end
-
-  context "--pluginpath" do
-    let(:single_path) { "/some/path" }
-    let(:multiple_paths) { ["/some/path1", "/some/path2"] }
-
-    it "should add single valid dir path to the environment" do
-      expect(File).to receive(:directory?).and_return(true)
-      expect(LogStash::Environment).to receive(:add_plugin_path).with(single_path)
-      subject.configure_plugin_paths(single_path)
-    end
-
-    it "should fail with single invalid dir path" do
-      expect(File).to receive(:directory?).and_return(false)
-      expect(LogStash::Environment).not_to receive(:add_plugin_path)
-      expect{subject.configure_plugin_paths(single_path)}.to raise_error(LogStash::ConfigurationError)
-    end
-
-    it "should add multiple valid dir path to the environment" do
-      expect(File).to receive(:directory?).exactly(multiple_paths.size).times.and_return(true)
-      multiple_paths.each{|path| expect(LogStash::Environment).to receive(:add_plugin_path).with(path)}
-      subject.configure_plugin_paths(multiple_paths)
-    end
-  end
-end
-
diff --git a/spec/outputs/base_spec.rb b/spec/outputs/base_spec.rb
deleted file mode 100644
index 841ba424df9..00000000000
--- a/spec/outputs/base_spec.rb
+++ /dev/null
@@ -1,26 +0,0 @@
-# encoding: utf-8
-require "spec_helper"
-
-# use a dummy NOOP output to test Outputs::Base
-class LogStash::Outputs::NOOP < LogStash::Outputs::Base
-  config_name "noop"
-  milestone 2
-
-  config :dummy_option, :validate => :string
-
-  def register; end
-
-  def receive(event)
-    return output?(event)
-  end
-end
-
-describe "LogStash::Outputs::Base#worker_setup" do
-  it "should create workers using original parameters except workers = 1" do
-    params = { "dummy_option" => "potatoes", "codec" => "json", "workers" => 2 }
-    worker_params = params.dup; worker_params["workers"] = 1
-    output = LogStash::Outputs::NOOP.new(params.dup)
-    expect(LogStash::Outputs::NOOP).to receive(:new).twice.with(worker_params).and_call_original
-    output.worker_setup
-  end
-end
diff --git a/spec/plugin_manager/install_spec.rb b/spec/plugin_manager/install_spec.rb
new file mode 100644
index 00000000000..40eb3dfe408
--- /dev/null
+++ b/spec/plugin_manager/install_spec.rb
@@ -0,0 +1,28 @@
+# encoding: utf-8
+require 'spec_helper'
+require 'pluginmanager/main'
+
+describe LogStash::PluginManager::Install do
+  let(:cmd) { LogStash::PluginManager::Install.new("install") }
+
+  before(:each) do
+    expect(cmd).to receive(:validate_cli_options!).and_return(nil)
+  end
+
+  context "when validating plugins" do
+    let(:sources) { ["https://rubygems.org", "http://localhost:9292"] }
+
+    before(:each) do
+      expect(cmd).to receive(:plugins_gems).and_return([["dummy", nil]])
+      expect(cmd).to receive(:install_gems_list!).and_return(nil)
+      expect(cmd).to receive(:remove_unused_locally_installed_gems!).and_return(nil)
+      cmd.verify = true
+    end
+
+    it "should load all the sources defined in the Gemfile" do
+      expect(cmd.gemfile.gemset).to receive(:sources).and_return(sources)
+      expect(LogStash::PluginManager).to receive(:logstash_plugin?).with("dummy", nil, {:rubygems_source => sources}).and_return(true)
+      cmd.execute
+    end
+  end
+end
diff --git a/spec/plugin_manager/update_spec.rb b/spec/plugin_manager/update_spec.rb
new file mode 100644
index 00000000000..5498f9dea0c
--- /dev/null
+++ b/spec/plugin_manager/update_spec.rb
@@ -0,0 +1,39 @@
+# encoding: utf-8
+require 'spec_helper'
+require 'pluginmanager/main'
+
+describe LogStash::PluginManager::Update do
+  let(:cmd)     { LogStash::PluginManager::Update.new("update") }
+  let(:sources) { cmd.gemfile.gemset.sources }
+
+  before(:each) do
+    expect(cmd).to receive(:find_latest_gem_specs).and_return({})
+    allow(cmd).to receive(:warn_local_gems).and_return(nil)
+    expect(cmd).to receive(:display_updated_plugins).and_return(nil)
+    expect_any_instance_of(LogStash::Bundler).to receive(:invoke!).with(:clean => true)
+  end
+
+  it "pass all gem sources to the bundle update command" do
+    sources = cmd.gemfile.gemset.sources
+    expect_any_instance_of(LogStash::Bundler).to receive(:invoke!).with(:update => [], :rubygems_source => sources)
+    cmd.execute
+  end
+
+  context "when skipping validation" do
+    let(:cmd)    { LogStash::PluginManager::Update.new("update") }
+    let(:plugin) { OpenStruct.new(:name => "dummy", :options => {} ) }
+
+    before(:each) do
+      expect(cmd.gemfile).to receive(:find).with(plugin).and_return(plugin)
+      expect(cmd.gemfile).to receive(:save).and_return(nil)
+      expect(cmd).to receive(:plugins_to_update).and_return([plugin])
+      expect_any_instance_of(LogStash::Bundler).to receive(:invoke!).with(:update => [plugin], :rubygems_source => sources).and_return(nil)
+    end
+
+    it "skips version verification when ask for it" do
+      cmd.verify = false
+      expect(cmd).to_not receive(:validates_version)
+      cmd.execute
+    end
+  end
+end
diff --git a/spec/plugin_manager/util_spec.rb b/spec/plugin_manager/util_spec.rb
new file mode 100644
index 00000000000..10824e56adc
--- /dev/null
+++ b/spec/plugin_manager/util_spec.rb
@@ -0,0 +1,71 @@
+#encoding: utf-8
+require 'spec_helper'
+require 'pluginmanager/util'
+require 'gems'
+
+describe LogStash::PluginManager do
+
+  describe "fetching plugin information" do
+    let(:plugin_name) { "logstash-output-elasticsearch" }
+
+    let(:version_data) do
+      [ { "authors"=>"Elastic", "built_at"=>"2015-08-11T00:00:00.000Z", "description"=>"Output events to elasticsearch",
+          "downloads_count"=>1638, "metadata"=>{"logstash_group"=>"output", "logstash_plugin"=>"true"}, "number"=>"2.0.0.pre",
+          "summary"=>"Logstash Output to Elasticsearch", "platform"=>"java", "ruby_version"=>">= 0", "prerelease"=>true,
+          "licenses"=>["apache-2.0"], "requirements"=>[], "sha"=>"194b27099c13605a882a3669e2363fdecccaab1de48dd44b0cda648dd5516799"},
+      { "authors"=>"Elastic", "built_at"=>"2015-08-10T00:00:00.000Z", "description"=>"Output events to elasticsearch",
+        "downloads_count"=>1638, "metadata"=>{"logstash_group"=>"output", "logstash_plugin"=>"true"}, "number"=>"1.0.7",
+        "summary"=>"Logstash Output to Elasticsearch", "platform"=>"java", "ruby_version"=>">= 0", "prerelease"=>false,
+        "licenses"=>["apache-2.0"], "requirements"=>[], "sha"=>"194b27099c13605a882a3669e2363fdecccaab1de48dd44b0cda648dd5516799"},
+      { "authors"=>"Elastic", "built_at"=>"2015-08-09T00:00:00.000Z", "description"=>"Output events to elasticsearch",
+        "downloads_count"=>1638, "metadata"=>{"logstash_group"=>"output", "logstash_plugin"=>"true"}, "number"=>"1.0.4",
+        "summary"=>"Logstash Output to Elasticsearch", "platform"=>"java", "ruby_version"=>">= 0", "prerelease"=>false,
+        "licenses"=>["apache-2.0"], "requirements"=>[], "sha"=>"194b27099c13605a882a3669e2363fdecccaab1de48dd44b0cda648dd5516799"} ]
+    end
+
+    before(:each) do
+      allow(Gems).to receive(:versions).with(plugin_name).and_return(version_data)
+    end
+
+    context "fetch plugin info" do
+      it "should search for the last version infomation non prerelease" do
+        version_info = LogStash::PluginManager.fetch_latest_version_info(plugin_name)
+        expect(version_info["number"]).to eq("1.0.7")
+      end
+
+
+      it "should search for the last version infomation with prerelease" do
+        version_info = LogStash::PluginManager.fetch_latest_version_info(plugin_name, :pre => true)
+        expect(version_info["number"]).to eq("2.0.0.pre")
+      end
+    end
+  end
+
+  describe "a logstash_plugin validation" do
+    let(:plugin)  { "foo" }
+    let(:version) { "9.0.0.0" }
+
+    let(:sources) { ["http://source.01", "http://source.02"] }
+    let(:options) { {:rubygems_source => sources} }
+
+    let(:gemset)  { double("gemset") }
+    let(:gemfile) { double("gemfile") }
+    let(:dep)     { double("dep") }
+    let(:fetcher) { double("fetcher") }
+
+    before(:each) do
+      allow(gemfile).to  receive(:gemset).and_return(gemset)
+      allow(gemset).to   receive(:sources).and_return(sources)
+      expect(fetcher).to receive(:spec_for_dependency).and_return([[],[]])
+    end
+
+    it "should load all available sources" do
+      expect(subject).to receive(:plugin_file?).and_return(false)
+      expect(Gem::Dependency).to receive(:new).and_return(dep)
+      expect(Gem::SpecFetcher).to receive(:fetcher).and_return(fetcher)
+
+      subject.logstash_plugin?(plugin, version, options)
+      expect(Gem.sources.map { |source| source }).to eq(sources)
+    end
+  end
+end
diff --git a/spec/util/gemfile_spec.rb b/spec/pluginmanager/gemfile_spec.rb
similarity index 100%
rename from spec/util/gemfile_spec.rb
rename to spec/pluginmanager/gemfile_spec.rb
diff --git a/spec/pluginmanager/util_spec.rb b/spec/pluginmanager/util_spec.rb
deleted file mode 100644
index 6a14beeb950..00000000000
--- a/spec/pluginmanager/util_spec.rb
+++ /dev/null
@@ -1,42 +0,0 @@
-# encoding: utf-8
-require "spec_helper"
-require "pluginmanager/util"
-require "gems"
-
-describe LogStash::PluginManager do
-
-  let(:plugin_name) { "logstash-output-elasticsearch" }
-
-  let(:version_data) do
-    [ { "authors"=>"Elastic", "built_at"=>"2015-08-11T00:00:00.000Z", "description"=>"Output events to elasticsearch",
-        "downloads_count"=>1638, "metadata"=>{"logstash_group"=>"output", "logstash_plugin"=>"true"}, "number"=>"2.0.0.pre",
-        "summary"=>"Logstash Output to Elasticsearch", "platform"=>"java", "ruby_version"=>">= 0", "prerelease"=>true,
-        "licenses"=>["apache-2.0"], "requirements"=>[], "sha"=>"194b27099c13605a882a3669e2363fdecccaab1de48dd44b0cda648dd5516799"},
-    { "authors"=>"Elastic", "built_at"=>"2015-08-10T00:00:00.000Z", "description"=>"Output events to elasticsearch",
-      "downloads_count"=>1638, "metadata"=>{"logstash_group"=>"output", "logstash_plugin"=>"true"}, "number"=>"1.0.7",
-      "summary"=>"Logstash Output to Elasticsearch", "platform"=>"java", "ruby_version"=>">= 0", "prerelease"=>false,
-      "licenses"=>["apache-2.0"], "requirements"=>[], "sha"=>"194b27099c13605a882a3669e2363fdecccaab1de48dd44b0cda648dd5516799"},
-    { "authors"=>"Elastic", "built_at"=>"2015-08-09T00:00:00.000Z", "description"=>"Output events to elasticsearch",
-      "downloads_count"=>1638, "metadata"=>{"logstash_group"=>"output", "logstash_plugin"=>"true"}, "number"=>"1.0.4",
-      "summary"=>"Logstash Output to Elasticsearch", "platform"=>"java", "ruby_version"=>">= 0", "prerelease"=>false,
-      "licenses"=>["apache-2.0"], "requirements"=>[], "sha"=>"194b27099c13605a882a3669e2363fdecccaab1de48dd44b0cda648dd5516799"} ]
-  end
-
-  before(:each) do
-    allow(Gems).to receive(:versions).with(plugin_name).and_return(version_data)
-  end
-
-  context "fetch plugin info" do
-
-    it "should search for the last version infomation non prerelease" do
-      version_info = LogStash::PluginManager.fetch_latest_version_info(plugin_name)
-      expect(version_info["number"]).to eq("1.0.7")
-    end
-
-
-    it "should search for the last version infomation with prerelease" do
-      version_info = LogStash::PluginManager.fetch_latest_version_info(plugin_name, :pre => true)
-      expect(version_info["number"]).to eq("2.0.0.pre")
-    end
-  end
-end
diff --git a/spec/spec_helper.rb b/spec/spec_helper.rb
index 5428fd8fd90..5d9cce28a0e 100644
--- a/spec/spec_helper.rb
+++ b/spec/spec_helper.rb
@@ -5,7 +5,38 @@
 CoverageHelper.eager_load if ENV['COVERAGE']
 
 require "logstash/devutils/rspec/spec_helper"
+require "logstash/logging/json"
+
+class JSONIOThingy < IO
+  def initialize; end
+  def flush; end
+
+  def puts(payload)
+    # Ensure that all log payloads are valid json.
+    LogStash::Json.load(payload)
+  end
+end
+
+RSpec.configure do |c|
+  c.before do
+    # Force Cabin to always have a JSON subscriber.  The main purpose of this
+    # is to catch crashes in json serialization for our logs. JSONIOThingy
+    # exists to validate taht what LogStash::Logging::JSON emits is always
+    # valid JSON.
+    jsonvalidator = JSONIOThingy.new
+    allow(Cabin::Channel).to receive(:new).and_wrap_original do |m, *args|
+      logger = m.call(*args)
+      logger.level = :debug
+      logger.subscribe(LogStash::Logging::JSON.new(jsonvalidator))
+
+      logger
+    end
+  end
+
+end
 
 def installed_plugins
   Gem::Specification.find_all.select { |spec| spec.metadata["logstash_plugin"] }.map { |plugin| plugin.name }
 end
+
+
diff --git a/spec/util/compress_spec.rb b/spec/util/compress_spec.rb
new file mode 100644
index 00000000000..47bab9e995a
--- /dev/null
+++ b/spec/util/compress_spec.rb
@@ -0,0 +1,121 @@
+# encoding: utf-8
+require "spec_helper"
+require 'ostruct'
+require "bootstrap/util/compress"
+
+describe LogStash::Util::Zip do
+
+  subject { Class.new { extend LogStash::Util::Zip } }
+
+  context "#extraction" do
+
+    let(:source) { File.join(File.expand_path("."), "source_file.zip") }
+    let(:target) { File.expand_path("target_dir") }
+
+    it "raise an exception if the target dir exist" do
+      allow(File).to receive(:exist?).with(target).and_return(true)
+      expect { subject.extract(source, target) }.to raise_error
+    end
+
+    let(:zip_file) do
+      [ "foo", "bar", "zoo" ].inject([]) do |acc, name|
+        acc << OpenStruct.new(:name => name)
+        acc
+      end
+    end
+
+    it "extract the list of entries from a zip file" do
+      allow(Zip::File).to receive(:open).with(source).and_yield(zip_file)
+      expect(FileUtils).to receive(:mkdir_p).exactly(3).times
+      expect(zip_file).to receive(:extract).exactly(3).times
+      subject.extract(source, target)
+    end
+  end
+
+  context "#compression" do
+
+    let(:target) { File.join(File.expand_path("."), "target_file.zip") }
+    let(:source) { File.expand_path("source_dir") }
+
+    it "raise an exception if the target file exist" do
+      allow(File).to receive(:exist?).with(target).and_return(true)
+      expect { subject.compress(source, target) }.to raise_error
+    end
+
+    let(:dir_files) do
+      [ "foo", "bar", "zoo" ]
+    end
+
+    let(:zip_file) { Class.new }
+
+    it "add a dir to a zip file" do
+      allow(Zip::File).to receive(:open).with(target, ::Zip::File::CREATE).and_yield(zip_file)
+      allow(Dir).to receive(:glob).and_return(dir_files)
+      expect(zip_file).to receive(:add).exactly(3).times
+      subject.compress(source, target)
+    end
+  end
+end
+
+describe LogStash::Util::Tar do
+
+  subject { Class.new { extend LogStash::Util::Tar } }
+
+  context "#extraction" do
+
+    let(:source) { File.join(File.expand_path("."), "source_file.tar.gz") }
+    let(:target) { File.expand_path("target_dir") }
+
+    it "raise an exception if the target dir exist" do
+      allow(File).to receive(:exist?).with(target).and_return(true)
+      expect { subject.extract(source, target) }.to raise_error
+    end
+
+    let(:gzip_file) { Class.new }
+
+    let(:tar_file) do
+      [ "foo", "bar", "zoo" ].inject([]) do |acc, name|
+        acc << OpenStruct.new(:full_name => name)
+        acc
+      end
+    end
+
+    it "extract the list of entries from a tar.gz file" do
+      allow(Zlib::GzipReader).to receive(:open).with(source).and_yield(gzip_file)
+      allow(Gem::Package::TarReader).to receive(:new).with(gzip_file).and_yield(tar_file)
+
+      expect(FileUtils).to receive(:mkdir).with(target)
+      expect(File).to receive(:open).exactly(3).times
+      subject.extract(source, target)
+    end
+  end
+
+  context "#compression" do
+
+    let(:target) { File.join(File.expand_path("."), "target_file.tar.gz") }
+    let(:source) { File.expand_path("source_dir") }
+
+    it "raise an exception if the target file exist" do
+      allow(File).to receive(:exist?).with(target).and_return(true)
+      expect { subject.compress(source, target) }.to raise_error
+    end
+
+    let(:dir_files) do
+      [ "foo", "bar", "zoo" ]
+    end
+
+    let(:tar_file) { Class.new }
+    let(:tar)      { Class.new }
+
+    it "add a dir to a tgz file" do
+      allow(Stud::Temporary).to receive(:file).and_yield(tar_file)
+      allow(Gem::Package::TarWriter).to receive(:new).with(tar_file).and_yield(tar)
+      allow(Dir).to receive(:glob).and_return(dir_files)
+      expect(File).to receive(:stat).exactly(3).times.and_return(OpenStruct.new(:mode => "rw"))
+      expect(tar).to receive(:add_file).exactly(3).times
+      expect(tar_file).to receive(:rewind)
+      expect(subject).to receive(:gzip).with(target, tar_file)
+      subject.compress(source, target)
+    end
+  end
+end
diff --git a/spec/util/worker_threads_default_printer_spec.rb b/spec/util/worker_threads_default_printer_spec.rb
deleted file mode 100644
index 348b9d263e1..00000000000
--- a/spec/util/worker_threads_default_printer_spec.rb
+++ /dev/null
@@ -1,26 +0,0 @@
-# encoding: utf-8
-require "spec_helper"
-require "logstash/util/worker_threads_default_printer"
-
-describe LogStash::Util::WorkerThreadsDefaultPrinter do
-  let(:settings) { {} }
-  let(:collector) { [] }
-
-  subject { described_class.new(settings) }
-
-  context 'when the settings hash is empty' do
-    it 'the #visit method returns a string with 1 filter worker' do
-      subject.visit(collector)
-      expect(collector.first).to eq("Filter workers: 1")
-    end
-  end
-
-  context 'when the settings hash has content' do
-    let(:settings) { {'filter-workers' => 42} }
-
-    it 'the #visit method returns a string with 42 filter workers' do
-      subject.visit(collector)
-      expect(collector.first).to eq("Filter workers: 42")
-    end
-  end
-end
