diff --git a/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java b/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
index 4222a0c80fb..e84a976b56b 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
@@ -38,6 +38,11 @@ public final class CompiledPipeline {
 
     private static final Logger LOGGER = LogManager.getLogger(CompiledPipeline.class);
 
+    /**
+     * Compiler for conditional expressions that turn {@link IfVertex} into {@link EventCondition}.
+     */
+    private final EventCondition.Compiler conditionalCompiler = new EventCondition.Compiler();
+
     /**
      * Configured inputs.
      */
@@ -342,7 +347,7 @@ private Collection<Dataset> compileDependencies(final Vertex start,
                         final IfVertex ifvert = (IfVertex) dependency;
                         final SplitDataset ifDataset = split(
                             datasets,
-                            EventCondition.Compiler.buildCondition(ifvert.getBooleanExpression()),
+                            conditionalCompiler.buildCondition(ifvert.getBooleanExpression()),
                             dependency
                         );
                         // It is important that we double check that we are actually dealing with the
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/EventCondition.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/EventCondition.java
index 76773932462..b45018e37d1 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/EventCondition.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/EventCondition.java
@@ -50,7 +50,7 @@ public interface EventCondition {
      * <h3>EventCondition Compiler.</h3>
      * Compiles {@link BooleanExpression} into {@link EventCondition} globally ensuring that no
      * duplicate {@link EventCondition} are generated by strict synchronization on the internal
-     * compiler cache {@link EventCondition.Compiler#CACHE}.
+     * compiler cache {@link EventCondition.Compiler#cache}.
      */
     final class Compiler {
 
@@ -67,24 +67,24 @@ final class Compiler {
         /**
          * Cache of all compiled {@link EventCondition}.
          */
-        private static final Map<String, EventCondition> CACHE = new HashMap<>(10);
+        private final Map<String, EventCondition> cache = new HashMap<>(10);
 
-        private Compiler() {
+        public Compiler() {
             //Utility Class.
         }
 
         /**
          * Compiles a {@link BooleanExpression} into an {@link EventCondition}.
-         * All compilation is globally {@code synchronized} on {@link EventCondition.Compiler#CACHE}
+         * All compilation is globally {@code synchronized} on {@link EventCondition.Compiler#cache}
          * to minimize code size by avoiding compiling logically equivalent expressions in more than
          * one instance.
          * @param expression BooleanExpress to compile
          * @return Compiled {@link EventCondition}
          */
-        public static EventCondition buildCondition(final BooleanExpression expression) {
-            synchronized (CACHE) {
+        public EventCondition buildCondition(final BooleanExpression expression) {
+            synchronized (cache) {
                 final String cachekey = expression.toRubyString();
-                final EventCondition cached = CACHE.get(cachekey);
+                final EventCondition cached = cache.get(cachekey);
                 if (cached != null) {
                     return cached;
                 }
@@ -116,11 +116,48 @@ public static EventCondition buildCondition(final BooleanExpression expression)
                 } else {
                     throw new EventCondition.Compiler.UnexpectedTypeException(expression);
                 }
-                CACHE.put(cachekey, condition);
+                cache.put(cachekey, condition);
                 return condition;
             }
         }
 
+        private EventCondition[] booleanPair(final BinaryBooleanExpression expression) {
+            final Expression left = expression.getLeft();
+            final Expression right = expression.getRight();
+            final EventCondition first;
+            final EventCondition second;
+            if (left instanceof BooleanExpression && right instanceof BooleanExpression) {
+                first = buildCondition((BooleanExpression) left);
+                second = buildCondition((BooleanExpression) right);
+            } else if (eAndE(expression)) {
+                first = truthy((EventValueExpression) left);
+                second = truthy((EventValueExpression) right);
+            } else if (left instanceof BooleanExpression && right instanceof EventValueExpression) {
+                first = buildCondition((BooleanExpression) left);
+                second = truthy((EventValueExpression) right);
+            } else if (right instanceof BooleanExpression &&
+                left instanceof EventValueExpression) {
+                first = truthy((EventValueExpression) left);
+                second = buildCondition((BooleanExpression) right);
+            } else {
+                throw new EventCondition.Compiler.UnexpectedTypeException(left, right);
+            }
+            return new EventCondition[]{first, second};
+        }
+
+        private EventCondition not(final Not not) {
+            final EventCondition condition;
+            final Expression inner = not.getExpression();
+            if (inner instanceof BooleanExpression) {
+                condition = not(buildCondition((BooleanExpression) inner));
+            } else if (inner instanceof EventValueExpression) {
+                condition = not(truthy((EventValueExpression) inner));
+            } else {
+                throw new EventCondition.Compiler.UnexpectedTypeException(inner);
+            }
+            return condition;
+        }
+
         /**
          * Checks if a {@link BinaryBooleanExpression} consists of a {@link ValueExpression} on the
          * left and a {@link EventValueExpression} on the right.
@@ -186,19 +223,6 @@ private static EventCondition regex(final RegexEq regex) {
             return condition;
         }
 
-        private static EventCondition not(final Not not) {
-            final EventCondition condition;
-            final Expression inner = not.getExpression();
-            if (inner instanceof BooleanExpression) {
-                condition = not(buildCondition((BooleanExpression) inner));
-            } else if (inner instanceof EventValueExpression) {
-                condition = not(truthy((EventValueExpression) inner));
-            } else {
-                throw new EventCondition.Compiler.UnexpectedTypeException(inner);
-            }
-            return condition;
-        }
-
         private static EventCondition gte(final Gte gte) {
             final EventCondition condition;
             final Expression uleft = gte.getLeft();
@@ -392,30 +416,6 @@ private static EventCondition truthy(final EventValueExpression evalE) {
             return new EventCondition.Compiler.FieldTruthy(FieldReference.from(evalE.getFieldName()));
         }
 
-        private static EventCondition[] booleanPair(final BinaryBooleanExpression expression) {
-            final Expression left = expression.getLeft();
-            final Expression right = expression.getRight();
-            final EventCondition first;
-            final EventCondition second;
-            if (left instanceof BooleanExpression && right instanceof BooleanExpression) {
-                first = buildCondition((BooleanExpression) left);
-                second = buildCondition((BooleanExpression) right);
-            } else if (eAndE(expression)) {
-                first = truthy((EventValueExpression) left);
-                second = truthy((EventValueExpression) right);
-            } else if (left instanceof BooleanExpression && right instanceof EventValueExpression) {
-                first = buildCondition((BooleanExpression) left);
-                second = truthy((EventValueExpression) right);
-            } else if (right instanceof BooleanExpression &&
-                left instanceof EventValueExpression) {
-                first = truthy((EventValueExpression) left);
-                second = buildCondition((BooleanExpression) right);
-            } else {
-                throw new EventCondition.Compiler.UnexpectedTypeException(left, right);
-            }
-            return new EventCondition[]{first, second};
-        }
-
         private static EventCondition not(final EventCondition condition) {
             return new EventCondition.Compiler.Negated(condition);
         }
