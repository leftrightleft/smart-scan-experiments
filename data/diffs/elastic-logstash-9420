diff --git a/logstash-core/build.gradle b/logstash-core/build.gradle
index e76ddd6dc0a..bf8032ec446 100644
--- a/logstash-core/build.gradle
+++ b/logstash-core/build.gradle
@@ -113,6 +113,7 @@ dependencies {
     compile 'org.apache.logging.log4j:log4j-api:2.9.1'
     compile 'org.apache.logging.log4j:log4j-core:2.9.1'
     runtime 'org.apache.logging.log4j:log4j-slf4j-impl:2.9.1'
+    compile 'org.apache.httpcomponents:httpclient:4.5.5'
     // Jackson version moved to versions.yml in the project root (the JrJackson version is there too)
     compile "com.fasterxml.jackson.core:jackson-core:${jacksonVersion}"
     compile "com.fasterxml.jackson.core:jackson-databind:${jacksonVersion}"
@@ -128,4 +129,5 @@ dependencies {
     testCompile 'net.javacrumbs.json-unit:json-unit:1.9.0'
     testCompile 'org.elasticsearch:securemock:1.2'
     testCompile 'org.assertj:assertj-core:3.8.0'
+    testCompile 'com.github.tomakehurst:wiremock-standalone:2.6.0'
 }
diff --git a/logstash-core/src/main/java/org/logstash/common/clients/HttpClient.java b/logstash-core/src/main/java/org/logstash/common/clients/HttpClient.java
new file mode 100644
index 00000000000..dd3ea031430
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/common/clients/HttpClient.java
@@ -0,0 +1,655 @@
+package org.logstash.common.clients;
+
+import java.io.*;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.security.*;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.security.interfaces.RSAPrivateKey;
+import java.security.spec.KeySpec;
+import java.security.spec.PKCS8EncodedKeySpec;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.*;
+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.message.BasicHeader;
+
+import javax.net.ssl.*;
+
+/**
+ * Easy-to-use HTTP client.
+ */
+public class HttpClient {
+    public enum Protocol { HTTP, HTTPS }
+
+    private final CloseableHttpClient httpClient;
+    private final URL baseUrl;
+
+    private HttpClient(CloseableHttpClient httpClient, URL baseUrl) {
+        this.httpClient = httpClient;
+        this.baseUrl = baseUrl;
+    }
+
+    /**
+     * Performs an HTTP HEAD request
+     *
+     * @param relativePath  Relative path to resource, e.g. api/status
+     * @throws RequestFailedException
+     */
+    public Response head(String relativePath) throws RequestFailedException {
+        return head(relativePath, null);
+    }
+
+    /**
+     * Performs an HTTP HEAD request
+     *
+     * @param relativePath  Relative path to resource, e.g. api/status
+     * @param headers       Headers to include with request
+     * @throws RequestFailedException
+     */
+    public Response head(String relativePath, Map<String, String> headers) throws RequestFailedException {
+        String url = makeUrlFrom(relativePath);
+        HttpHead request = new HttpHead(url);
+
+        if (headers != null) {
+            headers.forEach(request::addHeader);
+        }
+
+        try {
+            return new Response(httpClient.execute(request));
+        } catch (IOException e) {
+            throw new RequestFailedException("HEAD", url, e);
+        }
+    }
+
+    /**
+     * Performs an HTTP GET request
+     *
+     * @param relativePath  Relative path to resource, e.g. api/kibana/dashboards/export
+     * @return Response entity
+     * @throws RequestFailedException
+     */
+    public CloseableResponse get(String relativePath) throws RequestFailedException {
+        return get(relativePath, null);
+    }
+
+    /**
+     * Performs an HTTP GET request
+     *
+     * @param relativePath  Relative path to resource, e.g. api/kibana/dashboards/export
+     * @param headers       Headers to include with request
+     * @return Response entity
+     * @throws RequestFailedException
+     */
+    public CloseableResponse get(String relativePath, Map<String, String> headers) throws RequestFailedException {
+        String url = makeUrlFrom(relativePath);
+        HttpGet request = new HttpGet(url);
+
+        if (headers != null) {
+            headers.forEach(request::addHeader);
+        }
+
+        try {
+            return new CloseableResponse(httpClient.execute(request));
+        } catch (IOException e) {
+            throw new RequestFailedException("GET", url, e);
+        }
+    }
+
+    /**
+     * Performs an HTTP POST request
+     *
+     * @param relativePath  Relative path to resource, e.g. api/kibana/dashboards/import
+     * @param requestBody   Body of request
+     * @return Response entity
+     * @throws RequestFailedException
+     */
+    public CloseableResponse post(String relativePath, String requestBody) throws RequestFailedException {
+        return post(relativePath, requestBody, null);
+    }
+
+    /**
+     * Performs an HTTP POST request
+     *
+     * @param relativePath  Relative path to resource, e.g. api/kibana/dashboards/import
+     * @param requestBody   Body of request
+     * @param headers       Headers to include with request
+     * @return Response entity
+     * @throws RequestFailedException
+     */
+    public CloseableResponse post(String relativePath, String requestBody, Map<String, String> headers) throws RequestFailedException {
+
+        String url = makeUrlFrom(relativePath);
+
+        HttpPost request = new HttpPost(url);
+        try {
+            request.setEntity(new StringEntity(requestBody));
+        } catch (UnsupportedEncodingException e) {
+            throw new RequestFailedException("POST", url, e);
+        }
+
+        if (headers != null) {
+            headers.forEach(request::addHeader);
+        }
+
+        try {
+            return new CloseableResponse(httpClient.execute(request));
+        } catch (IOException e) {
+            throw new RequestFailedException("POST", url, e);
+        }
+    }
+
+    /**
+     * Performs an HTTP PUT request
+     *
+     * @param relativePath  Relative path to resource, e.g. api/kibana/dashboards/import
+     * @param requestBody   Body of request
+     * @return Response entity
+     * @throws RequestFailedException
+     */
+    public CloseableResponse put(String relativePath, String requestBody) throws RequestFailedException {
+        return put(relativePath, requestBody, null);
+    }
+
+    /**
+     * Performs an HTTP PUT request
+     *
+     * @param relativePath  Relative path to resource, e.g. api/kibana/dashboards/import
+     * @param requestBody   Body of request
+     * @param headers       Headers to include with request
+     * @return Response entity
+     * @throws RequestFailedException
+     */
+    public CloseableResponse put(String relativePath, String requestBody, Map<String, String> headers) throws RequestFailedException {
+
+        String url = makeUrlFrom(relativePath);
+
+        HttpPut request = new HttpPut(url);
+        try {
+            request.setEntity(new StringEntity(requestBody));
+        } catch (UnsupportedEncodingException e) {
+            throw new RequestFailedException("PUT", url, e);
+        }
+
+        if (headers != null) {
+            headers.forEach(request::addHeader);
+        }
+
+        try {
+            return new CloseableResponse(httpClient.execute(request));
+        } catch (IOException e) {
+            throw new RequestFailedException("PUT", url, e);
+        }
+    }
+
+    /**
+     * Performs an HTTP DELETE request
+     *
+     * @param relativePath  Relative path to resource, e.g. api/status
+     * @throws RequestFailedException
+     */
+    public Response delete(String relativePath) throws RequestFailedException {
+        return delete(relativePath, null);
+    }
+
+    /**
+     * Performs an HTTP DELETE request
+     *
+     * @param relativePath  Relative path to resource, e.g. api/status
+     * @param headers       Headers to include with request
+     * @throws RequestFailedException
+     */
+    public Response delete(String relativePath, Map<String, String> headers) throws RequestFailedException {
+        String url = makeUrlFrom(relativePath);
+        HttpDelete request = new HttpDelete(url);
+
+        if (headers != null) {
+            headers.forEach(request::addHeader);
+        }
+
+        try {
+            return new Response(httpClient.execute(request));
+        } catch (IOException e) {
+            throw new RequestFailedException("DELETE", url ,e);
+        }
+    }
+
+    private String makeUrlFrom(String relativePath) {
+        return this.baseUrl.toString().replaceFirst("/$", "")
+                + '/'
+                + relativePath.replaceFirst("^/", "");
+    }
+
+    /**
+     * Build an instance of the HTTP client with default configuration options.
+     *
+     * @return HTTP client instance
+     * @throws OptionsBuilderException
+     */
+    public static HttpClient build() throws OptionsBuilderException {
+        return new OptionsBuilder().build();
+    }
+
+    /**
+     * Start building an instance of the HTTP client.
+     *
+     * @return An OptionsBuilder instance to allow configuration of the HTTP client before building it.
+     */
+    public static OptionsBuilder builder() {
+        return new OptionsBuilder();
+    }
+
+    /**
+     * Builder pattern obj
+     */
+    public static class OptionsBuilder {
+
+        private Protocol protocol;
+        private String hostname;
+        private int port;
+        private String basePath;
+
+        private String basicAuthUsername;
+        private String basicAuthPassword;
+
+        private X509Certificate sslCaCertificate;
+        private X509Certificate sslClientCertificate;
+        private RSAPrivateKey sslClientPrivateKey;
+        private boolean sslVerifyServerHostname;
+        private boolean sslVerifyServerCredentials;
+
+        private static final Pattern KEY_EXTRACTION_REGEXP =Pattern.compile(".*-----BEGIN (\\S+ )?PRIVATE KEY-----\n(.*)-----END (\\S+ )?PRIVATE KEY.*$", Pattern.DOTALL);
+
+        private OptionsBuilder() {
+            this.protocol = Protocol.HTTP;
+            this.hostname = "localhost";
+            this.port = 80;
+            this.basePath = "/";
+            this.sslVerifyServerHostname = true;
+            this.sslVerifyServerCredentials = true;
+        }
+
+        /**
+         * Set the HTTP server's protocol (HTTP or HTTPS) that should be used by the HTTP client
+         * when making requests. Defaults to HTTP.
+         *
+         * @param protocol Server protocol, HTTP or HTTPS
+         * @return Same OptionsBuilder instance to continue configuring HTTP client
+         */
+        public OptionsBuilder protocol(Protocol protocol) {
+            this.protocol = protocol;
+            return this;
+        }
+
+        /**
+         * Set the HTTP server's hostname that should be used by the HTTP client when making requests.
+         * Defaults to localhost.
+         *
+         * @param hostname Server hostname
+         * @return Same OptionsBuilder instance to continue configuring HTTP client
+         */
+        public OptionsBuilder hostname(String hostname) {
+            this.hostname = hostname;
+            return this;
+        }
+
+        /**
+         * Set the HTTP server's port that should be used by the HTTP client when making requests. Defaults
+         * to 80.
+         *
+         * @param port Server port
+         * @return Same OptionsBuilder instance to continue configuring HTTP client
+         */
+        public OptionsBuilder port(int port) {
+            this.port = port;
+            return this;
+        }
+
+        /**
+         * Set the HTTP server's base path that should be used by the HTTP client when making requests. Defaults
+         * to /.
+         *
+         * @param basePath Server basePath
+         * @return Same OptionsBuilder instance to continue configuring HTTP client
+         */
+        public OptionsBuilder basePath(String basePath) {
+            this.basePath = basePath;
+            return this;
+        }
+
+        /**
+         * Set the HTTP server's basic authentication credentials that should be used by the HTTP client when
+         * making requests. By default, no basic authentication is used.
+         *
+         * @param username Basic authentication username
+         * @param password Basic authentication password
+         * @return Same OptionsBuilder instance to continue configuring HTTP client
+         */
+        public OptionsBuilder basicAuth(String username, String password) {
+            this.basicAuthUsername = username;
+            this.basicAuthPassword = password;
+
+            return this;
+        }
+
+        /**
+         * Set the Certificate Authority's certificate that the HTTP client should use for validating the
+         * server's SSL/TLS certificate. By default the certificate authority certificates provided by
+         * the system are used.
+         *
+         * @param caCertificatePath Path to Certificate Authority certificate file
+         * @return Same OptionsBuilder instance to continue configuring HTTP client
+         * @throws OptionsBuilderException
+         */
+        public OptionsBuilder sslCaCertificate(String caCertificatePath) throws OptionsBuilderException {
+            this.sslCaCertificate = getCertificate(caCertificatePath);
+            return this;
+        }
+
+        /**
+         * Set the client's certificate the HTTP client should present to the server, should the server ask for it during
+         * the ClientKeyExchange step. By default no client certificate is presented to the server.
+         *
+         * @param clientCertificatePath Path to client certificate file
+         * @return Same OptionsBuilder instance to continue configuring HTTP client
+         * @throws OptionsBuilderException
+         */
+        public OptionsBuilder sslClientCertificate(String clientCertificatePath) throws OptionsBuilderException {
+            this.sslClientCertificate = getCertificate(clientCertificatePath);
+            return this;
+        }
+
+        /**
+         * Set the client's private key the HTTP client should use during the (optional) ClientKeyExchange step. By
+         * default no client private key is used.
+         *
+         * @param clientPrivateKeyPath Path to client private key file
+         * @return Same OptionsBuilder instance to continue configuring HTTP client
+         * @throws OptionsBuilderException
+         */
+        public OptionsBuilder sslClientPrivateKey(String clientPrivateKeyPath) throws OptionsBuilderException {
+            this.sslClientPrivateKey = getPrivateKey(clientPrivateKeyPath);
+            return this;
+        }
+
+        /**
+         * Tell the HTTP client not to verify the server's hostname against the server's certificate.
+         *
+         * @return Same OptionsBuilder instance to continue configuring HTTP client
+         */
+        public OptionsBuilder sslNoVerifyServerHostname() {
+            this.sslVerifyServerHostname = false;
+            return this;
+        }
+
+        /**
+         * Tell the HTTP client not to verify the server's certificate against a Certificate Authority.
+         *
+         * @return Same OptionsBuilder instance to continue configuring HTTP client
+         */
+        public OptionsBuilder sslNoVerifyServerCredentials() {
+            this.sslVerifyServerCredentials = false;
+            return this;
+        }
+
+        /**
+         * Tell the HTTP client not to perform any SSL verification checks.
+         *
+         * @return Same OptionsBuilder instance to continue configuring HTTP client
+         */
+        public OptionsBuilder sslNoVerify() {
+            return this.sslNoVerifyServerHostname()
+                    .sslNoVerifyServerCredentials();
+        }
+
+        /**
+         * Finish building configuration for the HTTP client.
+         *
+         * @return Instance of the HTTP client with configuration options provided.
+         * @throws OptionsBuilderException
+         */
+        public HttpClient build() throws OptionsBuilderException {
+
+            URL baseUrl;
+            try {
+                baseUrl = new URL(this.protocol.name().toLowerCase(), this.hostname, this.port, this.basePath);
+            } catch (MalformedURLException e) {
+                throw new OptionsBuilderException("Unable to create base URL", e);
+            }
+
+            if (!usesSsl(baseUrl) && !usesBasicAuth()) {
+                CloseableHttpClient httpClient = HttpClients.createDefault();
+                return new HttpClient(httpClient, baseUrl);
+            }
+
+            HttpClientBuilder httpClientBuilder = HttpClients.custom();
+
+            if (usesSsl(baseUrl)) {
+                TrustManager[] trustManagers;
+                if (this.sslVerifyServerCredentials) {
+                    if (this.sslCaCertificate == null) {
+                        throw new OptionsBuilderException("Certificate authority not provided. "
+                                + "Please provide the certificate authority using the sslCaCertificate method.");
+                    }
+
+                    try {
+                        KeyStore keystore = getKeyStore();
+                        keystore.setCertificateEntry("caCertificate", this.sslCaCertificate);
+
+                        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+                        trustManagerFactory.init(keystore);
+
+                        trustManagers = trustManagerFactory.getTrustManagers();
+                    } catch (Exception e) {
+                        throw new OptionsBuilderException("Unable to use provided certificate authority.", e);
+                    }
+                } else {
+                    trustManagers = new TrustManager[] { getAnyTrustManager() };
+                }
+
+                KeyManager[] keyManagers = null;
+                if ((this.sslClientCertificate != null) && (this.sslClientPrivateKey != null)) {
+                    KeyStore keystore = getKeyStore();
+
+                    try {
+                        keystore.setKeyEntry("clientPrivateKey", this.sslClientPrivateKey, "".toCharArray(), new Certificate[]{this.sslClientCertificate});
+
+                        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
+                        keyManagerFactory.init(keystore, "".toCharArray());
+
+                        keyManagers = keyManagerFactory.getKeyManagers();
+                    } catch (Exception e) {
+                        throw new OptionsBuilderException("Unable to use provided client certificate and/or client private key", e);
+                    }
+                }
+
+                try {
+                    SSLContext sslContext = SSLContext.getInstance("TLS");
+                    sslContext.init(keyManagers, trustManagers, null);
+
+                    SSLConnectionSocketFactory sslSocketFactory;
+                    if (this.sslVerifyServerHostname) {
+                        sslSocketFactory = new SSLConnectionSocketFactory(sslContext, SSLConnectionSocketFactory.STRICT_HOSTNAME_VERIFIER);
+                    } else {
+                        sslSocketFactory = new SSLConnectionSocketFactory(sslContext, SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
+                    }
+
+                    httpClientBuilder.setSSLSocketFactory(sslSocketFactory);
+                } catch (Exception e) {
+                    throw new OptionsBuilderException("Unable to configure HTTP client with SSL/TLS", e);
+                }
+            }
+
+            if (usesBasicAuth()) {
+                String credentials = this.basicAuthUsername + ":" + this.basicAuthPassword;
+                String encodedCredentials = new String(Base64.getEncoder().encode(credentials.getBytes(StandardCharsets.UTF_8)), StandardCharsets.UTF_8);
+
+                List<Header> headerList = Collections.singletonList(new BasicHeader("Authorization", "Basic " + encodedCredentials));
+                httpClientBuilder.setDefaultHeaders(headerList);
+            }
+
+            return new HttpClient(httpClientBuilder.build(), baseUrl);
+        }
+
+        private boolean usesBasicAuth() {
+            return (this.basicAuthUsername != null) && (this.basicAuthPassword != null);
+        }
+
+        private boolean usesSsl(URL baseUrl) {
+            return baseUrl.getProtocol().equals("https");
+        }
+
+        private static X509Certificate getCertificate(String certificateFilePath) throws OptionsBuilderException {
+            try (FileInputStream fis = new FileInputStream(certificateFilePath)) {
+                CertificateFactory cf = CertificateFactory.getInstance("X.509");
+                return (X509Certificate) cf.generateCertificate(fis);
+            } catch (FileNotFoundException e) {
+                throw new OptionsBuilderException("Could not read certificate at " + certificateFilePath, e);
+            } catch (IOException e) {
+                throw new OptionsBuilderException("Could not close certificate file at " + certificateFilePath + " after reading it", e);
+            } catch (Exception e) {
+                throw new OptionsBuilderException("Could not generate certificate from " + certificateFilePath, e);
+            }
+        }
+
+        private static RSAPrivateKey getPrivateKey(String privateKeyPath) throws OptionsBuilderException {
+            String privateKeyFileContents;
+            try {
+                privateKeyFileContents = new String(Files.readAllBytes(Paths.get(privateKeyPath)), StandardCharsets.UTF_8);
+            } catch (IOException e) {
+                throw new OptionsBuilderException("Could not read private key file at " + privateKeyPath, e);
+            }
+
+            Matcher matcher = KEY_EXTRACTION_REGEXP.matcher(privateKeyFileContents);
+
+            final String obeMessage = "Could not parse private key file at " + privateKeyPath;
+
+            if (!matcher.matches()) {
+                throw new OptionsBuilderException(obeMessage);
+            }
+
+            String keyContentsBase64Encoded = matcher.group(2);
+            if (keyContentsBase64Encoded == null) {
+                throw new OptionsBuilderException(obeMessage);
+            }
+
+            try {
+                byte[] keyContents = Base64.getDecoder().decode(keyContentsBase64Encoded.replaceAll("\n", ""));
+                KeySpec spec = new PKCS8EncodedKeySpec(keyContents);
+                return (RSAPrivateKey) KeyFactory.getInstance("RSA").generatePrivate(spec);
+            } catch (Exception e) {
+                throw new OptionsBuilderException(obeMessage, e);
+            }
+        }
+
+        private static KeyStore getKeyStore() throws OptionsBuilderException {
+            KeyStore keystore;
+            try {
+                keystore = KeyStore.getInstance(KeyStore.getDefaultType());
+                keystore.load(null, null);
+            } catch (Exception e) {
+                throw new OptionsBuilderException("Unable to create keystore", e);
+            }
+            return keystore;
+        }
+
+        private static X509TrustManager getAnyTrustManager() {
+            return new X509TrustManager() {
+                @Override
+                public void checkClientTrusted(X509Certificate[] x509Certificates, String s) {
+
+                }
+
+                @Override
+                public void checkServerTrusted(X509Certificate[] x509Certificates, String s) {
+
+                }
+
+                @Override
+                public X509Certificate[] getAcceptedIssuers() {
+                    return new X509Certificate[0];
+                }
+            };
+        }
+
+    }
+
+    public static class Response {
+        protected HttpResponse response;
+
+        public Response(HttpResponse response) {
+            this.response = response;
+        }
+
+        public int getStatusCode() {
+            return this.response.getStatusLine().getStatusCode();
+        }
+    }
+
+    public static class CloseableResponse extends Response implements Closeable {
+        public CloseableResponse(CloseableHttpResponse response) {
+            super(response);
+        }
+
+        public String getBodyAsString() throws IOException {
+            ByteArrayOutputStream responseBody = new ByteArrayOutputStream();
+            this.response
+                    .getEntity()
+                    .writeTo(responseBody);
+            return responseBody.toString("UTF-8");
+        }
+
+        @Override
+        public void close() throws IOException {
+            ((CloseableHttpResponse)this.response).close();
+
+        }
+    }
+
+    /**
+     * Exception thrown when there is an error while configuring an HTTP client instance
+     */
+    public static class OptionsBuilderException extends Exception {
+        public OptionsBuilderException(String errorMessage, Throwable cause) {
+            super(errorMessage, cause);
+        }
+
+        public OptionsBuilderException(String errorMessage) {
+            super(errorMessage);
+        }
+    }
+
+    /**
+     * Exception thrown when a request made by this client to the HTTP resource fails
+     */
+    public static class RequestFailedException extends Exception {
+        RequestFailedException(String method, String url, Throwable cause) {
+            super(makeMessage(method, url, null), cause);
+        }
+
+        RequestFailedException(String method, String url, String reason) {
+            super(makeMessage(method, url, reason));
+        }
+
+        private static String makeMessage(String method, String url, String reason) {
+            String message = "Could not make " + method + " " + url + " request";
+            if (reason != null) {
+                message += "; reason: " + reason;
+            }
+            return message;
+        }
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/common/clients/HttpClientTest.java b/logstash-core/src/test/java/org/logstash/common/clients/HttpClientTest.java
new file mode 100644
index 00000000000..ffafec16a24
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/common/clients/HttpClientTest.java
@@ -0,0 +1,394 @@
+package org.logstash.common.clients;
+
+import com.github.tomakehurst.wiremock.WireMockServer;
+import com.github.tomakehurst.wiremock.junit.WireMockRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.logstash.common.clients.HttpClient.RequestFailedException;
+
+import java.net.InetAddress;
+import java.nio.file.Paths;
+
+import static com.github.tomakehurst.wiremock.client.WireMock.*;
+import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.options;
+import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
+
+public class HttpClientTest {
+
+    @Rule
+    public WireMockRule httpServer = new WireMockRule(options().dynamicPort());
+
+    @Test
+    public void canMakeHttpRequestWithAlmostDefaultSettings() throws Exception {
+        final String path = "/api/hello";
+        final String expectedResponseBody = "Hello, World";
+
+        httpServer.stubFor(get(urlPathEqualTo(path))
+                .willReturn(aResponse()
+                        .withStatus(200)
+                        .withBody(expectedResponseBody))
+        );
+
+        HttpClient httpClient = HttpClient.builder()
+                .port(httpServer.port()) // We set this one setting so we don't need to run this test as a superuser
+                .build();
+
+        try(HttpClient.CloseableResponse closeableResponse = httpClient.get(path)) {
+            assertThat(closeableResponse.getBodyAsString()).isEqualTo(expectedResponseBody);
+        }
+    }
+
+    @Test
+    public void canMakeHttpRequestWithCustomHostnameAndPort() throws Exception {
+        final String BIND_ADDRESS = InetAddress.getLoopbackAddress().getHostAddress();
+
+        WireMockServer localhostHttpServer = new WireMockServer(options()
+                .dynamicPort()
+                .bindAddress(BIND_ADDRESS));
+
+        try {
+            localhostHttpServer.start();
+            final String path = "/api/hello";
+            final String expectedResponseBody = "Hello, World";
+
+            localhostHttpServer.stubFor(get(urlPathEqualTo(path))
+                    .willReturn(aResponse()
+                            .withStatus(200)
+                            .withBody(expectedResponseBody))
+            );
+
+            HttpClient httpClient = HttpClient.builder()
+                    .hostname(BIND_ADDRESS)
+                    .port(localhostHttpServer.port())
+                    .build();
+
+            try(HttpClient.CloseableResponse closeableResponse = httpClient.get(path)) {
+                assertThat(closeableResponse.getBodyAsString()).isEqualTo(expectedResponseBody);
+            }
+        } finally {
+            localhostHttpServer.stop();
+        }
+    }
+
+    @Test
+    public void canMakeHttpRequestWithBasicAuth() throws Exception {
+        final String USERNAME = "seger";
+        final String PASSWORD = "comma_bob";
+
+        final String path = "/api/hello";
+        final String expectedResponseBody = "Hello, World";
+
+        httpServer.stubFor(get(urlPathEqualTo(path))
+                .withBasicAuth(USERNAME, PASSWORD)
+                .willReturn(aResponse()
+                        .withStatus(200)
+                        .withBody(expectedResponseBody))
+        );
+
+        HttpClient httpClient = HttpClient.builder()
+                .port(httpServer.port())
+                .basicAuth(USERNAME, PASSWORD)
+                .build();
+
+        try(HttpClient.CloseableResponse closeableResponse = httpClient.get(path)) {
+            assertThat(closeableResponse.getBodyAsString()).isEqualTo(expectedResponseBody);
+        }
+    }
+
+    @Test
+    public void canMakeHttpsRequestWithSslNoVerify() throws Exception {
+        WireMockServer httpsServer = new WireMockServer(options()
+                .dynamicHttpsPort());
+
+        try {
+            httpsServer.start();
+            final String path = "/api/hello";
+            final String expectedResponseBody = "Hello, World";
+
+            httpsServer.stubFor(get(urlPathEqualTo(path))
+                    .willReturn(aResponse()
+                            .withStatus(200)
+                            .withBody(expectedResponseBody))
+            );
+
+            HttpClient httpClient = HttpClient.builder()
+                    .protocol(HttpClient.Protocol.HTTPS)
+                    .port(httpsServer.httpsPort())
+                    .sslNoVerify()
+                    .build();
+
+            try(HttpClient.CloseableResponse closeableResponse = httpClient.get(path)) {
+                assertThat(closeableResponse.getBodyAsString()).isEqualTo(expectedResponseBody);
+            }
+        } finally {
+            httpsServer.stop();
+        }
+    }
+
+    @Test
+    public void canMakeHttpsRequestWithSslSelfSignedServerCertificate() throws Exception {
+        WireMockServer httpsServer = new WireMockServer(options()
+                .dynamicHttpsPort()
+                .keystorePath(Paths.get(getClass().getResource("server.jks").toURI()).toString())
+                .keystorePassword("elastic"));
+
+        try {
+            httpsServer.start();
+            final String path = "/api/hello";
+            final String expectedResponseBody = "Hello, World";
+
+            httpsServer.stubFor(get(urlPathEqualTo(path))
+                    .willReturn(aResponse()
+                            .withStatus(200)
+                            .withBody(expectedResponseBody))
+            );
+
+            HttpClient httpClient = HttpClient.builder()
+                    .protocol(HttpClient.Protocol.HTTPS)
+                    .port(httpsServer.httpsPort())
+                    .sslCaCertificate(Paths.get(getClass().getResource("server.crt").toURI()).toString())
+                    .build();
+
+            try(HttpClient.CloseableResponse response = httpClient.get(path)) {
+                assertThat(response.getBodyAsString()).isEqualTo(expectedResponseBody);
+            }
+        } finally {
+            httpsServer.stop();
+        }
+    }
+
+    @Test
+    public void canMakeHttpsRequestWithSslSelfSignedServerAndClientCertificates() throws Exception {
+        WireMockServer httpsServer = new WireMockServer(options()
+                .dynamicHttpsPort()
+                .keystorePath(Paths.get(getClass().getResource("server.jks").toURI()).toString())
+                .keystorePassword("elastic")
+                .needClientAuth(true)
+                .trustStorePath(Paths.get(getClass().getResource("server.jks").toURI()).toString())
+                .trustStorePassword("elastic")
+        );
+
+        try {
+            httpsServer.start();
+            final String path = "/api/hello";
+            final String expectedResponseBody = "Hello, World";
+
+            httpsServer.stubFor(get(urlPathEqualTo(path))
+                    .willReturn(aResponse()
+                            .withStatus(200)
+                            .withBody(expectedResponseBody))
+            );
+
+            HttpClient httpClient = HttpClient.builder()
+                    .protocol(HttpClient.Protocol.HTTPS)
+                    .port(httpsServer.httpsPort())
+                    .sslCaCertificate(Paths.get(getClass().getResource("server.crt").toURI()).toString())
+                    .sslClientCertificate(Paths.get(getClass().getResource("client.crt").toURI()).toString())
+                    .sslClientPrivateKey(Paths.get(getClass().getResource("client.key").toURI()).toString())
+                    .build();
+
+            try(HttpClient.CloseableResponse response = httpClient.get(path)) {
+                assertThat(response.getBodyAsString()).isEqualTo(expectedResponseBody);
+            }
+        } finally {
+            httpsServer.stop();
+        }
+    }
+
+    @Test
+    public void cantMakeHttpsRequestWithUnverifiedHostnameAndSslNoVerifyServerHostname() throws Exception {
+        WireMockServer httpsServer = new WireMockServer(options()
+                .dynamicHttpsPort()
+                .keystorePath(Paths.get(getClass().getResource("server_no_san.jks").toURI()).toString())
+                .keystorePassword("elastic")
+        );
+
+        try {
+            httpsServer.start();
+            final String path = "/api/hello";
+            final String expectedResponseBody = "Hello, World";
+
+            httpsServer.stubFor(get(urlPathEqualTo(path))
+                    .willReturn(aResponse()
+                            .withStatus(200)
+                            .withBody(expectedResponseBody))
+            );
+
+            HttpClient httpClient = HttpClient.builder()
+                    .protocol(HttpClient.Protocol.HTTPS)
+                    .port(httpsServer.httpsPort())
+                    .sslCaCertificate(Paths.get(getClass().getResource("server_no_san.crt").toURI()).toString())
+                    .sslNoVerifyServerHostname()
+                    .build();
+
+            try(HttpClient.CloseableResponse response = httpClient.get(path)) {
+                assertThat(response.getBodyAsString()).isEqualTo(expectedResponseBody);
+            }
+        } finally {
+            httpsServer.stop();
+        }
+    }
+
+    @Test(expected = RequestFailedException.class)
+    public void throwsExceptionForHttpsRequestWithUnverifiedHostname() throws Exception {
+        WireMockServer httpsServer = new WireMockServer(options()
+                .dynamicHttpsPort()
+                .keystorePath(Paths.get(getClass().getResource("server_no_san.jks").toURI()).toString())
+                .keystorePassword("elastic")
+        );
+
+        try {
+            httpsServer.start();
+            final String path = "/api/hello";
+            final String expectedResponseBody = "Hello, World";
+
+            httpsServer.stubFor(get(urlPathEqualTo(path))
+                    .willReturn(aResponse()
+                            .withStatus(200)
+                            .withBody(expectedResponseBody))
+            );
+
+            HttpClient httpClient = HttpClient.builder()
+                    .protocol(HttpClient.Protocol.HTTPS)
+                    .port(httpsServer.httpsPort())
+                    .sslCaCertificate(Paths.get(getClass().getResource("server_no_san.crt").toURI()).toString())
+                    .build();
+
+            try(HttpClient.CloseableResponse response = httpClient.get(path)) {}
+        } finally {
+            httpsServer.stop();
+        }
+    }
+
+    @Test
+    public void canMakeHttpPostRequest() throws Exception {
+        final String path = "/api/hello";
+        final String expectedResponseBody = "Hello, World";
+
+        httpServer.stubFor(post(urlPathEqualTo(path))
+                .willReturn(aResponse()
+                        .withStatus(200)
+                        .withBody(expectedResponseBody))
+        );
+
+        HttpClient httpClient = HttpClient.builder()
+                .port(httpServer.port())
+                .build();
+
+        String body = "Hello!";
+        try(HttpClient.CloseableResponse response = httpClient.post(path, body)) {
+            assertThat(response.getBodyAsString()).isEqualTo(expectedResponseBody);
+        }
+    }
+
+    @Test
+    public void canMakeHttpPutRequest() throws Exception {
+        final String path = "/api/hello";
+        final String expectedResponseBody = "Hello, World";
+
+        httpServer.stubFor(put(urlPathEqualTo(path))
+                .willReturn(aResponse()
+                        .withStatus(200)
+                        .withBody(expectedResponseBody))
+        );
+
+        HttpClient httpClient = HttpClient.builder()
+                .port(httpServer.port())
+                .build();
+
+        String body = "Hello!";
+        try(HttpClient.CloseableResponse response = httpClient.put(path, body)) {
+            assertThat(response.getBodyAsString()).isEqualTo(expectedResponseBody);
+        }
+    }
+
+    @Test
+    public void returnsBadRequestForUnsuccessfulHeadRequest() throws Exception {
+        final String path = "/api/hello";
+
+        httpServer.stubFor(head(urlPathEqualTo(path))
+                .willReturn(aResponse()
+                        .withStatus(400))
+        );
+
+        HttpClient httpClient = HttpClient.builder()
+                .port(httpServer.port())
+                .build();
+
+        HttpClient.Response response = httpClient.head(path);
+        assertThat(response.getStatusCode()).isEqualTo(400);
+    }
+
+    @Test
+    public void returnsBadRequestForUnsuccessfulGetRequest() throws Exception {
+        final String path = "/api/hello";
+
+        httpServer.stubFor(get(urlPathEqualTo(path))
+                .willReturn(aResponse()
+                        .withStatus(400))
+        );
+
+        HttpClient httpClient = HttpClient.builder()
+                .port(httpServer.port())
+                .build();
+
+        try(HttpClient.CloseableResponse response = httpClient.get(path)) {
+            assertThat(response.getStatusCode()).isEqualTo(400);
+        }
+    }
+
+    @Test
+    public void returnsBadRequestForUnsuccessfulPostRequest() throws Exception {
+        final String path = "/api/hello";
+
+        httpServer.stubFor(post(urlPathEqualTo(path))
+                .willReturn(aResponse()
+                        .withStatus(400))
+        );
+
+        HttpClient httpClient = HttpClient.builder()
+                .port(httpServer.port())
+                .build();
+
+        String body = "Hello!";
+        try(HttpClient.CloseableResponse response = httpClient.post(path, body)) {
+            assertThat(response.getStatusCode()).isEqualTo(400);
+        }
+    }
+
+    @Test
+    public void returnsBadRequestForUnsuccessfulPutRequest() throws Exception {
+        final String path = "/api/hello";
+
+        httpServer.stubFor(put(urlPathEqualTo(path))
+                .willReturn(aResponse()
+                        .withStatus(400))
+        );
+
+        HttpClient httpClient = HttpClient.builder()
+                .port(httpServer.port())
+                .build();
+
+        String body = "Hello!";
+        try(HttpClient.CloseableResponse response = httpClient.put(path, body)) {
+            assertThat(response.getStatusCode()).isEqualTo(400);
+        }
+    }
+
+    @Test
+    public void returnsBadRequestForUnsuccessfulDeleteRequest() throws Exception {
+        final String path = "/api/hello";
+
+        httpServer.stubFor(delete(urlPathEqualTo(path))
+                .willReturn(aResponse()
+                        .withStatus(400))
+        );
+
+        HttpClient httpClient = HttpClient.builder()
+                .port(httpServer.port())
+                .build();
+
+        HttpClient.Response response = httpClient.delete(path);
+        assertThat(response.getStatusCode()).isEqualTo(400);
+    }
+}
diff --git a/logstash-core/src/test/resources/org/logstash/common/clients/client.crt b/logstash-core/src/test/resources/org/logstash/common/clients/client.crt
new file mode 100644
index 00000000000..6456314bf1c
--- /dev/null
+++ b/logstash-core/src/test/resources/org/logstash/common/clients/client.crt
@@ -0,0 +1,22 @@
+-----BEGIN CERTIFICATE-----
+MIIDjzCCAnegAwIBAgIECLLFSjANBgkqhkiG9w0BAQsFADB4MQswCQYDVQQGEwJV
+UzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQ
+MA4GA1UEChMHRWxhc3RpYzEUMBIGA1UECxMLRW5naW5lZXJpbmcxFDASBgNVBAMT
+C1Rlc3QgQ2xpZW50MB4XDTE4MDUwNDE4NDc0M1oXDTE4MDgwMjE4NDc0M1oweDEL
+MAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDU1vdW50
+YWluIFZpZXcxEDAOBgNVBAoTB0VsYXN0aWMxFDASBgNVBAsTC0VuZ2luZWVyaW5n
+MRQwEgYDVQQDEwtUZXN0IENsaWVudDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
+AQoCggEBAIFDKIQ71+X6/JMUqVB2v3WvKLsrlqwQCZq/f6lijZedO4lED4FpGFkH
+uOhzfffleqQjTdGzHc2q/+YBECihW81xjDdqhO4ZYocgYI3oMpj1uAC19GzSyxWc
+udn7MNLODYUCiax7TqfxDbiEfn5zrggDS/vEA5iA1vaaKRf+eQYaDj3JjpvNZ/tO
+zFd/1Vf0R9prulUbLMX2wFgcycM71HKjaLU+LidaP9YpOdfd3Z51wjbaLtO5JT6m
+/+0sb2jEmv65+HCPT1gYm4idUoDngWjS+tNM4X6qz4ru9UcqHjUoI5q1GANvyGx8
++Cdkntv32CWxgxcasBOPJXQnZ+WzbFkCAwEAAaMhMB8wHQYDVR0OBBYEFFH/X84d
+nX9V/yH0s+GuhpSeod4/MA0GCSqGSIb3DQEBCwUAA4IBAQBEDF5urr3QvsDwPnYw
+rX53Ql1iZZGcw6ZAnBMMWC4lzi6UaQu6rnZgX5ABx8qTkuBrE/cLGEcO39bdzJrL
+fW6nt8bE5XbWXMaFgBPW/Lb745Sv7tYJ5LlkzBv9jN2HSk6xpoNw75QBPVQvIemw
+386NosB9KCJrBIqZ2nOUq7cTYG2kt2N3I+jkIWGBS59BsFQ01OLsCF1AL3jSWOlh
+jPvJghwxBxWkOXcVw0mgaOJeE4/UZP0ccYfbATTCX/PUSH+m5GT7xLJLymbpQ/PT
+G9Q10QmWcU97HkH25Vxwiu3j/QoDgoo+A9z+7Vjg+PBM70FBPEHdSlCt2gAqwbAq
+xw/L
+-----END CERTIFICATE-----
diff --git a/logstash-core/src/test/resources/org/logstash/common/clients/client.jks b/logstash-core/src/test/resources/org/logstash/common/clients/client.jks
new file mode 100644
index 00000000000..29a71b693cb
Binary files /dev/null and b/logstash-core/src/test/resources/org/logstash/common/clients/client.jks differ
diff --git a/logstash-core/src/test/resources/org/logstash/common/clients/client.key b/logstash-core/src/test/resources/org/logstash/common/clients/client.key
new file mode 100644
index 00000000000..a6d4ee94dd4
--- /dev/null
+++ b/logstash-core/src/test/resources/org/logstash/common/clients/client.key
@@ -0,0 +1,32 @@
+Bag Attributes
+    friendlyName: client
+    localKeyID: 54 69 6D 65 20 31 35 32 35 34 37 32 37 39 35 33 36 36 
+Key Attributes: <No Attributes>
+-----BEGIN PRIVATE KEY-----
+MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCBQyiEO9fl+vyT
+FKlQdr91ryi7K5asEAmav3+pYo2XnTuJRA+BaRhZB7joc3335XqkI03Rsx3Nqv/m
+ARAooVvNcYw3aoTuGWKHIGCN6DKY9bgAtfRs0ssVnLnZ+zDSzg2FAomse06n8Q24
+hH5+c64IA0v7xAOYgNb2mikX/nkGGg49yY6bzWf7TsxXf9VX9Efaa7pVGyzF9sBY
+HMnDO9Ryo2i1Pi4nWj/WKTnX3d2edcI22i7TuSU+pv/tLG9oxJr+ufhwj09YGJuI
+nVKA54Fo0vrTTOF+qs+K7vVHKh41KCOatRgDb8hsfPgnZJ7b99glsYMXGrATjyV0
+J2fls2xZAgMBAAECggEAXk9pmFExTJK7BXTls9dwCaUqyqUa4Z8x4r4lnqhRNnV5
+osUNqxXKtep0duUM23mK6Yb4mC9fZ1eELYRJDdvs5xAZhbUqF65dvMlaqS7o+8EL
+5zjahSunELWww+IJ1USRiKI5YKb21IGDyUSiJhCwwRfmsGJrXTFjpbkEkoUQN+pq
+v4vEFmvL535A1R1Z3gp6NrbQ4jzwdzCFPkPTqnHTCrPeROm1/HKKR/Vl6MwRDWpC
+BB69D8vEz2e37pqWP7CNQGsrhe9S7WLw8xUGKazVgvWCN8q1CwE43ZOItZzBC1Wp
+tgvsvwghgK1WfD5YrSqgrSyP2iLoa/l+1bo+kHA8oQKBgQDjN2G/xOTZQ5BK1s2q
+IkbpWtPAGk6upqF8kU6bP3XkcViMxlxVkEklEox4IfMXs8iuLY07fFRV44ctEWkI
+SSfKCx8fNWC0bPBzNLzl83cijnukzH1/gag5f1hffIAz38QI3ju38cmvdbwgWQsZ
+fCcFLYcOm7FEvFH1xyzIPOsrRwKBgQCRoyGsphT17ChW0z2hqWIHPt7oUhxFpjO/
+Tqi8uPCRUxrtGqfLc23BJgoSisadLTeulCd3nGPM2tJYoNCGooKTyK+kq/u3rPpW
+YaLekz92SFCKgkPbVyKwQ6FYR8lGVXDXTPSKtm+SK73DfupZPVytqi+GZHCO8G9I
+hZGfTWM7XwKBgQC9KL4YCLL8rWLS60ENArxGSXc/1qbqf46xRcdLN+nN5Q7zI7B7
+C0PZuTd4S8s1UFchqoqJm1gaqPFAc94dJ8oYSmn+cVGw44DKaH1acvYbrsMAz70r
+CaYjOAE6fUu94+wv9dOBr6lYiYu04mx7KwDRLrXhU3yg3KbfFpIRoaWmwQKBgFf/
+6mkYMbIncHiGS8dTQhh+tNJMSykKtFn0faELXtFxFeQPJzSYGsmK4qsxj7GJkQu8
+Gdz8cpFl55QGF/pCWARUT02BXiguLVXkyTUUZFRkfcYz0CzJCfzX4LYnKkeFeRmf
+NmRauC/qnk9ycMhbe5S0MONT7W9xeMypaMSJTlyhAoGBAJaXZFUxeapQCU5mts8t
+VzWGpWZJkQhfQ4PtCTfvOzhJ6P1X/pTIgZUmBEw7xMWyk0PP6seTElGfc0VJsREb
+t+XcBwctiYE7xiWMFeD7pI3j+X3rbQ4TvZbGoAN3CAVevgVZgV2D6nhU8LGr/uNB
+W1SNUwhl8zc6IZzKh6BTqqZh
+-----END PRIVATE KEY-----
diff --git a/logstash-core/src/test/resources/org/logstash/common/clients/server.crt b/logstash-core/src/test/resources/org/logstash/common/clients/server.crt
new file mode 100644
index 00000000000..61efa8916d4
--- /dev/null
+++ b/logstash-core/src/test/resources/org/logstash/common/clients/server.crt
@@ -0,0 +1,22 @@
+-----BEGIN CERTIFICATE-----
+MIIDpTCCAo2gAwIBAgIET1wcDDANBgkqhkiG9w0BAQsFADB4MQswCQYDVQQGEwJV
+UzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQ
+MA4GA1UEChMHRWxhc3RpYzEUMBIGA1UECxMLRW5naW5lZXJpbmcxFDASBgNVBAMT
+C1Rlc3QgU2VydmVyMB4XDTE4MDUwNDE4NTQ0MFoXDTE4MDgwMjE4NTQ0MFoweDEL
+MAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDU1vdW50
+YWluIFZpZXcxEDAOBgNVBAoTB0VsYXN0aWMxFDASBgNVBAsTC0VuZ2luZWVyaW5n
+MRQwEgYDVQQDEwtUZXN0IFNlcnZlcjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
+AQoCggEBAMnNcY65yj8ZamRbkvRrKUDKoJ0xjD7/CYQ/ulOxFs/T8Z8fnhHI2Ofh
+ob8IH2QzL2dWhq7hsDbnshtW+VJ8AgY4ioeruLpVz9eqY7myFBCJsURPDLkhTehm
+4fgns4Hnes8NeJFvlEbilg/RepziEmwgQos8Jf0yYEe8nS9aKnnV4yzeGue62Ypy
+21mUAIQCoTUk55zlQ2wqbpS61ZZQsJvYy5Mo03qwIIxel3THG59k1OQ/QfmC2a2g
+93nzovvqrG/g6Y8GlSxRdGr5NRfr6/EMC7KecS3b+34RIdAGY8bS3uJZdJaC4AZM
+yzrFVAjw1MuDgOEYph992L23IPBXUrMCAwEAAaM3MDUwFAYDVR0RBA0wC4IJbG9j
+YWxob3N0MB0GA1UdDgQWBBSDZA4Uf5+RHA4tL3QNpF3yZOR2kDANBgkqhkiG9w0B
+AQsFAAOCAQEAq2c+5no8RxvZEbnJAUP7HM7PNAWddsYKPZdYQRlzN34RZKNgZLsf
+ksfFMYHVPAzrtJvklXIybBvmlrCDrpuGqpxj3R517BpSXKl6nFZdjbByS44MVkfS
+jFZtP7ru1N/Oa7r8bvWVid6wIokEoaz1ksA64ycYejaVFXlgZDOpUPgEdV0lsfRl
+5OOYziQg+Ck2cZHGL2XxLfrhllhz/Z5ldFwDL0azcB5522XHKls25nYF66OY8m3c
+sb8oEdYFma7JjW4SNP7bRc8m85OrEIvVHaQQPePIsd19lbfPdiG1FN44f5LPWNxu
+pZI+aTYvIpd03CCJVentJtkrgQ4fmg/aFw==
+-----END CERTIFICATE-----
diff --git a/logstash-core/src/test/resources/org/logstash/common/clients/server.jks b/logstash-core/src/test/resources/org/logstash/common/clients/server.jks
new file mode 100644
index 00000000000..12745e94218
Binary files /dev/null and b/logstash-core/src/test/resources/org/logstash/common/clients/server.jks differ
diff --git a/logstash-core/src/test/resources/org/logstash/common/clients/server_no_san.crt b/logstash-core/src/test/resources/org/logstash/common/clients/server_no_san.crt
new file mode 100644
index 00000000000..88018109d68
--- /dev/null
+++ b/logstash-core/src/test/resources/org/logstash/common/clients/server_no_san.crt
@@ -0,0 +1,22 @@
+-----BEGIN CERTIFICATE-----
+MIIDjzCCAnegAwIBAgIEBnpwDDANBgkqhkiG9w0BAQsFADB4MQswCQYDVQQGEwJV
+UzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQ
+MA4GA1UEChMHRWxhc3RpYzEUMBIGA1UECxMLRW5naW5lZXJpbmcxFDASBgNVBAMT
+C1Rlc3QgU2VydmVyMB4XDTE4MDUwNTExMzgwMFoXDTE4MDgwMzExMzgwMFoweDEL
+MAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDU1vdW50
+YWluIFZpZXcxEDAOBgNVBAoTB0VsYXN0aWMxFDASBgNVBAsTC0VuZ2luZWVyaW5n
+MRQwEgYDVQQDEwtUZXN0IFNlcnZlcjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
+AQoCggEBAOnEECc8hC+JQc9AbjGykBvcE7e7Jc0n2zc9vbs74S80BaTLCQASCbY3
+eFvrwMC/omxlH1Pc4LxyTUXj65MDZS2CLe0RKVis3wIn0j5X91US2OjOdRAV/Qxt
+7wi7QZhEhSbB1x77Rmn3hmQjolfCYs2UwCt8TyOxjxDyYdRb8LQ9TnPFrdSgH2TB
+EtcSFM70dAEBJsvWWrVBLlXyrWlLpbNzOViJAvU1OM0wATHU4leK065LXZEQ9ATk
+qpXYkyibBXzQRtHxZNoSvP0ZUhl6oCfNvfb6eGIk5rVMErRVA8LrR01PlxBtAZfF
+oi9IM8OadVx2PSe4qkq7HUqN3WG6l78CAwEAAaMhMB8wHQYDVR0OBBYEFLF5Y/Rl
+vgtwACO3cHCcBSG6FgE2MA0GCSqGSIb3DQEBCwUAA4IBAQBatyBmjl4SwtzOlq9i
+hfVmgWmqvTN6OcULuoZkMDpqvAv8wzB3nNitxld4kEDpWLGLIK8kGuDQSEYYVIAF
+dB6P/WiDUPgv/Kqrx6VWMkVMxTAYDRdfEEwwAPSbRwUNgd4krcVlMrkZhbDrvK01
+zJm/JLL6BF6H89ElP+1coadwWik6brpRidAEM7UWJRgV9QqMEzp0G0bPJnbPiYCT
+kjp5bWcmXSwJS1yt1iHwdCDTZhaI6+uezIyfPz9md3D+mgKQeztDS8aMTbiF/VmY
+KVj7RFvOKjowauP4hcuVoHcGhtqNfM7Nerr/Scw4OUgXmgd+xv/eNF9HO9bdonIq
+JQ2d
+-----END CERTIFICATE-----
diff --git a/logstash-core/src/test/resources/org/logstash/common/clients/server_no_san.jks b/logstash-core/src/test/resources/org/logstash/common/clients/server_no_san.jks
new file mode 100644
index 00000000000..74481228e6e
Binary files /dev/null and b/logstash-core/src/test/resources/org/logstash/common/clients/server_no_san.jks differ
