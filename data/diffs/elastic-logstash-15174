diff --git a/.rubocop.yml b/.rubocop.yml
index d6ed3a22d16..2807b1e224e 100644
--- a/.rubocop.yml
+++ b/.rubocop.yml
@@ -19,7 +19,13 @@ AllCops:
     - 'config/**/*'
   DisplayCopNames: true
   UseCache: false
+
 #################### Layout ###########################
+##### Enabled Cops #####
+Layout/TrailingWhitespace:
+  Enabled: true
+
+##### Need review #####
 Layout/AccessModifierIndentation:
   Enabled: false
 Layout/ArgumentAlignment:
@@ -216,5 +222,3 @@ Layout/SpaceInsideStringInterpolation:
   Enabled: false
 Layout/TrailingEmptyLines:
   Enabled: false
-Layout/TrailingWhitespace:
-  Enabled: false
diff --git a/lib/pluginmanager/command.rb b/lib/pluginmanager/command.rb
index 1e37fae932a..8fd700db564 100644
--- a/lib/pluginmanager/command.rb
+++ b/lib/pluginmanager/command.rb
@@ -38,7 +38,7 @@ def display_bundler_output(output)
   end
 
   # Each plugin install for a gemfile create a path with a unique id.
-  # we must clear what is not currently used in the 
+  # we must clear what is not currently used in the
   def remove_unused_locally_installed_gems!
     used_path = gemfile.locally_installed_gems.collect { |gem| gem.options[:path] }
 
diff --git a/lib/pluginmanager/update.rb b/lib/pluginmanager/update.rb
index ede063a533a..6d3d7a86bf5 100644
--- a/lib/pluginmanager/update.rb
+++ b/lib/pluginmanager/update.rb
@@ -104,7 +104,7 @@ def plugins_to_update(previous_gem_specs_map)
     if update_all?
       previous_gem_specs_map.values.map{|spec| spec.name}
     else
-      # If the plugins isn't available in the gemspec or in 
+      # If the plugins isn't available in the gemspec or in
       # the gemfile defined with a local path, we assume the plugins is not
       # installed.
       not_installed = plugins_arg.select { |plugin| !previous_gem_specs_map.has_key?(plugin.downcase) && !gemfile.find(plugin) }
diff --git a/logstash-core/lib/logstash/agent.rb b/logstash-core/lib/logstash/agent.rb
index d3eab797ca2..612972e11b8 100644
--- a/logstash-core/lib/logstash/agent.rb
+++ b/logstash-core/lib/logstash/agent.rb
@@ -95,7 +95,7 @@ def initialize(settings = LogStash::SETTINGS, source_loader = nil)
     initialize_flow_metrics
 
     initialize_geoip_database_metrics(metric)
-    
+
     @pq_config_validator = LogStash::PersistedQueueConfigValidator.new
 
     @dispatcher = LogStash::EventDispatcher.new(self)
@@ -174,7 +174,7 @@ def converge_state_and_update_if_running
   # NOTE that there is no point of calling this method before
   # Agent#execute has been called since it will itself call
   # converge_state_and_update and will result in a double
-  # convergence. 
+  # convergence.
   def converge_state_and_update
     results = @source_loader.fetch
 
diff --git a/logstash-core/lib/logstash/api/commands/base.rb b/logstash-core/lib/logstash/api/commands/base.rb
index 60df1873548..25e71edd1db 100644
--- a/logstash-core/lib/logstash/api/commands/base.rb
+++ b/logstash-core/lib/logstash/api/commands/base.rb
@@ -20,7 +20,7 @@ module Api
     module Commands
       class Base
         attr_reader :service
-        
+
         def initialize(service = LogStash::Api::Service.instance)
           @service = service
         end
@@ -28,7 +28,7 @@ def initialize(service = LogStash::Api::Service.instance)
         def uptime
           service.agent.uptime
         end
-        
+
         def started_at
           (LogStash::Agent::STARTED_AT.to_f * 1000.0).to_i
         end
diff --git a/logstash-core/lib/logstash/api/commands/hot_threads_reporter.rb b/logstash-core/lib/logstash/api/commands/hot_threads_reporter.rb
index 5d51111cf4b..0f928339909 100644
--- a/logstash-core/lib/logstash/api/commands/hot_threads_reporter.rb
+++ b/logstash-core/lib/logstash/api/commands/hot_threads_reporter.rb
@@ -33,9 +33,9 @@ def to_s
     report << '=' * STRING_SEPARATOR_LENGTH
     report << "\n"
     hash[:threads].each do |thread|
-      line_str = I18n.t("logstash.web_api.hot_threads.thread_title", 
-        :percent_of_cpu_time => thread[:percent_of_cpu_time], 
-        :thread_state => thread[:state], 
+      line_str = I18n.t("logstash.web_api.hot_threads.thread_title",
+        :percent_of_cpu_time => thread[:percent_of_cpu_time],
+        :thread_state => thread[:state],
         :thread_name => thread[:name],
         :thread_id => thread[:thread_id])
       thread_report = "#{line_str} \n"
diff --git a/logstash-core/lib/logstash/compiler/lscl/helpers.rb b/logstash-core/lib/logstash/compiler/lscl/helpers.rb
index 3362f1c9877..677eb99a47d 100644
--- a/logstash-core/lib/logstash/compiler/lscl/helpers.rb
+++ b/logstash-core/lib/logstash/compiler/lscl/helpers.rb
@@ -26,7 +26,7 @@ def source_meta
     def base_source_with_metadata=(value)
       set_meta(:base_source_with_metadata, value)
     end
-    
+
     def base_source_with_metadata
       get_meta(:base_source_with_metadata)
     end
@@ -63,7 +63,7 @@ def jdsl
     def self.jdsl
       org.logstash.config.ir.DSL
     end
-    
+
     BOOLEAN_DSL_METHOD_SIGNATURE = [org.logstash.common.SourceWithMetadata, org.logstash.config.ir.expression.Expression, org.logstash.config.ir.expression.Expression]
     AND_METHOD = jdsl.java_method(:eAnd, BOOLEAN_DSL_METHOD_SIGNATURE)
     NAND_METHOD = jdsl.java_method(:eNand, BOOLEAN_DSL_METHOD_SIGNATURE)
diff --git a/logstash-core/lib/logstash/compiler/treetop_monkeypatches.rb b/logstash-core/lib/logstash/compiler/treetop_monkeypatches.rb
index cbc02128a34..36ccb458423 100644
--- a/logstash-core/lib/logstash/compiler/treetop_monkeypatches.rb
+++ b/logstash-core/lib/logstash/compiler/treetop_monkeypatches.rb
@@ -20,11 +20,11 @@
 class Treetop::Runtime::SyntaxNode
   def get_meta(key)
     @ast_metadata ||= {}
-    return @ast_metadata[key] if @ast_metadata[key] 
+    return @ast_metadata[key] if @ast_metadata[key]
     return self.parent.get_meta(key) if self.parent
     nil
   end
-  
+
   def set_meta(key, value)
     @ast_metadata ||= {}
     @ast_metadata[key] = value
@@ -65,7 +65,7 @@ def recursive_inject(results=[], &block)
   # and ignore the empty nodes.
   def recursive_select(*klasses)
     return recursive_inject { |e| klasses.any? {|k| e.is_a?(k)} }
-  end  
+  end
 
   def recursive_inject_parent(results=[], &block)
     if !parent.nil?
@@ -81,7 +81,7 @@ def recursive_inject_parent(results=[], &block)
   def recursive_select_parent(results=[], klass)
     return recursive_inject_parent(results) { |e| e.is_a?(klass) }
   end
-  
+
   # Monkeypatch Treetop::Runtime::SyntaxNode's inspect method to skip
   # any Whitespace or SyntaxNodes with no children.
   def _inspect(indent="")
diff --git a/logstash-core/lib/logstash/config/lir_serializer.rb b/logstash-core/lib/logstash/config/lir_serializer.rb
index 663d3ad506c..e3389cb6dfc 100644
--- a/logstash-core/lib/logstash/config/lir_serializer.rb
+++ b/logstash-core/lib/logstash/config/lir_serializer.rb
@@ -22,7 +22,7 @@ module LogStash;
   module Config;
   class LIRSerializer
     attr_reader :lir_pipeline
-    
+
     def self.serialize(lir_pipeline)
       self.new(lir_pipeline).serialize
     end
@@ -30,7 +30,7 @@ def self.serialize(lir_pipeline)
     def initialize(lir_pipeline)
       @lir_pipeline = lir_pipeline
     end
-    
+
     def serialize
       {
         "hash" => lir_pipeline.unique_hash,
@@ -42,24 +42,24 @@ def serialize
         }
       }
     end
-    
+
     def vertices
       graph.getVertices.map {|v| vertex(v) }.compact
     end
-    
+
     def edges
       remove_separators_from_edges(graph.getEdges)
     end
-    
+
     def graph
       lir_pipeline.graph
     end
-    
+
     def vertex(v)
-      hashified_vertex = case vertex_type(v) 
-                         when :plugin 
+      hashified_vertex = case vertex_type(v)
+                         when :plugin
                            plugin_vertex(v)
-                         when :if 
+                         when :if
                            if_vertex(v)
                          when :queue
                            queue_vertex(v)
@@ -69,7 +69,7 @@ def vertex(v)
 
       decorate_vertex(v, hashified_vertex) unless hashified_vertex.nil?
     end
-    
+
     def vertex_type(v)
       if v.kind_of?(org.logstash.config.ir.graph.PluginVertex)
         :plugin
@@ -83,7 +83,7 @@ def vertex_type(v)
         raise "Unexpected vertex type! #{v}"
       end
     end
-    
+
     def decorate_vertex(v, v_json)
       v_json["meta"] = format_swm(v.source_with_metadata)
       v_json["id"] = v.id
@@ -91,7 +91,7 @@ def decorate_vertex(v, v_json)
       v_json["type"] = vertex_type(v).to_s
       v_json
     end
-    
+
     def plugin_vertex(v)
       pd = v.plugin_definition
       {
@@ -99,17 +99,17 @@ def plugin_vertex(v)
         "plugin_type" => pd.getType.to_s.downcase
       }
     end
-    
+
     def if_vertex(v)
       {
         "condition" => v.humanReadableExpression
       }
     end
-    
+
     def queue_vertex(v)
       {}
     end
-    
+
     def separator_vertex(v)
       {}
     end
@@ -142,17 +142,17 @@ def edge(e)
         "to" => e.to.id,
         "id" => e.id
       }
-      
+
       if e.kind_of?(org.logstash.config.ir.graph.BooleanEdge)
         e_json["when"] = e.edge_type
         e_json["type"] = "boolean"
       else
         e_json["type"] = "plain"
       end
-      
+
       e_json
     end
-    
+
     def format_swm(source_with_metadata)
       return nil unless source_with_metadata
       {
@@ -166,7 +166,7 @@ def format_swm(source_with_metadata)
         }
       }
     end
-    
+
   end
   end
 end
diff --git a/logstash-core/lib/logstash/config/pipelines_info.rb b/logstash-core/lib/logstash/config/pipelines_info.rb
index ce38306c1b8..58a491d9be0 100644
--- a/logstash-core/lib/logstash/config/pipelines_info.rb
+++ b/logstash-core/lib/logstash/config/pipelines_info.rb
@@ -54,7 +54,7 @@ def self.format_pipeline_events(stats)
 
     def self.format_pipeline_vertex_stats(stats, pipeline)
       return nil unless stats
-      
+
       [:inputs, :filters, :outputs].flat_map do |section|
         format_pipeline_vertex_section_stats(stats[section], pipeline)
       end.select {|stats| !stats.nil?} # Ignore empty sections
@@ -70,13 +70,13 @@ def self.format_pipeline_vertex_stats(stats, pipeline)
 
     def self.format_pipeline_vertex_section_stats(stats, pipeline)
       return nil unless stats
-      
+
        (stats || {}).reduce([]) do |acc,kv|
         plugin_id, plugin_stats = kv
-        
+
         props = Hash.new {|h,k| h[k] = []}
         next unless plugin_stats
-        
+
         flattened = flatten_metrics(plugin_stats)
 
         segmented = flattened.reduce(Hash.new {|h,k| h[k] = []}) do |acc,kv|
@@ -124,7 +124,7 @@ def self.format_pipeline_vertex_section_stats(stats, pipeline)
 
     def self.flatten_metrics(hash_or_value, namespaces = [])
       if hash_or_value.is_a?(Hash)
-        return hash_or_value.reduce({}) do |acc,kv| 
+        return hash_or_value.reduce({}) do |acc,kv|
           k,v = kv
           # We must concat the arrays, creating a copy instead of mutation
           # to handle the case where there are multiple sibling metrics in a namespace
diff --git a/logstash-core/lib/logstash/instrument/metric_store.rb b/logstash-core/lib/logstash/instrument/metric_store.rb
index 3832a5dcf6c..c4401df0adb 100644
--- a/logstash-core/lib/logstash/instrument/metric_store.rb
+++ b/logstash-core/lib/logstash/instrument/metric_store.rb
@@ -136,7 +136,7 @@ def get_shallow(*key_paths)
 
 
     # Return a hash including the values of the keys given at the path given
-    # 
+    #
     # Example Usage:
     # extract_metrics(
     #   [:jvm, :process],
@@ -144,7 +144,7 @@ def get_shallow(*key_paths)
     #   [:cpu, [:total_in_millis, :percent]]
     #   [:pipelines, [:one, :two], :size]
     # )
-    # 
+    #
     # Returns:
     # # From the jvm.process metrics namespace
     # {
@@ -174,7 +174,7 @@ def extract_metrics(path, *keys)
           next_paths.each do |next_path|
             # If there already is a hash at this location use that so we don't overwrite it
             np_hash = acc[next_path] || {}
-            
+
             acc[next_path] = next_keys.reduce(np_hash) do |a,next_key|
               a.merge! extract_metrics(path + [next_path], [next_key, *rest])
             end
@@ -183,10 +183,10 @@ def extract_metrics(path, *keys)
           res = get_shallow(*path)[k]
           acc[k] = res ? res.value : nil
         end
-        
+
         acc
       end
-    end    
+    end
 
     def has_metric?(*path)
       @fast_lookup[path]
diff --git a/logstash-core/lib/logstash/patches/stronger_openssl_defaults.rb b/logstash-core/lib/logstash/patches/stronger_openssl_defaults.rb
index 55372a41731..ec0d124fca1 100644
--- a/logstash-core/lib/logstash/patches/stronger_openssl_defaults.rb
+++ b/logstash-core/lib/logstash/patches/stronger_openssl_defaults.rb
@@ -49,7 +49,7 @@ def self.__default_options
     # secure, so let's fix that here. The next few lines setting options and
     # ciphers come from jmhodges' proposed patch
     ssloptions = OpenSSL::SSL::OP_ALL
- 
+
     # TODO(sissel): JRuby doesn't have this. Maybe work on a fix?
     if defined?(OpenSSL::SSL::OP_DONT_INSERT_EMPTY_FRAGMENTS)
       ssloptions &= ~OpenSSL::SSL::OP_DONT_INSERT_EMPTY_FRAGMENTS
diff --git a/logstash-core/lib/logstash/util/thread_dump.rb b/logstash-core/lib/logstash/util/thread_dump.rb
index 8f18e56c30b..5a994dd6e5a 100644
--- a/logstash-core/lib/logstash/util/thread_dump.rb
+++ b/logstash-core/lib/logstash/util/thread_dump.rb
@@ -52,7 +52,7 @@ def idle_thread?(thread_name, data)
           # these are likely JVM dependent
           idle = true
         elsif thread_name.match(/Ruby-\d+-JIT-\d+/)
-          # This are internal JRuby JIT threads, 
+          # This are internal JRuby JIT threads,
           # see java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor for details.
           idle = true
         elsif thread_name.match(/pool-\d+-thread-\d+/)
diff --git a/logstash-core/spec/conditionals_spec.rb b/logstash-core/spec/conditionals_spec.rb
index ada9b51a652..6621b128f9a 100644
--- a/logstash-core/spec/conditionals_spec.rb
+++ b/logstash-core/spec/conditionals_spec.rb
@@ -583,28 +583,28 @@ def multi_receive(events)
       filter {
         if ("foo" in [tags]) {
           mutate { id => addbar add_tag => bar }
-      
+
           if ("bar" in [tags]) {
             mutate { id => addbaz  add_tag => baz }
           }
-      
+
           if ("baz" in [tags]) {
             mutate { id => addbot add_tag => bot }
-      
+
             if ("bot" in [tags]) {
               mutate { id => addbonk add_tag => bonk }
             }
           }
         }
-      
+
         if ("bot" in [tags]) {
           mutate { id => addwat add_tag => wat }
         }
-      
+
         mutate { id => addprev add_tag => prev }
-      
+
         mutate { id => addfinal add_tag => final }
-      
+
       }
     CONFIG
 
diff --git a/logstash-core/spec/logstash/agent/converge_spec.rb b/logstash-core/spec/logstash/agent/converge_spec.rb
index 52815d0139d..91a752f6a85 100644
--- a/logstash-core/spec/logstash/agent/converge_spec.rb
+++ b/logstash-core/spec/logstash/agent/converge_spec.rb
@@ -64,7 +64,7 @@
     end
 
     context "system pipeline" do
-      
+
       let(:system_pipeline_config) { mock_pipeline_config(:system_pipeline, "input { dummyblockinginput { } } output { null {} }", { "pipeline.system" => true }) }
 
       context "when we have a finite pipeline and a system pipeline running" do
diff --git a/logstash-core/spec/logstash/api/modules/plugins_spec.rb b/logstash-core/spec/logstash/api/modules/plugins_spec.rb
index b65fb8ec513..0ac158c194a 100644
--- a/logstash-core/spec/logstash/api/modules/plugins_spec.rb
+++ b/logstash-core/spec/logstash/api/modules/plugins_spec.rb
@@ -51,7 +51,7 @@
                 }
               ]
             },
-            "total" => { "type" => "number" } 
+            "total" => { "type" => "number" }
           },
           "required" => ["plugins", "total"]
         },
@@ -70,7 +70,7 @@
 
     it "return a list of available plugins" do
       payload["plugins"].each do |plugin|
-        expect do 
+        expect do
           Gem::Specification.find_by_name(plugin["name"])
         end.not_to raise_error
       end
diff --git a/logstash-core/spec/logstash/codecs/base_spec.rb b/logstash-core/spec/logstash/codecs/base_spec.rb
index e8cf4458737..ca4eb8fd357 100644
--- a/logstash-core/spec/logstash/codecs/base_spec.rb
+++ b/logstash-core/spec/logstash/codecs/base_spec.rb
@@ -57,14 +57,14 @@ def encode_sync(event)
   describe "encoding" do
     shared_examples "encoder types" do |codec_class|
       let(:klass) { codec_class }
-      
+
       describe "#{codec_class}" do
         describe "multi_encode" do
           it "should return an array of [event,data] tuples" do
             expect(instance.multi_encode([event,event])).to eq([encoded_tuple, encoded_tuple])
           end
         end
-        
+
         describe "#encode" do
           before do
             @result = nil
@@ -73,7 +73,7 @@ def encode_sync(event)
             end
             instance.encode(event)
           end
-          
+
           it "should yield the correct result" do
             expect(@result).to eq(encoded_tuple)
           end
@@ -87,4 +87,4 @@ def encode_sync(event)
   end
 end
 
-                          
+
diff --git a/logstash-core/spec/logstash/compiler/compiler_spec.rb b/logstash-core/spec/logstash/compiler/compiler_spec.rb
index e9f32c6a36b..3bb464bf019 100644
--- a/logstash-core/spec/logstash/compiler/compiler_spec.rb
+++ b/logstash-core/spec/logstash/compiler/compiler_spec.rb
@@ -60,7 +60,7 @@ def rand_meta
 
       let(:processed_value)  { 'The computer says, "No"' }
 
-      let(:source) { 
+      let(:source) {
         %q(
           input {
             foo {
@@ -133,7 +133,7 @@ def rand_meta
       describe "a plugin with mixed parameter types" do
         let(:plugin_source) { "generator { aarg => [1] hasharg => {foo => bar} iarg => 123 farg => 123.123 sarg => 'hello'}" }
         let(:expected_plugin_args) do
-          { 
+          {
             "aarg" => [1],
             "hasharg" => {"foo" => "bar"},
             "iarg" => 123,
@@ -414,21 +414,21 @@ def compose(*statements)
           j.iComposeParallel(*statements)
         end
       end
-      
+
       describe "multiple section declarations" do
         let(:source) do
           <<-EOS
             #{section} {
               aplugin { count => 1 }
             }
-            
+
             #{section} {
               aplugin { count => 2 }
             }
           EOS
         end
-        
-        
+
+
         it "should contain both section declarations, in order" do
           expect(compiled_section).to ir_eql(compose(
                                       splugin("aplugin", {"count" => 1}),
@@ -662,11 +662,11 @@ def compose(*statements)
               it "should compile correctly" do
                 expect(c_expression).to ir_eql(j.eRegexEq(j.eEventValue("[foo]"), j.eRegex('^abc$')))
               end
-              
+
               # Believe it or not, "\.\." is a valid regexp!
               describe "when given a quoted regexp" do
                 let(:expression) { '[foo] =~ "\\.\\."' }
-              
+
                 it "should compile correctly" do
                   expect(c_expression).to ir_eql(j.eRegexEq(j.eEventValue("[foo]"), j.eRegex('\\.\\.')))
                 end
diff --git a/logstash-core/spec/logstash/config/config_ast_spec.rb b/logstash-core/spec/logstash/config/config_ast_spec.rb
index 8a9ed6deabc..85ca84a3f37 100644
--- a/logstash-core/spec/logstash/config/config_ast_spec.rb
+++ b/logstash-core/spec/logstash/config/config_ast_spec.rb
@@ -75,7 +75,7 @@
         }
       CONFIG
       subject { LogStashConfigParser.new }
-         
+
       it "should compile successfully" do
         result = subject.parse(config)
         expect(result).not_to(be_nil)
diff --git a/logstash-core/spec/logstash/java_pipeline_spec.rb b/logstash-core/spec/logstash/java_pipeline_spec.rb
index 949d5ac0724..f8c559cbfbb 100644
--- a/logstash-core/spec/logstash/java_pipeline_spec.rb
+++ b/logstash-core/spec/logstash/java_pipeline_spec.rb
@@ -1098,8 +1098,8 @@ def flush(options)
       }
       filter {
        clone {
-          add_field => { 
-            'cloned' =>  'cloned' 
+          add_field => {
+            'cloned' =>  'cloned'
           }
           clones => ["clone1"]
         }
diff --git a/logstash-core/spec/logstash/plugins/builtin/pipeline_input_output_spec.rb b/logstash-core/spec/logstash/plugins/builtin/pipeline_input_output_spec.rb
index d410a4674d0..97de62702db 100644
--- a/logstash-core/spec/logstash/plugins/builtin/pipeline_input_output_spec.rb
+++ b/logstash-core/spec/logstash/plugins/builtin/pipeline_input_output_spec.rb
@@ -60,7 +60,7 @@ def wait_input_running(input_plugin)
     def start_input
       input.register
 
-      @input_thread = Thread.new do 
+      @input_thread = Thread.new do
         input.run(queue)
       end
 
@@ -122,7 +122,7 @@ def stop_input
         end
 
       end
-      
+
       after(:each) do
         stop_input
         output.do_close
@@ -183,7 +183,7 @@ def stop_input
         output.register
 
         @input_threads = inputs_queues.map do |input_plugin,input_queue|
-          Thread.new do 
+          Thread.new do
             input_plugin.run(input_queue)
           end
         end
@@ -234,7 +234,7 @@ def stop_input
           expect(inputs_queues[other_input].size).to eql(0)
         end
       end
-      
+
       after(:each) do
         inputs.each(&:do_stop)
         inputs.each(&:do_close)
diff --git a/logstash-core/spec/logstash/settings/writable_directory_spec.rb b/logstash-core/spec/logstash/settings/writable_directory_spec.rb
index d1dd8ad4dce..ca2ada2af78 100644
--- a/logstash-core/spec/logstash/settings/writable_directory_spec.rb
+++ b/logstash-core/spec/logstash/settings/writable_directory_spec.rb
@@ -50,8 +50,8 @@
     context "when the directory is missing" do
 
       context "and the parent is writable" do
-        after { 
-          Dir.unlink(path) 
+        after {
+          Dir.unlink(path)
         }
         it "creates the directory" do
           subject.value # need to invoke `#value` to make it do the work.
@@ -104,7 +104,7 @@
         it_behaves_like "failure"
       end unless LogStash::Environment.windows?
 
-      
+
       context "but is a symlink" do
         before { FileUtils.symlink("whatever", path) }
         it_behaves_like "failure"
diff --git a/logstash-core/spec/logstash/settings_spec.rb b/logstash-core/spec/logstash/settings_spec.rb
index 73f7a15b978..b3962322f4a 100644
--- a/logstash-core/spec/logstash/settings_spec.rb
+++ b/logstash-core/spec/logstash/settings_spec.rb
@@ -125,10 +125,10 @@
       expect(settings.names).to contain_exactly("one.two.three", "this.that")
     end
   end
-  
+
   describe "post_process" do
     subject(:settings) { described_class.new }
-    
+
     before do
       settings.on_post_process do
         settings.set("baz", "bot")
@@ -137,11 +137,11 @@
       settings.register(LogStash::Setting::String.new("baz", "somedefault"))
       settings.post_process
     end
-    
+
     it "should run the post process callbacks" do
       expect(settings.get("baz")).to eq("bot")
     end
-    
+
     it "should preserve original settings" do
       expect(settings.get("foo")).to eq("bar")
     end
@@ -204,7 +204,7 @@
         ENV.delete('some.logstash.spec.env.var')
         ENV.delete('a')
       end
-      
+
       subject do
         settings = described_class.new
         settings.register(LogStash::Setting::String.new("interpolated_env", "missing"))
diff --git a/logstash-core/spec/logstash/util/java_version_spec.rb b/logstash-core/spec/logstash/util/java_version_spec.rb
index 6718ce15f05..7cb4446149d 100644
--- a/logstash-core/spec/logstash/util/java_version_spec.rb
+++ b/logstash-core/spec/logstash/util/java_version_spec.rb
@@ -36,15 +36,15 @@
   it "should mark java 7 version as bad" do
     expect(mod.bad_java_version?("1.7.0_51")).to be_truthy
   end
-  
+
   it "should mark java version 8 as good" do
     expect(mod.bad_java_version?("1.8.0")).to be_falsey
   end
-  
+
   it "should mark a good standard java version as good" do
     expect(mod.bad_java_version?("1.8.0_65")).to be_falsey
   end
-  
+
   it "should mark a good beta version as good" do
     expect(mod.bad_java_version?("1.8.0-beta")).to be_falsey
   end
diff --git a/qa/acceptance/spec/lib/cli_operation_spec.rb b/qa/acceptance/spec/lib/cli_operation_spec.rb
index 928ca9cfdf7..4d73008b6cf 100644
--- a/qa/acceptance/spec/lib/cli_operation_spec.rb
+++ b/qa/acceptance/spec/lib/cli_operation_spec.rb
@@ -25,7 +25,7 @@
 require_relative "../shared_examples/cli/logstash-plugin/generate"
 require_relative "../shared_examples/cli/logstash-plugin/integration_plugin"
 
-# This is the collection of test for the CLI interface, this include the plugin manager behaviour, 
+# This is the collection of test for the CLI interface, this include the plugin manager behaviour,
 # it also include the checks for other CLI options.
 describe "CLI operation" do
   config = ServiceTester.configuration
diff --git a/qa/integration/framework/settings.rb b/qa/integration/framework/settings.rb
index 74402e5beb1..c2e0bfe231d 100644
--- a/qa/integration/framework/settings.rb
+++ b/qa/integration/framework/settings.rb
@@ -32,11 +32,11 @@ def initialize(test_file_path)
     @suite_settings = YAML.load(ERB.new(File.new(SUITE_SETTINGS_FILE).read).result)
     # Per test settings, where one can override stuff and define test specific config
     @test_settings = YAML.load_file(@tests_settings_file)
-    
+
     if verbose_mode?
       puts "Test settings file: #{@tests_settings_file}"
       puts "Suite settings file: #{SUITE_SETTINGS_FILE}"
-    end  
+    end
 
     if is_set?("config")
       if get("config").is_a?(Hash)
@@ -59,10 +59,10 @@ def get(key)
       @suite_settings[key]
     end
   end
-  
+
   def verbose_mode?
     @suite_settings["verbose_mode"]
-  end  
+  end
 
   def is_set?(key)
     @suite_settings.key?(key) || @test_settings.key?(key)
diff --git a/qa/integration/services/monitoring_api.rb b/qa/integration/services/monitoring_api.rb
index 5f15fc25aaa..50b37a82cda 100644
--- a/qa/integration/services/monitoring_api.rb
+++ b/qa/integration/services/monitoring_api.rb
@@ -39,7 +39,7 @@ def version
     r = JSON.parse(response.body.read)
     r["version"]
   end
-  
+
   def node_info
     resp = Manticore.get("http://localhost:9600/_node").body
     JSON.parse(resp)
diff --git a/qa/integration/specs/cli/install_spec.rb b/qa/integration/specs/cli/install_spec.rb
index 7dc65f3c11b..06ba4d42efc 100644
--- a/qa/integration/specs/cli/install_spec.rb
+++ b/qa/integration/specs/cli/install_spec.rb
@@ -116,7 +116,7 @@ def gem_in_lock_file?(pattern, lock_file)
         end
       end
     end
-    
+
     context "install non bundle plugin" do
       let(:plugin_name) { "logstash-input-github" }
       let(:install_command) { "bin/logstash-plugin install" }
diff --git a/qa/integration/specs/env_variables_condition_spec.rb b/qa/integration/specs/env_variables_condition_spec.rb
index a0d0ae320c8..e708d76ae33 100644
--- a/qa/integration/specs/env_variables_condition_spec.rb
+++ b/qa/integration/specs/env_variables_condition_spec.rb
@@ -48,7 +48,7 @@
   after(:each) {
     @logstash.teardown
   }
-  
+
   let(:num_retries) { 50 }
   let(:test_path) { Stud::Temporary.directory }
   let(:test_env) {
@@ -95,4 +95,4 @@
     expect(logstash.stderr_and_stdout).to match(/Cannot evaluate `\$\{NOT_EXIST\}`/)
     expect(logstash.exit_code).to be(1)
   end
-end  
\ No newline at end of file
+end
\ No newline at end of file
diff --git a/qa/integration/specs/env_variables_config_spec.rb b/qa/integration/specs/env_variables_config_spec.rb
index 248d8c35280..1ff5917bc15 100644
--- a/qa/integration/specs/env_variables_config_spec.rb
+++ b/qa/integration/specs/env_variables_config_spec.rb
@@ -29,7 +29,7 @@
   after(:all) {
     @fixture.teardown
   }
-  
+
   let(:num_retries) { 50 }
   let(:test_tcp_port) { random_port }
   let(:test_tag) { "environment_variables_are_evil" }
@@ -42,7 +42,7 @@
     test_env["TEST_ENV_TCP_PORT"] = "#{test_tcp_port}"
     test_env["TEST_ENV_TAG"] = test_tag
     test_env["TEST_ENV_PATH"] = test_path
-    
+
     logstash_service = @fixture.get_service("logstash")
     logstash_service.env_variables = test_env
     logstash_service.start_background(@fixture.config)
@@ -50,7 +50,7 @@
     try(num_retries) do
       expect(is_port_open?(test_tcp_port)).to be true
     end
-    
+
     #send data and make sure all env variables are expanded by checking each stage
     send_data(test_tcp_port, sample_data)
     output_file = File.join(test_path, "logstash_env_test.log")
@@ -62,4 +62,4 @@
       expect(IO.read(output_file).gsub("\n", "")).to eq("#{sample_data} blah,environment_variables_are_evil")
     end
   end
-end  
\ No newline at end of file
+end
\ No newline at end of file
diff --git a/qa/integration/specs/es_output_how_spec.rb b/qa/integration/specs/es_output_how_spec.rb
index aa7e76cf648..d0fb054d22d 100644
--- a/qa/integration/specs/es_output_how_spec.rb
+++ b/qa/integration/specs/es_output_how_spec.rb
@@ -60,7 +60,7 @@
     es_client.indices.refresh
     result = es_client.search(index: 'logstash-*', size: 0, q: '*')
     expect(result).to have_hits(37)
-    
+
     # randomly checked for results and structured fields
     result = es_client.search(index: 'logstash-*', size: 1, q: 'dynamic')
     expect(result).to have_hits(1)
diff --git a/qa/integration/specs/monitoring_api_spec.rb b/qa/integration/specs/monitoring_api_spec.rb
index de22f2c030d..71bb5be6cad 100644
--- a/qa/integration/specs/monitoring_api_spec.rb
+++ b/qa/integration/specs/monitoring_api_spec.rb
@@ -30,11 +30,11 @@
   after(:all) {
     @fixture.teardown
   }
-  
+
   after(:each) {
     @fixture.get_service("logstash").teardown
   }
-  
+
   let(:number_of_events) { 5 }
   let(:max_retry) { 120 }
   let(:plugins_config) { "input { stdin {} } filter { mutate { add_tag => 'integration test adding tag' } } output { stdout {} }" }
diff --git a/qa/integration/specs/multiple_pipeline_spec.rb b/qa/integration/specs/multiple_pipeline_spec.rb
index de13917cfd1..ce519ae21ac 100644
--- a/qa/integration/specs/multiple_pipeline_spec.rb
+++ b/qa/integration/specs/multiple_pipeline_spec.rb
@@ -125,7 +125,7 @@
 
   describe "inter-pipeline communication" do
     let(:count) { 2 }
-    let(:pipelines) do 
+    let(:pipelines) do
       [
         {
           "pipeline.id" => "test",
diff --git a/qa/integration/specs/reload_config_spec.rb b/qa/integration/specs/reload_config_spec.rb
index 07ae7481ae0..b210def0bcf 100644
--- a/qa/integration/specs/reload_config_spec.rb
+++ b/qa/integration/specs/reload_config_spec.rb
@@ -35,7 +35,7 @@
   after(:all) {
     @fixture.teardown
   }
-  
+
   let(:timeout_seconds) { 5 }
   let(:initial_port) { random_port }
   let(:reload_port) { random_port }
@@ -43,7 +43,7 @@
   let(:output_file1) { Stud::Temporary.file.path }
   let(:output_file2) { Stud::Temporary.file.path }
   let(:sample_data) { '74.125.176.147 - - [11/Sep/2014:21:50:37 +0000] "GET /?flav=rss20 HTTP/1.1" 200 29941 "-" "FeedBurner/1.0 (http://www.FeedBurner.com)"' }
-  
+
   let(:initial_config_file) { config_to_temp_file(@fixture.config("initial", { :port => initial_port, :file => output_file1 })) }
   let(:reload_config_file) { config_to_temp_file(@fixture.config("reload", { :port => reload_port, :file => output_file2 })) }
 
@@ -54,13 +54,13 @@
     logstash_service.spawn_logstash("-f", "#{initial_config_file}", "--config.reload.automatic", "true")
     logstash_service.wait_for_logstash
     wait_for_port(initial_port, retry_attempts)
-    
+
     # try sending events with this
     send_data(initial_port, sample_data)
     Stud.try(retry_attempts.times, RSpec::Expectations::ExpectationNotMetError) do
       expect(IO.read(output_file1).gsub("\n", "")).to eq(sample_data)
     end
-    
+
     # check metrics
     result = logstash_service.monitoring_api.event_stats
     expect(result["in"]).to eq(1)
@@ -77,7 +77,7 @@
 
     logstash_service.wait_for_logstash
     wait_for_port(reload_port, retry_attempts)
-    
+
     # make sure old socket is closed
     expect(is_port_open?(initial_port)).to be false
 
@@ -98,7 +98,7 @@
     Stud.try(retry_attempts.times, RSpec::Expectations::ExpectationNotMetError) do
       expect(LogStash::Util.blank?(IO.read(output_file2))).to be false
     end
-    
+
     # check instance metrics. It should not be reset
     instance_event_stats = logstash_service.monitoring_api.event_stats
     expect(instance_event_stats["in"]).to eq(2)
@@ -143,7 +143,7 @@
     expect(pipeline_reload_stats["failures"]).to eq(0)
     expect(LogStash::Util.blank?(pipeline_reload_stats["last_success_timestamp"])).to be false
     expect(pipeline_reload_stats["last_error"]).to eq(nil)
-    
+
     expect(instance_reload_stats["successes"]).to eq(1)
     expect(instance_reload_stats["failures"]).to eq(0)
     # parse the results and validate
diff --git a/qa/platform_config.rb b/qa/platform_config.rb
index 3e7d5114aed..df0f2151891 100644
--- a/qa/platform_config.rb
+++ b/qa/platform_config.rb
@@ -18,7 +18,7 @@
 require "json"
 require "ostruct"
 
-# This is a wrapper to encapsulate the logic behind the different platforms we test with, 
+# This is a wrapper to encapsulate the logic behind the different platforms we test with,
 # this is done here in order to simplify the necessary configuration for bootstrap and interactions
 # necessary later on in the tests phases.
 #
diff --git a/qa/rspec/commands.rb b/qa/rspec/commands.rb
index d79bb7817f4..c2eaa63678a 100644
--- a/qa/rspec/commands.rb
+++ b/qa/rspec/commands.rb
@@ -28,7 +28,7 @@
 module ServiceTester
 
   # An artifact is the component being tested, it's able to interact with
-  # a destination machine by holding a client and is basically provides all 
+  # a destination machine by holding a client and is basically provides all
   # necessary abstractions to make the test simple.
   class Artifact
 
@@ -103,7 +103,7 @@ def gem_vendored?(gem_name)
     def download(from, to)
       client.download(from, to , host)
     end
-    
+
     def replace_in_gemfile(pattern, replace)
       client.replace_in_gemfile(pattern, replace, host)
     end
diff --git a/qa/rspec/commands/redhat.rb b/qa/rspec/commands/redhat.rb
index 9374131d1e7..f61cbaf486d 100644
--- a/qa/rspec/commands/redhat.rb
+++ b/qa/rspec/commands/redhat.rb
@@ -53,7 +53,7 @@ def install(package, host=nil)
         exit_status += cmd.exit_status
         errors << cmd.stderr unless cmd.stderr.empty?
       end
-      if exit_status > 0 
+      if exit_status > 0
         raise InstallException.new("Error installing #{package}, #{errors.join('\n')}")
       end
     end
diff --git a/qa/rspec/commands/system_helpers.rb b/qa/rspec/commands/system_helpers.rb
index 3752316b7e5..f0b4159346a 100644
--- a/qa/rspec/commands/system_helpers.rb
+++ b/qa/rspec/commands/system_helpers.rb
@@ -65,6 +65,6 @@ def service_manager(service, action, host=nil)
       at(hosts, {in: :serial}) do |_|
         sudo_exec!("initctl #{action} #{service}")
       end
-    end 
+    end
   end
 end
diff --git a/qa/vagrant/helpers.rb b/qa/vagrant/helpers.rb
index e99480cd3ac..1af0a47cfca 100644
--- a/qa/vagrant/helpers.rb
+++ b/qa/vagrant/helpers.rb
@@ -29,7 +29,7 @@ def self.halt(machines=[], options={})
 
     def self.destroy(machines=[], options={})
       debug = options.fetch(:debug, false)
-      CommandExecutor.run!("vagrant destroy --force #{machines.join(' ')}", debug) 
+      CommandExecutor.run!("vagrant destroy --force #{machines.join(' ')}", debug)
     end
 
     def self.bootstrap(machines=[], options={})
diff --git a/rakelib/plugins_docs_dependencies.rake b/rakelib/plugins_docs_dependencies.rake
index b9ef6224141..6aa6f4513ed 100644
--- a/rakelib/plugins_docs_dependencies.rake
+++ b/rakelib/plugins_docs_dependencies.rake
@@ -185,11 +185,11 @@ task :generate_plugins_version do
   # to this helper cause each new closures to reference the previous one. The size of each binding
   # accumulates and OOM occurs after 70-100 iterations.
   # This is easy to replicate by looping over `Bundler::SharedHelpers.trap("INT") { 1 }`.
-  # 
+  #
   # This workaround removes the capture of the previous binding. Not calling all the previous handlers
-  # may cause some threads to not be cleaned up, but this rake task has a short life so everything 
+  # may cause some threads to not be cleaned up, but this rake task has a short life so everything
   # ends up being cleaned up on exit anyway.
-  # We're confining this patch to this task only as this is the only place where we need to resolve 
+  # We're confining this patch to this task only as this is the only place where we need to resolve
   # dependencies many many times.
   #
   # You're still here? You're awesome :) Thanks for reading!
diff --git a/rakelib/test.rake b/rakelib/test.rake
index 1d884e3c905..2ba4c9f12e9 100644
--- a/rakelib/test.rake
+++ b/rakelib/test.rake
@@ -39,7 +39,7 @@ namespace "test" do
 
   desc "run all core specs"
   task "core" => ["core-slow"]
-  
+
   def default_spec_command
     ["bin/rspec", "-fd", "--pattern", "spec/unit/**/*_spec.rb,logstash-core/spec/**/*_spec.rb"]
   end
diff --git a/spec/unit/plugin_manager/prepare_offline_pack_spec.rb b/spec/unit/plugin_manager/prepare_offline_pack_spec.rb
index 2685d85e21f..e4f02f45e02 100644
--- a/spec/unit/plugin_manager/prepare_offline_pack_spec.rb
+++ b/spec/unit/plugin_manager/prepare_offline_pack_spec.rb
@@ -131,7 +131,7 @@
         end
 
         it "should fails" do
-          # ignore the first path part of tmp_zip_file because on Windows the long path is shrinked in the exception message 
+          # ignore the first path part of tmp_zip_file because on Windows the long path is shrinked in the exception message
           expect { subject.run(cmd_args) }.to raise_error Clamp::ExecutionError, /output file destination .+#{::File.basename(tmp_zip_file)} already exist/
         end
       end
diff --git a/tools/paquet/lib/paquet/gem.rb b/tools/paquet/lib/paquet/gem.rb
index 6c59f18e46a..693433b17b3 100644
--- a/tools/paquet/lib/paquet/gem.rb
+++ b/tools/paquet/lib/paquet/gem.rb
@@ -111,7 +111,7 @@ def resolve_dependencies(name)
     end
 
     def gem_full_name(gem)
-      gem.ruby? ? "#{gem.name}-#{gem.version}.gem" : "#{gem.name}-#{gem.version}-#{gem.platform}.gem" 
+      gem.ruby? ? "#{gem.name}-#{gem.version}.gem" : "#{gem.name}-#{gem.version}-#{gem.platform}.gem"
     end
 
     def download_gem(gem_name)
diff --git a/x-pack/lib/filters/geoip/database_metadata.rb b/x-pack/lib/filters/geoip/database_metadata.rb
index a2f70d4ef52..d397d98337d 100644
--- a/x-pack/lib/filters/geoip/database_metadata.rb
+++ b/x-pack/lib/filters/geoip/database_metadata.rb
@@ -89,7 +89,7 @@ def is_eula(database_type)
   def dirnames
     get_all.map { |metadata| metadata[Column::DIRNAME] }
   end
-  
+
   def exist?
     file_exist?(@metadata_path)
   end
diff --git a/x-pack/lib/filters/geoip/download_manager.rb b/x-pack/lib/filters/geoip/download_manager.rb
index fe743cedb18..4c8e7febfd5 100644
--- a/x-pack/lib/filters/geoip/download_manager.rb
+++ b/x-pack/lib/filters/geoip/download_manager.rb
@@ -58,7 +58,7 @@ def fetch_database
         end
       end
   end
-  
+
   private
   # Call infra endpoint to get md5 of latest databases and verify with metadata
   # return Array of new database information [database_type, db_info]
diff --git a/x-pack/lib/monitoring/inputs/metrics.rb b/x-pack/lib/monitoring/inputs/metrics.rb
index 63abb067907..fffa1445713 100644
--- a/x-pack/lib/monitoring/inputs/metrics.rb
+++ b/x-pack/lib/monitoring/inputs/metrics.rb
@@ -18,14 +18,14 @@ module LogStash module Inputs
   class Metrics < LogStash::Inputs::Base
     require "monitoring/inputs/metrics/state_event_factory"
     require "monitoring/inputs/metrics/stats_event_factory"
-    
+
     @pipelines_mutex = Mutex.new
     @pipelines = {}
 
     require "monitoring/inputs/timer_task_logger"
-    
+
     attr_reader :queue, :agent
-  
+
     config_name "metrics"
 
     # Polling frequency in seconds on the metric store
diff --git a/x-pack/qa/integration/management/multiple_pipelines_spec.rb b/x-pack/qa/integration/management/multiple_pipelines_spec.rb
index f6a8cbb85f7..a9c885f7098 100644
--- a/x-pack/qa/integration/management/multiple_pipelines_spec.rb
+++ b/x-pack/qa/integration/management/multiple_pipelines_spec.rb
@@ -110,7 +110,7 @@ def count_hashes(pipelines)
     elasticsearch_client.indices.refresh
 
     query = {
-      "size": 0, 
+      "size": 0,
       "query": {
         "term": {
           "type": {
@@ -138,7 +138,7 @@ def count_hashes(pipelines)
 
     begin
       res = elasticsearch_client.search(index: '.monitoring-logstash-*', body: query)
-    rescue Elasticsearch::Transport::Transport::Errors::ServiceUnavailable 
+    rescue Elasticsearch::Transport::Transport::Errors::ServiceUnavailable
       return nil
     end
 
diff --git a/x-pack/qa/integration/support/shared_examples.rb b/x-pack/qa/integration/support/shared_examples.rb
index d1465051d99..5c8a54f00f3 100644
--- a/x-pack/qa/integration/support/shared_examples.rb
+++ b/x-pack/qa/integration/support/shared_examples.rb
@@ -28,7 +28,7 @@
     end
   end
 
-  describe "state" do 
+  describe "state" do
     let(:schema_file) { File.join(schemas_path, "states_document_schema.json") }
 
     it "records state on es" do
diff --git a/x-pack/spec/license_checker/license_reader_spec.rb b/x-pack/spec/license_checker/license_reader_spec.rb
index 13da437ea6d..f9b731f0de8 100644
--- a/x-pack/spec/license_checker/license_reader_spec.rb
+++ b/x-pack/spec/license_checker/license_reader_spec.rb
@@ -74,7 +74,7 @@
         # set up expectation of single failure
         expect(subject.logger).to receive(:warn).with(a_string_starting_with("Attempt to validate Elasticsearch license failed."), any_args)
         expect(mock_client).to receive(:get).with('_xpack').and_raise(host_not_reachable).once
-        
+
         # ensure subsequent success
         expect(mock_client).to receive(:get).with('_xpack').and_return(xpack_info)
       end
diff --git a/x-pack/spec/modules/arcsight/arcsight_module_config_spec.rb b/x-pack/spec/modules/arcsight/arcsight_module_config_spec.rb
index d4d1fc93535..413d761004c 100644
--- a/x-pack/spec/modules/arcsight/arcsight_module_config_spec.rb
+++ b/x-pack/spec/modules/arcsight/arcsight_module_config_spec.rb
@@ -5,7 +5,7 @@
 require 'logstash/modules/scaffold'
 require 'arcsight_module_config_helper'
 
-describe "ArcSight module" do 
+describe "ArcSight module" do
   let(:logstash_config_class) { LogStash::Modules::LogStashConfig  }
   let(:module_name) { "arcsight" }
   let(:module_path) { ::File.join(LogStash::Environment::LOGSTASH_HOME, "x-pack", "modules", module_name, "configuration") }
diff --git a/x-pack/spec/modules/azure/filters/azure_event_spec.rb b/x-pack/spec/modules/azure/filters/azure_event_spec.rb
index 2389bacc790..fa739118c06 100644
--- a/x-pack/spec/modules/azure/filters/azure_event_spec.rb
+++ b/x-pack/spec/modules/azure/filters/azure_event_spec.rb
@@ -51,7 +51,7 @@
         <<-CONFIG
       filter {
         azure_event {
-          # allow default 
+          # allow default
         }
       }
         CONFIG
diff --git a/x-pack/spec/monitoring/inputs/metrics/state_event/lir_serializer_spec.rb b/x-pack/spec/monitoring/inputs/metrics/state_event/lir_serializer_spec.rb
index beafe3bd67c..0a703bb6f21 100644
--- a/x-pack/spec/monitoring/inputs/metrics/state_event/lir_serializer_spec.rb
+++ b/x-pack/spec/monitoring/inputs/metrics/state_event/lir_serializer_spec.rb
@@ -9,9 +9,9 @@
   let(:config) do
     <<-EOC
       input { fake_input {} }
-      filter { 
+      filter {
         if ([foo] < 2) {
-          fake_filter {} 
+          fake_filter {}
         }
       }
       output { fake_output {} }
