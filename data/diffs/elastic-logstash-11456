diff --git a/logstash-core/lib/logstash/compiler.rb b/logstash-core/lib/logstash/compiler.rb
index 6cd68b280e0..d22c33936b3 100644
--- a/logstash-core/lib/logstash/compiler.rb
+++ b/logstash-core/lib/logstash/compiler.rb
@@ -6,8 +6,14 @@
 module LogStash; class Compiler
   include ::LogStash::Util::Loggable
 
+   def self.empty_or_space(str)
+     str.match(/\A\s*\Z/).nil? == false
+   end
+
   def self.compile_sources(sources_with_metadata, support_escapes)
-    graph_sections = sources_with_metadata.map do |swm|
+    graph_sections = sources_with_metadata.reject do |swm|
+       self.empty_or_space(swm.text)
+    end.map do |swm|
       self.compile_graph(swm, support_escapes)
     end
 
diff --git a/logstash-core/lib/logstash/config/config_ast.rb b/logstash-core/lib/logstash/config/config_ast.rb
index 1d0019616b5..67e88ff6e5a 100644
--- a/logstash-core/lib/logstash/config/config_ast.rb
+++ b/logstash-core/lib/logstash/config/config_ast.rb
@@ -233,12 +233,12 @@ def compile_initializer
       # If any parent is a Plugin, this must be a codec.
 
       if attributes.elements.nil?
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, #{source_meta.line}, #{source_meta.column})" << (plugin_type == "codec" ? "" : "\n")
+        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, line_to_source(#{source_meta.line}, #{source_meta.column}))" << (plugin_type == "codec" ? "" : "\n")
       else
         settings = attributes.recursive_select(Attribute).collect(&:compile).reject(&:empty?)
 
         attributes_code = "LogStash::Util.hash_merge_many(#{settings.map { |c| "{ #{c} }" }.join(", ")})"
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, #{source_meta.line}, #{source_meta.column}, #{attributes_code})" << (plugin_type == "codec" ? "" : "\n")
+        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, line_to_source(#{source_meta.line}, #{source_meta.column}), #{attributes_code})" << (plugin_type == "codec" ? "" : "\n")
       end
     end
 
@@ -255,7 +255,7 @@ def compile
       when "codec"
         settings = attributes.recursive_select(Attribute).collect(&:compile).reject(&:empty?)
         attributes_code = "LogStash::Util.hash_merge_many(#{settings.map { |c| "{ #{c} }" }.join(", ")})"
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, #{source_meta.line}, #{source_meta.column}, #{attributes_code})"
+        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, line_to_source(#{source_meta.line}, #{source_meta.column}), #{attributes_code})"
       end
     end
 
diff --git a/logstash-core/lib/logstash/config/pipeline_config.rb b/logstash-core/lib/logstash/config/pipeline_config.rb
index d93b444b4e5..268345271ab 100644
--- a/logstash-core/lib/logstash/config/pipeline_config.rb
+++ b/logstash-core/lib/logstash/config/pipeline_config.rb
@@ -5,6 +5,8 @@ module LogStash module Config
   class PipelineConfig
     include LogStash::Util::Loggable
 
+    LineToSource = Struct.new("LineToSource", :bounds, :source)
+
     attr_reader :source, :pipeline_id, :config_parts, :settings, :read_at
 
     def initialize(source, pipeline_id, config_parts, settings)
@@ -44,5 +46,30 @@ def display_debug_information
       logger.debug("Merged config")
       logger.debug("\n\n#{config_string}")
     end
+
+    def lookup_source(global_line_number, source_column)
+      res = source_references.find { |line_to_source| line_to_source.bounds.include? global_line_number }
+      if res == nil
+        raise IndexError, "can't find the config segment related to line #{global_line_number}"
+      end
+      swm = res.source
+      SourceWithMetadata.new(swm.getProtocol(), swm.getId(), global_line_number + 1 - res.bounds.begin, source_column, swm.getText())
+    end
+
+    private
+    def source_references
+      @source_refs ||= begin
+        offset = 0
+        source_refs = []
+        config_parts.each do |config_part|
+          #line numbers starts from 1 in text files
+          lines_range = (config_part.getLine() + offset + 1..config_part.getLinesCount() + offset)
+          source_segment = LineToSource.new(lines_range, config_part)
+          source_refs << source_segment
+          offset += config_part.getLinesCount()
+        end
+        source_refs.freeze
+      end
+    end
   end
 end end
diff --git a/logstash-core/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
index 181c8fed17f..f182c49cdf4 100644
--- a/logstash-core/lib/logstash/pipeline.rb
+++ b/logstash-core/lib/logstash/pipeline.rb
@@ -54,6 +54,10 @@ def initialize(pipeline_config, namespaced_metric = nil, agent = nil)
     end
   end
 
+  def line_to_source(line, column)
+    pipeline_config.lookup_source(line, column)
+  end
+
   def reloadable?
     configured_as_reloadable? && reloadable_plugins?
   end
@@ -69,8 +73,8 @@ def non_reloadable_plugins
   private
 
 
-  def plugin(plugin_type, name, line, column, *args)
-    @plugin_factory.plugin(plugin_type, name, line, column, *args)
+  def plugin(plugin_type, name, source, *args)
+    @plugin_factory.plugin(plugin_type, name, source, *args)
   end
 
   def default_logging_keys(other_keys = {})
diff --git a/logstash-core/spec/logstash/compiler/compiler_spec.rb b/logstash-core/spec/logstash/compiler/compiler_spec.rb
index 8e614332fe8..160f1c5ed84 100644
--- a/logstash-core/spec/logstash/compiler/compiler_spec.rb
+++ b/logstash-core/spec/logstash/compiler/compiler_spec.rb
@@ -32,6 +32,24 @@ def rand_meta
     end
   end
 
+  describe "compile with empty source" do
+    subject(:source_id) { "fake_sourcefile" }
+    let(:source_with_metadata) { org.logstash.common.SourceWithMetadata.new(source_protocol, source_id, 0, 0, source) }
+    subject(:compiled) { puts "PCOMP"; described_class.compile_pipeline(source_with_metadata, settings) }
+
+    let(:sources_with_metadata) do
+      [
+        org.logstash.common.SourceWithMetadata.new("str", "in_plugin", 0, 0, "input { input_0 {} } "),
+        org.logstash.common.SourceWithMetadata.new("str", "out_plugin", 0, 0, "output { output_0 {} } "),
+        org.logstash.common.SourceWithMetadata.new("str", "<empty>", 0, 0, "     ")
+      ]
+    end
+
+    it "should compile only the text parts" do
+      described_class.compile_sources(sources_with_metadata, false)
+    end
+  end
+
   describe "compiling to Pipeline" do
     subject(:source_id) { "fake_sourcefile" }
     let(:source_with_metadata) { org.logstash.common.SourceWithMetadata.new(source_protocol, source_id, 0, 0, source) }
diff --git a/logstash-core/spec/logstash/config/config_ast_spec.rb b/logstash-core/spec/logstash/config/config_ast_spec.rb
index 17d0ba61b21..7e1d5edf2ea 100644
--- a/logstash-core/spec/logstash/config/config_ast_spec.rb
+++ b/logstash-core/spec/logstash/config/config_ast_spec.rb
@@ -209,6 +209,7 @@ def initialize(config, settings)
           eval(@code)
         end
         def plugin(*args);end
+        def line_to_source(*args);end
       end
     end
     context "(filters)" do
@@ -262,6 +263,7 @@ def initialize(config, settings)
           eval(@code)
         end
         def plugin(*args);end
+        def line_to_source(*args);end
       end
     end
 
diff --git a/logstash-core/spec/logstash/config/pipeline_config_spec.rb b/logstash-core/spec/logstash/config/pipeline_config_spec.rb
index d7ed1c56524..fa76e1719f2 100644
--- a/logstash-core/spec/logstash/config/pipeline_config_spec.rb
+++ b/logstash-core/spec/logstash/config/pipeline_config_spec.rb
@@ -72,4 +72,79 @@
       end
     end
   end
+
+  describe "source and line remapping" do
+    context "when pipeline is constructed from single file single line" do
+      let (:pipeline_conf_string) { 'input { generator1 }' }
+      subject { described_class.new(source, pipeline_id, [org.logstash.common.SourceWithMetadata.new("file", "/tmp/1", 0, 0, pipeline_conf_string)], settings) }
+      it "return the same line of the queried" do
+        expect(subject.lookup_source(1, 0).getLine()).to eq(1)
+      end
+    end
+
+    context "when pipeline is constructed from single file" do
+      let (:pipeline_conf_string) { 'input {
+                                       generator1
+                                     }' }
+      subject { described_class.new(source, pipeline_id, [org.logstash.common.SourceWithMetadata.new("file", "/tmp/1", 0, 0, pipeline_conf_string)], settings) }
+
+      it "return the same line of the queried" do
+        expect(subject.lookup_source(1, 0).getLine()).to eq(1)
+        expect(subject.lookup_source(2, 0).getLine()).to eq(2)
+      end
+
+      it "throw exception if line is out of bound" do
+        expect { subject.lookup_source(100, -1) }.to raise_exception(IndexError)
+      end
+    end
+
+    context "when pipeline is constructed from multiple files" do
+      let (:pipeline_conf_string_part1) { 'input {
+                                             generator1
+                                           }' }
+      let (:pipeline_conf_string_part2) { 'output {
+                                             stdout
+                                           }' }
+      let(:merged_config_parts) do
+        [
+          org.logstash.common.SourceWithMetadata.new("file", "/tmp/input", 0, 0, pipeline_conf_string_part1),
+          org.logstash.common.SourceWithMetadata.new("file", "/tmp/output", 0, 0, pipeline_conf_string_part2)
+        ]
+      end
+      subject { described_class.new(source, pipeline_id, merged_config_parts, settings) }
+
+      it "return the line of first segment" do
+        expect(subject.lookup_source(2, 0).getLine()).to eq(2)
+        expect(subject.lookup_source(2, 0).getId()).to eq("/tmp/input")
+      end
+
+      it "return the line of second segment" do
+        expect(subject.lookup_source(4, 0).getLine()).to eq(1)
+        expect(subject.lookup_source(4, 0).getId()).to eq("/tmp/output")
+      end
+
+      it "throw exception if line is out of bound" do
+        expect { subject.lookup_source(100, 0) }.to raise_exception(IndexError)
+      end
+    end
+
+    context "when pipeline is constructed from multiple files and the first has trailing newline" do
+        let (:pipeline_conf_string_part1) { "input {\n  generator1\n}\n" }
+        let (:pipeline_conf_string_part2) { 'output {
+                                               stdout
+                                             }' }
+        let(:merged_config_parts) do
+          [
+            org.logstash.common.SourceWithMetadata.new("file", "/tmp/input", 0, 0, pipeline_conf_string_part1),
+            org.logstash.common.SourceWithMetadata.new("file", "/tmp/output", 0, 0, pipeline_conf_string_part2)
+          ]
+        end
+        subject { described_class.new(source, pipeline_id, merged_config_parts, settings) }
+
+        it "shouldn't slide the mapping of subsequent" do
+          expect(subject.lookup_source(4, 0).getLine()).to eq(1)
+          expect(subject.lookup_source(4, 0).getId()).to eq("/tmp/output")
+        end
+    end
+  end
 end
diff --git a/logstash-core/src/main/java/org/logstash/common/SourceWithMetadata.java b/logstash-core/src/main/java/org/logstash/common/SourceWithMetadata.java
index 9a76ef5e533..76562a56402 100644
--- a/logstash-core/src/main/java/org/logstash/common/SourceWithMetadata.java
+++ b/logstash-core/src/main/java/org/logstash/common/SourceWithMetadata.java
@@ -18,6 +18,7 @@ public class SourceWithMetadata implements HashableWithSource {
     private final Integer line;
     private final Integer column;
     private final String text;
+    private int linesCount;
 
     public String getProtocol() {
         return this.protocol;
@@ -60,11 +61,13 @@ public SourceWithMetadata(String protocol, String id, Integer line, Integer colu
           badAttributes.add(this.getText());
         }
 
-        if (!badAttributes.isEmpty()){
+        if (!badAttributes.isEmpty()) {
             String message = "Missing attributes in SourceWithMetadata: (" + badAttributes + ") "
                     + this.toString();
             throw new IncompleteSourceWithMetadataException(message);
         }
+
+        this.linesCount = text.split("\\n").length;
     }
 
     public SourceWithMetadata(String protocol, String id, String text) throws IncompleteSourceWithMetadataException {
@@ -93,4 +96,15 @@ private Collection<Object> attributes() {
     private Collection<Object> hashableAttributes() {
         return Arrays.asList(this.getId(), this.getProtocol(), this.getLine(), this.getColumn(), this.getText());
     }
+
+    public int getLinesCount() {
+        return linesCount;
+    }
+
+    public boolean equalsWithoutText(SourceWithMetadata other) {
+        return getProtocol().equals(other.getProtocol())
+                && getId().equals(other.getId())
+                && getLine().equals(other.getLine())
+                && getColumn().equals(other.getColumn());
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java b/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
index 612865c8f57..a204f1c66df 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
@@ -132,8 +132,7 @@ private Map<String, AbstractOutputDelegatorExt> setupOutputs(ConfigVariableExpan
             final PluginDefinition def = v.getPluginDefinition();
             final SourceWithMetadata source = v.getSourceWithMetadata();
             res.put(v.getId(), pluginFactory.buildOutput(
-                    RubyUtil.RUBY.newString(def.getName()), RubyUtil.RUBY.newFixnum(source.getLine()),
-                    RubyUtil.RUBY.newFixnum(source.getColumn()), convertArgs(def), convertJavaArgs(def, cve)
+                    RubyUtil.RUBY.newString(def.getName()), source, convertArgs(def), convertJavaArgs(def, cve)
             ));
         });
         return res;
@@ -150,8 +149,7 @@ private Map<String, AbstractFilterDelegatorExt> setupFilters(ConfigVariableExpan
             final PluginDefinition def = vertex.getPluginDefinition();
             final SourceWithMetadata source = vertex.getSourceWithMetadata();
             res.put(vertex.getId(), pluginFactory.buildFilter(
-                    RubyUtil.RUBY.newString(def.getName()), RubyUtil.RUBY.newFixnum(source.getLine()),
-                    RubyUtil.RUBY.newFixnum(source.getColumn()), convertArgs(def), convertJavaArgs(def, cve)
+                    RubyUtil.RUBY.newString(def.getName()), source, convertArgs(def), convertJavaArgs(def, cve)
             ));
         }
         return res;
@@ -167,8 +165,7 @@ private Collection<IRubyObject> setupInputs(ConfigVariableExpander cve) {
             final PluginDefinition def = v.getPluginDefinition();
             final SourceWithMetadata source = v.getSourceWithMetadata();
             IRubyObject o = pluginFactory.buildInput(
-                    RubyUtil.RUBY.newString(def.getName()), RubyUtil.RUBY.newFixnum(source.getLine()),
-                    RubyUtil.RUBY.newFixnum(source.getColumn()), convertArgs(def), convertJavaArgs(def, cve));
+                    RubyUtil.RUBY.newString(def.getName()), source, convertArgs(def), convertJavaArgs(def, cve));
             nodes.add(o);
         });
         return nodes;
@@ -189,10 +186,11 @@ private RubyHash convertArgs(final PluginDefinition def) {
             final Object toput;
             if (value instanceof PluginStatement) {
                 final PluginDefinition codec = ((PluginStatement) value).getPluginDefinition();
+                SourceWithMetadata source = ((PluginStatement) value).getSourceWithMetadata();
                 toput = pluginFactory.buildCodec(
                     RubyUtil.RUBY.newString(codec.getName()),
-                    Rubyfier.deep(RubyUtil.RUBY, codec.getArguments()),
-                    codec.getArguments()
+                        source, Rubyfier.deep(RubyUtil.RUBY, codec.getArguments()),
+                        codec.getArguments()
                 );
             } else {
                 toput = value;
@@ -217,10 +215,11 @@ private Map<String, Object> convertJavaArgs(final PluginDefinition def, ConfigVa
             final IRubyObject toput;
             if (value instanceof PluginStatement) {
                 final PluginDefinition codec = ((PluginStatement) value).getPluginDefinition();
+                SourceWithMetadata source = ((PluginStatement) value).getSourceWithMetadata();
                 Map<String, Object> codecArgs = expandConfigVariables(cve, codec.getArguments());
                 toput = pluginFactory.buildCodec(
                         RubyUtil.RUBY.newString(codec.getName()),
-                        Rubyfier.deep(RubyUtil.RUBY, codec.getArguments()),
+                        source, Rubyfier.deep(RubyUtil.RUBY, codec.getArguments()),
                         codecArgs
                 );
                 Codec javaCodec = (Codec)JavaUtil.unwrapJavaValue(toput);
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/ConfigCompiler.java b/logstash-core/src/main/java/org/logstash/config/ir/ConfigCompiler.java
index 668563fc6bb..5fc2414e05c 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/ConfigCompiler.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/ConfigCompiler.java
@@ -1,5 +1,7 @@
 package org.logstash.config.ir;
 
+import org.jruby.RubyArray;
+import org.jruby.RubyClass;
 import org.jruby.javasupport.JavaUtil;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.logstash.RubyUtil;
@@ -17,28 +19,19 @@ private ConfigCompiler() {
     }
 
     /**
-     * @param config Logstash Config String
+     * @param sourcesWithMetadata Logstash Config partitioned
      * @param supportEscapes The value of the setting {@code config.support_escapes}
      * @return Compiled {@link PipelineIR}
-     * @throws IncompleteSourceWithMetadataException On Broken Configuration
      */
-    public static PipelineIR configToPipelineIR(final String config, final boolean supportEscapes)
-        throws IncompleteSourceWithMetadataException {
+    public static PipelineIR configToPipelineIR(final @SuppressWarnings("rawtypes") RubyArray sourcesWithMetadata,
+                                                final boolean supportEscapes) {
         final IRubyObject compiler = RubyUtil.RUBY.executeScript(
-            "require 'logstash/compiler'\nLogStash::Compiler",
-            ""
+                "require 'logstash/compiler'\nLogStash::Compiler",
+                ""
         );
         final IRubyObject code =
             compiler.callMethod(RubyUtil.RUBY.getCurrentContext(), "compile_sources",
-                new IRubyObject[]{
-                    RubyUtil.RUBY.newArray(
-                        JavaUtil.convertJavaToRuby(
-                            RubyUtil.RUBY,
-                            new SourceWithMetadata("str", "pipeline", 0, 0, config)
-                        )
-                    ),
-                    RubyUtil.RUBY.newBoolean(supportEscapes)
-                }
+                new IRubyObject[]{sourcesWithMetadata, RubyUtil.RUBY.newBoolean(supportEscapes)}
             );
         return code.toJava(PipelineIR.class);
     }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/PluginFactory.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/PluginFactory.java
index 304a720f423..766eabc7337 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/PluginFactory.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/PluginFactory.java
@@ -1,13 +1,13 @@
 package org.logstash.config.ir.compiler;
 
 import co.elastic.logstash.api.Codec;
-import org.jruby.RubyInteger;
 import org.jruby.RubyString;
 import org.jruby.runtime.builtin.IRubyObject;
 import co.elastic.logstash.api.Configuration;
 import co.elastic.logstash.api.Context;
 import co.elastic.logstash.api.Filter;
 import co.elastic.logstash.api.Input;
+import org.logstash.common.SourceWithMetadata;
 
 import java.util.Map;
 
@@ -18,9 +18,7 @@ public interface PluginFactory extends RubyIntegration.PluginFactory {
 
     Input buildInput(String name, String id, Configuration configuration, Context context);
 
-    Filter buildFilter(
-            String name, String id, Configuration configuration, Context context
-    );
+    Filter buildFilter(String name, String id, Configuration configuration, Context context);
 
     final class Default implements PluginFactory {
 
@@ -41,28 +39,27 @@ public Filter buildFilter(final String name, final String id, final Configuratio
         }
 
         @Override
-        public IRubyObject buildInput(final RubyString name, final RubyInteger line, final RubyInteger column,
+        public IRubyObject buildInput(final RubyString name, SourceWithMetadata source,
                                       final IRubyObject args, Map<String, Object> pluginArgs) {
-            return rubyFactory.buildInput(name, line, column, args, pluginArgs);
+            return rubyFactory.buildInput(name, source, args, pluginArgs);
         }
 
         @Override
-        public AbstractOutputDelegatorExt buildOutput(final RubyString name, final RubyInteger line,
-                                                      final RubyInteger column, final IRubyObject args,
-                                                      final Map<String, Object> pluginArgs) {
-            return rubyFactory.buildOutput(name, line, column, args, pluginArgs);
+        public AbstractOutputDelegatorExt buildOutput(final RubyString name, SourceWithMetadata source,
+                                                      final IRubyObject args, final Map<String, Object> pluginArgs) {
+            return rubyFactory.buildOutput(name, source, args, pluginArgs);
         }
 
         @Override
-        public AbstractFilterDelegatorExt buildFilter(final RubyString name, final RubyInteger line,
-                                                      final RubyInteger column, final IRubyObject args,
-                                                      final Map<String, Object> pluginArgs) {
-            return rubyFactory.buildFilter(name, line, column, args, pluginArgs);
+        public AbstractFilterDelegatorExt buildFilter(final RubyString name, SourceWithMetadata source,
+                                                      final IRubyObject args, final Map<String, Object> pluginArgs) {
+            return rubyFactory.buildFilter(name, source, args, pluginArgs);
         }
 
         @Override
-        public IRubyObject buildCodec(final RubyString name, final IRubyObject args, Map<String, Object> pluginArgs) {
-            return rubyFactory.buildCodec(name, args, pluginArgs);
+        public IRubyObject buildCodec(final RubyString name, SourceWithMetadata source, final IRubyObject args,
+                                      Map<String, Object> pluginArgs) {
+            return rubyFactory.buildCodec(name, source, args, pluginArgs);
         }
 
         @Override
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java
index d840597294a..835da3ebdf5 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java
@@ -1,9 +1,9 @@
 package org.logstash.config.ir.compiler;
 
 import co.elastic.logstash.api.Codec;
-import org.jruby.RubyInteger;
 import org.jruby.RubyString;
 import org.jruby.runtime.builtin.IRubyObject;
+import org.logstash.common.SourceWithMetadata;
 
 import java.util.Map;
 
@@ -21,16 +21,17 @@ private RubyIntegration() {
      */
     public interface PluginFactory {
 
-        IRubyObject buildInput(RubyString name, RubyInteger line, RubyInteger column,
-            IRubyObject args, Map<String, Object> pluginArgs);
+        IRubyObject buildInput(RubyString name, SourceWithMetadata source,
+                               IRubyObject args, Map<String, Object> pluginArgs);
 
-        AbstractOutputDelegatorExt buildOutput(RubyString name, RubyInteger line, RubyInteger column,
-            IRubyObject args, Map<String, Object> pluginArgs);
+        AbstractOutputDelegatorExt buildOutput(RubyString name, SourceWithMetadata source,
+                                               IRubyObject args, Map<String, Object> pluginArgs);
 
-        AbstractFilterDelegatorExt buildFilter(RubyString name, RubyInteger line, RubyInteger column, IRubyObject args,
-            Map<String, Object> pluginArgs);
+        AbstractFilterDelegatorExt buildFilter(RubyString name, SourceWithMetadata source, IRubyObject args,
+                                               Map<String, Object> pluginArgs);
 
-        IRubyObject buildCodec(RubyString name, IRubyObject args, Map<String, Object> pluginArgs);
+        IRubyObject buildCodec(RubyString name, SourceWithMetadata source, IRubyObject args,
+                               Map<String, Object> pluginArgs);
 
         Codec buildDefaultCodec(String codecName);
 
diff --git a/logstash-core/src/main/java/org/logstash/execution/AbstractPipelineExt.java b/logstash-core/src/main/java/org/logstash/execution/AbstractPipelineExt.java
index b726ff4a84c..6d8b213396c 100644
--- a/logstash-core/src/main/java/org/logstash/execution/AbstractPipelineExt.java
+++ b/logstash-core/src/main/java/org/logstash/execution/AbstractPipelineExt.java
@@ -93,6 +93,9 @@ public class AbstractPipelineExt extends RubyBasicObject {
 
     private RubyString configString;
 
+    @SuppressWarnings("rawtypes")
+    private RubyArray configParts;
+
     private RubyString configHash;
 
     private IRubyObject settings;
@@ -121,12 +124,13 @@ public AbstractPipelineExt(final Ruby runtime, final RubyClass metaClass) {
     public final AbstractPipelineExt initialize(final ThreadContext context,
         final IRubyObject pipelineConfig, final IRubyObject namespacedMetric,
         final IRubyObject rubyLogger)
-        throws NoSuchAlgorithmException, IncompleteSourceWithMetadataException {
+        throws NoSuchAlgorithmException {
         reporter = new PipelineReporterExt(
             context.runtime, RubyUtil.PIPELINE_REPORTER_CLASS).initialize(context, rubyLogger, this
         );
         pipelineSettings = pipelineConfig;
         configString = (RubyString) pipelineSettings.callMethod(context, "config_string");
+        configParts = (RubyArray) pipelineSettings.callMethod(context, "config_parts");
         configHash = context.runtime.newString(
             Hex.encodeHexString(
                 MessageDigest.getInstance("SHA1").digest(configString.getBytes())
@@ -153,10 +157,8 @@ public final AbstractPipelineExt initialize(final ThreadContext context,
                 );
             }
         }
-        lir = ConfigCompiler.configToPipelineIR(
-            configString.asJavaString(),
-            getSetting(context, "config.support_escapes").isTrue()
-        );
+        boolean supportEscapes = getSetting(context, "config.support_escapes").isTrue();
+        lir = ConfigCompiler.configToPipelineIR(configParts, supportEscapes);
         return this;
     }
 
@@ -370,7 +372,7 @@ public final JRubyWrappedWriteClientExt wrappedWriteClient(final ThreadContext c
     @JRubyMethod(name = "pipeline_source_details", visibility = Visibility.PROTECTED)
     @SuppressWarnings("rawtypes")
     public RubyArray getPipelineSourceDetails(final ThreadContext context) {
-        RubyArray res = (RubyArray) pipelineSettings.callMethod(context, "config_parts");
+        RubyArray res = configParts;
         List<RubyString> pipelineSources = new ArrayList<>(res.size());
         for (IRubyObject part : res.toJavaArray()) {
             SourceWithMetadata sourceWithMetadata = part.toJava(SourceWithMetadata.class);
diff --git a/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java b/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java
index f570fe0d6d9..7f36421fa16 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java
@@ -12,7 +12,6 @@
 import org.jruby.RubyBasicObject;
 import org.jruby.RubyClass;
 import org.jruby.RubyHash;
-import org.jruby.RubyInteger;
 import org.jruby.RubyString;
 import org.jruby.RubySymbol;
 import org.jruby.anno.JRubyClass;
@@ -24,6 +23,7 @@
 import org.logstash.common.AbstractDeadLetterQueueWriterExt;
 import org.logstash.common.DLQWriterAdapter;
 import org.logstash.common.NullDeadLetterQueueWriter;
+import org.logstash.common.SourceWithMetadata;
 import org.logstash.config.ir.PipelineIR;
 import org.logstash.config.ir.compiler.AbstractFilterDelegatorExt;
 import org.logstash.config.ir.compiler.AbstractOutputDelegatorExt;
@@ -115,61 +115,41 @@ public PluginFactoryExt.Plugins init(final PipelineIR lir, final PluginFactoryEx
 
         @SuppressWarnings("unchecked")
         @Override
-        public IRubyObject buildInput(final RubyString name, final RubyInteger line, final RubyInteger column,
+        public IRubyObject buildInput(final RubyString name, SourceWithMetadata source,
                                       final IRubyObject args, Map<String, Object> pluginArgs) {
             return plugin(
-                    RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.INPUT,
-                    name.asJavaString(), line.getIntValue(), column.getIntValue(),
-                    (Map<String, IRubyObject>) args, pluginArgs
-            );
-        }
-
-        @JRubyMethod(required = 4)
-        public IRubyObject buildInput(final ThreadContext context, final IRubyObject[] args) {
-            return buildInput(
-                    (RubyString) args[0], args[1].convertToInteger(), args[2].convertToInteger(),
-                    args[3], null
+                    RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.INPUT, name.asJavaString(),
+                    source, (Map<String, IRubyObject>) args, pluginArgs
             );
         }
 
         @SuppressWarnings("unchecked")
         @Override
-        public AbstractOutputDelegatorExt buildOutput(final RubyString name, final RubyInteger line,
-                                                      final RubyInteger column, final IRubyObject args,
-                                                      Map<String, Object> pluginArgs) {
+        public AbstractOutputDelegatorExt buildOutput(final RubyString name, SourceWithMetadata source,
+                                                      final IRubyObject args, Map<String, Object> pluginArgs) {
             return (AbstractOutputDelegatorExt) plugin(
-                    RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.OUTPUT,
-                    name.asJavaString(), line.getIntValue(), column.getIntValue(),
-                    (Map<String, IRubyObject>) args, pluginArgs
-            );
-        }
-
-        @JRubyMethod(required = 4)
-        public AbstractOutputDelegatorExt buildOutput(final ThreadContext context,
-                                                      final IRubyObject[] args) {
-            return buildOutput(
-                    (RubyString) args[0], args[1].convertToInteger(), args[2].convertToInteger(), args[3], null
+                    RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.OUTPUT, name.asJavaString(),
+                    source, (Map<String, IRubyObject>) args, pluginArgs
             );
         }
 
         @SuppressWarnings("unchecked")
         @Override
-        public AbstractFilterDelegatorExt buildFilter(final RubyString name, final RubyInteger line,
-                                                      final RubyInteger column, final IRubyObject args,
-                                                      Map<String, Object> pluginArgs) {
+        public AbstractFilterDelegatorExt buildFilter(final RubyString name, SourceWithMetadata source,
+                                                      final IRubyObject args, Map<String, Object> pluginArgs) {
             return (AbstractFilterDelegatorExt) plugin(
-                    RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.FILTER,
-                    name.asJavaString(), line.getIntValue(), column.getIntValue(),
-                    (Map<String, IRubyObject>) args, pluginArgs
+                    RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.FILTER, name.asJavaString(),
+                    source, (Map<String, IRubyObject>) args, pluginArgs
             );
         }
 
         @SuppressWarnings("unchecked")
         @Override
-        public IRubyObject buildCodec(final RubyString name, final IRubyObject args, Map<String, Object> pluginArgs) {
+        public IRubyObject buildCodec(final RubyString name, SourceWithMetadata source, final IRubyObject args,
+                                      Map<String, Object> pluginArgs) {
             return plugin(
                     RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.CODEC,
-                    name.asJavaString(), 0, 0, (Map<String, IRubyObject>) args, pluginArgs
+                    name.asJavaString(), source, (Map<String, IRubyObject>) args, pluginArgs
             );
         }
 
@@ -177,27 +157,25 @@ public IRubyObject buildCodec(final RubyString name, final IRubyObject args, Map
         public Codec buildDefaultCodec(String codecName) {
             return (Codec) JavaUtil.unwrapJavaValue(plugin(
                     RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.CODEC,
-                    codecName, 0, 0, Collections.emptyMap(), Collections.emptyMap()
+                    codecName, null, Collections.emptyMap(), Collections.emptyMap()
             ));
         }
 
         @SuppressWarnings("unchecked")
-        @JRubyMethod(required = 4, optional = 1)
+        @JRubyMethod(required = 3, optional = 1)
         public IRubyObject plugin(final ThreadContext context, final IRubyObject[] args) {
             return plugin(
                     context,
                     PluginLookup.PluginType.valueOf(args[0].asJavaString().toUpperCase(Locale.ENGLISH)),
                     args[1].asJavaString(),
-                    args[2].convertToInteger().getIntValue(),
-                    args[3].convertToInteger().getIntValue(),
-                    args.length > 4 ? (Map<String, IRubyObject>) args[4] : new HashMap<>(),
+                    JavaUtil.unwrapIfJavaObject(args[2]),
+                    args.length > 3 ? (Map<String, IRubyObject>) args[3] : new HashMap<>(),
                     null
             );
         }
-
         @SuppressWarnings("unchecked")
         private IRubyObject plugin(final ThreadContext context, final PluginLookup.PluginType type, final String name,
-                                   final int line, final int column, final Map<String, IRubyObject> args,
+                                   SourceWithMetadata source, final Map<String, IRubyObject> args,
                                    Map<String, Object> pluginArgs) {
             final String id;
             final PluginLookup.PluginClass pluginClass = PluginLookup.lookup(type, name);
@@ -205,17 +183,17 @@ private IRubyObject plugin(final ThreadContext context, final PluginLookup.Plugi
             if (type == PluginLookup.PluginType.CODEC) {
                 id = UUID.randomUUID().toString();
             } else {
-                id = lir.getGraph().vertices().filter(
-                        v -> v.getSourceWithMetadata() != null
-                                && v.getSourceWithMetadata().getLine() == line
-                                && v.getSourceWithMetadata().getColumn() == column
-                ).findFirst().map(Vertex::getId).orElse(null);
+                id = lir.getGraph().vertices()
+                        .filter(v -> v.getSourceWithMetadata() != null
+                                && v.getSourceWithMetadata().equalsWithoutText(source))
+                        .findFirst()
+                        .map(Vertex::getId).orElse(null);
             }
             if (id == null) {
                 throw context.runtime.newRaiseException(
                         RubyUtil.CONFIGURATION_ERROR_CLASS,
-                        String.format(
-                                "Could not determine ID for %s/%s", type.rubyLabel().asJavaString(), name
+                        String.format("Could not determine ID for %s/%s, source don't matched: %s",
+                                type.rubyLabel().asJavaString(), name, source
                         )
                 );
             }
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java b/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java
index 70642c10621..32f3c2ba4fa 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java
@@ -14,7 +14,6 @@
 import java.util.function.Supplier;
 import org.hamcrest.CoreMatchers;
 import org.hamcrest.MatcherAssert;
-import org.jruby.RubyInteger;
 import org.jruby.RubyString;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.junit.After;
@@ -25,6 +24,7 @@
 import org.logstash.Event;
 import org.logstash.RubyUtil;
 import org.logstash.common.IncompleteSourceWithMetadataException;
+import org.logstash.common.SourceWithMetadata;
 import org.logstash.config.ir.compiler.AbstractFilterDelegatorExt;
 import org.logstash.config.ir.compiler.AbstractOutputDelegatorExt;
 import org.logstash.config.ir.compiler.FilterDelegatorExt;
@@ -97,7 +97,7 @@ public void afterEach() {
     @Test
     public void buildsTrivialPipeline() throws Exception {
         final PipelineIR pipelineIR = ConfigCompiler.configToPipelineIR(
-            "input {mockinput{}} output{mockoutput{}}", false
+                IRHelpers.toSourceWithMetadata("input {mockinput{}} output{mockoutput{}}"), false
         );
         final JrubyEventExtLibrary.RubyEvent testEvent =
             JrubyEventExtLibrary.RubyEvent.newRubyEvent(RubyUtil.RUBY, new Event());
@@ -116,7 +116,7 @@ public void buildsTrivialPipeline() throws Exception {
     @Test
     public void buildsStraightPipeline() throws Exception {
         final PipelineIR pipelineIR = ConfigCompiler.configToPipelineIR(
-            "input {mockinput{}} filter { mockfilter {} mockfilter {} mockfilter {}} output{mockoutput{}}",
+                IRHelpers.toSourceWithMetadata("input {mockinput{}} filter { mockfilter {} mockfilter {} mockfilter {}} output{mockoutput{}}"),
             false
         );
         final JrubyEventExtLibrary.RubyEvent testEvent =
@@ -136,7 +136,7 @@ public void buildsStraightPipeline() throws Exception {
 
     @Test
     public void buildsForkedPipeline() throws Exception {
-        final PipelineIR pipelineIR = ConfigCompiler.configToPipelineIR(
+        final PipelineIR pipelineIR = ConfigCompiler.configToPipelineIR(IRHelpers.toSourceWithMetadata(
             "input {mockinput{}} filter { " +
                 "if [foo] != \"bar\" { " +
                 "mockfilter {} " +
@@ -144,7 +144,7 @@ public void buildsForkedPipeline() throws Exception {
                 "if [foo] != \"bar\" { " +
                 "mockfilter {} " +
                 "}} " +
-                "} output {mockoutput{} }",
+                "} output {mockoutput{} }"),
             false
         );
         final JrubyEventExtLibrary.RubyEvent testEvent =
@@ -268,9 +268,9 @@ private void verifyRegex(String operator, int expectedEvents)
 
         new CompiledPipeline(
                 ConfigCompiler.configToPipelineIR(
-                        "input {mockinput{}} output { " +
+                        IRHelpers.toSourceWithMetadata("input {mockinput{}} output { " +
                                 String.format("if \"z\" %s /z/ { ", operator) +
-                                " mockoutput{} } }",
+                                " mockoutput{} } }"),
                         false
                 ),
                 new CompiledPipelineTest.MockPluginFactory(
@@ -289,7 +289,7 @@ private void verifyRegex(String operator, int expectedEvents)
     @Test
     public void equalityCheckOnCompositeField() throws Exception {
         final PipelineIR pipelineIR = ConfigCompiler.configToPipelineIR(
-                "input {mockinput{}} filter { if 4 == [list] { mockaddfilter {} } if 5 == [map] { mockaddfilter {} } } output {mockoutput{} }",
+                IRHelpers.toSourceWithMetadata("input {mockinput{}} filter { if 4 == [list] { mockaddfilter {} } if 5 == [map] { mockaddfilter {} } } output {mockoutput{} }"),
                 false
         );
         final Collection<String> s = new ArrayList<>();
@@ -320,7 +320,7 @@ public void equalityCheckOnCompositeField() throws Exception {
     @Test
     public void conditionalWithNullField() throws Exception {
         final PipelineIR pipelineIR = ConfigCompiler.configToPipelineIR(
-                "input {mockinput{}} filter { if [foo] == [bar] { mockaddfilter {} } } output {mockoutput{} }",
+                IRHelpers.toSourceWithMetadata("input {mockinput{}} filter { if [foo] == [bar] { mockaddfilter {} } } output {mockoutput{} }"),
                 false
         );
         final JrubyEventExtLibrary.RubyEvent testEvent =
@@ -344,7 +344,7 @@ public void conditionalWithNullField() throws Exception {
     @Test
     public void conditionalNestedMetaFieldPipeline() throws Exception {
         final PipelineIR pipelineIR = ConfigCompiler.configToPipelineIR(
-            "input {mockinput{}} filter { if [@metadata][foo][bar] { mockaddfilter {} } } output {mockoutput{} }",
+                IRHelpers.toSourceWithMetadata("input {mockinput{}} filter { if [@metadata][foo][bar] { mockaddfilter {} } } output {mockoutput{} }"),
             false
         );
         final JrubyEventExtLibrary.RubyEvent testEvent =
@@ -369,7 +369,7 @@ public void conditionalNestedMetaFieldPipeline() throws Exception {
     @Test
     public void moreThan255Parents() throws Exception {
         final PipelineIR pipelineIR = ConfigCompiler.configToPipelineIR(
-            "input {mockinput{}} filter { " +
+                IRHelpers.toSourceWithMetadata("input {mockinput{}} filter { " +
                 "if [foo] != \"bar\" { " +
                 "mockfilter {} " +
                 "mockaddfilter {} " +
@@ -377,7 +377,7 @@ public void moreThan255Parents() throws Exception {
                 "mockfilter {} " +
                 Strings.repeat("} else if [foo] != \"bar\" {" +
                     "mockfilter {} ", 300) + " } } " +
-                "} output {mockoutput{} }",
+                "} output {mockoutput{} }"),
             false
         );
         final JrubyEventExtLibrary.RubyEvent testEvent =
@@ -426,11 +426,11 @@ private void verifyComparison(final boolean expected, final String conditional,
 
         new CompiledPipeline(
             ConfigCompiler.configToPipelineIR(
-                "input {mockinput{}} filter { " +
+                    IRHelpers.toSourceWithMetadata("input {mockinput{}} filter { " +
                     String.format("if %s { ", conditional) +
                     " mockaddfilter {} " +
                     "} " +
-                    "} output {mockoutput{} }",
+                    "} output {mockoutput{} }"),
                 false
             ),
             new CompiledPipelineTest.MockPluginFactory(
@@ -476,28 +476,28 @@ static final class MockPluginFactory implements PluginFactory {
         }
 
         @Override
-        public IRubyObject buildInput(final RubyString name, final RubyInteger line,
-            final RubyInteger column, final IRubyObject args, Map<String, Object> pluginArgs) {
+        public IRubyObject buildInput(final RubyString name, SourceWithMetadata source,
+                                      final IRubyObject args, Map<String, Object> pluginArgs) {
             return setupPlugin(name, inputs);
         }
 
         @Override
-        public AbstractOutputDelegatorExt buildOutput(final RubyString name, final RubyInteger line,
-            final RubyInteger column, final IRubyObject args, Map<String, Object> pluginArgs) {
+        public AbstractOutputDelegatorExt buildOutput(final RubyString name, SourceWithMetadata source,
+                                                      final IRubyObject args, Map<String, Object> pluginArgs) {
             return PipelineTestUtil.buildOutput(setupPlugin(name, outputs));
         }
 
         @Override
-        public AbstractFilterDelegatorExt buildFilter(final RubyString name, final RubyInteger line,
-                                                      final RubyInteger column, final IRubyObject args,
-                                                      Map<String, Object> pluginArgs) {
+        public AbstractFilterDelegatorExt buildFilter(final RubyString name, SourceWithMetadata source,
+                                                      final IRubyObject args, Map<String, Object> pluginArgs) {
             return new FilterDelegatorExt(
                 RubyUtil.RUBY, RubyUtil.FILTER_DELEGATOR_CLASS)
                 .initForTesting(setupPlugin(name, filters));
         }
 
         @Override
-        public IRubyObject buildCodec(final RubyString name, final IRubyObject args, Map<String, Object> pluginArgs) {
+        public IRubyObject buildCodec(final RubyString name, SourceWithMetadata source, final IRubyObject args,
+                                      Map<String, Object> pluginArgs) {
             throw new IllegalStateException("No codec setup expected in this test.");
         }
 
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/ConfigCompilerTest.java b/logstash-core/src/test/java/org/logstash/config/ir/ConfigCompilerTest.java
index 1314dd0ec8f..aeae84e5c0d 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/ConfigCompilerTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/ConfigCompilerTest.java
@@ -2,8 +2,13 @@
 
 import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
+
+import org.jruby.javasupport.JavaUtil;
+import org.jruby.runtime.builtin.IRubyObject;
 import org.junit.Test;
+import org.logstash.RubyUtil;
 import org.logstash.common.IncompleteSourceWithMetadataException;
+import org.logstash.common.SourceWithMetadata;
 import org.logstash.config.ir.graph.Graph;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -13,8 +18,10 @@ public class ConfigCompilerTest extends RubyEnvTestCase {
 
     @Test
     public void testConfigToPipelineIR() throws Exception {
+        IRubyObject swm = JavaUtil.convertJavaToRuby(
+                RubyUtil.RUBY, new SourceWithMetadata("proto", "path", 1, 1, "input {stdin{}} output{stdout{}}"));
         final PipelineIR pipelineIR =
-            ConfigCompiler.configToPipelineIR("input {stdin{}} output{stdout{}}", false);
+            ConfigCompiler.configToPipelineIR(RubyUtil.RUBY.newArray(swm), false);
         assertThat(pipelineIR.getOutputPluginVertices().size(), is(1));
         assertThat(pipelineIR.getFilterPluginVertices().size(), is(0));
     }
@@ -60,8 +67,9 @@ public void testComplexConfigToPipelineIR() throws Exception {
         assertThat(graphHash(config), is(first));
     }
 
-    private static String graphHash(final String config)
-        throws IncompleteSourceWithMetadataException {
-        return ConfigCompiler.configToPipelineIR(config, false).uniqueHash();
+    private static String graphHash(final String config) throws IncompleteSourceWithMetadataException {
+        IRubyObject swm = JavaUtil.convertJavaToRuby(
+                RubyUtil.RUBY, new SourceWithMetadata("proto", "path", 1, 1, config));
+        return ConfigCompiler.configToPipelineIR(RubyUtil.RUBY.newArray(swm), false).uniqueHash();
     }
 }
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/EventConditionTest.java b/logstash-core/src/test/java/org/logstash/config/ir/EventConditionTest.java
index 0d47a4a1d18..394fb0df905 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/EventConditionTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/EventConditionTest.java
@@ -55,12 +55,12 @@ public void afterEach() {
     @SuppressWarnings("rawtypes")
     public void testInclusionWithFieldInField() throws Exception {
         final PipelineIR pipelineIR = ConfigCompiler.configToPipelineIR(
-                "input {mockinput{}} filter { " +
+                IRHelpers.toSourceWithMetadata("input {mockinput{}} filter { " +
                         "mockfilter {} } " +
                         "output { " +
                         "  if [left] in [right] { " +
                         "    mockoutput{}" +
-                        "  } }",
+                        "  } }"),
                 false
         );
 
@@ -136,12 +136,12 @@ public void testConditionWithConstantEmptyStringValue() throws Exception {
 
     private void testConditionWithConstantValue(String condition, int expectedMatches) throws Exception {
         final PipelineIR pipelineIR = ConfigCompiler.configToPipelineIR(
-                "input {mockinput{}} filter { " +
+                IRHelpers.toSourceWithMetadata("input {mockinput{}} filter { " +
                         "mockfilter {} } " +
                         "output { " +
                         "  if " + condition + " { " +
                         "    mockoutput{}" +
-                        "  } }",
+                        "  } }"),
                 false
         );
 
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java b/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java
index 8d4b1cb48cb..ec29b1a5f92 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/IRHelpers.java
@@ -1,6 +1,9 @@
 package org.logstash.config.ir;
 
 import org.hamcrest.MatcherAssert;
+import org.jruby.RubyArray;
+import org.jruby.javasupport.JavaUtil;
+import org.logstash.RubyUtil;
 import org.logstash.common.IncompleteSourceWithMetadataException;
 import org.logstash.common.SourceWithMetadata;
 import org.logstash.config.ir.expression.BooleanExpression;
@@ -165,4 +168,11 @@ public static String randomString(Random rng, int length) {
         }
         return out.toString();
     }
+
+
+    @SuppressWarnings("rawtypes")
+    public static RubyArray toSourceWithMetadata(String config) throws IncompleteSourceWithMetadataException {
+        return RubyUtil.RUBY.newArray(JavaUtil.convertJavaToRuby(
+                RubyUtil.RUBY, new SourceWithMetadata("proto", "path", 1, 1, config)));
+    }
 }
diff --git a/logstash-core/src/test/java/org/logstash/plugins/TestPluginFactory.java b/logstash-core/src/test/java/org/logstash/plugins/TestPluginFactory.java
index 0c78ac865e4..b5fd7bd6eaa 100644
--- a/logstash-core/src/test/java/org/logstash/plugins/TestPluginFactory.java
+++ b/logstash-core/src/test/java/org/logstash/plugins/TestPluginFactory.java
@@ -1,9 +1,9 @@
 package org.logstash.plugins;
 
 import co.elastic.logstash.api.Codec;
-import org.jruby.RubyInteger;
 import org.jruby.RubyString;
 import org.jruby.runtime.builtin.IRubyObject;
+import org.logstash.common.SourceWithMetadata;
 import org.logstash.config.ir.compiler.AbstractFilterDelegatorExt;
 import org.logstash.config.ir.compiler.AbstractOutputDelegatorExt;
 import org.logstash.config.ir.compiler.RubyIntegration;
@@ -15,22 +15,26 @@
 public class TestPluginFactory implements RubyIntegration.PluginFactory {
 
     @Override
-    public IRubyObject buildInput(RubyString name, RubyInteger line, RubyInteger column, IRubyObject args, Map<String, Object> pluginArgs) {
+    public IRubyObject buildInput(RubyString name, SourceWithMetadata source,
+                                  IRubyObject args, Map<String, Object> pluginArgs) {
         return null;
     }
 
     @Override
-    public AbstractOutputDelegatorExt buildOutput(RubyString name, RubyInteger line, RubyInteger column, IRubyObject args, Map<String, Object> pluginArgs) {
+    public AbstractOutputDelegatorExt buildOutput(RubyString name, SourceWithMetadata source,
+                                                  IRubyObject args, Map<String, Object> pluginArgs) {
         return null;
     }
 
     @Override
-    public AbstractFilterDelegatorExt buildFilter(RubyString name, RubyInteger line, RubyInteger column, IRubyObject args, Map<String, Object> pluginArgs) {
+    public AbstractFilterDelegatorExt buildFilter(RubyString name, SourceWithMetadata source,
+                                                  IRubyObject args, Map<String, Object> pluginArgs) {
         return null;
     }
 
     @Override
-    public IRubyObject buildCodec(RubyString name, IRubyObject args, Map<String, Object> pluginArgs) {
+    public IRubyObject buildCodec(RubyString name, SourceWithMetadata source, IRubyObject args,
+                                  Map<String, Object> pluginArgs) {
         return null;
     }
 
