diff --git a/.gitignore b/.gitignore
index d6cbc6a259f..0cadd48f8fb 100644
--- a/.gitignore
+++ b/.gitignore
@@ -33,3 +33,4 @@ qa/.vagrant
 qa/.rspec
 qa/acceptance/.vagrant
 qa/Gemfile.lock
+
diff --git a/benchmark/event_accessor.rb b/benchmark/event_accessor.rb
new file mode 100644
index 00000000000..018785b51ae
--- /dev/null
+++ b/benchmark/event_accessor.rb
@@ -0,0 +1,17 @@
+# encoding: utf-8
+require "benchmark/ips"
+require "logstash/event"
+
+options = { :time => 10, :warmup => 60 }
+puts "Same Event instance"
+
+event = LogStash::Event.new("foo" => {"bar" => {"foobar" => "morebar"} })
+STDERR.puts ""
+STDERR.puts " ----------> event.get(\"[foo][bar][foobar]\") => #{event.get("[foo][bar][foobar]")}"
+STDERR.puts ""
+
+Benchmark.ips do |x|
+  x.config(options)
+
+  x.report("Deep fetch") { event.get("[foo][bar][foobar]") }
+end
diff --git a/logstash-core-event-java/.gitignore b/logstash-core-event-java/.gitignore
index a453cb95034..0224a02d2d8 100644
--- a/logstash-core-event-java/.gitignore
+++ b/logstash-core-event-java/.gitignore
@@ -3,7 +3,3 @@
 # build dirs
 build
 .gradle
-
-# Intellij
-.idea
-*.iml
diff --git a/logstash-core-event-java/build.gradle b/logstash-core-event-java/build.gradle
index b2a4a55ec43..cbefa2fc893 100644
--- a/logstash-core-event-java/build.gradle
+++ b/logstash-core-event-java/build.gradle
@@ -27,7 +27,7 @@ apply plugin: 'idea'
 
 group = 'org.logstash'
 
-project.sourceCompatibility = 1.7
+project.sourceCompatibility = 1.8
 
 task sourcesJar(type: Jar, dependsOn: classes) {
     from sourceSets.main.allSource
@@ -94,7 +94,7 @@ idea {
 dependencies {
     compile 'com.fasterxml.jackson.core:jackson-core:2.7.1'
     compile 'com.fasterxml.jackson.core:jackson-databind:2.7.1-1'
-    provided 'org.jruby:jruby-core:1.7.22'
+    provided 'org.jruby:jruby-core:1.7.25'
     testCompile 'junit:junit:4.12'
     testCompile 'net.javacrumbs.json-unit:json-unit:1.9.0'
 }
diff --git a/logstash-core-event-java/gradle/wrapper/gradle-wrapper.properties b/logstash-core-event-java/gradle/wrapper/gradle-wrapper.properties
index 25611753f15..5dd8b01df92 100644
--- a/logstash-core-event-java/gradle/wrapper/gradle-wrapper.properties
+++ b/logstash-core-event-java/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Fri Jan 22 14:29:02 EST 2016
+#Sat Jun 11 09:10:51 BST 2016
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.8-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.8-all.zip
diff --git a/logstash-core-event-java/spec/event_spec.rb b/logstash-core-event-java/spec/event_spec.rb
index 144d817b789..86b670a5706 100644
--- a/logstash-core-event-java/spec/event_spec.rb
+++ b/logstash-core-event-java/spec/event_spec.rb
@@ -114,6 +114,14 @@
       expect(e.get("foo")).to eq(-9223372036854776000)
     end
 
+    it "should convert Time to Timestamp" do
+      e = LogStash::Event.new()
+      time = Time.now
+      e.set("[foo]", Time.at(time.to_f))
+      expect(e.get("foo")).to be_kind_of(LogStash::Timestamp)
+      expect(e.get("foo").to_f).to be_within(0.1).of(time.to_f)
+    end
+
     it "should set XXJavaProxy Jackson crafted" do
       proxy = com.logstash.Util.getMapFixtureJackson()
       # proxy is {"string": "foo", "int": 42, "float": 42.42, "array": ["bar","baz"], "hash": {"string":"quux"} }
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Cloner.java b/logstash-core-event-java/src/main/java/com/logstash/Cloner.java
index 4823f10726a..cd78a7007d8 100644
--- a/logstash-core-event-java/src/main/java/com/logstash/Cloner.java
+++ b/logstash-core-event-java/src/main/java/com/logstash/Cloner.java
@@ -24,6 +24,8 @@ private static <E> List<E> deepList(final List<E> list) {
             clone = new LinkedList<E>();
         } else if (list instanceof ArrayList<?>) {
             clone = new ArrayList<E>();
+        } else if (list instanceof ConvertedList<?>) {
+            clone = new ArrayList<E>();
         } else {
             throw new ClassCastException("unexpected List type " + list.getClass());
         }
@@ -43,6 +45,8 @@ private static <K, V> Map<K, V> deepMap(final Map<K, V> map) {
             clone = new TreeMap<K, V>();
         } else if (map instanceof HashMap<?, ?>) {
             clone = new HashMap<K, V>();
+        } else if (map instanceof ConvertedMap<?, ?>) {
+            clone = new HashMap<K, V>();
         } else {
             throw new ClassCastException("unexpected Map type " + map.getClass());
         }
diff --git a/logstash-core-event-java/src/main/java/com/logstash/ConvertedList.java b/logstash-core-event-java/src/main/java/com/logstash/ConvertedList.java
new file mode 100644
index 00000000000..319f1c300cf
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/ConvertedList.java
@@ -0,0 +1,224 @@
+package com.logstash;
+
+import org.jruby.RubyArray;
+import org.jruby.runtime.builtin.IRubyObject;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.Spliterator;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.function.UnaryOperator;
+import java.util.stream.Stream;
+
+import static com.logstash.Valuefier.convert;
+
+public class ConvertedList<T> implements List<T>, Collection<T>, Iterable<T> {
+    private final List<T> delegate;
+
+    public ConvertedList(List<T> delegate) {
+        this.delegate = delegate;
+    }
+    public ConvertedList() {
+        this.delegate = new ArrayList<>();
+    }
+
+    public static ConvertedList<Object> newFromList(List<Object> list) {
+        ConvertedList<Object> array = new ConvertedList<>();
+
+        for (Object item : list) {
+            array.add(convert(item));
+        }
+        return array;
+    }
+
+    public static ConvertedList<Object> newFromRubyArray(RubyArray a) {
+        final ConvertedList<Object> result = new ConvertedList<>();
+
+        for (IRubyObject o : a.toJavaArray()) {
+            result.add(convert(o));
+        }
+        return result;
+    }
+
+    public Object unconvert() {
+        final ArrayList<Object> result = new ArrayList<>();
+        for (Object obj : delegate) {
+            result.add(Javafier.deep(obj));
+        }
+        return result;
+    }
+
+    // delegate methods
+    @Override
+    public int size() {
+        return delegate.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return delegate.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return delegate.contains(o);
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        return delegate.iterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return delegate.toArray();
+    }
+
+    @Override
+    public <T1> T1[] toArray(T1[] a) {
+        return delegate.toArray(a);
+    }
+
+    @Override
+    public boolean add(T t) {
+        return delegate.add(t);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        return delegate.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        return delegate.containsAll(c);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends T> c) {
+        return delegate.addAll(c);
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends T> c) {
+        return delegate.addAll(index, c);
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        return delegate.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        return delegate.retainAll(c);
+    }
+
+    @Override
+    public void replaceAll(UnaryOperator<T> operator) {
+        delegate.replaceAll(operator);
+    }
+
+    @Override
+    public void sort(Comparator<? super T> c) {
+        delegate.sort(c);
+    }
+
+    @Override
+    public void clear() {
+        delegate.clear();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        return delegate.equals(o);
+    }
+
+    @Override
+    public int hashCode() {
+        return delegate.hashCode();
+    }
+
+    @Override
+    public T get(int index) {
+        return delegate.get(index);
+    }
+
+    @Override
+    public T set(int index, T element) {
+        return delegate.set(index, element);
+    }
+
+    @Override
+    public void add(int index, T element) {
+        delegate.add(index, element);
+    }
+
+    @Override
+    public T remove(int index) {
+        return delegate.remove(index);
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        return delegate.indexOf(o);
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        return delegate.lastIndexOf(o);
+    }
+
+    @Override
+    public ListIterator<T> listIterator() {
+        return delegate.listIterator();
+    }
+
+    @Override
+    public ListIterator<T> listIterator(int index) {
+        return delegate.listIterator(index);
+    }
+
+    @Override
+    public List<T> subList(int fromIndex, int toIndex) {
+        return delegate.subList(fromIndex, toIndex);
+    }
+
+    @Override
+    public Spliterator<T> spliterator() {
+        return delegate.spliterator();
+    }
+
+    @Override
+    public String toString() {
+        final StringBuffer sb = new StringBuffer("ConvertedList{");
+        sb.append("delegate=").append(delegate.toString());
+        sb.append('}');
+        return sb.toString();
+    }
+
+    @Override
+    public boolean removeIf(Predicate<? super T> filter) {
+        return delegate.removeIf(filter);
+    }
+
+    @Override
+    public Stream<T> stream() {
+        return delegate.stream();
+    }
+
+    @Override
+    public Stream<T> parallelStream() {
+        return delegate.parallelStream();
+    }
+
+    @Override
+    public void forEach(Consumer<? super T> action) {
+        delegate.forEach(action);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/ConvertedMap.java b/logstash-core-event-java/src/main/java/com/logstash/ConvertedMap.java
new file mode 100644
index 00000000000..1efc2be8308
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/ConvertedMap.java
@@ -0,0 +1,182 @@
+package com.logstash;
+
+import com.logstash.bivalues.BiValues;
+import org.jruby.RubyHash;
+import org.jruby.runtime.builtin.IRubyObject;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+
+public class ConvertedMap<K, V> implements Map<K, V> {
+
+    private final Map<K, V> delegate;
+
+    public ConvertedMap(Map<K, V> delegate) {
+        this.delegate = delegate;
+    }
+
+    public ConvertedMap() {
+        this.delegate = new HashMap<>();
+    }
+
+    public static ConvertedMap<String, Object> newFromMap(Map<String, Object> o) {
+        ConvertedMap<String, Object> cm = new ConvertedMap<>();
+        for (Map.Entry<String, Object> entry : o.entrySet()) {
+            String k = String.valueOf(BiValues.newBiValue(entry.getKey()).javaValue());
+            cm.put(k, Valuefier.convert(entry.getValue()));
+        }
+        return cm;
+    }
+
+    public static ConvertedMap<String, Object> newFromRubyHash(RubyHash o) {
+        final ConvertedMap<String, Object> result = new ConvertedMap<>();
+
+        o.visitAll(new RubyHash.Visitor() {
+            @Override
+            public void visit(IRubyObject key, IRubyObject value) {
+                String k = String.valueOf(BiValues.newBiValue(key).javaValue()) ;
+                result.put(k, Valuefier.convert(value));
+            }
+        });
+        return result;
+    }
+
+    public Object unconvert() {
+        final HashMap<K, V> result = new HashMap<>();
+        for (Map.Entry<K, V> entry : entrySet()) {
+            result.put(entry.getKey(), (V) Javafier.deep(entry.getValue()));
+        }
+        return result;
+    }
+
+    // Delegate methods
+    @Override
+    public int size() {
+        return delegate.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return delegate.isEmpty();
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return delegate.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return delegate.containsValue(value);
+    }
+
+    @Override
+    public V get(Object key) {
+        return delegate.get(key);
+    }
+
+    @Override
+    public V put(K key, V value) {
+        return delegate.put(key, value);
+    }
+
+    @Override
+    public V remove(Object key) {
+        return delegate.remove(key);
+    }
+
+    @Override
+    public void putAll(Map<? extends K, ? extends V> m) {
+        delegate.putAll(m);
+    }
+
+    @Override
+    public void clear() {
+        delegate.clear();
+    }
+
+    @Override
+    public Set<K> keySet() {
+        return delegate.keySet();
+    }
+
+    @Override
+    public Collection<V> values() {
+        return delegate.values();
+    }
+
+    @Override
+    public Set<Entry<K, V>> entrySet() {
+        return delegate.entrySet();
+    }
+
+    @Override
+    public V getOrDefault(Object key, V defaultValue) {
+        return delegate.getOrDefault(key, defaultValue);
+    }
+
+    @Override
+    public void forEach(BiConsumer<? super K, ? super V> action) {
+        delegate.forEach(action);
+    }
+
+    @Override
+    public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
+        delegate.replaceAll(function);
+    }
+
+    @Override
+    public V putIfAbsent(K key, V value) {
+        return delegate.putIfAbsent(key, value);
+    }
+
+    @Override
+    public boolean remove(Object key, Object value) {
+        return delegate.remove(key, value);
+    }
+
+    @Override
+    public boolean replace(K key, V oldValue, V newValue) {
+        return delegate.replace(key, oldValue, newValue);
+    }
+
+    @Override
+    public V replace(K key, V value) {
+        return delegate.replace(key, value);
+    }
+
+    @Override
+    public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
+        return delegate.computeIfAbsent(key, mappingFunction);
+    }
+
+    @Override
+    public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
+        return delegate.computeIfPresent(key, remappingFunction);
+    }
+
+    @Override
+    public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
+        return delegate.compute(key, remappingFunction);
+    }
+
+    @Override
+    public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        return delegate.merge(key, value, remappingFunction);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        return delegate.equals(o);
+    }
+
+    @Override
+    public int hashCode() {
+        return delegate.hashCode();
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Event.java b/logstash-core-event-java/src/main/java/com/logstash/Event.java
index d8979b41003..a95fb08e472 100644
--- a/logstash-core-event-java/src/main/java/com/logstash/Event.java
+++ b/logstash-core-event-java/src/main/java/com/logstash/Event.java
@@ -1,13 +1,21 @@
 package com.logstash;
 
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.logstash.bivalues.NullBiValue;
+import com.logstash.bivalues.StringBiValue;
+import com.logstash.bivalues.TimeBiValue;
+import com.logstash.bivalues.TimestampBiValue;
 import com.logstash.ext.JrubyTimestampExtLibrary;
 import org.joda.time.DateTime;
 import org.jruby.RubySymbol;
 
 import java.io.IOException;
 import java.io.Serializable;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 
 public class Event implements Cloneable, Serializable {
@@ -48,13 +56,14 @@ public Event()
 
     public Event(Map data)
     {
-        this.data = data;
+        this.data = (Map<String, Object>)Valuefier.convert(data);
+
         if (!this.data.containsKey(VERSION)) {
             this.data.put(VERSION, VERSION_ONE);
         }
 
         if (this.data.containsKey(METADATA)) {
-            this.metadata = (HashMap<String, Object>) this.data.remove(METADATA);
+            this.metadata = (Map<String, Object>) this.data.remove(METADATA);
         } else {
             this.metadata = new HashMap<String, Object>();
         }
@@ -75,7 +84,7 @@ public Map<String, Object> getMetadata() {
     }
 
     public void setData(Map<String, Object> data) {
-        this.data = data;
+        this.data = ConvertedMap.newFromMap(data);
     }
 
     public Accessors getAccessors() {
@@ -120,6 +129,11 @@ public void setTimestamp(Timestamp t) {
     }
 
     public Object getField(String reference) {
+        Object val = getUnconvertedField(reference);
+        return Javafier.deep(val);
+    }
+
+    public Object getUnconvertedField(String reference) {
         if (reference.equals(METADATA)) {
             return this.metadata;
         } else if (reference.startsWith(METADATA_BRACKETS)) {
@@ -134,12 +148,12 @@ public void setField(String reference, Object value) {
             // TODO(talevy): check type of timestamp
             this.accessors.set(reference, value);
         } else if (reference.equals(METADATA_BRACKETS) || reference.equals(METADATA)) {
-            this.metadata = (HashMap<String, Object>) value;
+            this.metadata = (Map<String, Object>) value;
             this.metadata_accessors = new Accessors(this.metadata);
         } else if (reference.startsWith(METADATA_BRACKETS)) {
             this.metadata_accessors.set(reference.substring(METADATA_BRACKETS.length()), value);
         } else {
-            this.accessors.set(reference, value);
+            this.accessors.set(reference, Valuefier.convert(value));
         }
     }
 
@@ -156,7 +170,7 @@ public boolean includes(String reference) {
     public String toJson()
             throws IOException
     {
-        return mapper.writeValueAsString((Map<String, Object>)this.data);
+        return mapper.writeValueAsString(this.data);
     }
 
     public static Event[] fromJson(String json)
@@ -205,7 +219,6 @@ public Event overwrite(Event e) {
         return this;
     }
 
-
     public Event append(Event e) {
         Util.mapMerge(this.data, e.data);
 
@@ -247,16 +260,22 @@ public String toString() {
 
     private Timestamp initTimestamp(Object o) {
         try {
-            if (o == null) {
+            if (o == null || o instanceof NullBiValue) {
                 // most frequent
                 return new Timestamp();
             } else if (o instanceof String) {
                 // second most frequent
                 return new Timestamp((String) o);
+            } else if (o instanceof StringBiValue) {
+                return new Timestamp(((StringBiValue) o).javaValue());
+            } else if (o instanceof TimeBiValue) {
+                return new Timestamp(((TimeBiValue) o).javaValue());
             } else if (o instanceof JrubyTimestampExtLibrary.RubyTimestamp) {
                 return new Timestamp(((JrubyTimestampExtLibrary.RubyTimestamp) o).getTimestamp());
             } else if (o instanceof Timestamp) {
                 return new Timestamp((Timestamp) o);
+            } else if (o instanceof TimestampBiValue) {
+                return new Timestamp(((TimestampBiValue) o).javaValue());
             } else if (o instanceof DateTime) {
                 return new Timestamp((DateTime) o);
             } else if (o instanceof Date) {
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Javafier.java b/logstash-core-event-java/src/main/java/com/logstash/Javafier.java
index 76103bf29ef..ab8ec0ebbff 100644
--- a/logstash-core-event-java/src/main/java/com/logstash/Javafier.java
+++ b/logstash-core-event-java/src/main/java/com/logstash/Javafier.java
@@ -1,234 +1,34 @@
 package com.logstash;
 
-import com.logstash.ext.JrubyTimestampExtLibrary;
-import org.joda.time.DateTime;
-import org.jruby.RubyArray;
-import org.jruby.RubyBignum;
-import org.jruby.RubyBoolean;
-import org.jruby.RubyFixnum;
-import org.jruby.RubyFloat;
-import org.jruby.RubyHash;
-import org.jruby.RubyInteger;
-import org.jruby.RubyNil;
-import org.jruby.RubyString;
-import org.jruby.RubySymbol;
-import org.jruby.RubyTime;
-import org.jruby.ext.bigdecimal.RubyBigDecimal;
-import org.jruby.java.proxies.JavaProxy;
-import org.jruby.java.proxies.MapJavaProxy;
-import org.jruby.javasupport.JavaUtil;
-import org.jruby.runtime.builtin.IRubyObject;
 
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import com.logstash.bivalues.BiValue;
+import com.logstash.bivalues.BiValues;
 
 public class Javafier {
     private static final String ERR_TEMPLATE = "Missing Ruby class handling for full class name=%s, simple name=%s";
-    private static final String PROXY_ERR_TEMPLATE = "Missing Ruby class handling for full class name=%s, simple name=%s, wrapped object=%s";
-
+    /*
+    Javafier.deep() is called by getField.
+    When any value is added to the Event it should pass through Valuefier.convert.
+    deep(Object o) is the mechanism to pluck the Java value from a BiValue or convert a
+    ConvertedList and ConvertedMap back to ArrayList or HashMap.
+     */
     private Javafier(){}
 
-    public static List<Object> deep(IRubyObject[] a) {
-        final ArrayList<Object> result = new ArrayList();
-
-        for (IRubyObject o : a) {
-            result.add(deep(o));
-        }
-        return result;
-    }
-
-    public static List<Object> deep(RubyArray a) {
-        return deep(a.toJavaArray());
-    }
-
-    private static HashMap<String, Object> deepMap(final Map<?, ?> map) {
-        final HashMap<String, Object> result = new HashMap();
-
-        for (Map.Entry<?, ?> entry : map.entrySet()) {
-            String k;
-            if (entry.getKey() instanceof IRubyObject) {
-                k = ((IRubyObject) entry.getKey()).asJavaString();
-            } else {
-                k = String.valueOf(entry.getKey());
-            }
-            result.put(k, deepAnything(entry.getValue()));
-        }
-        return result;
-    }
-
-    private static List<Object> deepList(List<Object> a) {
-        final ArrayList<Object> result = new ArrayList();
-
-        for (Object o : a) {
-            result.add(deepAnything(o));
-        }
-        return result;
-    }
-
-    public static HashMap<String, Object> deep(RubyHash h) {
-        final HashMap<String, Object> result = new HashMap();
-
-        h.visitAll(new RubyHash.Visitor() {
-            @Override
-            public void visit(IRubyObject key, IRubyObject value) {
-                result.put(deep(key).toString(), deep(value));
+    public static Object deep(Object o) {
+        if (o instanceof BiValue) {
+            return ((BiValue)o).javaValue();
+        } else if(o instanceof ConvertedMap) {
+            return ((ConvertedMap) o).unconvert();
+        }  else if(o instanceof ConvertedList) {
+            return ((ConvertedList) o).unconvert();
+        } else {
+            try {
+                return BiValues.newBiValue(o).javaValue();
+            } catch (IllegalArgumentException e) {
+                Class cls = o.getClass();
+                throw new IllegalArgumentException(String.format(ERR_TEMPLATE, cls.getName(), cls.getSimpleName()));
             }
-        });
-        return result;
-    }
-
-    private static Object deepAnything(Object o) {
-        // because, although we have a Java object (from a JavaProxy??), it may have IRubyObjects inside
-        if (o instanceof IRubyObject) {
-            return deep((IRubyObject) o);
-        }
-        if (o instanceof Map) {
-            return deepMap((Map) o);
-        }
-        if (o instanceof List) {
-            return deepList((List) o);
-        }
-        return o;
-    }
-
-    public static String deep(RubyString s) {
-        return s.asJavaString();
-    }
-
-    public static long deep(RubyInteger i) {
-        return i.getLongValue();
-    }
-
-    public static long deep(RubyFixnum n) {
-        return n.getLongValue();
-    }
-
-    public static double deep(RubyFloat f) {
-        return f.getDoubleValue();
-    }
-
-    public static BigDecimal deep(RubyBigDecimal bd) {
-        return bd.getBigDecimalValue();
-    }
-
-    public static BigInteger deep(RubyBignum bn) {
-        return bn.getBigIntegerValue();
-    }
-
-    public static Timestamp deep(JrubyTimestampExtLibrary.RubyTimestamp t) {
-        return t.getTimestamp();
-    }
-
-    public static boolean deep(RubyBoolean b) {
-        return b.isTrue();
-    }
-
-    public static Object deep(RubyNil n) {
-        return null;
-    }
-
-    public static DateTime deep(RubyTime t) {
-        return t.getDateTime();
-    }
-
-    public static String deep(RubySymbol s) {
-        return s.asJavaString();
-    }
-
-    public static Object deep(RubyBoolean.True b) {
-        return true;
-    }
-
-    public static Object deep(RubyBoolean.False b) {
-        return false;
-    }
-
-    private static Object deepJavaProxy(JavaProxy jp) {
-        Object obj = JavaUtil.unwrapJavaObject(jp);
-        if (obj instanceof IRubyObject[]) {
-            return deep((IRubyObject[])obj);
-        }
-        if (obj instanceof List) {
-            return deepList((List<Object>) obj);
-        }
-        Class cls = jp.getClass();
-        throw new IllegalArgumentException(missingHandlerString(PROXY_ERR_TEMPLATE, cls.getName(), cls.getSimpleName(), obj.getClass().getName()));
-    }
-
-    public static Object deep(IRubyObject o) {
-        // TODO: (colin) this enum strategy is cleaner but I am hoping that is not slower than using a instanceof cascade
-        Class cls = o.getClass();
-        RUBYCLASS clazz;
-        try {
-            clazz = RUBYCLASS.valueOf(cls.getSimpleName());
-        } catch (IllegalArgumentException e) {
-            throw new IllegalArgumentException(missingHandlerString(ERR_TEMPLATE, cls.getName(), cls.getSimpleName()));
-        }
-
-        switch(clazz) {
-            case RubyArray: return deep((RubyArray)o);
-            case RubyHash: return deep((RubyHash)o);
-            case RubyString: return deep((RubyString)o);
-            case RubyInteger: return deep((RubyInteger)o);
-            case RubyFloat: return deep((RubyFloat)o);
-            case RubyBigDecimal: return deep((RubyBigDecimal)o);
-            case RubyTimestamp: return deep((JrubyTimestampExtLibrary.RubyTimestamp)o);
-            case RubyBoolean: return deep((RubyBoolean)o);
-            case RubyFixnum: return deep((RubyFixnum)o);
-            case RubyBignum: return deep((RubyBignum)o);
-            case RubyTime: return deep((RubyTime)o);
-            case RubySymbol: return deep((RubySymbol)o);
-            case RubyNil: return deep((RubyNil)o);
-            case True: return deep((RubyBoolean.True)o);
-            case False: return deep((RubyBoolean.False)o);
-            case MapJavaProxy: return deepMap((Map)((MapJavaProxy) o).getObject());
-            case ArrayJavaProxy:  return deepJavaProxy((JavaProxy) o);
-            case ConcreteJavaProxy: return deepJavaProxy((JavaProxy) o);
         }
-
-        if (o.isNil()) {
-            return null;
-        }
-
-        // TODO: (colin) temporary trace to spot any unhandled types
-        System.out.println(String.format(
-                "***** WARN: UNHANDLED IRubyObject full class name=%s, simple name=%s java class=%s toString=%s",
-                o.getMetaClass().getRealClass().getName(),
-                o.getClass().getSimpleName(),
-                o.getJavaClass().toString(),
-                o.toString()));
-
-        return o.toJava(o.getJavaClass());
-    }
-
-    enum RUBYCLASS {
-        RubyString,
-        RubyInteger,
-        RubyFloat,
-        RubyBigDecimal,
-        RubyTimestamp,
-        RubyArray,
-        RubyHash,
-        RubyBoolean,
-        RubyFixnum,
-        RubyBignum,
-        RubyNil,
-        RubyTime,
-        RubySymbol,
-        True,
-        False,
-        // these proxies may wrap a java collection of IRubyObject types
-        MapJavaProxy,
-        ArrayJavaProxy,
-        ConcreteJavaProxy
-    }
-
-    private static String missingHandlerString(String fmt, String... subs) {
-        return String.format(fmt, subs);
     }
 }
 
diff --git a/logstash-core-event-java/src/main/java/com/logstash/KeyNode.java b/logstash-core-event-java/src/main/java/com/logstash/KeyNode.java
index cfc46861f69..ed5ada11e7c 100644
--- a/logstash-core-event-java/src/main/java/com/logstash/KeyNode.java
+++ b/logstash-core-event-java/src/main/java/com/logstash/KeyNode.java
@@ -1,6 +1,7 @@
 package com.logstash;
 
 import com.fasterxml.jackson.databind.ObjectMapper;
+import com.logstash.bivalues.BiValue;
 
 import java.io.IOException;
 import java.util.List;
@@ -58,6 +59,9 @@ public static String join(List<?> list, String delim) {
     private static String toString(Object value, String delim) {
         if (value == null) return "";
         if (value instanceof List) return join((List)value, delim);
+        if (value instanceof BiValue) {
+            return ((BiValue) value).toString();
+        }
         return value.toString();
     }
 }
\ No newline at end of file
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Rubyfier.java b/logstash-core-event-java/src/main/java/com/logstash/Rubyfier.java
index 0bafab8c9da..7f32ab96027 100644
--- a/logstash-core-event-java/src/main/java/com/logstash/Rubyfier.java
+++ b/logstash-core-event-java/src/main/java/com/logstash/Rubyfier.java
@@ -1,65 +1,59 @@
 package com.logstash;
 
-import com.logstash.ext.JrubyTimestampExtLibrary;
+import com.logstash.bivalues.BiValue;
+import com.logstash.bivalues.BiValues;
 import org.jruby.Ruby;
 import org.jruby.RubyArray;
 import org.jruby.RubyHash;
-import org.jruby.ext.bigdecimal.RubyBigDecimal;
-import org.jruby.javasupport.JavaUtil;
 import org.jruby.runtime.builtin.IRubyObject;
 
-import java.math.BigDecimal;
-import java.util.*;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
 
 public final class Rubyfier {
-
-    private Rubyfier(){}
-
-    public static IRubyObject deep(Ruby runtime, final Object input) {
-        if (input instanceof IRubyObject) return (IRubyObject)input;
-        if (input instanceof Map) return deepMap(runtime, (Map) input);
-        if (input instanceof List) return deepList(runtime, (List) input);
-        if (input instanceof Timestamp) return JrubyTimestampExtLibrary.RubyTimestamp.newRubyTimestamp(runtime, (Timestamp)input);
-        if (input instanceof Collection) throw new ClassCastException("unexpected Collection type " + input.getClass());
-
-        // BigDecimal is not currenly handled by JRuby and this is the type Jackson uses for floats
-        if (input instanceof BigDecimal) return new RubyBigDecimal(runtime, runtime.getClass("BigDecimal"), (BigDecimal)input);
-
-        return JavaUtil.convertJavaToUsableRubyObject(runtime, input);
+    private static final String ERR_TEMPLATE = "Missing Java class handling for full class name=%s, simple name=%s";
+    /*
+    Rubyfier.deep() is called by JrubyEventExtLibrary RubyEvent ruby_get_field,
+    ruby_remove, ruby_to_hash and ruby_to_hash_with_metadata.
+    When any value is added to the Event it should pass through Valuefier.convert.
+    Rubyfier.deep is the mechanism to pluck the Ruby value from a BiValue or convert a
+    ConvertedList and ConvertedMap back to RubyArray or RubyHash.
+    However, IRubyObjects and the RUby runtime do not belong in ConvertedMap or ConvertedList
+    so they are unconverted here.
+    */
+    private Rubyfier() {
     }
 
-    public static Object deepOnly(Ruby runtime, final Object input) {
+    public static IRubyObject deep(Ruby runtime, final Object input) {
+        if (input instanceof BiValue) return ((BiValue) input).rubyValue(runtime);
         if (input instanceof Map) return deepMap(runtime, (Map) input);
         if (input instanceof List) return deepList(runtime, (List) input);
-        if (input instanceof Timestamp) return JrubyTimestampExtLibrary.RubyTimestamp.newRubyTimestamp(runtime, (Timestamp)input);
-        if (input instanceof Collection) throw new ClassCastException("unexpected Collection type " + input.getClass());
-
-        // BigDecimal is not currenly handled by JRuby and this is the type Jackson uses for floats
-        if (input instanceof BigDecimal) return new RubyBigDecimal(runtime, runtime.getClass("BigDecimal"), (BigDecimal)input);
+        if (input instanceof Collection) throw new ClassCastException("Unexpected Collection type " + input.getClass());
 
-        return input;
+        try {
+            return BiValues.newBiValue(input).rubyValue(runtime);
+        } catch (IllegalArgumentException e) {
+            Class cls = input.getClass();
+            throw new IllegalArgumentException(String.format(ERR_TEMPLATE, cls.getName(), cls.getSimpleName()));
+        }
     }
 
     private static RubyArray deepList(Ruby runtime, final List list) {
         final int length = list.size();
         final RubyArray array = runtime.newArray(length);
-
         for (Object item : list) {
-            // use deepOnly because RubyArray.add already calls JavaUtil.convertJavaToUsableRubyObject on item
-            array.add(deepOnly(runtime, item));
+            array.add(deep(runtime, item));
         }
-
         return array;
     }
 
     private static RubyHash deepMap(Ruby runtime, final Map<?, ?> map) {
         RubyHash hash = RubyHash.newHash(runtime);
-
-        for (Map.Entry<?, ?> entry : map.entrySet()) {
-            // use deepOnly on value because RubyHash.put already calls JavaUtil.convertJavaToUsableRubyObject on items
-            hash.put(entry.getKey(), deepOnly(runtime, entry.getValue()));
+        for (Map.Entry entry : map.entrySet()) {
+            // Note: RubyHash.put calls JavaUtil.convertJavaToUsableRubyObject on keys and values
+            hash.put(entry.getKey(), deep(runtime, entry.getValue()));
         }
-
         return hash;
     }
 }
diff --git a/logstash-core-event-java/src/main/java/com/logstash/Valuefier.java b/logstash-core-event-java/src/main/java/com/logstash/Valuefier.java
new file mode 100644
index 00000000000..ea2b55b8a38
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/Valuefier.java
@@ -0,0 +1,92 @@
+package com.logstash;
+
+import com.logstash.bivalues.BiValue;
+import com.logstash.bivalues.BiValues;
+import com.logstash.ext.JrubyTimestampExtLibrary;
+import org.joda.time.DateTime;
+import org.jruby.RubyArray;
+import org.jruby.RubyHash;
+import org.jruby.RubyTime;
+import org.jruby.java.proxies.ArrayJavaProxy;
+import org.jruby.java.proxies.ConcreteJavaProxy;
+import org.jruby.java.proxies.JavaProxy;
+import org.jruby.java.proxies.MapJavaProxy;
+import org.jruby.javasupport.JavaUtil;
+import org.jruby.runtime.builtin.IRubyObject;
+
+import java.util.List;
+import java.util.Map;
+
+public class Valuefier {
+    private static final String PROXY_ERR_TEMPLATE = "Missing Valuefier handling for full class name=%s, simple name=%s, wrapped object=%s";
+    private static final String ERR_TEMPLATE = "Missing Valuefier handling for full class name=%s, simple name=%s";
+
+    private Valuefier(){}
+
+    private static Object convertJavaProxy(JavaProxy jp) {
+        Object obj = JavaUtil.unwrapJavaObject(jp);
+        if (obj instanceof IRubyObject[]) {
+            ConvertedList<Object> list = new ConvertedList<>();
+            for (IRubyObject ro : ((IRubyObject[]) obj)) {
+                list.add(convert(ro));
+            }
+            return list;
+        }
+        if (obj instanceof List) {
+            return ConvertedList.newFromList((List<Object>) obj);
+        }
+        try {
+            return BiValues.newBiValue(jp);
+        } catch (IllegalArgumentException e) {
+            Class cls = obj.getClass();
+            throw new IllegalArgumentException(String.format(PROXY_ERR_TEMPLATE, cls.getName(), cls.getSimpleName(), obj.getClass().getName()), e);
+        }
+    }
+
+    public static Object convertNonCollection(Object o) {
+        try {
+            return BiValues.newBiValue(o);
+        } catch (IllegalArgumentException e) {
+            Class cls = o.getClass();
+            throw new IllegalArgumentException(String.format(ERR_TEMPLATE, cls.getName(), cls.getSimpleName()), e);
+        }
+    }
+
+    public static Object convert(Object o) throws IllegalArgumentException {
+        if (o instanceof ConvertedMap || o instanceof ConvertedList) {
+            return o;
+        }
+        if (o instanceof BiValue) {
+            return o;
+        }
+        if (o instanceof RubyHash) {
+            return ConvertedMap.newFromRubyHash((RubyHash) o);
+        }
+        if (o instanceof RubyArray) {
+            return ConvertedList.newFromRubyArray((RubyArray) o);
+        }
+        if (o instanceof Map) {
+            return ConvertedMap.newFromMap((Map<String, Object>) o);
+        }
+        if (o instanceof List) {
+            return ConvertedList.newFromList((List<Object>) o);
+        }
+        if (o instanceof MapJavaProxy){
+            return ConvertedMap.newFromMap((Map)((MapJavaProxy) o).getObject());
+        }
+        if (o instanceof ArrayJavaProxy || o instanceof ConcreteJavaProxy){
+            return convertJavaProxy((JavaProxy) o);
+        }
+        if (o instanceof RubyTime) {
+            RubyTime time = (RubyTime) o;
+            Timestamp ts = new Timestamp(time.getDateTime());
+            JrubyTimestampExtLibrary.RubyTimestamp rts = JrubyTimestampExtLibrary.RubyTimestamp.newRubyTimestamp(time.getRuntime(), ts);
+            return convertNonCollection(rts);
+        }
+        if (o instanceof DateTime) {
+            Timestamp ts = new Timestamp((DateTime) o);
+            return convertNonCollection(ts);
+        }
+        return convertNonCollection(o);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/BiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BiValue.java
new file mode 100644
index 00000000000..1eab0cd359e
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BiValue.java
@@ -0,0 +1,18 @@
+package com.logstash.bivalues;
+
+import org.jruby.Ruby;
+import org.jruby.runtime.builtin.IRubyObject;
+
+public interface BiValue<R extends IRubyObject, J> {
+    IRubyObject rubyValue(Ruby runtime);
+
+    J javaValue();
+
+    R rubyValueUnconverted();
+
+    boolean hasRubyValue();
+
+    boolean hasJavaValue();
+}
+
+
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/BiValueCommon.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BiValueCommon.java
new file mode 100644
index 00000000000..b8759f27d5c
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BiValueCommon.java
@@ -0,0 +1,110 @@
+package com.logstash.bivalues;
+
+import com.fasterxml.jackson.annotation.JsonValue;
+import org.jruby.Ruby;
+import org.jruby.runtime.builtin.IRubyObject;
+
+import java.io.InvalidObjectException;
+import java.io.ObjectInputStream;
+import java.io.ObjectStreamException;
+import java.io.Serializable;
+
+public abstract class BiValueCommon<R extends IRubyObject, J> implements Serializable {
+    protected transient R rubyValue;
+    protected J javaValue;
+
+    public R rubyValue(Ruby runtime) {
+        if (hasRubyValue()) {
+            return rubyValue;
+        }
+        addRuby(runtime);
+        return rubyValue;
+    }
+
+    @JsonValue
+    public J javaValue() {
+        if (javaValue == null) {
+            addJava();
+        }
+        return javaValue;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+
+        if (hasJavaValue() && javaValue.getClass().isAssignableFrom(o.getClass())){
+            return javaValue.equals(o);
+        }
+
+        if(!(o instanceof BiValue)) {
+            return false;
+        }
+
+        BiValueCommon<?, ?> other = (BiValueCommon<?, ?>) o;
+
+        return (other.hasJavaValue() && other.javaValue().equals(javaValue)) ||
+                (other.hasRubyValue() && other.rubyValueUnconverted().equals(rubyValue));
+
+    }
+
+    @Override
+    public int hashCode() {
+        if (hasRubyValue()) {
+            return rubyValue.hashCode();
+        }
+        if (hasJavaValue()) {
+            return javaValue.hashCode();
+        }
+        return 0;
+    }
+
+    public R rubyValueUnconverted() {
+        return rubyValue;
+    }
+
+    public boolean hasRubyValue() {
+        return null != rubyValue;
+    }
+
+    public boolean hasJavaValue() {
+        return null != javaValue;
+    }
+
+    protected abstract void addRuby(Ruby runtime);
+
+    protected abstract void addJava();
+
+    @Override
+    public String toString() {
+        if (hasRubyValue()) {
+            javaValue();
+        }
+        if (javaValue == null) {
+            return "";
+        }
+        return String.valueOf(javaValue);
+    }
+
+    protected static Object newProxy(BiValue instance) {
+        return new SerializationProxy(instance);
+    }
+
+    private static class SerializationProxy implements Serializable {
+        private static final long serialVersionUID = -1749700725129586973L;
+
+        private final Object javaValue;
+
+        public SerializationProxy(BiValue o) {
+            javaValue = o.javaValue(); // ensure the javaValue is converted from a ruby one if it exists
+        }
+
+        private Object readResolve() throws ObjectStreamException {
+            return BiValues.newBiValue(javaValue);
+        }
+    }
+
+    private void readObject(ObjectInputStream stream) throws InvalidObjectException {
+        throw new InvalidObjectException("Proxy required");
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/BiValues.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BiValues.java
new file mode 100644
index 00000000000..df1ffbfaebc
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BiValues.java
@@ -0,0 +1,203 @@
+package com.logstash.bivalues;
+
+import com.logstash.Timestamp;
+import com.logstash.ext.JrubyTimestampExtLibrary.RubyTimestamp;
+import org.jruby.RubyBignum;
+import org.jruby.RubyBoolean;
+import org.jruby.RubyFloat;
+import org.jruby.RubyInteger;
+import org.jruby.RubyNil;
+import org.jruby.RubyString;
+import org.jruby.RubySymbol;
+import org.jruby.ext.bigdecimal.RubyBigDecimal;
+import org.jruby.java.proxies.JavaProxy;
+import org.jruby.runtime.builtin.IRubyObject;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.HashMap;
+
+public enum BiValues {
+    COM_LOGSTASH_EXT_JRUBYTIMESTAMPEXTLIBRARY$RUBYTIMESTAMP(BiValueType.TIMESTAMP),
+    COM_LOGSTASH_TIMESTAMP(BiValueType.TIMESTAMP),
+    JAVA_LANG_BOOLEAN(BiValueType.BOOLEAN),
+    JAVA_LANG_DOUBLE(BiValueType.DOUBLE),
+    JAVA_LANG_FLOAT(BiValueType.FLOAT),
+    JAVA_LANG_INTEGER(BiValueType.INT),
+    JAVA_LANG_LONG(BiValueType.LONG),
+    JAVA_LANG_STRING(BiValueType.STRING),
+    JAVA_MATH_BIGDECIMAL(BiValueType.DECIMAL),
+    JAVA_MATH_BIGINTEGER(BiValueType.BIGINT),
+    ORG_JRUBY_EXT_BIGDECIMAL_RUBYBIGDECIMAL(BiValueType.DECIMAL),
+    ORG_JRUBY_JAVA_PROXIES_CONCRETEJAVAPROXY(BiValueType.JAVAPROXY),
+    ORG_JRUBY_RUBYBIGNUM(BiValueType.BIGINT),
+    ORG_JRUBY_RUBYBOOLEAN$FALSE(BiValueType.BOOLEAN),
+    ORG_JRUBY_RUBYBOOLEAN$TRUE(BiValueType.BOOLEAN),
+    ORG_JRUBY_RUBYBOOLEAN(BiValueType.BOOLEAN),
+    ORG_JRUBY_RUBYFIXNUM(BiValueType.LONG),
+    ORG_JRUBY_RUBYFLOAT(BiValueType.DOUBLE),
+    ORG_JRUBY_RUBYINTEGER(BiValueType.LONG),
+    ORG_JRUBY_RUBYNIL(BiValueType.NULL),
+    ORG_JRUBY_RUBYSTRING(BiValueType.STRING),
+    ORG_JRUBY_RUBYSYMBOL(BiValueType.SYMBOL), // one way conversion, a Java string will use STRING
+    NULL(BiValueType.NULL);
+
+    private static HashMap<String, String> initCache() {
+        HashMap<String, String> hm = new HashMap<>();
+        hm.put("com.logstash.Timestamp", "COM_LOGSTASH_TIMESTAMP");
+        hm.put("com.logstash.ext.JrubyTimestampExtLibrary$RubyTimestamp", "COM_LOGSTASH_EXT_JRUBYTIMESTAMPEXTLIBRARY$RUBYTIMESTAMP");
+        hm.put("java.lang.Boolean", "JAVA_LANG_BOOLEAN");
+        hm.put("java.lang.Double", "JAVA_LANG_DOUBLE");
+        hm.put("java.lang.Float", "JAVA_LANG_FLOAT");
+        hm.put("java.lang.Integer", "JAVA_LANG_INTEGER");
+        hm.put("java.lang.Long", "JAVA_LANG_LONG");
+        hm.put("java.lang.String", "JAVA_LANG_STRING");
+        hm.put("java.math.BigDecimal", "JAVA_MATH_BIGDECIMAL");
+        hm.put("java.math.BigInteger", "JAVA_MATH_BIGINTEGER");
+        hm.put("org.jruby.RubyBignum", "ORG_JRUBY_RUBYBIGNUM");
+        hm.put("org.jruby.RubyBoolean", "ORG_JRUBY_RUBYBOOLEAN");
+        hm.put("org.jruby.RubyBoolean$False", "ORG_JRUBY_RUBYBOOLEAN$FALSE");
+        hm.put("org.jruby.RubyBoolean$True", "ORG_JRUBY_RUBYBOOLEAN$TRUE");
+        hm.put("org.jruby.RubyFixnum", "ORG_JRUBY_RUBYFIXNUM");
+        hm.put("org.jruby.RubyFloat", "ORG_JRUBY_RUBYFLOAT");
+        hm.put("org.jruby.RubyInteger", "ORG_JRUBY_RUBYINTEGER");
+        hm.put("org.jruby.RubyNil", "ORG_JRUBY_RUBYNIL");
+        hm.put("org.jruby.RubyString", "ORG_JRUBY_RUBYSTRING");
+        hm.put("org.jruby.RubySymbol", "ORG_JRUBY_RUBYSYMBOL");
+        hm.put("org.jruby.ext.bigdecimal.RubyBigDecimal", "ORG_JRUBY_EXT_BIGDECIMAL_RUBYBIGDECIMAL");
+        hm.put("org.jruby.java.proxies.ConcreteJavaProxy", "ORG_JRUBY_JAVA_PROXIES_CONCRETEJAVAPROXY");
+        return hm;
+    }
+
+    private final BiValueType biValueType;
+
+    BiValues(BiValueType biValueType) {
+        this.biValueType = biValueType;
+    }
+
+    private static final HashMap<String, String> nameCache = initCache();
+
+    private BiValue build(Object value) {
+        return biValueType.build(value);
+    }
+
+    public static BiValue newBiValue(Object o) {
+        if (o == null){
+            return NULL.build(null);
+        }
+        BiValues bvs = valueOf(fetchName(o));
+        return bvs.build(o);
+    }
+
+    private static String fetchName(Object o) {
+        String cls = o.getClass().getName();
+        if (nameCache.containsKey(cls)) {
+            return nameCache.get(cls);
+        }
+        String toCache = cls.toUpperCase().replace('.', '_');
+        // TODO[Guy] log warn that we are seeing a uncached value
+        nameCache.put(cls, toCache);
+        return toCache;
+    }
+
+    private enum BiValueType {
+        STRING {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new StringBiValue((RubyString) value);
+                }
+                return new StringBiValue((String) value);
+            }
+        },
+        SYMBOL {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new SymbolBiValue((RubySymbol) value);
+                }
+                return new SymbolBiValue((String) value);
+            }
+        },
+        LONG {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new LongBiValue((RubyInteger) value);
+                }
+                return new LongBiValue((Long) value);
+            }
+        },
+        INT {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new IntegerBiValue((RubyInteger) value);
+                }
+                return new IntegerBiValue((Integer) value);
+            }
+        },
+        DOUBLE {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new DoubleBiValue((RubyFloat) value);
+                }
+                return new DoubleBiValue((Double) value);
+            }
+        },
+        FLOAT {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new DoubleBiValue((RubyFloat) value);
+                }
+                return new FloatBiValue((Float) value);
+            }
+        },
+        DECIMAL {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new BigDecimalBiValue((RubyBigDecimal) value);
+                }
+                return new BigDecimalBiValue((BigDecimal) value);
+            }
+        },
+        BOOLEAN {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new BooleanBiValue((RubyBoolean) value);
+                }
+                return new BooleanBiValue((Boolean) value);
+            }
+        },
+        TIMESTAMP {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new TimestampBiValue((RubyTimestamp) value);
+                }
+                return new TimestampBiValue((Timestamp) value);
+            }
+        },
+        NULL {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new NullBiValue((RubyNil) value);
+                }
+                return NullBiValue.newNullBiValue();
+            }
+        },
+        BIGINT {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new BigIntegerBiValue((RubyBignum) value);
+                }
+                return new BigIntegerBiValue((BigInteger) value);
+            }
+        },
+        JAVAPROXY {
+            BiValue build(Object value) {
+                if (value instanceof IRubyObject) {
+                    return new JavaProxyBiValue((JavaProxy) value);
+                }
+                return new JavaProxyBiValue(value);
+            }
+        };
+        abstract BiValue build(Object value);
+    }
+
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/BigDecimalBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BigDecimalBiValue.java
new file mode 100644
index 00000000000..77a41d3619c
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BigDecimalBiValue.java
@@ -0,0 +1,36 @@
+package com.logstash.bivalues;
+
+import org.jruby.Ruby;
+import org.jruby.ext.bigdecimal.RubyBigDecimal;
+
+import java.io.ObjectStreamException;
+import java.math.BigDecimal;
+
+public class BigDecimalBiValue extends BiValueCommon<RubyBigDecimal, BigDecimal> implements BiValue<RubyBigDecimal, BigDecimal> {
+
+    public BigDecimalBiValue(RubyBigDecimal rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public BigDecimalBiValue(BigDecimal javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private BigDecimalBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = new RubyBigDecimal(runtime, runtime.getClass("BigDecimal"), javaValue);
+    }
+
+    protected void addJava() {
+        javaValue = rubyValue.getBigDecimalValue();
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/BigIntegerBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BigIntegerBiValue.java
new file mode 100644
index 00000000000..e4760ac85bf
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BigIntegerBiValue.java
@@ -0,0 +1,36 @@
+package com.logstash.bivalues;
+
+import org.jruby.Ruby;
+import org.jruby.RubyBignum;
+
+import java.io.ObjectStreamException;
+import java.math.BigInteger;
+
+public class BigIntegerBiValue extends BiValueCommon<RubyBignum, BigInteger> implements BiValue<RubyBignum, BigInteger> {
+
+    public BigIntegerBiValue(RubyBignum rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public BigIntegerBiValue(BigInteger javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private BigIntegerBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = new RubyBignum(runtime, javaValue);
+    }
+
+    protected void addJava() {
+        javaValue = rubyValue.getValue();
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/BooleanBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BooleanBiValue.java
new file mode 100644
index 00000000000..aab70dcef52
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/BooleanBiValue.java
@@ -0,0 +1,36 @@
+package com.logstash.bivalues;
+
+import org.jruby.Ruby;
+import org.jruby.RubyBoolean;
+
+import java.io.ObjectStreamException;
+
+
+public class BooleanBiValue extends BiValueCommon<RubyBoolean, Boolean> implements BiValue<RubyBoolean, Boolean> {
+
+    public BooleanBiValue(RubyBoolean rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public BooleanBiValue(Boolean javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private BooleanBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = RubyBoolean.newBoolean(runtime, javaValue);
+    }
+
+    protected void addJava() {
+        javaValue = rubyValue.isTrue();
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/DoubleBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/DoubleBiValue.java
new file mode 100644
index 00000000000..7a39ea13523
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/DoubleBiValue.java
@@ -0,0 +1,36 @@
+package com.logstash.bivalues;
+
+import org.jruby.Ruby;
+import org.jruby.RubyFloat;
+
+import java.io.ObjectStreamException;
+
+
+public class DoubleBiValue extends BiValueCommon<RubyFloat, Double> implements BiValue<RubyFloat, Double> {
+
+    public DoubleBiValue(RubyFloat rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public DoubleBiValue(Double javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private DoubleBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = RubyFloat.newFloat(runtime, javaValue);
+    }
+
+    protected void addJava() {
+        javaValue = rubyValue.getDoubleValue();
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/FloatBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/FloatBiValue.java
new file mode 100644
index 00000000000..d33a38bcba1
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/FloatBiValue.java
@@ -0,0 +1,40 @@
+package com.logstash.bivalues;
+
+import org.jruby.Ruby;
+import org.jruby.RubyFloat;
+
+import java.io.ObjectStreamException;
+
+
+public class FloatBiValue extends BiValueCommon<RubyFloat, Float> implements BiValue<RubyFloat, Float> {
+
+    public FloatBiValue(RubyFloat rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public FloatBiValue(Float javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private FloatBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = RubyFloat.newFloat(runtime, (double)javaValue);
+    }
+
+    protected void addJava() {
+        double value = rubyValue.getDoubleValue();
+        if ((float) value != value) {
+            throw new ArithmeticException("Float overflow - Incorrect FloatBiValue usage: BiValues should pick DoubleBiValue for RubyFloat");
+        }
+        javaValue = (float) value;
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/IntegerBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/IntegerBiValue.java
new file mode 100644
index 00000000000..30ad9d43dec
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/IntegerBiValue.java
@@ -0,0 +1,40 @@
+package com.logstash.bivalues;
+
+import org.jruby.Ruby;
+import org.jruby.RubyInteger;
+import org.jruby.javasupport.JavaUtil;
+
+import java.io.ObjectStreamException;
+
+public class IntegerBiValue extends BiValueCommon<RubyInteger, Integer> implements BiValue<RubyInteger, Integer> {
+
+    public IntegerBiValue(RubyInteger rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public IntegerBiValue(int javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private IntegerBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = (RubyInteger) JavaUtil.convertJavaToUsableRubyObject(runtime, javaValue);
+    }
+
+    protected void addJava() {
+        long value = rubyValue.getLongValue();
+        if ((int) value != value) {
+            throw new ArithmeticException("Integer overflow - Incorrect IntegerBiValue usage: BiValues should pick LongBiValue for RubyInteger");
+        }
+        javaValue = (int) value;
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/JavaProxyBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/JavaProxyBiValue.java
new file mode 100644
index 00000000000..e18c0a5540f
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/JavaProxyBiValue.java
@@ -0,0 +1,36 @@
+package com.logstash.bivalues;
+
+import org.jruby.Ruby;
+import org.jruby.java.proxies.JavaProxy;
+import org.jruby.javasupport.JavaUtil;
+
+import java.io.ObjectStreamException;
+
+public class JavaProxyBiValue extends BiValueCommon<JavaProxy, Object> implements BiValue<JavaProxy, Object> {
+
+    public JavaProxyBiValue(JavaProxy rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public JavaProxyBiValue(Object javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private JavaProxyBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = (JavaProxy) JavaUtil.convertJavaToUsableRubyObject(runtime, javaValue);
+    }
+
+    protected void addJava() {
+        javaValue = rubyValue.getObject();
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/LongBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/LongBiValue.java
new file mode 100644
index 00000000000..97f5285f3db
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/LongBiValue.java
@@ -0,0 +1,36 @@
+package com.logstash.bivalues;
+
+import org.jruby.Ruby;
+import org.jruby.RubyInteger;
+import org.jruby.javasupport.JavaUtil;
+
+import java.io.ObjectStreamException;
+
+public class LongBiValue extends BiValueCommon<RubyInteger, Long> implements BiValue<RubyInteger, Long> {
+
+    public LongBiValue(RubyInteger rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public LongBiValue(long javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private LongBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = (RubyInteger) JavaUtil.convertJavaToUsableRubyObject(runtime, javaValue);
+    }
+
+    protected void addJava() {
+        javaValue = rubyValue.getLongValue();
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/NullBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/NullBiValue.java
new file mode 100644
index 00000000000..285d304e483
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/NullBiValue.java
@@ -0,0 +1,45 @@
+package com.logstash.bivalues;
+
+import com.fasterxml.jackson.annotation.JsonValue;
+import org.jruby.Ruby;
+import org.jruby.RubyNil;
+
+import java.io.ObjectStreamException;
+
+public class NullBiValue extends BiValueCommon<RubyNil, Object> implements BiValue<RubyNil, Object> {
+    public static NullBiValue newNullBiValue() {
+        return new NullBiValue();
+    }
+
+    public NullBiValue(RubyNil rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    private NullBiValue() {
+        rubyValue = null;
+        javaValue = null;
+    }
+
+    @JsonValue
+    @Override
+    public Object javaValue() {
+        return null;
+    }
+
+    @Override
+    public boolean hasJavaValue() {
+        return true;
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = (RubyNil) runtime.getNil();
+    }
+
+    protected void addJava() {}
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/StringBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/StringBiValue.java
new file mode 100644
index 00000000000..664f51ddc27
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/StringBiValue.java
@@ -0,0 +1,35 @@
+package com.logstash.bivalues;
+
+import org.jruby.Ruby;
+import org.jruby.RubyString;
+
+import java.io.ObjectStreamException;
+
+public class StringBiValue extends BiValueCommon<RubyString, String> implements BiValue<RubyString, String> {
+
+    public StringBiValue(RubyString rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public StringBiValue(String javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private StringBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = RubyString.newUnicodeString(runtime, javaValue);
+    }
+
+    protected void addJava() {
+        javaValue = rubyValue.asJavaString();
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/SymbolBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/SymbolBiValue.java
new file mode 100644
index 00000000000..db5da434106
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/SymbolBiValue.java
@@ -0,0 +1,35 @@
+package com.logstash.bivalues;
+
+import org.jruby.Ruby;
+import org.jruby.RubySymbol;
+
+import java.io.ObjectStreamException;
+
+public class SymbolBiValue extends BiValueCommon<RubySymbol, String> implements BiValue<RubySymbol, String> {
+
+    public SymbolBiValue(RubySymbol rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public SymbolBiValue(String javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private SymbolBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = RubySymbol.newSymbol(runtime, javaValue);
+    }
+
+    protected void addJava() {
+        javaValue = rubyValue.asJavaString();
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/TimeBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/TimeBiValue.java
new file mode 100644
index 00000000000..548ecd61d28
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/TimeBiValue.java
@@ -0,0 +1,37 @@
+package com.logstash.bivalues;
+
+import org.joda.time.DateTime;
+import org.jruby.Ruby;
+import org.jruby.RubyTime;
+
+import java.io.ObjectStreamException;
+
+
+public class TimeBiValue extends BiValueCommon<RubyTime, DateTime> implements BiValue<RubyTime, DateTime> {
+
+    public TimeBiValue(RubyTime rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public TimeBiValue(DateTime javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private TimeBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = RubyTime.newTime(runtime, javaValue);
+    }
+
+    protected void addJava() {
+        javaValue = rubyValue.getDateTime();
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/bivalues/TimestampBiValue.java b/logstash-core-event-java/src/main/java/com/logstash/bivalues/TimestampBiValue.java
new file mode 100644
index 00000000000..59b844a20b2
--- /dev/null
+++ b/logstash-core-event-java/src/main/java/com/logstash/bivalues/TimestampBiValue.java
@@ -0,0 +1,36 @@
+package com.logstash.bivalues;
+
+import com.logstash.Timestamp;
+import com.logstash.ext.JrubyTimestampExtLibrary.RubyTimestamp;
+import org.jruby.Ruby;
+
+import java.io.ObjectStreamException;
+
+public class TimestampBiValue extends BiValueCommon<RubyTimestamp, Timestamp> implements BiValue<RubyTimestamp, Timestamp> {
+
+    public TimestampBiValue(RubyTimestamp rubyValue) {
+        this.rubyValue = rubyValue;
+        javaValue = null;
+    }
+
+    public TimestampBiValue(Timestamp javaValue) {
+        this.javaValue = javaValue;
+        rubyValue = null;
+    }
+
+    private TimestampBiValue() {
+    }
+
+    protected void addRuby(Ruby runtime) {
+        rubyValue = RubyTimestamp.newRubyTimestamp(runtime, (Timestamp) javaValue);
+    }
+
+    protected void addJava() {
+        javaValue = rubyValue.getTimestamp();
+    }
+
+    // Called when object is to be serialized on a stream to allow the object to substitute a proxy for itself.
+    private Object writeReplace() throws ObjectStreamException {
+        return newProxy(this);
+    }
+}
diff --git a/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyEventExtLibrary.java b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyEventExtLibrary.java
index d468def96dd..6c533f663e7 100644
--- a/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyEventExtLibrary.java
+++ b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyEventExtLibrary.java
@@ -1,22 +1,7 @@
 package com.logstash.ext;
 
-import com.logstash.Logger;
-import com.logstash.Event;
-import com.logstash.PathCache;
-import com.logstash.Javafier;
-import com.logstash.Timestamp;
-import com.logstash.Rubyfier;
-import com.logstash.Javafier;
-import org.jruby.Ruby;
-import org.jruby.RubyObject;
-import org.jruby.RubyClass;
-import org.jruby.RubyModule;
-import org.jruby.RubyString;
-import org.jruby.RubyHash;
-import org.jruby.RubyBoolean;
-import org.jruby.RubyArray;
-import org.jruby.RubyFloat;
-import org.jruby.RubyInteger;
+import com.logstash.*;
+import org.jruby.*;
 import org.jruby.anno.JRubyClass;
 import org.jruby.anno.JRubyMethod;
 import org.jruby.exceptions.RaiseException;
@@ -27,12 +12,9 @@
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.jruby.runtime.load.Library;
-import org.jruby.ext.bigdecimal.RubyBigDecimal;
+
 import java.io.IOException;
 import java.util.Map;
-import java.util.HashMap;
-import java.util.List;
-
 
 public class JrubyEventExtLibrary implements Library {
 
@@ -40,10 +22,12 @@ public class JrubyEventExtLibrary implements Library {
     private static RubyClass GENERATOR_ERROR = null;
     private static RubyClass LOGSTASH_ERROR = null;
 
+    @Override
     public void load(Ruby runtime, boolean wrap) throws IOException {
         RubyModule module = runtime.defineModule("LogStash");
 
         RubyClass clazz = runtime.defineClassUnder("Event", runtime.getObject(), new ObjectAllocator() {
+            @Override
             public IRubyObject allocate(Ruby runtime, RubyClass rubyClass) {
                 return new RubyEvent(runtime, rubyClass);
             }
@@ -128,9 +112,10 @@ public IRubyObject ruby_initialize(ThreadContext context, IRubyObject[] args)
             if (data == null || data.isNil()) {
                 this.event = new Event();
             } else if (data instanceof RubyHash) {
-                this.event = new Event(Javafier.deep((RubyHash) data));
+                this.event = new Event(ConvertedMap.newFromRubyHash((RubyHash) data));
             } else if (data instanceof MapJavaProxy) {
-                this.event = new Event((Map)((MapJavaProxy)data).getObject());
+                Map<String, Object> m = (Map)((MapJavaProxy)data).getObject();
+                this.event = new Event(ConvertedMap.newFromMap(m));
             } else {
                 throw context.runtime.newTypeError("wrong argument type " + data.getMetaClass() + " (expected Hash)");
             }
@@ -141,7 +126,7 @@ public IRubyObject ruby_initialize(ThreadContext context, IRubyObject[] args)
         @JRubyMethod(name = "get", required = 1)
         public IRubyObject ruby_get_field(ThreadContext context, RubyString reference)
         {
-            Object value = this.event.getField(reference.asJavaString());
+            Object value = this.event.getUnconvertedField(reference.asJavaString());
             return Rubyfier.deep(context.runtime, value);
         }
 
@@ -156,7 +141,7 @@ public IRubyObject ruby_set_field(ThreadContext context, RubyString reference, I
                 }
                 this.event.setTimestamp(((JrubyTimestampExtLibrary.RubyTimestamp)value).getTimestamp());
             } else {
-                this.event.setField(r, Javafier.deep(value));
+                this.event.setField(r, Valuefier.convert(value));
             }
             return value;
         }
@@ -274,8 +259,8 @@ public IRubyObject ruby_to_json(ThreadContext context, IRubyObject[] args)
             }
         }
 
-        // @param value [String] the json string. A json object/map will convert to an array containing a single Event.
-        // and a json array will convert each element into individual Event
+        // @param value [String] the json string. A json object/map will newFromRubyArray to an array containing a single Event.
+        // and a json array will newFromRubyArray each element into individual Event
         // @return Array<Event> array of events
         @JRubyMethod(name = "from_json", required = 1, meta = true)
         public static IRubyObject ruby_from_json(ThreadContext context, IRubyObject recv, RubyString value)
@@ -310,8 +295,9 @@ public static IRubyObject ruby_validate_value(ThreadContext context, IRubyObject
         @JRubyMethod(name = "tag", required = 1)
         public IRubyObject ruby_tag(ThreadContext context, RubyString value)
         {
+            //TODO(guy) should these tags be BiValues?
             this.event.tag(((RubyString) value).asJavaString());
-            return context.runtime.getNil();
+            return context.nil;
         }
 
         @JRubyMethod(name = "timestamp")
diff --git a/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyTimestampExtLibrary.java b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyTimestampExtLibrary.java
index 9748a815ccb..86e0d3ef3e8 100644
--- a/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyTimestampExtLibrary.java
+++ b/logstash-core-event-java/src/main/java/com/logstash/ext/JrubyTimestampExtLibrary.java
@@ -16,14 +16,22 @@
 import java.io.IOException;
 
 public class JrubyTimestampExtLibrary implements Library {
+
+    private static final ObjectAllocator ALLOCATOR = new ObjectAllocator() {
+        public RubyTimestamp allocate(Ruby runtime, RubyClass rubyClass) {
+            return new RubyTimestamp(runtime, rubyClass);
+        }
+    };
+
     public void load(Ruby runtime, boolean wrap) throws IOException {
+        createTimestamp(runtime);
+    }
+
+    public static RubyClass createTimestamp(Ruby runtime) {
         RubyModule module = runtime.defineModule("LogStash");
-        RubyClass clazz = runtime.defineClassUnder("Timestamp", runtime.getObject(), new ObjectAllocator() {
-            public IRubyObject allocate(Ruby runtime, RubyClass rubyClass) {
-                return new RubyTimestamp(runtime, rubyClass);
-            }
-        }, module);
+        RubyClass clazz = runtime.defineClassUnder("Timestamp", runtime.getObject(), ALLOCATOR, module);
         clazz.defineAnnotatedMethods(RubyTimestamp.class);
+        return clazz;
     }
 
     @JRubyClass(name = "Timestamp", parent = "Object")
diff --git a/logstash-core-event-java/src/test/java/com/logstash/EventTest.java b/logstash-core-event-java/src/test/java/com/logstash/EventTest.java
index 61bb4bb7a58..0177e66346d 100644
--- a/logstash-core-event-java/src/test/java/com/logstash/EventTest.java
+++ b/logstash-core-event-java/src/test/java/com/logstash/EventTest.java
@@ -3,10 +3,15 @@
 import org.junit.Test;
 
 import java.io.IOException;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
-import static org.junit.Assert.*;
 import static net.javacrumbs.jsonunit.JsonAssert.assertJsonEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 
 public class EventTest {
     @Test
@@ -126,7 +131,9 @@ public void testAppend() throws Exception {
         Event e2 = new Event(data2);
         e.append(e2);
 
-        assertEquals(Arrays.asList("original1", "original2"), e.getField("field1"));
+        assertEquals(2, ((List) e.getField("[field1]")).size());
+        assertEquals("original1", e.getField("[field1][0]"));
+        assertEquals("original2", e.getField("[field1][1]"));
     }
 
     @Test
diff --git a/logstash-core-event-java/src/test/java/com/logstash/JavafierTest.java b/logstash-core-event-java/src/test/java/com/logstash/JavafierTest.java
index 4e0653b630d..5a6f730e4eb 100644
--- a/logstash-core-event-java/src/test/java/com/logstash/JavafierTest.java
+++ b/logstash-core-event-java/src/test/java/com/logstash/JavafierTest.java
@@ -1,33 +1,12 @@
 package com.logstash;
 
-import org.jruby.Ruby;
 import org.jruby.RubyBignum;
-import org.jruby.RubyClass;
-import org.jruby.RubyMatchData;
-import org.jruby.RubyString;
-import org.jruby.java.proxies.ArrayJavaProxy;
-import org.jruby.java.proxies.ConcreteJavaProxy;
-import org.jruby.java.proxies.MapJavaProxy;
-import org.jruby.javasupport.Java;
-import org.jruby.runtime.builtin.IRubyObject;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 
 import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-
 import static org.junit.Assert.assertEquals;
 
-public class JavafierTest {
-    public static final Ruby ruby;
-    static {
-        ruby = Ruby.getGlobalRuntime();
-    }
+public class JavafierTest extends TestBase {
 
     @Test
     public void testRubyBignum() {
@@ -37,64 +16,4 @@ public void testRubyBignum() {
         assertEquals(BigInteger.class, result.getClass());
         assertEquals( "-9223372036854776000", result.toString());
     }
-
-    @Test
-    public void testMapJavaProxy() {
-        Map<IRubyObject, IRubyObject> map = new HashMap<>();
-        map.put(RubyString.newString(ruby, "foo"), RubyString.newString(ruby, "bar"));
-        RubyClass proxyClass = (RubyClass) Java.getProxyClass(ruby, HashMap.class);
-        MapJavaProxy mjp = new MapJavaProxy(ruby, proxyClass);
-        mjp.setObject(map);
-
-        Object result = Javafier.deep(mjp);
-        assertEquals(HashMap.class, result.getClass());
-        HashMap<String, Object> m = (HashMap) result;
-        assertEquals("bar", m.get("foo"));
-    }
-
-    @Test
-    public void testArrayJavaProxy() {
-        IRubyObject[] array = new IRubyObject[]{RubyString.newString(ruby, "foo")};
-        RubyClass proxyClass = (RubyClass) Java.getProxyClass(ruby, String[].class);
-        ArrayJavaProxy ajp = new ArrayJavaProxy(ruby, proxyClass, array);
-
-        Object result = Javafier.deep(ajp);
-        assertEquals(ArrayList.class, result.getClass());
-        List<Object> a = (ArrayList) result;
-        assertEquals("foo", a.get(0));
-    }
-
-    @Test
-    public void testConcreteJavaProxy() {
-        List<IRubyObject> array = new ArrayList<>();
-        array.add(RubyString.newString(ruby, "foo"));
-        RubyClass proxyClass = (RubyClass) Java.getProxyClass(ruby, ArrayList.class);
-        ConcreteJavaProxy cjp = new ConcreteJavaProxy(ruby, proxyClass, array);
-        Object result = Javafier.deep(cjp);
-        assertEquals(ArrayList.class, result.getClass());
-        List<Object> a = (ArrayList) result;
-        assertEquals("foo", a.get(0));
-    }
-
-    @Rule
-    public ExpectedException exception = ExpectedException.none();
-
-    @Test
-    public void testUnhandledObject() {
-        RubyMatchData md = new RubyMatchData(ruby);
-        exception.expect(IllegalArgumentException.class);
-        exception.expectMessage("Missing Ruby class handling for full class name=org.jruby.RubyMatchData, simple name=RubyMatchData");
-        Javafier.deep(md);
-    }
-
-    @Test
-    public void testUnhandledProxyObject() {
-        HashSet<Integer> hs = new HashSet<>();
-        hs.add(42);
-        RubyClass proxyClass = (RubyClass) Java.getProxyClass(ruby, HashSet.class);
-        ConcreteJavaProxy cjp = new ConcreteJavaProxy(ruby, proxyClass, hs);
-        exception.expect(IllegalArgumentException.class);
-        exception.expectMessage("Missing Ruby class handling for full class name=org.jruby.java.proxies.ConcreteJavaProxy, simple name=ConcreteJavaProxy, wrapped object=java.util.HashSet");
-        Javafier.deep(cjp);
-    }
 }
diff --git a/logstash-core-event-java/src/test/java/com/logstash/RubyfierTest.java b/logstash-core-event-java/src/test/java/com/logstash/RubyfierTest.java
index 5773ce65ae5..d8d015c739b 100644
--- a/logstash-core-event-java/src/test/java/com/logstash/RubyfierTest.java
+++ b/logstash-core-event-java/src/test/java/com/logstash/RubyfierTest.java
@@ -1,6 +1,11 @@
 package com.logstash;
 
-import org.jruby.*;
+import org.jruby.RubyArray;
+import org.jruby.RubyBignum;
+import org.jruby.RubyFixnum;
+import org.jruby.RubyFloat;
+import org.jruby.RubyHash;
+import org.jruby.RubyString;
 import org.jruby.ext.bigdecimal.RubyBigDecimal;
 import org.jruby.javasupport.JavaUtil;
 import org.jruby.runtime.builtin.IRubyObject;
@@ -14,13 +19,13 @@
 import java.util.List;
 import java.util.Map;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
-public class RubyfierTest {
+public class RubyfierTest extends TestBase {
 
     @Test
     public void testDeepWithString() {
-        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), "foo");
+        Object result = Rubyfier.deep(ruby, "foo");
         assertEquals(RubyString.class, result.getClass());
         assertEquals("foo", result.toString());
     }
@@ -31,14 +36,14 @@ public void testDeepMapWithString()
     {
         Map data = new HashMap();
         data.put("foo", "bar");
-        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(ruby, data));
 
         // Hack to be able to retrieve the original, unconverted Ruby object from Map
         // it seems the only method providing this is internalGet but it is declared protected.
         // I know this is bad practice but I think this is practically acceptable.
         Method internalGet = RubyHash.class.getDeclaredMethod("internalGet", IRubyObject.class);
         internalGet.setAccessible(true);
-        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(Ruby.getGlobalRuntime(), "foo"));
+        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(ruby, "foo"));
 
         assertEquals(RubyString.class, result.getClass());
         assertEquals("bar", result.toString());
@@ -51,16 +56,16 @@ public void testDeepListWithString()
         List data = new ArrayList();
         data.add("foo");
 
-        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(ruby, data));
 
-        // toJavaArray does not convert inner elemenst to Java types \o/
+        // toJavaArray does not newFromRubyArray inner elemenst to Java types \o/
         assertEquals(RubyString.class, rubyArray.toJavaArray()[0].getClass());
         assertEquals("foo", rubyArray.toJavaArray()[0].toString());
     }
 
     @Test
     public void testDeepWithInteger() {
-        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), 1);
+        Object result = Rubyfier.deep(ruby, 1);
         assertEquals(RubyFixnum.class, result.getClass());
         assertEquals(1L, ((RubyFixnum)result).getLongValue());
     }
@@ -71,14 +76,14 @@ public void testDeepMapWithInteger()
     {
         Map data = new HashMap();
         data.put("foo", 1);
-        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(ruby, data));
 
         // Hack to be able to retrieve the original, unconverted Ruby object from Map
         // it seems the only method providing this is internalGet but it is declared protected.
         // I know this is bad practice but I think this is practically acceptable.
         Method internalGet = RubyHash.class.getDeclaredMethod("internalGet", IRubyObject.class);
         internalGet.setAccessible(true);
-        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(Ruby.getGlobalRuntime(), "foo"));
+        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(ruby, "foo"));
 
         assertEquals(RubyFixnum.class, result.getClass());
         assertEquals(1L, ((RubyFixnum)result).getLongValue());
@@ -91,16 +96,16 @@ public void testDeepListWithInteger()
         List data = new ArrayList();
         data.add(1);
 
-        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(ruby, data));
 
-        // toJavaArray does not convert inner elemenst to Java types \o/
+        // toJavaArray does not newFromRubyArray inner elemenst to Java types \o/
         assertEquals(RubyFixnum.class, rubyArray.toJavaArray()[0].getClass());
         assertEquals(1L, ((RubyFixnum)rubyArray.toJavaArray()[0]).getLongValue());
     }
 
     @Test
     public void testDeepWithFloat() {
-        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), 1.0F);
+        Object result = Rubyfier.deep(ruby, 1.0F);
         assertEquals(RubyFloat.class, result.getClass());
         assertEquals(1.0D, ((RubyFloat)result).getDoubleValue(), 0);
     }
@@ -111,14 +116,14 @@ public void testDeepMapWithFloat()
     {
         Map data = new HashMap();
         data.put("foo", 1.0F);
-        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(ruby, data));
 
         // Hack to be able to retrieve the original, unconverted Ruby object from Map
         // it seems the only method providing this is internalGet but it is declared protected.
         // I know this is bad practice but I think this is practically acceptable.
         Method internalGet = RubyHash.class.getDeclaredMethod("internalGet", IRubyObject.class);
         internalGet.setAccessible(true);
-        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(Ruby.getGlobalRuntime(), "foo"));
+        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(ruby, "foo"));
 
         assertEquals(RubyFloat.class, result.getClass());
         assertEquals(1.0D, ((RubyFloat)result).getDoubleValue(), 0);
@@ -131,16 +136,16 @@ public void testDeepListWithFloat()
         List data = new ArrayList();
         data.add(1.0F);
 
-        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(ruby, data));
 
-        // toJavaArray does not convert inner elemenst to Java types \o/
+        // toJavaArray does not newFromRubyArray inner elemenst to Java types \o/
         assertEquals(RubyFloat.class, rubyArray.toJavaArray()[0].getClass());
         assertEquals(1.0D, ((RubyFloat)rubyArray.toJavaArray()[0]).getDoubleValue(), 0);
     }
 
     @Test
     public void testDeepWithDouble() {
-        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), 1.0D);
+        Object result = Rubyfier.deep(ruby, 1.0D);
         assertEquals(RubyFloat.class, result.getClass());
         assertEquals(1.0D, ((RubyFloat)result).getDoubleValue(), 0);
     }
@@ -151,14 +156,14 @@ public void testDeepMapWithDouble()
     {
         Map data = new HashMap();
         data.put("foo", 1.0D);
-        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(ruby, data));
 
         // Hack to be able to retrieve the original, unconverted Ruby object from Map
         // it seems the only method providing this is internalGet but it is declared protected.
         // I know this is bad practice but I think this is practically acceptable.
         Method internalGet = RubyHash.class.getDeclaredMethod("internalGet", IRubyObject.class);
         internalGet.setAccessible(true);
-        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(Ruby.getGlobalRuntime(), "foo"));
+        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(ruby, "foo"));
 
         assertEquals(RubyFloat.class, result.getClass());
         assertEquals(1.0D, ((RubyFloat)result).getDoubleValue(), 0);
@@ -171,16 +176,16 @@ public void testDeepListWithDouble()
         List data = new ArrayList();
         data.add(1.0D);
 
-        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(ruby, data));
 
-        // toJavaArray does not convert inner elemenst to Java types \o/
+        // toJavaArray does not newFromRubyArray inner elemenst to Java types \o/
         assertEquals(RubyFloat.class, rubyArray.toJavaArray()[0].getClass());
         assertEquals(1.0D, ((RubyFloat)rubyArray.toJavaArray()[0]).getDoubleValue(), 0);
     }
 
     @Test
     public void testDeepWithBigDecimal() {
-        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), new BigDecimal(1));
+        Object result = Rubyfier.deep(ruby, new BigDecimal(1));
         assertEquals(RubyBigDecimal.class, result.getClass());
         assertEquals(1.0D, ((RubyBigDecimal)result).getDoubleValue(), 0);
     }
@@ -192,14 +197,14 @@ public void testDeepMapWithBigDecimal()
         Map data = new HashMap();
         data.put("foo", new BigDecimal(1));
 
-        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+        RubyHash rubyHash = ((RubyHash)Rubyfier.deep(ruby, data));
 
         // Hack to be able to retrieve the original, unconverted Ruby object from Map
         // it seems the only method providing this is internalGet but it is declared protected.
         // I know this is bad practice but I think this is practically acceptable.
         Method internalGet = RubyHash.class.getDeclaredMethod("internalGet", IRubyObject.class);
         internalGet.setAccessible(true);
-        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(Ruby.getGlobalRuntime(), "foo"));
+        Object result = internalGet.invoke(rubyHash, JavaUtil.convertJavaToUsableRubyObject(ruby, "foo"));
 
         assertEquals(RubyBigDecimal.class, result.getClass());
         assertEquals(1.0D, ((RubyBigDecimal)result).getDoubleValue(), 0);
@@ -212,9 +217,9 @@ public void testDeepListWithBigDecimal()
         List data = new ArrayList();
         data.add(new BigDecimal(1));
 
-        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(Ruby.getGlobalRuntime(), data));
+        RubyArray rubyArray = ((RubyArray)Rubyfier.deep(ruby, data));
 
-        // toJavaArray does not convert inner elemenst to Java types \o/
+        // toJavaArray does not newFromRubyArray inner elemenst to Java types \o/
         assertEquals(RubyBigDecimal.class, rubyArray.toJavaArray()[0].getClass());
         assertEquals(1.0D, ((RubyBigDecimal)rubyArray.toJavaArray()[0]).getDoubleValue(), 0);
     }
@@ -222,7 +227,7 @@ public void testDeepListWithBigDecimal()
 
     @Test
     public void testDeepWithBigInteger() {
-        Object result = Rubyfier.deep(Ruby.getGlobalRuntime(), new BigInteger("1"));
+        Object result = Rubyfier.deep(ruby, new BigInteger("1"));
         assertEquals(RubyBignum.class, result.getClass());
         assertEquals(1L, ((RubyBignum)result).getLongValue());
     }
diff --git a/logstash-core-event-java/src/test/java/com/logstash/TestBase.java b/logstash-core-event-java/src/test/java/com/logstash/TestBase.java
new file mode 100644
index 00000000000..47e2ef73c64
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/TestBase.java
@@ -0,0 +1,25 @@
+package com.logstash;
+
+import com.logstash.ext.JrubyTimestampExtLibrary;
+import org.jruby.CompatVersion;
+import org.jruby.Ruby;
+import org.jruby.RubyInstanceConfig;
+import org.jruby.ext.bigdecimal.RubyBigDecimal;
+import org.junit.Before;
+
+public abstract class TestBase {
+    private static boolean setupDone = false;
+    public static Ruby ruby;
+
+    @Before
+    public void setUp() throws Exception {
+        if (setupDone) return;
+
+        RubyInstanceConfig config_19 = new RubyInstanceConfig();
+        config_19.setCompatVersion(CompatVersion.RUBY1_9);
+        ruby = Ruby.newInstance(config_19);
+        RubyBigDecimal.createBigDecimal(ruby); // we need to do 'require "bigdecimal"'
+        JrubyTimestampExtLibrary.createTimestamp(ruby);
+        setupDone = true;
+    }
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/ValuefierTest.java b/logstash-core-event-java/src/test/java/com/logstash/ValuefierTest.java
new file mode 100644
index 00000000000..ff00cafb1c6
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/ValuefierTest.java
@@ -0,0 +1,113 @@
+package com.logstash;
+
+import com.logstash.bivalues.BiValue;
+import com.logstash.bivalues.BiValues;
+import com.logstash.bivalues.TimestampBiValue;
+import org.joda.time.DateTime;
+import org.jruby.RubyClass;
+import org.jruby.RubyMatchData;
+import org.jruby.RubyString;
+import org.jruby.RubyTime;
+import org.jruby.java.proxies.ArrayJavaProxy;
+import org.jruby.java.proxies.ConcreteJavaProxy;
+import org.jruby.java.proxies.MapJavaProxy;
+import org.jruby.javasupport.Java;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+
+import static junit.framework.TestCase.assertEquals;
+
+public class ValuefierTest extends TestBase {
+    @Test
+    public void testMapJavaProxy() {
+        Map<IRubyObject, IRubyObject> map = new HashMap<>();
+        map.put(RubyString.newString(ruby, "foo"), RubyString.newString(ruby, "bar"));
+        RubyClass proxyClass = (RubyClass) Java.getProxyClass(ruby, HashMap.class);
+        MapJavaProxy mjp = new MapJavaProxy(ruby, proxyClass);
+        mjp.setObject(map);
+
+        Object result = Valuefier.convert(mjp);
+        assertEquals(ConvertedMap.class, result.getClass());
+        ConvertedMap<String, Object> m = (ConvertedMap) result;
+        BiValue bv = BiValues.newBiValue("bar");
+        assertEquals(bv.javaValue(), ((BiValue) m.get("foo")).javaValue());
+    }
+
+    @Test
+    public void testArrayJavaProxy() {
+        IRubyObject[] array = new IRubyObject[]{RubyString.newString(ruby, "foo")};
+        RubyClass proxyClass = (RubyClass) Java.getProxyClass(ruby, String[].class);
+        ArrayJavaProxy ajp = new ArrayJavaProxy(ruby, proxyClass, array);
+
+        Object result = Valuefier.convert(ajp);
+        assertEquals(ConvertedList.class, result.getClass());
+        List<Object> a = (ConvertedList) result;
+        BiValue bv = BiValues.newBiValue("foo");
+        assertEquals(bv.javaValue(), ((BiValue) a.get(0)).javaValue());
+    }
+
+    @Test
+    public void testConcreteJavaProxy() {
+        List<IRubyObject> array = new ArrayList<>();
+        array.add(RubyString.newString(ruby, "foo"));
+        RubyClass proxyClass = (RubyClass) Java.getProxyClass(ruby, ArrayList.class);
+        ConcreteJavaProxy cjp = new ConcreteJavaProxy(ruby, proxyClass, array);
+        Object result = Valuefier.convert(cjp);
+        assertEquals(ConvertedList.class, result.getClass());
+        List<Object> a = (ConvertedList) result;
+        BiValue bv = BiValues.newBiValue("foo");
+        assertEquals(bv.javaValue(), ((BiValue) a.get(0)).javaValue());
+    }
+
+    @Test
+    public void testRubyTime() {
+        RubyTime ro = RubyTime.newTime(ruby, DateTime.now());
+        Object result = Valuefier.convert(ro);
+
+        assertEquals(TimestampBiValue.class, result.getClass());
+    }
+
+    @Test
+    public void testJodaDateTIme() {
+        DateTime jo = DateTime.now();
+        Object result = Valuefier.convert(jo);
+
+        assertEquals(TimestampBiValue.class, result.getClass());
+    }
+
+    @Rule
+    public ExpectedException exception = ExpectedException.none();
+
+    @Test
+    public void testUnhandledObject() {
+        RubyMatchData md = new RubyMatchData(ruby);
+        exception.expect(IllegalArgumentException.class);
+        exception.expectMessage("Missing Valuefier handling for full class name=org.jruby.RubyMatchData, simple name=RubyMatchData");
+        Valuefier.convert(md);
+    }
+
+    @Test
+    public void testUnhandledProxyObject() {
+        HashSet<Integer> hs = new HashSet<>();
+        hs.add(42);
+        RubyClass proxyClass = (RubyClass) Java.getProxyClass(ruby, HashSet.class);
+        ConcreteJavaProxy cjp = new ConcreteJavaProxy(ruby, proxyClass, hs);
+        BiValue result = (BiValue) Valuefier.convert(cjp);
+        assertEquals(hs, result.javaValue());
+    }
+
+    @Test
+    public void scratch() {
+        String[] parts = "foo/1_4".split("\\W|_");
+        int ord = Integer.valueOf(parts[1]);
+        assertEquals(ord, 1);
+    }
+}
diff --git a/logstash-core-event-java/src/test/java/com/logstash/bivalues/BiValueTest.java b/logstash-core-event-java/src/test/java/com/logstash/bivalues/BiValueTest.java
new file mode 100644
index 00000000000..12ec50a128b
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/bivalues/BiValueTest.java
@@ -0,0 +1,215 @@
+package com.logstash.bivalues;
+
+import com.logstash.TestBase;
+import org.joda.time.DateTime;
+import org.jruby.RubyBignum;
+import org.jruby.RubyBoolean;
+import org.jruby.RubyFixnum;
+import org.jruby.RubyFloat;
+import org.jruby.RubyInteger;
+import org.jruby.RubyNil;
+import org.jruby.RubyString;
+import org.jruby.RubySymbol;
+import org.jruby.RubyTime;
+import org.jruby.ext.bigdecimal.RubyBigDecimal;
+import org.junit.Test;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class BiValueTest extends TestBase {
+    @Test
+    public void testStringBiValueFromRuby() {
+        String s = "foo bar baz";
+        StringBiValue subject = new StringBiValue(RubyString.newString(ruby, s));
+        assertTrue(subject.hasRubyValue());
+        assertFalse(subject.hasJavaValue());
+        assertEquals(s, subject.javaValue());
+    }
+
+    @Test
+    public void testStringBiValueFromJava() {
+        RubyString v = RubyString.newString(ruby, "foo bar baz");
+        StringBiValue subject = new StringBiValue("foo bar baz");
+        assertFalse(subject.hasRubyValue());
+        assertTrue(subject.hasJavaValue());
+        assertEquals(v, subject.rubyValue(ruby));
+    }
+
+    @Test
+    public void testSymbolBiValueFromRuby() {
+        String s = "foo";
+        SymbolBiValue subject = new SymbolBiValue(RubySymbol.newSymbol(ruby, s));
+        assertTrue(subject.hasRubyValue());
+        assertFalse(subject.hasJavaValue());
+        assertEquals(s, subject.javaValue());
+    }
+
+    @Test
+    public void testLongBiValueFromRuby() {
+        Long s = 123456789L;
+        LongBiValue subject = new LongBiValue(RubyFixnum.newFixnum(ruby, s));
+        assertTrue(subject.hasRubyValue());
+        assertFalse(subject.hasJavaValue());
+        assertEquals(s, subject.javaValue());
+    }
+
+    @Test
+    public void testLongBiValueFromJava() {
+        RubyInteger v = RubyFixnum.newFixnum(ruby, 123456789L);
+        LongBiValue subject = new LongBiValue(123456789L);
+        assertFalse(subject.hasRubyValue());
+        assertTrue(subject.hasJavaValue());
+        assertEquals(v, subject.rubyValue(ruby));
+    }
+
+
+    @Test
+    public void testIntegerBiValueFromRuby() {
+        int j = 123456789;
+        IntegerBiValue subject = new IntegerBiValue(RubyFixnum.newFixnum(ruby, j));
+        assertTrue(subject.hasRubyValue());
+        assertFalse(subject.hasJavaValue());
+        assertTrue(j - subject.javaValue() == 0);
+    }
+
+    @Test
+    public void testIntegerBiValueFromJava() {
+        RubyInteger v = RubyFixnum.newFixnum(ruby, 123456789);
+        IntegerBiValue subject = new IntegerBiValue(123456789);
+        assertFalse(subject.hasRubyValue());
+        assertTrue(subject.hasJavaValue());
+        assertEquals(v, subject.rubyValue(ruby));
+    }
+
+    @Test
+    public void testBigDecimalBiValueFromRuby() {
+        BigDecimal s = BigDecimal.valueOf(12345.678D);
+        BigDecimalBiValue subject = new BigDecimalBiValue(new RubyBigDecimal(ruby, s));
+        assertTrue(subject.hasRubyValue());
+        assertFalse(subject.hasJavaValue());
+        assertEquals(s, subject.javaValue());
+    }
+
+    @Test
+    public void testBigDecimalBiValueFromJava() {
+        RubyBigDecimal v = new RubyBigDecimal(ruby, new BigDecimal(12345.678D));
+        BigDecimalBiValue subject = new BigDecimalBiValue(new BigDecimal(12345.678D));
+        assertFalse(subject.hasRubyValue());
+        assertTrue(subject.hasJavaValue());
+        assertEquals(v, subject.rubyValue(ruby));
+    }
+
+    @Test
+    public void testDoubleBiValueFromRuby() {
+        Double s = 12345.678D;
+        DoubleBiValue subject = new DoubleBiValue(RubyFloat.newFloat(ruby, 12345.678D));
+        assertTrue(subject.hasRubyValue());
+        assertFalse(subject.hasJavaValue());
+        assertEquals(s, subject.javaValue());
+    }
+
+    @Test
+    public void testDoubleBiValueFromJava() {
+        RubyFloat v = RubyFloat.newFloat(ruby, 12345.678D);
+        DoubleBiValue subject = new DoubleBiValue(12345.678D);
+        assertFalse(subject.hasRubyValue());
+        assertTrue(subject.hasJavaValue());
+        assertEquals(v, subject.rubyValue(ruby));
+    }
+
+    @Test
+    public void testBooleanBiValueFromRuby() {
+        BooleanBiValue subject = new BooleanBiValue(RubyBoolean.newBoolean(ruby, true));
+        assertTrue(subject.hasRubyValue());
+        assertFalse(subject.hasJavaValue());
+        assertTrue(subject.javaValue());
+    }
+
+    @Test
+    public void testBooleanBiValueFromJava() {
+        RubyBoolean v = RubyBoolean.newBoolean(ruby, true);
+        BooleanBiValue subject = new BooleanBiValue(true);
+        assertFalse(subject.hasRubyValue());
+        assertTrue(subject.hasJavaValue());
+        assertEquals(v, subject.rubyValue(ruby));
+    }
+
+    @Test
+    public void testNullBiValueFromRuby() {
+        NullBiValue subject = new NullBiValue((RubyNil) ruby.getNil());
+        assertTrue(subject.hasRubyValue());
+        assertTrue(subject.hasJavaValue());
+        assertEquals(null, subject.javaValue());
+    }
+
+    @Test
+    public void testNullBiValueFromJava() {
+        NullBiValue subject = NullBiValue.newNullBiValue();
+        assertFalse(subject.hasRubyValue());
+        assertTrue(subject.hasJavaValue());
+        assertEquals(ruby.getNil(), subject.rubyValue(ruby));
+    }
+
+    @Test
+    public void testTimeBiValueFromRuby() {
+        DateTime t = DateTime.now();
+        RubyTime now = RubyTime.newTime(ruby, t);
+        TimeBiValue subject = new TimeBiValue(now);
+        assertTrue(subject.hasRubyValue());
+        assertFalse(subject.hasJavaValue());
+        assertEquals(t, subject.javaValue());
+    }
+
+    @Test
+    public void testTimeBiValueFromJava() {
+        DateTime t = DateTime.now();
+        TimeBiValue subject = new TimeBiValue(t);
+        assertFalse(subject.hasRubyValue());
+        assertTrue(subject.hasJavaValue());
+        assertEquals(RubyTime.newTime(ruby, t), subject.rubyValue(ruby));
+    }
+
+    @Test
+    public void testBigIntegerBiValueFromRuby() {
+        BigInteger s = BigInteger.valueOf(12345678L);
+        BigIntegerBiValue subject = new BigIntegerBiValue(new RubyBignum(ruby, s));
+        assertTrue(subject.hasRubyValue());
+        assertFalse(subject.hasJavaValue());
+        assertEquals(s, subject.javaValue());
+    }
+
+    @Test
+    public void testBigIntegerBiValueFromJava() {
+        RubyBignum v = new RubyBignum(ruby, BigInteger.valueOf(12345678L));
+        BigIntegerBiValue subject = new BigIntegerBiValue(BigInteger.valueOf(12345678L));
+        assertFalse(subject.hasRubyValue());
+        assertTrue(subject.hasJavaValue());
+        assertEquals(v, subject.rubyValue(ruby));
+    }
+
+    @Test
+    public void testSerialization() throws Exception {
+        RubyBignum v = RubyBignum.newBignum(ruby, "-9223372036854776000");
+        BiValue original = BiValues.newBiValue(v);
+
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ObjectOutputStream oos = new ObjectOutputStream(baos);
+        oos.writeObject(original);
+        oos.close();
+
+        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
+        ObjectInputStream ois = new ObjectInputStream(bais);
+        BiValue copy = (BiValue) ois.readObject();
+        assertEquals(original, copy);
+        assertFalse(copy.hasRubyValue());
+    }
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/test/java/com/logstash/bivalues/BiValuesTest.java b/logstash-core-event-java/src/test/java/com/logstash/bivalues/BiValuesTest.java
new file mode 100644
index 00000000000..d2cd3322a23
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/bivalues/BiValuesTest.java
@@ -0,0 +1,280 @@
+package com.logstash.bivalues;
+
+import com.logstash.TestBase;
+import com.logstash.Timestamp;
+import com.logstash.ext.JrubyTimestampExtLibrary.RubyTimestamp;
+import org.jruby.RubyBignum;
+import org.jruby.RubyBoolean;
+import org.jruby.RubyFixnum;
+import org.jruby.RubyFloat;
+import org.jruby.RubyInteger;
+import org.jruby.RubyNil;
+import org.jruby.RubyString;
+import org.jruby.RubySymbol;
+import org.jruby.ext.bigdecimal.RubyBigDecimal;
+import org.jruby.javasupport.JavaUtil;
+import org.junit.Test;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+public class BiValuesTest extends TestBase {
+
+    @Test
+    public void testBiValuesStringRuby() {
+        String js = "double";
+        RubyString rs = RubyString.newUnicodeString(ruby, js);
+        BiValue subject = BiValues.newBiValue(rs);
+
+        assertEquals(rs, subject.rubyValueUnconverted());
+        assertEquals(rs.getClass(), subject.rubyValue(ruby).getClass());
+        assertEquals(js, subject.javaValue());
+        assertEquals(String.class, subject.javaValue().getClass());
+    }
+
+    @Test
+    public void testBiValuesStringJava() {
+        String js = "double";
+        RubyString rs = RubyString.newUnicodeString(ruby, js);
+        BiValue subject = BiValues.newBiValue(js);
+
+        assertEquals(js, subject.javaValue());
+        assertEquals(String.class, subject.javaValue().getClass());
+        assertEquals(rs, subject.rubyValue(ruby));
+        assertEquals(rs.getClass(), subject.rubyValue(ruby).getClass());
+    }
+
+    @Test
+    public void testBiValuesSymbolRuby() {
+        String js = "double";
+        RubySymbol rs = RubySymbol.newSymbol(ruby, js);
+        BiValue subject = BiValues.newBiValue(rs);
+
+        assertEquals(rs, subject.rubyValueUnconverted());
+        assertEquals(rs.getClass(), subject.rubyValue(ruby).getClass());
+        assertEquals(js, subject.javaValue());
+        assertEquals(String.class, subject.javaValue().getClass());
+    }
+
+    @Test
+    public void testBiValuesLongRuby() {
+        long jo = 1234567L;
+        RubyInteger ro = (RubyInteger) JavaUtil.convertJavaToUsableRubyObject(ruby, jo);
+        BiValue subject = BiValues.newBiValue(ro);
+
+        assertEquals(ro, subject.rubyValueUnconverted());
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+        assertEquals(jo, subject.javaValue());
+        assertEquals(Long.class, subject.javaValue().getClass());
+    }
+
+    @Test
+    public void testBiValuesLongJava() {
+        long jo = 1234567L;
+        RubyInteger ro = (RubyInteger) JavaUtil.convertJavaToUsableRubyObject(ruby, jo);
+        BiValue subject = BiValues.newBiValue(jo);
+
+        assertEquals(jo, subject.javaValue());
+        assertEquals(Long.class, subject.javaValue().getClass());
+        assertEquals(ro, subject.rubyValue(ruby));
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+    }
+
+    @Test
+    public void testBiValuesFloatRuby() {
+        double jo = 1234.567D;
+        RubyFloat ro = (RubyFloat) JavaUtil.convertJavaToUsableRubyObject(ruby, jo);
+        BiValue subject = BiValues.newBiValue(ro);
+
+        assertEquals(ro, subject.rubyValueUnconverted());
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+        assertEquals(jo, subject.javaValue());
+        assertEquals(Double.class, subject.javaValue().getClass());
+    }
+
+    @Test
+    public void testBiValuesFloatJava() {
+        double jo = 1234.567D;
+        RubyFloat ro = (RubyFloat) JavaUtil.convertJavaToUsableRubyObject(ruby, jo);
+        BiValue subject = BiValues.newBiValue(jo);
+
+        assertEquals(jo, subject.javaValue());
+        assertEquals(Double.class, subject.javaValue().getClass());
+        assertEquals(ro, subject.rubyValue(ruby));
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+    }
+
+    @Test
+    public void testBiValuesBigDecimalRuby() {
+        BigDecimal jo = BigDecimal.valueOf(12345.678D);
+        RubyBigDecimal ro = new RubyBigDecimal(ruby, ruby.getClass("BigDecimal"), jo);
+        BiValue subject = BiValues.newBiValue(ro);
+
+        assertEquals(ro, subject.rubyValueUnconverted());
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+        assertEquals(jo, subject.javaValue());
+        assertEquals(BigDecimal.class, subject.javaValue().getClass());
+    }
+
+    @Test
+    public void testBiValuesBigDecimalJava() {
+        BigDecimal jo = BigDecimal.valueOf(12345.678D);
+        RubyBigDecimal ro = new RubyBigDecimal(ruby, ruby.getClass("BigDecimal"), jo);
+        BiValue subject = BiValues.newBiValue(jo);
+
+        assertEquals(jo, subject.javaValue());
+        assertEquals(BigDecimal.class, subject.javaValue().getClass());
+        assertEquals(ro, subject.rubyValue(ruby));
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+    }
+
+    @Test
+    public void testBiValuesBooleanRubyTrue() {
+        boolean jo = true;
+        RubyBoolean ro = (RubyBoolean) JavaUtil.convertJavaToUsableRubyObject(ruby, jo);
+        BiValue<RubyBoolean, Boolean> subject = BiValues.newBiValue(ro);
+
+        assertEquals(ro, subject.rubyValueUnconverted());
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+        assertTrue(subject.javaValue());
+        assertEquals(Boolean.class, subject.javaValue().getClass());
+    }
+
+    @Test
+    public void testBiValuesBooleanRubyFalse() {
+        boolean jo = false;
+        RubyBoolean ro = (RubyBoolean) JavaUtil.convertJavaToUsableRubyObject(ruby, jo);
+        BiValue<RubyBoolean, Boolean> subject = BiValues.newBiValue(ro);
+
+        assertEquals(ro, subject.rubyValueUnconverted());
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+        assertFalse(subject.javaValue());
+        assertEquals(Boolean.class, subject.javaValue().getClass());
+    }
+
+    @Test
+    public void testBiValuesBooleanJavaTrue() {
+        boolean jo = true;
+        RubyBoolean ro = (RubyBoolean) JavaUtil.convertJavaToUsableRubyObject(ruby, jo);
+        BiValue<RubyBoolean, Boolean> subject = BiValues.newBiValue(jo);
+
+        assertTrue(subject.javaValue());
+        assertEquals(Boolean.class, subject.javaValue().getClass());
+        assertEquals(ro, subject.rubyValue(ruby));
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+    }
+
+    @Test
+    public void testBiValuesBooleanJavaFalse() {
+        boolean jo = false;
+        RubyBoolean ro = (RubyBoolean) JavaUtil.convertJavaToUsableRubyObject(ruby, jo);
+        BiValue<RubyBoolean, Boolean> subject = BiValues.newBiValue(jo);
+
+        assertFalse(subject.javaValue());
+        assertEquals(Boolean.class, subject.javaValue().getClass());
+        assertEquals(ro, subject.rubyValue(ruby));
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+    }
+
+    @Test
+    public void testBiValuesTimestampRuby() {
+        Timestamp jo = new Timestamp("2014-09-23T00:00:00-0800");
+        RubyTimestamp ro = RubyTimestamp.newRubyTimestamp(ruby, jo);
+        BiValue subject = BiValues.newBiValue(ro);
+
+        assertEquals(ro, subject.rubyValueUnconverted());
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+        assertEquals(jo, subject.javaValue());
+        assertEquals(Timestamp.class, subject.javaValue().getClass());
+    }
+
+    @Test
+    public void testBiValuesTimestampJava() {
+        Timestamp jo = new Timestamp("2014-09-23T00:00:00-0800");
+        RubyTimestamp ro = RubyTimestamp.newRubyTimestamp(ruby, jo);
+        BiValue subject = BiValues.newBiValue(jo);
+
+        assertEquals(jo, subject.javaValue());
+        assertEquals(Timestamp.class, subject.javaValue().getClass());
+        assertEquals(ro.toString(), subject.rubyValue(ruby).toString());
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+    }
+
+    @Test
+    public void testBiValuesNilRuby() {
+        RubyNil ro = (RubyNil) ruby.getNil();
+        BiValue subject = BiValues.newBiValue(ro);
+
+        assertEquals(ro, subject.rubyValueUnconverted());
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+        assertNull(subject.javaValue());
+    }
+
+    @Test
+    public void testBiValuesNullJava() {
+        RubyNil ro = (RubyNil) ruby.getNil();
+        BiValue subject = BiValues.newBiValue(null);
+
+        assertNull(subject.javaValue());
+        assertEquals(ro, subject.rubyValue(ruby));
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+    }
+
+    @Test
+    public void testBiValuesBigIntegerRuby() {
+        BigInteger jo = BigInteger.valueOf(12345678L);
+        RubyBignum ro = new RubyBignum(ruby, jo);
+        BiValue subject = BiValues.newBiValue(ro);
+
+        assertEquals(BigIntegerBiValue.class, subject.getClass());
+        assertEquals(ro, subject.rubyValueUnconverted());
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+        assertEquals(jo, subject.javaValue());
+        assertEquals(BigInteger.class, subject.javaValue().getClass());
+    }
+
+    @Test
+    public void testBiValuesBigIntegerJava() {
+        BigInteger jo = BigInteger.valueOf(12345678L);
+        RubyBignum ro = new RubyBignum(ruby, jo);
+        BiValue subject = BiValues.newBiValue(jo);
+
+        assertEquals(jo, subject.javaValue());
+        assertEquals(BigInteger.class, subject.javaValue().getClass());
+        assertEquals(ro, subject.rubyValue(ruby));
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+    }
+
+    // NOTE: testBiValuesIntegerRuby will map to LongBiValue
+    @Test
+    public void testBiValuesIntegerRuby() {
+        int jo = 12345678;
+        RubyInteger ro = RubyFixnum.newFixnum(ruby, jo);
+        BiValue subject = BiValues.newBiValue(ro);
+
+        assertEquals(LongBiValue.class, subject.getClass());
+        assertEquals(ro, subject.rubyValueUnconverted());
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+        assertEquals(12345678L, subject.javaValue());
+        assertEquals(Long.class, subject.javaValue().getClass());
+    }
+
+    @Test
+    public void testBiValuesIntegerJava() {
+        int jo = 12345678;
+        RubyInteger ro = RubyFixnum.newFixnum(ruby, jo);
+        BiValue subject = BiValues.newBiValue(jo);
+
+        assertEquals(IntegerBiValue.class, subject.getClass());
+        assertEquals(jo, subject.javaValue());
+        assertEquals(Integer.class, subject.javaValue().getClass());
+        assertEquals(ro, subject.rubyValue(ruby));
+        assertEquals(ro.getClass(), subject.rubyValue(ruby).getClass());
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core-event-java/src/test/java/com/logstash/bivalues/SomeJavaObject.java b/logstash-core-event-java/src/test/java/com/logstash/bivalues/SomeJavaObject.java
new file mode 100644
index 00000000000..21a86a111c5
--- /dev/null
+++ b/logstash-core-event-java/src/test/java/com/logstash/bivalues/SomeJavaObject.java
@@ -0,0 +1,29 @@
+package com.logstash.bivalues;
+
+public class SomeJavaObject<T> {
+    private T value;
+
+    public T getValue() {
+        return value;
+    }
+
+    public SomeJavaObject(T value) {
+        this.value = value;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof SomeJavaObject)) return false;
+
+        SomeJavaObject<?> that = (SomeJavaObject<?>) o;
+
+        return value != null ? value.equals(that.getValue()) : that.value == null;
+
+    }
+
+    @Override
+    public int hashCode() {
+        return value != null ? value.hashCode() : 0;
+    }
+}
