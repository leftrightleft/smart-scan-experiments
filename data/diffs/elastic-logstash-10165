diff --git a/logstash-core/lib/logstash/filter_delegator.rb b/logstash-core/lib/logstash/filter_delegator.rb
index 0ba36af0214..548cf47a69e 100644
--- a/logstash-core/lib/logstash/filter_delegator.rb
+++ b/logstash-core/lib/logstash/filter_delegator.rb
@@ -1,69 +1,2 @@
-# encoding: utf-8
-#
-module LogStash
-  class FilterDelegator
-    extend Forwardable
-    DELEGATED_METHODS = [
-      :register,
-      :close,
-      :threadsafe?,
-      :do_close,
-      :do_stop,
-      :periodic_flush,
-      :reloadable?
-    ]
-    def_delegators :@filter, *DELEGATED_METHODS
-
-    attr_reader :id
-
-    def initialize(filter, id)
-      @klass = filter.class
-      @id = id
-      @filter = filter
-
-      # Scope the metrics to the plugin
-      namespaced_metric = filter.metric
-      @metric_events = namespaced_metric.namespace(:events)
-      @metric_events_in = @metric_events.counter(:in)
-      @metric_events_out = @metric_events.counter(:out)
-      @metric_events_time = @metric_events.counter(:duration_in_millis)
-      namespaced_metric.gauge(:name, config_name)
-
-      # Not all the filters will do bufferings
-      define_flush_method if @filter.respond_to?(:flush)
-    end
-
-    def config_name
-      @klass.config_name
-    end
-
-    def multi_filter(events)
-      @metric_events_in.increment(events.size)
-
-      start_time = java.lang.System.nano_time
-      new_events = @filter.multi_filter(events)
-      @metric_events_time.increment((java.lang.System.nano_time - start_time) / 1_000_000)
-
-      # There is no guarantee in the context of filter
-      # that EVENTS_IN == EVENTS_OUT, see the aggregates and
-      # the split filter
-      c = new_events.count { |event| !event.cancelled? }
-      @metric_events_out.increment(c) if c > 0
-      new_events
-    end
-
-    private
-    def define_flush_method
-      define_singleton_method(:flush) do |options = {}|
-        # we also need to trace the number of events
-        # coming from a specific filters.
-        new_events = @filter.flush(options)
-
-        # Filter plugins that does buffering or spooling of events like the
-        # `Logstash-filter-aggregates` can return `NIL` and will flush on the next flush ticks.
-        @metric_events_out.increment(new_events.size) if new_events && new_events.size > 0
-        new_events
-      end
-    end
-  end
-end
+# The contents of this file have been ported to Java. It is included for for compatibility
+# with plugins that directly include it.
diff --git a/logstash-core/spec/logstash/java_filter_delegator_spec.rb b/logstash-core/spec/logstash/java_filter_delegator_spec.rb
index f7a1ae2dcdb..0e813d2a76a 100644
--- a/logstash-core/spec/logstash/java_filter_delegator_spec.rb
+++ b/logstash-core/spec/logstash/java_filter_delegator_spec.rb
@@ -6,7 +6,7 @@
 
 java_import org.logstash.RubyUtil
 
-describe LogStash::JavaFilterDelegator do
+describe LogStash::FilterDelegator do
 
   class MockGauge
     def increment(_)
diff --git a/logstash-core/src/main/java/org/logstash/RubyUtil.java b/logstash-core/src/main/java/org/logstash/RubyUtil.java
index 770c21eb518..de408750eb2 100644
--- a/logstash-core/src/main/java/org/logstash/RubyUtil.java
+++ b/logstash-core/src/main/java/org/logstash/RubyUtil.java
@@ -1,6 +1,5 @@
 package org.logstash;
 
-import java.util.stream.Stream;
 import org.jruby.NativeException;
 import org.jruby.Ruby;
 import org.jruby.RubyClass;
@@ -13,8 +12,10 @@
 import org.logstash.ackedqueue.ext.JRubyWrappedAckedQueueExt;
 import org.logstash.common.AbstractDeadLetterQueueWriterExt;
 import org.logstash.common.BufferedTokenizerExt;
+import org.logstash.config.ir.compiler.AbstractFilterDelegatorExt;
 import org.logstash.config.ir.compiler.AbstractOutputDelegatorExt;
 import org.logstash.config.ir.compiler.FilterDelegatorExt;
+import org.logstash.config.ir.compiler.JavaFilterDelegatorExt;
 import org.logstash.config.ir.compiler.JavaOutputDelegatorExt;
 import org.logstash.config.ir.compiler.OutputDelegatorExt;
 import org.logstash.config.ir.compiler.OutputStrategyExt;
@@ -52,6 +53,8 @@
 import org.logstash.plugins.PluginFactoryExt;
 import org.logstash.plugins.UniversalPluginExt;
 
+import java.util.stream.Stream;
+
 /**
  * Utilities around interaction with the {@link Ruby} runtime.
  */
@@ -98,10 +101,14 @@ public final class RubyUtil {
 
     public static final RubyClass ABSTRACT_OUTPUT_DELEGATOR_CLASS;
 
+    public static final RubyClass ABSTRACT_FILTER_DELEGATOR_CLASS;
+
     public static final RubyClass RUBY_OUTPUT_DELEGATOR_CLASS;
 
     public static final RubyClass JAVA_OUTPUT_DELEGATOR_CLASS;
 
+    public static final RubyClass JAVA_FILTER_DELEGATOR_CLASS;
+
     public static final RubyClass FILTER_DELEGATOR_CLASS;
 
     public static final RubyClass OUTPUT_STRATEGY_REGISTRY;
@@ -417,8 +424,18 @@ public final class RubyUtil {
             ABSTRACT_OUTPUT_DELEGATOR_CLASS, JavaOutputDelegatorExt::new,
             JavaOutputDelegatorExt.class
         );
+        ABSTRACT_FILTER_DELEGATOR_CLASS = LOGSTASH_MODULE.defineClassUnder(
+                "AbstractFilterDelegator", RUBY.getObject(),
+                ObjectAllocator.NOT_ALLOCATABLE_ALLOCATOR
+        );
+        ABSTRACT_FILTER_DELEGATOR_CLASS.defineAnnotatedMethods(AbstractFilterDelegatorExt.class);
+        JAVA_FILTER_DELEGATOR_CLASS = setupLogstashClass(
+                ABSTRACT_FILTER_DELEGATOR_CLASS, JavaFilterDelegatorExt::new,
+                JavaFilterDelegatorExt.class
+        );
         FILTER_DELEGATOR_CLASS = setupLogstashClass(
-            FilterDelegatorExt::new, FilterDelegatorExt.class
+                ABSTRACT_FILTER_DELEGATOR_CLASS, FilterDelegatorExt::new,
+                FilterDelegatorExt.class
         );
         final RubyModule loggingModule = LOGSTASH_MODULE.defineOrGetModuleUnder("Logging");
         LOGGER = loggingModule.defineClassUnder("Logger", RUBY.getObject(), LoggerExt::new);
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java b/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
index 2cf43e87dca..621b7904f4e 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/CompiledPipeline.java
@@ -1,16 +1,5 @@
 package org.logstash.config.ir;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Objects;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.jruby.RubyHash;
@@ -18,27 +7,38 @@
 import org.logstash.RubyUtil;
 import org.logstash.Rubyfier;
 import org.logstash.common.SourceWithMetadata;
+import org.logstash.config.ir.compiler.AbstractFilterDelegatorExt;
 import org.logstash.config.ir.compiler.AbstractOutputDelegatorExt;
 import org.logstash.config.ir.compiler.ComputeStepSyntaxElement;
 import org.logstash.config.ir.compiler.Dataset;
 import org.logstash.config.ir.compiler.DatasetCompiler;
 import org.logstash.config.ir.compiler.EventCondition;
-import org.logstash.config.ir.compiler.FilterDelegatorExt;
 import org.logstash.config.ir.compiler.RubyIntegration;
 import org.logstash.config.ir.compiler.SplitDataset;
 import org.logstash.config.ir.graph.IfVertex;
 import org.logstash.config.ir.graph.PluginVertex;
 import org.logstash.config.ir.graph.Vertex;
 import org.logstash.config.ir.imperative.PluginStatement;
-import org.logstash.execution.Codec;
 import org.logstash.execution.Filter;
 import org.logstash.execution.Input;
 import org.logstash.execution.LsConfiguration;
 import org.logstash.execution.LsContext;
 import org.logstash.execution.Output;
-import org.logstash.execution.plugins.discovery.DiscoverPlugins;
+import org.logstash.execution.plugins.discovery.PluginRegistry;
 import org.logstash.ext.JrubyEventExtLibrary;
 
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Objects;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
 /**
  * <h3>Compiled Logstash Pipeline Configuration.</h3>
  * This class represents an executable pipeline, compiled from the configured topology that is
@@ -50,34 +50,6 @@ public final class CompiledPipeline {
 
     private static final Logger LOGGER = LogManager.getLogger(CompiledPipeline.class);
 
-    private static final Map<String, Class<Input>> JAVA_INPUTS = new HashMap<>();
-    private static final Map<String, Class<Filter>> JAVA_FILTERS = new HashMap<>();
-    private static final Map<String, Class<Output>> JAVA_OUTPUTS = new HashMap<>();
-    private static final Map<String, Class<Codec>> JAVA_CODECS = new HashMap<>();
-
-    static {
-        populatePluginDefinitions();
-    }
-
-    @SuppressWarnings("unchecked")
-    private static void populatePluginDefinitions() {
-        final Map<String, Class<?>> plugins = DiscoverPlugins.discoverPlugins();
-        plugins.forEach((name, cls) -> {
-            if (Filter.class.isAssignableFrom(cls)) {
-                JAVA_FILTERS.put(name, (Class<Filter>) cls);
-            }
-            if (Output.class.isAssignableFrom(cls)) {
-                JAVA_OUTPUTS.put(name, (Class<Output>) cls);
-            }
-            if (Input.class.isAssignableFrom(cls)) {
-                JAVA_INPUTS.put(name, (Class<Input>) cls);
-            }
-            if (Codec.class.isAssignableFrom(cls)) {
-                JAVA_CODECS.put(name, (Class<Codec>) cls);
-            }
-        });
-    }
-
     /**
      * Compiler for conditional expressions that turn {@link IfVertex} into {@link EventCondition}.
      */
@@ -96,7 +68,7 @@ private static void populatePluginDefinitions() {
     /**
      * Configured Filters, indexed by their ID as returned by {@link PluginVertex#getId()}.
      */
-    private final Map<String, FilterDelegatorExt> filters;
+    private final Map<String, AbstractFilterDelegatorExt> filters;
 
     /**
      * Configured outputs.
@@ -126,7 +98,7 @@ public Collection<IRubyObject> outputs() {
         return Collections.unmodifiableCollection(outputs.values());
     }
 
-    public Collection<FilterDelegatorExt> filters() {
+    public Collection<AbstractFilterDelegatorExt> filters() {
         return Collections.unmodifiableCollection(filters.values());
     }
 
@@ -148,7 +120,7 @@ public Dataset buildExecution() {
     }
 
     /**
-     * Sets up all Ruby outputs learnt from {@link PipelineIR}.
+     * Sets up all outputs learned from {@link PipelineIR}.
      */
     private Map<String, AbstractOutputDelegatorExt> setupOutputs() {
         final Collection<PluginVertex> outs = pipelineIR.getOutputPluginVertices();
@@ -156,10 +128,23 @@ private Map<String, AbstractOutputDelegatorExt> setupOutputs() {
         outs.forEach(v -> {
             final PluginDefinition def = v.getPluginDefinition();
             final SourceWithMetadata source = v.getSourceWithMetadata();
-            res.put(v.getId(), pluginFactory.buildOutput(
-                RubyUtil.RUBY.newString(def.getName()), RubyUtil.RUBY.newFixnum(source.getLine()),
-                RubyUtil.RUBY.newFixnum(source.getColumn()), convertArgs(def)
-            ));
+            final Class<Output> cls = PluginRegistry.getOutputClass(def.getName());
+            if (cls != null) {
+                Output output;
+                try {
+                    final Constructor<Output> ctor = cls.getConstructor(LsConfiguration.class, LsContext.class);
+                    output = ctor.newInstance(new LsConfiguration(Collections.EMPTY_MAP /* def.getArguments()*/), new LsContext());
+                } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException ex) {
+                    throw new IllegalStateException(ex);
+                }
+                res.put(v.getId(), pluginFactory.buildJavaOutput(def.getName(), source.getLine(),
+                        source.getColumn(), output, convertArgs(def)));
+            } else {
+                res.put(v.getId(), pluginFactory.buildOutput(
+                        RubyUtil.RUBY.newString(def.getName()), RubyUtil.RUBY.newFixnum(source.getLine()),
+                        RubyUtil.RUBY.newFixnum(source.getColumn()), convertArgs(def)
+                ));
+            }
         });
         return res;
     }
@@ -167,12 +152,31 @@ private Map<String, AbstractOutputDelegatorExt> setupOutputs() {
     /**
      * Sets up all Ruby filters learnt from {@link PipelineIR}.
      */
-    private Map<String, FilterDelegatorExt> setupFilters() {
+    private Map<String, AbstractFilterDelegatorExt> setupFilters() {
         final Collection<PluginVertex> filterPlugins = pipelineIR.getFilterPluginVertices();
-        final Map<String, FilterDelegatorExt> res =
-            new HashMap<>(filterPlugins.size(), 1.0F);
-        for (final PluginVertex plugin : filterPlugins) {
-            res.put(plugin.getId(), buildFilter(plugin));
+        final Map<String, AbstractFilterDelegatorExt> res = new HashMap<>(filterPlugins.size(), 1.0F);
+
+        for (final PluginVertex vertex : filterPlugins) {
+            final PluginDefinition def = vertex.getPluginDefinition();
+            final SourceWithMetadata source = vertex.getSourceWithMetadata();
+            final Class<Filter> cls = PluginRegistry.getFilterClass(def.getName());
+            if (cls != null) {
+                Filter filter;
+                try {
+                    final Constructor<Filter> ctor = cls.getConstructor(LsConfiguration.class, LsContext.class);
+                    filter = ctor.newInstance(new LsConfiguration(Collections.EMPTY_MAP /* def.getArguments()*/), new LsContext());
+                } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException ex) {
+                    throw new IllegalStateException(ex);
+                }
+                res.put(vertex.getId(), pluginFactory.buildJavaFilter(def.getName(), source.getLine(),
+                        source.getColumn(), filter, convertArgs(def)));
+
+            } else {
+                res.put(vertex.getId(), pluginFactory.buildFilter(
+                        RubyUtil.RUBY.newString(def.getName()), RubyUtil.RUBY.newFixnum(source.getLine()),
+                        RubyUtil.RUBY.newFixnum(source.getColumn()), convertArgs(def)
+                ));
+            }
         }
         return res;
     }
@@ -185,11 +189,10 @@ private Collection<IRubyObject> setupInputs() {
         final Collection<IRubyObject> nodes = new HashSet<>(vertices.size());
         vertices.forEach(v -> {
             final PluginDefinition def = v.getPluginDefinition();
-            if (JAVA_INPUTS.containsKey(def.getName())) {
-                final Class<Input> cls = JAVA_INPUTS.get(def.getName());
+            final Class<Input> cls = PluginRegistry.getInputClass(def.getName());
+            if (cls != null) {
                 try {
-                    final Constructor<Input> ctor =
-                        cls.getConstructor(LsConfiguration.class, LsContext.class);
+                    final Constructor<Input> ctor = cls.getConstructor(LsConfiguration.class, LsContext.class);
                     javaInputs.add(ctor.newInstance(new LsConfiguration(Collections.emptyMap()), new LsContext()));
                 } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException ex) {
                     throw new IllegalStateException(ex);
@@ -233,23 +236,9 @@ private RubyHash convertArgs(final PluginDefinition def) {
     }
 
     /**
-     * Compiles a {@link FilterDelegatorExt} from a given {@link PluginVertex}.
-     * @param vertex Filter {@link PluginVertex}
-     * @return Compiled {@link FilterDelegatorExt}
-     */
-    private FilterDelegatorExt buildFilter(final PluginVertex vertex) {
-        final PluginDefinition def = vertex.getPluginDefinition();
-        final SourceWithMetadata source = vertex.getSourceWithMetadata();
-        return pluginFactory.buildFilter(
-            RubyUtil.RUBY.newString(def.getName()), RubyUtil.RUBY.newFixnum(source.getLine()),
-            RubyUtil.RUBY.newFixnum(source.getColumn()), convertArgs(def)
-        );
-    }
-
-    /**
-     * Checks if a certain {@link Vertex} represents a {@link FilterDelegatorExt}.
+     * Checks if a certain {@link Vertex} represents a {@link AbstractFilterDelegatorExt}.
      * @param vertex Vertex to check
-     * @return True iff {@link Vertex} represents a {@link FilterDelegatorExt}
+     * @return True iff {@link Vertex} represents a {@link AbstractFilterDelegatorExt}
      */
     private boolean isFilter(final Vertex vertex) {
         return filters.containsKey(vertex.getId());
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractFilterDelegatorExt.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractFilterDelegatorExt.java
new file mode 100644
index 00000000000..e9ffd69c7d3
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractFilterDelegatorExt.java
@@ -0,0 +1,153 @@
+package org.logstash.config.ir.compiler;
+
+import org.jruby.Ruby;
+import org.jruby.RubyArray;
+import org.jruby.RubyClass;
+import org.jruby.RubyHash;
+import org.jruby.RubyObject;
+import org.jruby.RubyString;
+import org.jruby.anno.JRubyClass;
+import org.jruby.anno.JRubyMethod;
+import org.jruby.runtime.ThreadContext;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.logstash.RubyUtil;
+import org.logstash.execution.WorkerLoop;
+import org.logstash.ext.JrubyEventExtLibrary;
+import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
+import org.logstash.instrument.metrics.MetricKeys;
+import org.logstash.instrument.metrics.counter.LongCounter;
+
+import java.util.Collection;
+import java.util.concurrent.TimeUnit;
+
+@JRubyClass(name = "AbstractFilterDelegator")
+public abstract class AbstractFilterDelegatorExt extends RubyObject {
+
+    private static final long serialVersionUID = 1L;
+
+    protected AbstractNamespacedMetricExt metricEvents;
+
+    protected RubyString id;
+
+    protected LongCounter eventMetricOut;
+
+    protected LongCounter eventMetricIn;
+
+    protected LongCounter eventMetricTime;
+
+    public AbstractFilterDelegatorExt(final Ruby runtime, final RubyClass metaClass) {
+        super(runtime, metaClass);
+    }
+
+    protected void initMetrics(final String id, final AbstractNamespacedMetricExt namespacedMetric) {
+        final ThreadContext context = RubyUtil.RUBY.getCurrentContext();
+        this.id = RubyString.newString(context.runtime, id);
+        synchronized(namespacedMetric.getMetric()) {
+            metricEvents = namespacedMetric.namespace(context, MetricKeys.EVENTS_KEY);
+            eventMetricOut = LongCounter.fromRubyBase(metricEvents, MetricKeys.OUT_KEY);
+            eventMetricIn = LongCounter.fromRubyBase(metricEvents, MetricKeys.IN_KEY);
+            eventMetricTime = LongCounter.fromRubyBase(metricEvents, MetricKeys.DURATION_IN_MILLIS_KEY);
+            namespacedMetric.gauge(context, MetricKeys.NAME_KEY, configName(context));
+        }
+    }
+
+    @JRubyMethod
+    public IRubyObject register(final ThreadContext context) {
+        doRegister(context);
+        return context.nil;
+    }
+
+    protected abstract void doRegister(final ThreadContext context);
+
+    @JRubyMethod
+    public IRubyObject close(final ThreadContext context) {
+        return closeImpl(context);
+    }
+
+    protected abstract IRubyObject closeImpl(final ThreadContext context);
+
+    @JRubyMethod(name = "do_close")
+    public IRubyObject doClose(final ThreadContext context) {
+        return doCloseImpl(context);
+    }
+
+    protected abstract IRubyObject doCloseImpl(final ThreadContext context);
+
+    @JRubyMethod(name = "do_stop")
+    public IRubyObject doStop(final ThreadContext context) {
+        return doStopImpl(context);
+    }
+
+    protected abstract IRubyObject doStopImpl(final ThreadContext context);
+
+    @JRubyMethod(name = "reloadable?")
+    public IRubyObject isReloadable(final ThreadContext context) {
+        return reloadable(context);
+    }
+
+    protected abstract IRubyObject reloadable(final ThreadContext context);
+
+    @JRubyMethod(name = "threadsafe?")
+    public IRubyObject concurrency(final ThreadContext context) {
+        return getConcurrency(context);
+    }
+
+    protected abstract IRubyObject getConcurrency(final ThreadContext context);
+
+    @JRubyMethod(name = "config_name")
+    public IRubyObject configName(final ThreadContext context) {
+        return getConfigName(context);
+    }
+
+    protected abstract IRubyObject getConfigName(ThreadContext context);
+
+    @JRubyMethod(name = "id")
+    public IRubyObject getId() {
+        return id;
+    }
+
+    @SuppressWarnings("unchecked")
+    public RubyArray multiFilter(final RubyArray batch) {
+        eventMetricIn.increment((long) batch.size());
+        final long start = System.nanoTime();
+        final RubyArray result = doMultiFilter(batch);
+        eventMetricTime.increment(TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));
+        int count = 0;
+        for (final JrubyEventExtLibrary.RubyEvent event : (Collection<JrubyEventExtLibrary.RubyEvent>) result) {
+            if (!event.getEvent().isCancelled()) {
+                ++count;
+            }
+        }
+        eventMetricOut.increment((long) count);
+        return result;
+    }
+
+    protected abstract RubyArray doMultiFilter(final RubyArray batch);
+
+    public RubyArray flush(final RubyHash options) {
+        final ThreadContext context = WorkerLoop.THREAD_CONTEXT.get();
+        final IRubyObject newEvents = doFlush(context, options);
+        final RubyArray result;
+        if (newEvents.isNil()) {
+            result = RubyArray.newEmptyArray(context.runtime);
+        } else {
+            result = (RubyArray) newEvents;
+            eventMetricOut.increment((long) result.size());
+        }
+        return result;
+    }
+
+    protected abstract IRubyObject doFlush(final ThreadContext context, final RubyHash options);
+
+    public boolean hasFlush() {
+        return getHasFlush();
+    }
+
+    protected abstract boolean getHasFlush();
+
+    public boolean periodicFlush() {
+        return getPeriodicFlush();
+    }
+
+    protected abstract boolean getPeriodicFlush();
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractOutputDelegatorExt.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractOutputDelegatorExt.java
index 4bfaff72371..422a417efc0 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractOutputDelegatorExt.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/AbstractOutputDelegatorExt.java
@@ -95,9 +95,7 @@ public IRubyObject multiReceive(final IRubyObject events) {
         eventMetricIn.increment((long) count);
         final long start = System.nanoTime();
         doOutput(batch);
-        eventMetricTime.increment(
-            TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS)
-        );
+        eventMetricTime.increment(TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));
         eventMetricOut.increment((long) count);
         return this;
     }
@@ -109,14 +107,10 @@ protected void initMetrics(final String id, final AbstractMetricExt metric) {
         synchronized (metric) {
             namespacedMetric = metric.namespace(context, context.runtime.newSymbol(id));
             metricEvents = namespacedMetric.namespace(context, MetricKeys.EVENTS_KEY);
-            namespacedMetric.gauge(
-                context, MetricKeys.NAME_KEY, configName(context)
-            );
+            namespacedMetric.gauge(context, MetricKeys.NAME_KEY, configName(context));
             eventMetricOut = LongCounter.fromRubyBase(metricEvents, MetricKeys.OUT_KEY);
             eventMetricIn = LongCounter.fromRubyBase(metricEvents, MetricKeys.IN_KEY);
-            eventMetricTime = LongCounter.fromRubyBase(
-                metricEvents, MetricKeys.DURATION_IN_MILLIS_KEY
-            );
+            eventMetricTime = LongCounter.fromRubyBase(metricEvents, MetricKeys.DURATION_IN_MILLIS_KEY);
         }
     }
 
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/DatasetCompiler.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/DatasetCompiler.java
index 50b8d30f003..7df42534ef6 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/DatasetCompiler.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/DatasetCompiler.java
@@ -85,7 +85,7 @@ public static ComputeStepSyntaxElement<SplitDataset> splitDataset(final Collecti
      * @return Dataset representing the filter plugin
      */
     public static ComputeStepSyntaxElement<Dataset> filterDataset(final Collection<Dataset> parents,
-        final FilterDelegatorExt plugin) {
+        final AbstractFilterDelegatorExt plugin) {
         final ClassFields fields = new ClassFields();
         final ValueSyntaxElement outputBuffer = fields.add(new ArrayList<>());
         final Closure clear = Closure.wrap();
@@ -192,7 +192,7 @@ private static ValueSyntaxElement invokeOutput(final ValueSyntaxElement output,
 
     private static Closure filterBody(final ValueSyntaxElement outputBuffer,
         final ValueSyntaxElement inputBuffer, final ClassFields fields,
-        final FilterDelegatorExt plugin) {
+        final AbstractFilterDelegatorExt plugin) {
         final ValueSyntaxElement filterField = fields.add(plugin);
         final Closure body = Closure.wrap(
             buffer(outputBuffer, filterField.call("multiFilter", inputBuffer))
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/FilterDelegatorExt.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/FilterDelegatorExt.java
index c855ac21ae3..93b2e82268b 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/FilterDelegatorExt.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/FilterDelegatorExt.java
@@ -1,13 +1,10 @@
 package org.logstash.config.ir.compiler;
 
 import com.google.common.annotations.VisibleForTesting;
-import java.util.Collection;
-import java.util.concurrent.TimeUnit;
 import org.jruby.Ruby;
 import org.jruby.RubyArray;
 import org.jruby.RubyClass;
 import org.jruby.RubyHash;
-import org.jruby.RubyObject;
 import org.jruby.RubyString;
 import org.jruby.anno.JRubyClass;
 import org.jruby.anno.JRubyMethod;
@@ -16,51 +13,32 @@
 import org.jruby.runtime.builtin.IRubyObject;
 import org.logstash.RubyUtil;
 import org.logstash.execution.WorkerLoop;
-import org.logstash.ext.JrubyEventExtLibrary;
 import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
-import org.logstash.instrument.metrics.MetricKeys;
 import org.logstash.instrument.metrics.counter.LongCounter;
 
-@JRubyClass(name = "JavaFilterDelegator")
-public final class FilterDelegatorExt extends RubyObject {
-
-    private static final String FILTER_METHOD_NAME = "multi_filter";
+@JRubyClass(name = "FilterDelegator")
+public final class FilterDelegatorExt extends AbstractFilterDelegatorExt {
 
     private static final long serialVersionUID = 1L;
 
+    private static final String FILTER_METHOD_NAME = "multi_filter";
+
     private RubyClass filterClass;
 
     private IRubyObject filter;
 
-    private AbstractNamespacedMetricExt metricEvents;
-
-    private RubyString id;
-
-    private LongCounter eventMetricOut;
-
-    private LongCounter eventMetricIn;
-
     private DynamicMethod filterMethod;
 
-    private LongCounter eventMetricTime;
-
     private boolean flushes;
 
-    @JRubyMethod
-    public IRubyObject initialize(final ThreadContext context, final IRubyObject filter,
-        final IRubyObject id) {
+    @JRubyMethod(name="initialize")
+    public IRubyObject initialize(final ThreadContext context, final IRubyObject filter, final IRubyObject id) {
         this.id = (RubyString) id;
         this.filter = filter;
         filterClass = filter.getSingletonClass().getRealClass();
         filterMethod = filterClass.searchMethod(FILTER_METHOD_NAME);
         final AbstractNamespacedMetricExt namespacedMetric = (AbstractNamespacedMetricExt) filter.callMethod(context, "metric");
-        synchronized(namespacedMetric.getMetric()) {
-            metricEvents = namespacedMetric.namespace(context, MetricKeys.EVENTS_KEY);
-            eventMetricOut = LongCounter.fromRubyBase(metricEvents, MetricKeys.OUT_KEY);
-            eventMetricIn = LongCounter.fromRubyBase(metricEvents, MetricKeys.IN_KEY);
-            eventMetricTime = LongCounter.fromRubyBase(metricEvents, MetricKeys.DURATION_IN_MILLIS_KEY);
-            namespacedMetric.gauge(context, MetricKeys.NAME_KEY, configName(context));
-        }
+        initMetrics(this.id.asJavaString(), namespacedMetric);
         flushes = filter.respondsTo("flush");
         return this;
     }
@@ -80,84 +58,59 @@ public FilterDelegatorExt(final Ruby runtime, final RubyClass metaClass) {
         super(runtime, metaClass);
     }
 
-    @JRubyMethod
-    public IRubyObject register(final ThreadContext context) {
-        return filter.callMethod(context, "register");
+    @Override
+    protected void doRegister(final ThreadContext context) {
+        filter.callMethod(context, "register");
     }
 
-    @JRubyMethod
-    public IRubyObject close(final ThreadContext context) {
+    @Override
+    protected IRubyObject closeImpl(final ThreadContext context) {
         return filter.callMethod(context, "close");
     }
 
-    @JRubyMethod(name = "do_close")
-    public IRubyObject doClose(final ThreadContext context) {
+    @Override
+    protected IRubyObject doCloseImpl(final ThreadContext context) {
         return filter.callMethod(context, "do_close");
     }
 
-    @JRubyMethod(name = "do_stop")
-    public IRubyObject doStop(final ThreadContext context) {
+    @Override
+    protected IRubyObject doStopImpl(final ThreadContext context) {
         return filter.callMethod(context, "do_stop");
     }
 
-    @JRubyMethod(name = "reloadable?")
-    public IRubyObject isReloadable(final ThreadContext context) {
+    @Override
+    protected IRubyObject reloadable(final ThreadContext context) {
         return filter.callMethod(context, "reloadable?");
     }
 
-    @JRubyMethod(name = "threadsafe?")
-    public IRubyObject concurrency(final ThreadContext context) {
+    @Override
+    protected IRubyObject getConcurrency(final ThreadContext context) {
         return filter.callMethod(context, "threadsafe?");
     }
 
-    @JRubyMethod(name = "config_name")
-    public IRubyObject configName(final ThreadContext context) {
+    @Override
+    protected IRubyObject getConfigName(final ThreadContext context) {
         return filterClass.callMethod(context, "config_name");
     }
 
-    @JRubyMethod(name = "id")
-    public IRubyObject getId() {
-        return id;
-    }
-
-    @SuppressWarnings("unchecked")
-    public RubyArray multiFilter(final RubyArray batch) {
-        eventMetricIn.increment((long) batch.size());
-        final long start = System.nanoTime();
-        final RubyArray result = (RubyArray) filterMethod.call(
-            WorkerLoop.THREAD_CONTEXT.get(), filter, filterClass, FILTER_METHOD_NAME, batch
-        );
-        eventMetricTime.increment(
-            TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS)
-        );
-        int count = 0;
-        for (final JrubyEventExtLibrary.RubyEvent event : (Collection<JrubyEventExtLibrary.RubyEvent>) result) {
-            if (!event.getEvent().isCancelled()) {
-                ++count;
-            }
-        }
-        eventMetricOut.increment((long) count);
-        return result;
+    @Override
+    protected RubyArray doMultiFilter(final RubyArray batch) {
+        return (RubyArray) filterMethod.call(
+                WorkerLoop.THREAD_CONTEXT.get(), filter, filterClass, FILTER_METHOD_NAME, batch);
     }
 
-    public RubyArray flush(final RubyHash options) {
-        final ThreadContext context = WorkerLoop.THREAD_CONTEXT.get();
-        final IRubyObject newEvents = filter.callMethod(context, "flush", options);
-        final RubyArray result;
-        if (newEvents.isNil()) {
-            result = RubyArray.newEmptyArray(context.runtime);
-        } else {
-            result = (RubyArray) newEvents;
-            eventMetricOut.increment((long) result.size());
-        }
-        return result;
+    @Override
+    protected IRubyObject doFlush(final ThreadContext context, final RubyHash options) {
+        return filter.callMethod(context, "flush", options);
     }
 
-    public boolean hasFlush() {
+    @Override
+    protected boolean getHasFlush() {
         return flushes;
     }
 
-    public boolean periodicFlush() {
+    @Override
+    protected boolean getPeriodicFlush() {
         return filter.callMethod(RubyUtil.RUBY.getCurrentContext(), "periodic_flush").isTrue();
     }
 }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaFilterDelegatorExt.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaFilterDelegatorExt.java
new file mode 100644
index 00000000000..48ab20d7d39
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaFilterDelegatorExt.java
@@ -0,0 +1,108 @@
+package org.logstash.config.ir.compiler;
+
+import org.jruby.Ruby;
+import org.jruby.RubyArray;
+import org.jruby.RubyClass;
+import org.jruby.RubyHash;
+import org.jruby.RubyString;
+import org.jruby.RubySymbol;
+import org.jruby.anno.JRubyClass;
+import org.jruby.runtime.ThreadContext;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.logstash.Event;
+import org.logstash.RubyUtil;
+import org.logstash.execution.Filter;
+import org.logstash.ext.JrubyEventExtLibrary;
+import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.stream.Collectors;
+
+@JRubyClass(name = "JavaFilterDelegator")
+public class JavaFilterDelegatorExt extends AbstractFilterDelegatorExt {
+
+    private static final RubySymbol CONCURRENCY = RubyUtil.RUBY.newSymbol("java");
+
+    private RubyString configName;
+
+    private Filter filter;
+
+    public JavaFilterDelegatorExt(final Ruby runtime, final RubyClass metaClass) {
+        super(runtime, metaClass);
+    }
+
+    public static JavaFilterDelegatorExt create(final String configName, final String id,
+                                                final AbstractNamespacedMetricExt metric,
+                                                final Filter filter) {
+        final JavaFilterDelegatorExt instance =
+                new JavaFilterDelegatorExt(RubyUtil.RUBY, RubyUtil.JAVA_FILTER_DELEGATOR_CLASS);
+        instance.initMetrics(id, metric);
+        instance.configName = RubyUtil.RUBY.newString(configName);
+        instance.filter = filter;
+        return instance;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    protected RubyArray doMultiFilter(final RubyArray batch) {
+        List<Event> inputEvents = (List<Event>)batch.stream()
+                .map(x -> ((JrubyEventExtLibrary.RubyEvent)x).getEvent())
+                .collect(Collectors.toList());
+        Collection<Event> outputEvents = filter.filter(inputEvents);
+        RubyArray newBatch = RubyArray.newArray(RubyUtil.RUBY, outputEvents.size());
+        for (Event outputEvent : outputEvents) {
+            newBatch.add(JrubyEventExtLibrary.RubyEvent.newRubyEvent(RubyUtil.RUBY, outputEvent));
+        }
+        return newBatch;
+    }
+
+    @Override
+    protected void doRegister(ThreadContext context) {}
+
+    @Override
+    protected IRubyObject doFlush(final ThreadContext context, final RubyHash options) {
+        // add flush() to Java filter API?
+        return context.nil;
+    }
+
+    @Override
+    protected IRubyObject closeImpl(final ThreadContext context) {
+        return context.nil;
+    }
+
+    @Override
+    protected IRubyObject doCloseImpl(final ThreadContext context) {
+        return context.nil;
+    }
+
+    @Override
+    protected IRubyObject doStopImpl(final ThreadContext context) {
+        return context.nil;
+    }
+
+    @Override
+    protected IRubyObject reloadable(final ThreadContext context) {
+        return context.tru;
+    }
+
+    @Override
+    protected IRubyObject getConcurrency(final ThreadContext context) {
+        return CONCURRENCY;
+    }
+
+    @Override
+    protected IRubyObject getConfigName(final ThreadContext context) {
+        return configName;
+    }
+
+    @Override
+    protected boolean getHasFlush() {
+        return false;
+    }
+
+    @Override
+    protected boolean getPeriodicFlush() {
+        return false;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaOutputDelegatorExt.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaOutputDelegatorExt.java
index a55dd2b1ec1..2df23cdfb0b 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaOutputDelegatorExt.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaOutputDelegatorExt.java
@@ -1,7 +1,10 @@
 package org.logstash.config.ir.compiler;
 
 import java.util.Collection;
+import java.util.List;
 import java.util.function.Consumer;
+import java.util.stream.Collectors;
+
 import org.jruby.Ruby;
 import org.jruby.RubyClass;
 import org.jruby.RubyString;
@@ -9,7 +12,9 @@
 import org.jruby.anno.JRubyClass;
 import org.jruby.runtime.ThreadContext;
 import org.jruby.runtime.builtin.IRubyObject;
+import org.logstash.Event;
 import org.logstash.RubyUtil;
+import org.logstash.execution.Output;
 import org.logstash.ext.JrubyEventExtLibrary;
 import org.logstash.instrument.metrics.AbstractMetricExt;
 
@@ -26,6 +31,8 @@ public final class JavaOutputDelegatorExt extends AbstractOutputDelegatorExt {
 
     private Runnable registerAction;
 
+    private Output output;
+
     public JavaOutputDelegatorExt(final Ruby runtime, final RubyClass metaClass) {
         super(runtime, metaClass);
     }
@@ -44,6 +51,33 @@ public static JavaOutputDelegatorExt create(final String configName, final Strin
         return instance;
     }
 
+    public static JavaOutputDelegatorExt create(final String configName, final String id,
+                                                final AbstractMetricExt metric,
+                                                final Output output) {
+        final JavaOutputDelegatorExt instance =
+                new JavaOutputDelegatorExt(RubyUtil.RUBY, RubyUtil.JAVA_OUTPUT_DELEGATOR_CLASS);
+        instance.initMetrics(id, metric);
+        instance.configName = RubyUtil.RUBY.newString(configName);
+        instance.output = output;
+        instance.outputFunction = instance::outputRubyEvents;
+        instance.closeAction = instance::outputClose;
+        instance.registerAction = instance::outputRegister;
+        return instance;
+    }
+
+    void outputRubyEvents(Collection<JrubyEventExtLibrary.RubyEvent> e) {
+        List<Event> events = e.stream().map(JrubyEventExtLibrary.RubyEvent::getEvent).collect(Collectors.toList());
+        output.output(events);
+    }
+
+    void outputClose() {
+        output.stop();
+    }
+
+    void outputRegister() {
+
+    }
+
     @Override
     protected IRubyObject getConfigName(final ThreadContext context) {
         return configName;
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/PluginFactory.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/PluginFactory.java
index 06a18f78a78..1f8ed5ecd79 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/PluginFactory.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/PluginFactory.java
@@ -3,10 +3,8 @@
 import org.jruby.RubyInteger;
 import org.jruby.RubyString;
 import org.jruby.runtime.builtin.IRubyObject;
-import org.logstash.execution.Filter;
-import org.logstash.execution.Input;
-import org.logstash.execution.LsConfiguration;
-import org.logstash.execution.LsContext;
+import org.logstash.execution.*;
+import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
 /**
  * Factory that can instantiate Java plugins as well as Ruby plugins.
@@ -48,10 +46,20 @@ public AbstractOutputDelegatorExt buildOutput(final RubyString name, final RubyI
         }
 
         @Override
-        public FilterDelegatorExt buildFilter(final RubyString name, final RubyInteger line, final RubyInteger column, final IRubyObject args) {
+        public AbstractOutputDelegatorExt buildJavaOutput(String name, int line, int column, Output output, IRubyObject args) {
+            throw new NotImplementedException();
+        }
+
+        @Override
+        public AbstractFilterDelegatorExt buildFilter(final RubyString name, final RubyInteger line, final RubyInteger column, final IRubyObject args) {
             return rubyFactory.buildFilter(name, line, column, args);
         }
 
+        @Override
+        public AbstractFilterDelegatorExt buildJavaFilter(String name, int line, int column, Filter filter, IRubyObject args) {
+            throw new NotImplementedException();
+        }
+
         @Override
         public IRubyObject buildCodec(final RubyString name, final IRubyObject args) {
             return rubyFactory.buildCodec(name, args);
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java
index 7c5fd86c1ab..aaf15feb2a4 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/RubyIntegration.java
@@ -3,6 +3,8 @@
 import org.jruby.RubyInteger;
 import org.jruby.RubyString;
 import org.jruby.runtime.builtin.IRubyObject;
+import org.logstash.execution.Filter;
+import org.logstash.execution.Output;
 
 /**
  * This class holds interfaces implemented by Ruby concrete classes.
@@ -24,8 +26,11 @@ IRubyObject buildInput(RubyString name, RubyInteger line, RubyInteger column,
         AbstractOutputDelegatorExt buildOutput(RubyString name, RubyInteger line, RubyInteger column,
             IRubyObject args);
 
-        FilterDelegatorExt buildFilter(RubyString name, RubyInteger line, RubyInteger column,
-            IRubyObject args);
+        AbstractOutputDelegatorExt buildJavaOutput(String name, int line, int column, Output output, IRubyObject args);
+
+        AbstractFilterDelegatorExt buildFilter(RubyString name, RubyInteger line, RubyInteger column, IRubyObject args);
+
+        AbstractFilterDelegatorExt buildJavaFilter(String name, int line, int column, Filter filter, IRubyObject args);
 
         IRubyObject buildCodec(RubyString name, IRubyObject args);
     }
diff --git a/logstash-core/src/main/java/org/logstash/execution/Filter.java b/logstash-core/src/main/java/org/logstash/execution/Filter.java
index 8995bafab36..f3ed7433c93 100644
--- a/logstash-core/src/main/java/org/logstash/execution/Filter.java
+++ b/logstash-core/src/main/java/org/logstash/execution/Filter.java
@@ -48,7 +48,7 @@ public Collection<PluginConfigSpec<?>> configSchema() {
         }
     }
 
-    @LogstashPlugin(name = "clone")
+    @LogstashPlugin(name = "java-clone")
     final class Clone implements Filter {
 
         private Event clone;
@@ -65,7 +65,9 @@ public Clone(final LsConfiguration configuration, final LsContext context) {
 
         @Override
         public Collection<Event> filter(final Collection<Event> events) {
-            //TODO: Impl.
+            for (Event e : events) {
+                e.setField("java-clone", "was here");
+            }
             return events;
         }
 
diff --git a/logstash-core/src/main/java/org/logstash/execution/Input.java b/logstash-core/src/main/java/org/logstash/execution/Input.java
index 8505acc074d..cda75736fcb 100644
--- a/logstash-core/src/main/java/org/logstash/execution/Input.java
+++ b/logstash-core/src/main/java/org/logstash/execution/Input.java
@@ -31,6 +31,34 @@ public interface Input extends LsPlugin {
      */
     void awaitStop() throws InterruptedException;
 
+    @LogstashPlugin(name = "java-one-input-event")
+    final class OneInputEvent implements Input {
+
+        public OneInputEvent(final LsConfiguration configuration, final LsContext context) {
+            // do nothing
+        }
+
+        @Override
+        public void start(QueueWriter writer) {
+            writer.push(Collections.singletonMap("oneEvent", "isDone"));
+        }
+
+        @Override
+        public void stop() {
+
+        }
+
+        @Override
+        public void awaitStop() throws InterruptedException {
+
+        }
+
+        @Override
+        public Collection<PluginConfigSpec<?>> configSchema() {
+            return Collections.EMPTY_LIST;
+        }
+    }
+
     @LogstashPlugin(name = "stream")
     final class StreamInput implements Input {
 
diff --git a/logstash-core/src/main/java/org/logstash/execution/Output.java b/logstash-core/src/main/java/org/logstash/execution/Output.java
index 27251ca13a7..89885fe873c 100644
--- a/logstash-core/src/main/java/org/logstash/execution/Output.java
+++ b/logstash-core/src/main/java/org/logstash/execution/Output.java
@@ -25,7 +25,7 @@ public interface Output extends LsPlugin {
     @LogstashPlugin(name = "output")
     final class StreamOutput implements Output {
 
-        private final PrintStream outpt;
+        private final PrintStream output;
 
         private volatile boolean stopped;
 
@@ -37,7 +37,7 @@ final class StreamOutput implements Output {
          * @param context Logstash Context
          */
         public StreamOutput(final LsConfiguration configuration, final LsContext context) {
-            this.outpt = new PrintStream(System.out);
+            this.output = new PrintStream(System.out);
         }
 
         @Override
@@ -52,7 +52,7 @@ public void output(final Collection<Event> events) {
 
         @Override
         public void stop() {
-            outpt.close();
+            output.close();
             stopped = true;
         }
 
diff --git a/logstash-core/src/main/java/org/logstash/execution/codecs/CodecFactory.java b/logstash-core/src/main/java/org/logstash/execution/codecs/CodecFactory.java
deleted file mode 100644
index 5839722cc32..00000000000
--- a/logstash-core/src/main/java/org/logstash/execution/codecs/CodecFactory.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package org.logstash.execution.codecs;
-
-import org.logstash.execution.Codec;
-import org.logstash.execution.LsConfiguration;
-import org.logstash.execution.LsContext;
-
-import java.lang.reflect.Constructor;
-import java.util.concurrent.ConcurrentHashMap;
-
-public class CodecFactory {
-
-    // eagerly initialize singleton
-    private static final CodecFactory INSTANCE;
-
-    private ConcurrentHashMap<String, Class> codecMap = new ConcurrentHashMap<>();
-
-    // not necessary after DiscoverPlugins is implemented
-    static {
-        INSTANCE = new CodecFactory();
-        INSTANCE.addCodec("line", Line.class);
-    }
-
-    private CodecFactory() {
-        // singleton class
-    }
-
-    public static CodecFactory getInstance() {
-        return INSTANCE;
-    }
-
-    public void addCodec(String name, Class codecClass) {
-        codecMap.put(name, codecClass);
-    }
-
-    public Codec getCodec(String name, LsConfiguration configuration, LsContext context) {
-        if (name != null && codecMap.containsKey(name)) {
-            return instantiateCodec(codecMap.get(name), configuration, context);
-        }
-        return null;
-    }
-
-    private Codec instantiateCodec(Class clazz, LsConfiguration configuration, LsContext context) {
-        try {
-            Constructor<Codec> constructor = clazz.getConstructor(LsConfiguration.class, LsContext.class);
-            return constructor.newInstance(configuration, context);
-        } catch (Exception e) {
-            throw new IllegalStateException("Unable to instantiate codec", e);
-        }
-    }
-}
diff --git a/logstash-core/src/main/java/org/logstash/execution/inputs/Stdin.java b/logstash-core/src/main/java/org/logstash/execution/inputs/Stdin.java
index c39afa8c83c..3d8e0d54037 100644
--- a/logstash-core/src/main/java/org/logstash/execution/inputs/Stdin.java
+++ b/logstash-core/src/main/java/org/logstash/execution/inputs/Stdin.java
@@ -7,8 +7,8 @@
 import org.logstash.execution.LsContext;
 import org.logstash.execution.PluginHelper;
 import org.logstash.execution.plugins.PluginConfigSpec;
+import org.logstash.execution.plugins.discovery.PluginRegistry;
 import org.logstash.execution.queue.QueueWriter;
-import org.logstash.execution.codecs.CodecFactory;
 
 import java.io.FileDescriptor;
 import java.io.FileInputStream;
@@ -57,8 +57,7 @@ public Stdin(final LsConfiguration configuration, final LsContext context) {
         } catch (UnknownHostException e) {
             hostname = "[unknownHost]";
         }
-        codec = CodecFactory.getInstance().getCodec(configuration.getRawValue(CODEC_CONFIG),
-                configuration, context);
+        codec = PluginRegistry.getCodec(configuration.getRawValue(CODEC_CONFIG), configuration, context);
         input = inputChannel;
     }
 
diff --git a/logstash-core/src/main/java/org/logstash/execution/plugins/discovery/DiscoverPlugins.java b/logstash-core/src/main/java/org/logstash/execution/plugins/discovery/DiscoverPlugins.java
deleted file mode 100644
index 8bec710908f..00000000000
--- a/logstash-core/src/main/java/org/logstash/execution/plugins/discovery/DiscoverPlugins.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.logstash.execution.plugins.discovery;
-
-import java.lang.annotation.Annotation;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-import org.logstash.execution.LogstashPlugin;
-
-/**
- * Logstash Java Plugin Discovery.
- */
-public final class DiscoverPlugins {
-
-    public static Map<String, Class<?>> discoverPlugins() {
-        Reflections reflections = new Reflections("");
-        Set<Class<?>> annotated = reflections.getTypesAnnotatedWith(LogstashPlugin.class);
-        final Map<String, Class<?>> results = new HashMap<>();
-        for (final Class<?> cls : annotated) {
-            for (final Annotation annotation : cls.getAnnotations()) {
-                if (annotation instanceof LogstashPlugin) {
-                    results.put(((LogstashPlugin) annotation).name(), cls);
-                    break;
-                }
-            }
-        }
-        return results;
-    }
-}
diff --git a/logstash-core/src/main/java/org/logstash/execution/plugins/discovery/PluginRegistry.java b/logstash-core/src/main/java/org/logstash/execution/plugins/discovery/PluginRegistry.java
new file mode 100644
index 00000000000..0f632f425dd
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/execution/plugins/discovery/PluginRegistry.java
@@ -0,0 +1,91 @@
+package org.logstash.execution.plugins.discovery;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import org.logstash.execution.Codec;
+import org.logstash.execution.Filter;
+import org.logstash.execution.Input;
+import org.logstash.execution.LogstashPlugin;
+import org.logstash.execution.LsConfiguration;
+import org.logstash.execution.LsContext;
+import org.logstash.execution.Output;
+
+/**
+ * Logstash Java Plugin Registry.
+ */
+public final class PluginRegistry {
+
+    private static final Map<String, Class<Input>> INPUTS = new HashMap<>();
+    private static final Map<String, Class<Filter>> FILTERS = new HashMap<>();
+    private static final Map<String, Class<Output>> OUTPUTS = new HashMap<>();
+    private static final Map<String, Class<Codec>> CODECS = new HashMap<>();
+
+    static {
+        discoverPlugins();
+    }
+
+    private PluginRegistry() {} // utility class
+
+    @SuppressWarnings("unchecked")
+    private static void discoverPlugins() {
+        Reflections reflections = new Reflections("");
+        Set<Class<?>> annotated = reflections.getTypesAnnotatedWith(LogstashPlugin.class);
+        for (final Class<?> cls : annotated) {
+            for (final Annotation annotation : cls.getAnnotations()) {
+                if (annotation instanceof LogstashPlugin) {
+                    String name = ((LogstashPlugin) annotation).name();
+                    if (Filter.class.isAssignableFrom(cls)) {
+                        FILTERS.put(name, (Class<Filter>) cls);
+                    }
+                    if (Output.class.isAssignableFrom(cls)) {
+                        OUTPUTS.put(name, (Class<Output>) cls);
+                    }
+                    if (Input.class.isAssignableFrom(cls)) {
+                        INPUTS.put(name, (Class<Input>) cls);
+                    }
+                    if (Codec.class.isAssignableFrom(cls)) {
+                        CODECS.put(name, (Class<Codec>) cls);
+                    }
+
+                    break;
+                }
+            }
+        }
+    }
+
+    public static Class<Input> getInputClass(String name) {
+        return INPUTS.get(name);
+    }
+
+    public static Class<Filter> getFilterClass(String name) {
+        return FILTERS.get(name);
+    }
+
+    public static Class<Codec> getCodecClass(String name) {
+        return CODECS.get(name);
+    }
+
+    public static Class<Output> getOutputClass(String name) {
+        return OUTPUTS.get(name);
+    }
+
+    public static Codec getCodec(String name, LsConfiguration configuration, LsContext context) {
+        if (name != null && CODECS.containsKey(name)) {
+            return instantiateCodec(CODECS.get(name), configuration, context);
+        }
+        return null;
+    }
+
+    private static Codec instantiateCodec(Class clazz, LsConfiguration configuration, LsContext context) {
+        try {
+            Constructor<Codec> constructor = clazz.getConstructor(LsConfiguration.class, LsContext.class);
+            return constructor.newInstance(configuration, context);
+        } catch (Exception e) {
+            throw new IllegalStateException("Unable to instantiate codec", e);
+        }
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java b/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java
index b40816f8aa0..15da8d9551a 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java
@@ -1,12 +1,5 @@
 package org.logstash.plugins;
 
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Locale;
-import java.util.Map;
-import java.util.UUID;
 import org.jruby.Ruby;
 import org.jruby.RubyArray;
 import org.jruby.RubyBasicObject;
@@ -21,18 +14,31 @@
 import org.jruby.runtime.builtin.IRubyObject;
 import org.logstash.RubyUtil;
 import org.logstash.config.ir.PipelineIR;
+import org.logstash.config.ir.compiler.AbstractFilterDelegatorExt;
 import org.logstash.config.ir.compiler.AbstractOutputDelegatorExt;
 import org.logstash.config.ir.compiler.FilterDelegatorExt;
+import org.logstash.config.ir.compiler.JavaFilterDelegatorExt;
+import org.logstash.config.ir.compiler.JavaOutputDelegatorExt;
 import org.logstash.config.ir.compiler.OutputDelegatorExt;
 import org.logstash.config.ir.compiler.OutputStrategyExt;
 import org.logstash.config.ir.compiler.RubyIntegration;
 import org.logstash.config.ir.graph.Vertex;
 import org.logstash.execution.ExecutionContextExt;
+import org.logstash.execution.Filter;
+import org.logstash.execution.Output;
 import org.logstash.instrument.metrics.AbstractMetricExt;
 import org.logstash.instrument.metrics.AbstractNamespacedMetricExt;
 import org.logstash.instrument.metrics.MetricKeys;
 import org.logstash.instrument.metrics.NullMetricExt;
 
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Map;
+import java.util.UUID;
+
 public final class PluginFactoryExt {
 
     @JRubyClass(name = "PluginFactory")
@@ -62,7 +68,9 @@ public static IRubyObject filterDelegator(final ThreadContext context,
                 ((AbstractMetricExt) args[3]).namespace(context, id.intern19())
             );
             filterInstance.callMethod(context, "execution_context=", args[4]);
-            return args[0].callMethod(context, "new", new IRubyObject[]{filterInstance, id});
+            FilterDelegatorExt fd = (FilterDelegatorExt) new FilterDelegatorExt(context.runtime, RubyUtil.FILTER_DELEGATOR_CLASS)
+                    .initialize(context, filterInstance, id);
+            return fd;
         }
 
         public Plugins(final Ruby runtime, final RubyClass metaClass) {
@@ -127,11 +135,19 @@ public AbstractOutputDelegatorExt buildOutput(final ThreadContext context,
             );
         }
 
+        @Override
+        public AbstractOutputDelegatorExt buildJavaOutput(final String name, final int line, final int column,
+                                                          Output output, final IRubyObject args) {
+            return (AbstractOutputDelegatorExt) plugin(
+                    RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.OUTPUT,
+                    name, line, column, (Map<String, IRubyObject>) args, true, output);
+        }
+
         @SuppressWarnings("unchecked")
         @Override
-        public FilterDelegatorExt buildFilter(final RubyString name, final RubyInteger line,
-            final RubyInteger column, final IRubyObject args) {
-            return (FilterDelegatorExt) plugin(
+        public AbstractFilterDelegatorExt buildFilter(final RubyString name, final RubyInteger line,
+                                                      final RubyInteger column, final IRubyObject args) {
+            return (AbstractFilterDelegatorExt) plugin(
                 RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.FILTER,
                 name.asJavaString(), line.getIntValue(), column.getIntValue(),
                 (Map<String, IRubyObject>) args
@@ -146,6 +162,14 @@ public IRubyObject buildFilter(final ThreadContext context, final IRubyObject[]
             );
         }
 
+        @Override
+        public AbstractFilterDelegatorExt buildJavaFilter(final String name, final int line, final int column,
+                                                          Filter filter, final IRubyObject args) {
+            return (AbstractFilterDelegatorExt) plugin(
+                    RubyUtil.RUBY.getCurrentContext(), PluginLookup.PluginType.FILTER,
+                    name, line, column, (Map<String, IRubyObject>) args, true, filter);
+        }
+
         @SuppressWarnings("unchecked")
         @Override
         public IRubyObject buildCodec(final RubyString name, final IRubyObject args) {
@@ -173,9 +197,15 @@ public IRubyObject plugin(final ThreadContext context, final IRubyObject[] args)
             );
         }
 
+        private IRubyObject plugin(final ThreadContext context,
+                                   final PluginLookup.PluginType type, final String name, final int line, final int column,
+                                   final Map<String, IRubyObject> args) {
+            return plugin(context, type, name, line, column, args, false, null);
+        }
+
         private IRubyObject plugin(final ThreadContext context,
             final PluginLookup.PluginType type, final String name, final int line, final int column,
-            final Map<String, IRubyObject> args) {
+            final Map<String, IRubyObject> args, boolean isJava, Object javaPlugin) {
             final String id;
             if (type == PluginLookup.PluginType.CODEC) {
                 id = UUID.randomUUID().toString();
@@ -201,10 +231,10 @@ private IRubyObject plugin(final ThreadContext context,
                 );
             }
             pluginsById.add(id);
-            final AbstractNamespacedMetricExt typeScopedMetric =
-                metrics.create(context, type.rubyLabel());
-            final PluginLookup.PluginClass pluginClass = PluginLookup.lookup(type, name);
-            if (pluginClass.language() == PluginLookup.PluginLanguage.RUBY) {
+            final AbstractNamespacedMetricExt typeScopedMetric = metrics.create(context, type.rubyLabel());
+
+            if (!isJava) {
+                final PluginLookup.PluginClass pluginClass = PluginLookup.lookup(type, name);
                 final Map<String, Object> newArgs = new HashMap<>(args);
                 newArgs.put("id", id);
                 final RubyClass klass = (RubyClass) pluginClass.klass();
@@ -238,7 +268,13 @@ private IRubyObject plugin(final ThreadContext context,
                     return pluginInstance;
                 }
             } else {
-                return context.nil;
+                if (type == PluginLookup.PluginType.OUTPUT) {
+                    return JavaOutputDelegatorExt.create(name, id, typeScopedMetric, (Output)javaPlugin);
+                } else if (type == PluginLookup.PluginType.FILTER) {
+                    return JavaFilterDelegatorExt.create(name, id, typeScopedMetric, (Filter)javaPlugin);
+                } else {
+                    return context.nil;
+                }
             }
         }
     }
diff --git a/logstash-core/src/main/java/org/logstash/plugins/PluginLookup.java b/logstash-core/src/main/java/org/logstash/plugins/PluginLookup.java
index b3f91b41a1c..58eaa0a1656 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/PluginLookup.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/PluginLookup.java
@@ -19,8 +19,7 @@ private PluginLookup() {
         // Utility Class
     }
 
-    public static PluginLookup.PluginClass lookup(final PluginLookup.PluginType type,
-        final String name) {
+    public static PluginLookup.PluginClass lookup(final PluginLookup.PluginType type, final String name) {
         return new PluginLookup.PluginClass() {
             @Override
             public PluginLookup.PluginLanguage language() {
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java b/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java
index 5fda5071dc4..2648e7c60ce 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/CompiledPipelineTest.java
@@ -24,14 +24,13 @@
 import org.logstash.Event;
 import org.logstash.RubyUtil;
 import org.logstash.common.IncompleteSourceWithMetadataException;
+import org.logstash.config.ir.compiler.AbstractFilterDelegatorExt;
 import org.logstash.config.ir.compiler.AbstractOutputDelegatorExt;
 import org.logstash.config.ir.compiler.FilterDelegatorExt;
 import org.logstash.config.ir.compiler.PluginFactory;
-import org.logstash.execution.Filter;
-import org.logstash.execution.Input;
-import org.logstash.execution.LsConfiguration;
-import org.logstash.execution.LsContext;
+import org.logstash.execution.*;
 import org.logstash.ext.JrubyEventExtLibrary;
+import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
 /**
  * Tests for {@link CompiledPipeline}.
@@ -448,13 +447,23 @@ public AbstractOutputDelegatorExt buildOutput(final RubyString name, final RubyI
         }
 
         @Override
-        public FilterDelegatorExt buildFilter(final RubyString name, final RubyInteger line,
-            final RubyInteger column, final IRubyObject args) {
+        public AbstractOutputDelegatorExt buildJavaOutput(String name, int line, int column, Output output, IRubyObject args) {
+            throw new NotImplementedException();
+        }
+
+        @Override
+        public AbstractFilterDelegatorExt buildFilter(final RubyString name, final RubyInteger line,
+                                                      final RubyInteger column, final IRubyObject args) {
             return new FilterDelegatorExt(
-                RubyUtil.RUBY, RubyUtil.RUBY_OUTPUT_DELEGATOR_CLASS)
+                RubyUtil.RUBY, RubyUtil.FILTER_DELEGATOR_CLASS)
                 .initForTesting(setupPlugin(name, filters));
         }
 
+        @Override
+        public AbstractFilterDelegatorExt buildJavaFilter(String name, int line, int column, Filter filter, IRubyObject args) {
+            throw new NotImplementedException();
+        }
+
         @Override
         public IRubyObject buildCodec(final RubyString name, final IRubyObject args) {
             throw new IllegalStateException("No codec setup expected in this test.");
diff --git a/logstash-core/src/test/java/org/logstash/execution/codecs/CodecFactoryTest.java b/logstash-core/src/test/java/org/logstash/execution/codecs/CodecFactoryTest.java
deleted file mode 100644
index 3e5c7686e17..00000000000
--- a/logstash-core/src/test/java/org/logstash/execution/codecs/CodecFactoryTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.logstash.execution.codecs;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.logstash.execution.Codec;
-import org.logstash.execution.LsConfiguration;
-import org.logstash.execution.LsContext;
-
-import java.util.Collections;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-
-public class CodecFactoryTest {
-
-    private CodecFactory codecFactory;
-
-    @Before
-    public void setup() {
-        // shouldn't be necessary once DiscoverPlugins is fully implemented
-        codecFactory = CodecFactory.getInstance();
-        codecFactory.addCodec("line", Line.class);
-    }
-
-    @Test
-    public void testBasicLookups() {
-        LsConfiguration config = new LsConfiguration(Collections.EMPTY_MAP);
-        LsContext context = new LsContext();
-        Codec c = codecFactory.getCodec("line", config, context);
-        assertNotNull(c);
-        assertEquals(Line.class, c.getClass());
-
-        c = codecFactory.getCodec(null, config, context);
-        assertNull(c);
-    }
-}
