diff --git a/docker/data/logstash/env2yaml/env2yaml.go b/docker/data/logstash/env2yaml/env2yaml.go
index 507f73f0ad2..e63390e8cf5 100644
--- a/docker/data/logstash/env2yaml/env2yaml.go
+++ b/docker/data/logstash/env2yaml/env2yaml.go
@@ -57,6 +57,7 @@ func normalizeSetting(setting string) (string, error) {
 		"pipeline.batch.delay",
 		"pipeline.unsafe_shutdown",
 		"pipeline.java_execution",
+		"pipeline.plugin_classloaders",
 		"path.config",
 		"config.string",
 		"config.test_and_exit",
diff --git a/docs/static/contributing-java-plugin.asciidoc b/docs/static/contributing-java-plugin.asciidoc
index 04e994fed8d..e509eaaf648 100644
--- a/docs/static/contributing-java-plugin.asciidoc
+++ b/docs/static/contributing-java-plugin.asciidoc
@@ -17,8 +17,7 @@ The APIs are in the `co.elastic.logstash.api` package.
 A Java plugin might break if it references classes or specific concrete
 implementations of API interfaces outside that package. The implementation of
 classes outside of the API package may change at any time.
-* Coming in a future release: Tooling to automate the packaging and deployment of
-Java plugins in Logstash. (Currently, this process is manual.)
+* Tooling to automate the packaging and deployment of Java plugins in Logstash.
 
 [float]
 === Process overview
diff --git a/docs/static/include/javapluginpkg.asciidoc b/docs/static/include/javapluginpkg.asciidoc
index b3f16c1982f..7f23d2f0aff 100644
--- a/docs/static/include/javapluginpkg.asciidoc
+++ b/docs/static/include/javapluginpkg.asciidoc
@@ -2,122 +2,72 @@
 === Package and deploy
 
 Java plugins are packaged as Ruby gems for dependency management and
-interoperability with Ruby plugins. 
-
-NOTE: One of the goals for Java plugin support is to eliminate the need for any
-knowledge of Ruby or its toolchain for Java plugin development. Future phases of
-the Java plugin project will automate the packaging of Java plugins as Ruby gems
-so no direct knowledge of or interaction with Ruby will be required. In the
-current phase, Java plugins must still be manually packaged as Ruby gems
-and installed with the `logstash-plugin` utility.
-
-[float]
-==== Compile to JAR file
-
-The Java plugin should be compiled and assembled into a fat jar with the
-`vendor` task in the Gradle build file. This will package all Java dependencies
-into a single jar and write it to the correct folder for later packaging into a
-Ruby gem.
+interoperability with Ruby plugins. Once they are packaged as gems, they may
+be installed with the `logstash-plugin` utility just as Ruby plugins are.
+Because no knowledge of Ruby or its toolchain should be required for Java
+plugin development, the procedure for packaging Java plugins as Ruby gems
+has been automated through a custom task in the Gradle build file provided
+with the example Java plugins. The following sections describe how to
+configure and execute that packaging task as well as how to install the
+packaged Java plugin in Logstash.
 
 [float]
-==== Manually package as Ruby gem 
-
-Several Ruby source files are required to package the jar file as a
-Ruby gem. These Ruby files are used only at Logstash startup time to identify
-the Java plugin and are not used during runtime event processing. 
-
-NOTE: These Ruby source files will be automatically generated in a future release. 
+==== Configuring the Gradle packaging task
 
-**+logstash-{plugintype}-<{plugintype}-name>.gemspec+**
+The following section appears near the top of the `build.gradle` file supplied
+with the example Java plugins:
 
-[source,txt]
+[source,java]
 [subs="attributes"]
 -----
-Gem::Specification.new do |s|
-  s.name            = 'logstash-{plugintype}-java_{plugintype}_example'
-  s.version         = PLUGIN_VERSION
-  s.licenses        = ['Apache-2.0']
-  s.summary         = "Example {plugintype} using Java plugin API"
-  s.description     = ""
-  s.authors         = ['Elasticsearch']
-  s.email           = 'info@elastic.co'
-  s.homepage        = "http://www.elastic.co/guide/en/logstash/current/index.html"
-  s.require_paths = ['lib', 'vendor/jar-dependencies']
-
-  # Files
-  s.files = Dir["lib/**/*","spec/**/*","*.gemspec","*.md","CONTRIBUTORS","Gemfile","LICENSE","NOTICE.TXT", "vendor/jar-dependencies/**/*.jar", "vendor/jar-dependencies/**/*.rb", "VERSION", "docs/**/*"]
-
-  # Special flag to let us know this is actually a logstash plugin
-  s.metadata = { 'logstash_plugin' => 'true', 'logstash_group' => '{plugintype}'}
-
-  # Gem dependencies
-  s.add_runtime_dependency "logstash-core-plugin-api", ">= 1.60", "<= 2.99"
-  s.add_runtime_dependency 'jar-dependencies'
-
-  s.add_development_dependency 'logstash-devutils'
-end
+// ===========================================================================
+// plugin info
+// ===========================================================================
+group                      'org.logstashplugins' // must match the package of the main plugin class
+version                    "${file("VERSION").text.trim()}" // read from required VERSION file
+description                = "Example Java filter implementation"
+pluginInfo.licenses        = ['Apache-2.0'] // list of SPDX license IDs
+pluginInfo.longDescription = "This gem is a Logstash plugin required to be installed on top of the Logstash core pipeline using \$LS_HOME/bin/logstash-plugin install gemname. This gem is not a stand-alone program"
+pluginInfo.authors         = ['Elasticsearch']
+pluginInfo.email           = ['info@elastic.co']
+pluginInfo.homepage        = "http://www.elastic.co/guide/en/logstash/current/index.html"
+pluginInfo.pluginType      = "filter"
+pluginInfo.pluginClass     = "JavaFilterExample"
+pluginInfo.pluginName      = "java_filter_example"
+// ===========================================================================
 -----
 
-You can use this file with the following modifications: 
+You should configure the values above for your plugin.
 
-* `s.name` must follow the +logstash-pass:attributes[{plugintype}]-<{plugintype}-name>+ pattern
-* `s.version` must match the `project.version` specified in the `build.gradle` file. 
-Both versions should be set to be read from the `VERSION` file in this example.
-
-**+lib/logstash/{plugintype}s/<{plugintype}-name>.rb+**
-
-[source,ruby]
-[subs="attributes"]
------
-# encoding: utf-8
-require "logstash/{plugintype}s/base"
-require "logstash/namespace"
-require "logstash-{plugintype}-java_{plugintype}_example_jars"
-require "java"
-
-class LogStash::{plugintype}s::Java{plugintypecap}Example < LogStash::{pluginclass}::Base
-  config_name "java_{plugintype}_example"
-  
-  def self.javaClass() org.logstash.javaapi.Java{plugintypecap}Example.java_class; end
-end
------
+* The `version` value will be automatically read from the `VERSION` file in the
+root of your plugin's codebase.
+* `pluginInfo.pluginType` should be set to one of `input`, `filter`, `codec`,
+or `output`.
+* `pluginInfo.pluginName` must match the name specified on the `@LogstashPlugin`
+annotation on the main plugin class. The Gradle packaging task will validate
+that and return an error if they do not match.
 
-Modify these items in the file above:
+[float]
+==== Running the Gradle packaging task
 
-* Change the name to correspond with the {plugintype} name.
-* Change +require "logstash-{plugintype}-java_{plugintype}_example_jars"+ to reference the appropriate "jars" file
-as described below.
-* Change +class LogStash::{pluginclass}::Java{plugintypecap}Example < LogStash::{pluginclass}::Base+ to provide a unique and
-descriptive Ruby class name.
-* Change +config_name "java_{plugintype}_example"+ to match the name of the plugin as specified in the `name` property of
-the `@LogstashPlugin` annotation.
-* Change +def self.javaClass() org.logstash.javaapi.Java{plugintypecap}Example.java_class; end+ to return the
-class of the Java {plugintype}.
+Several Ruby source files along with a `gemspec` file and a `Gemfile` are
+required to package the plugin as a Ruby gem. These Ruby files are used only
+for defining the Ruby gem structure or at Logstash startup time to register
+the Java plugin. They are not used during runtime event processing. The
+Gradle packaging task automatically generates all of these files based on
+the values configured in the section above.
 
-**+lib/logstash-{plugintype}-<{plugintype}-name>_jars.rb+**
+You run the Gradle packaging task with the following command:
 
-[source,txt]
-[subs="attributes"]
+[source,shell]
 -----
-require 'jar_dependencies'
-require_jar('org.logstash.javaapi', 'logstash-{plugintype}-java_{plugintype}_example', {sversion})
+./gradlew gem
 -----
 
-In the file above:
-
-* Rename the file to correspond to the {plugintype} name.
-* Change the `require_jar` directive to correspond to the `group` specified in the
-Gradle build file, the name of the {plugintype} JAR file, and the version as
-specified in both the gemspec and Gradle build file.
-
-After you have created the previous files and the plugin JAR file, build the gem using the
-following command:
+For Windows platforms: Substitute `gradlew.bat` for `./gradlew` as appropriate in the command.
 
-[source,shell]
-[subs="attributes"]
------
-gem build logstash-{plugintype}-<{plugintype}-name>.gemspec
------
+That task will produce a gem file in the root directory of your
+plugin's codebase with the name `logstash-{plugintype}-<pluginName>-<version>.gem`
 
 [float]
 ==== Installing the Java plugin in Logstash
@@ -131,4 +81,3 @@ bin/logstash-plugin install --no-verify --local /path/to/javaPlugin.gem
 -----
 
 For Windows platforms: Substitute backslashes for forward slashes as appropriate in the command. 
-
diff --git a/docs/static/include/javapluginsetup.asciidoc b/docs/static/include/javapluginsetup.asciidoc
index 02e5d60114c..8a753138fcf 100644
--- a/docs/static/include/javapluginsetup.asciidoc
+++ b/docs/static/include/javapluginsetup.asciidoc
@@ -20,8 +20,8 @@ git clone --branch <branch_name> --single-branch https://github.com/elastic/logs
 The `branch_name` should correspond to the version of Logstash containing the
 preferred revision of the Java plugin API. 
 
-NOTE: The beta version of the Java plugin API is available in the `6.7`
-branch of the Logstash codebase.
+NOTE: The GA version of the Java plugin API is available in the `7.1`
+and later branches of the Logstash codebase.
 
 Specify the `target_folder` for your local copy of the Logstash codebase. If you
 do not specify `target_folder`, it defaults to a new folder called `logstash`
diff --git a/docs/static/java-codec.asciidoc b/docs/static/java-codec.asciidoc
index a68fde22eb7..a1b4ad1441f 100644
--- a/docs/static/java-codec.asciidoc
+++ b/docs/static/java-codec.asciidoc
@@ -20,8 +20,6 @@
 
 === How to write a Java codec plugin
 
-beta[]
-
 NOTE: Java codecs are currently supported only for Java input and output plugins. They will not work with Ruby
 input or output plugins.
 
@@ -51,9 +49,6 @@ public class JavaCodecExample implements Codec {
 
     private final String id;
     private final String delimiter;
-    private final CharsetEncoder encoder;
-    private Event currentEncodedEvent;
-    private CharBuffer currentEncoding;
 
     public JavaCodecExample(final Configuration config, final Context context) {
         this(config.get(DELIMITER_CONFIG));
@@ -62,7 +57,6 @@ public class JavaCodecExample implements Codec {
     private JavaCodecExample(String delimiter) {
         this.id = UUID.randomUUID().toString();
         this.delimiter = delimiter;
-        this.encoder = Charset.defaultCharset().newEncoder();
     }
 
     @Override
@@ -91,30 +85,8 @@ public class JavaCodecExample implements Codec {
     }
 
     @Override
-    public boolean encode(Event event, ByteBuffer buffer) throws EncodeException {
-        try {
-            if (currentEncodedEvent != null && event != currentEncodedEvent) {
-                throw new EncodeException("New event supplied before encoding of previous event was completed");
-            } else if (currentEncodedEvent == null) {
-                currentEncoding = CharBuffer.wrap(event.toString() + delimiter);
-            }
-
-            CoderResult result = encoder.encode(currentEncoding, buffer, true);
-            buffer.flip();
-            if (result.isError()) {
-                result.throwException();
-            }
-
-            if (result.isOverflow()) {
-                currentEncodedEvent = event;
-                return false;
-            } else {
-                currentEncodedEvent = null;
-                return true;
-            }
-        } catch (IOException e) {
-            throw new IllegalStateException(e);
-        }
+    public void encode(Event event, OutputStream outputStream) throws IOException {
+        outputStream.write((event.toString() + delimiter).getBytes(Charset.defaultCharset()));
     }
 
     @Override
@@ -132,6 +104,7 @@ public class JavaCodecExample implements Codec {
     public String getId() {
         return this.id;
     }
+
 }
 -----
 
@@ -154,6 +127,8 @@ Notes about the class declaration:
    an appropriate input or output in the Logstash pipeline defintion as `codec => java_codec_example { }`
 ** The value of the `name` property must match the name of the class excluding casing and underscores.
 * The class must implement the `co.elastic.logstash.api.Codec` interface.
+* Java plugins may not be created in the `org.logstash` or `co.elastic.logstash` packages to prevent potential
+clashes with classes in Logstash itself.
 
 [float]
 ===== Plugin settings
@@ -188,7 +163,6 @@ settings are present and that no unsupported settings are present.
 -----
 private final String id;
 private final String delimiter;
-private final CharsetEncoder encoder;
 
 public JavaCodecExample(final Configuration config, final Context context) {
     this(config.get(DELIMITER_CONFIG));
@@ -197,7 +171,6 @@ public JavaCodecExample(final Configuration config, final Context context) {
 private JavaCodecExample(String delimiter) {
     this.id = UUID.randomUUID().toString();
     this.delimiter = delimiter;
-    this.encoder = Charset.defaultCharset().newEncoder();
 }
 -----
 
@@ -239,36 +212,17 @@ public void decode(ByteBuffer byteBuffer, Consumer<Map<String, Object>> consumer
 
 @Override
 public void flush(ByteBuffer byteBuffer, Consumer<Map<String, Object>> consumer) {
+    // if the codec maintains any internal state such as partially-decoded input, this
+    // method should flush that state along with any additional input supplied in
+    // the ByteBuffer
+
     decode(byteBuffer, consumer); // this is a simplistic implementation
 }
 
 @Override
-public boolean encode(Event event, ByteBuffer buffer) throws EncodeException {
-    try {
-        if (currentEncodedEvent != null && event != currentEncodedEvent) {
-            throw new EncodeException("New event supplied before encoding of previous event was completed");
-        } else if (currentEncodedEvent == null) {
-            currentEncoding = CharBuffer.wrap(event.toString() + delimiter);
-        }
-
-        CoderResult result = encoder.encode(currentEncoding, buffer, true);
-        buffer.flip();
-        if (result.isError()) {
-            result.throwException();
-        }
-
-        if (result.isOverflow()) {
-            currentEncodedEvent = event;
-            return false;
-        } else {
-            currentEncodedEvent = null;
-            return true;
-        }
-    } catch (IOException e) {
-        throw new IllegalStateException(e);
-    }
+public void encode(Event event, OutputStream outputStream) throws IOException {
+    outputStream.write((event.toString() + delimiter).getBytes(Charset.defaultCharset()));
 }
-
 -----
 
 The `decode`, `flush`, and `encode` methods provide the core functionality of
@@ -285,7 +239,7 @@ responsible for returning the buffer to write mode via either
 `byteBuffer.clear()` or `byteBuffer.compact()` before resuming writes. In the
 example above, the `decode` method simply splits the incoming byte stream on the
 specified delimiter. A production-grade codec such as
-https://github.com/elastic/logstash/blob/6.7/logstash-core/src/main/java/org/logstash/plugins/codecs/Line.java[`java-line`]
+https://github.com/elastic/logstash/blob/master/logstash-core/src/main/java/org/logstash/plugins/codecs/Line.java[`java-line`]
 would not make the simplifying assumption that the end of the supplied byte
 stream corresponded with the end of an  event.
 
@@ -307,25 +261,9 @@ above is a simplistic implementation that does not maintain any state about
 partially-supplied byte streams across calls to `decode`.
 
 The `encode` method encodes an event into a sequence of bytes and writes it into
-the specified `ByteBuffer`. Under  ideal circumstances, the entirety of the
-event's encoding will fit into the supplied buffer. In cases where the buffer
-has insufficient space to hold the event's encoding, the codec must fill the
-buffer with as much of the event's encoding as possible, the `encode` must
-return `false`, and the output must call the `encode` method with the same event
-and a buffer that has more `buffer.remaining()` bytes. The output typically does
-that by draining the partial encoding from the supplied buffer. This process
-must be repeated until the event's entire encoding is written to the buffer at
-which point the `encode` method will return `true`. Attempting to call this
-method with a new event before the entirety of the previous event's encoding has
-been written to a buffer must result in an `EncodeException`. As the coneptual
-inverse of the `decode` method, the `encode` method must return the buffer in a
-state from which it can be read, typically by calling `buffer.flip()` before
-returning. In the example above, the `encode` method attempts to write the
-event's encoding to the supplied buffer. If the buffer contains sufficient free
-space, the entirety of the event is written and `true` is returned. Otherwise,
-the method writes as much of the event's encoding to the buffer as possible,
-returns `false`, and stores the remainder to be written to the buffer in the
-next call to the `encode` method.
+the specified `OutputStream`. Because a single codec instance is shared across
+all pipeline workers in the output stage of the Logstash pipeline, codecs should
+_not_ retain state across calls to their `encode` methods.
 
 [float]
 ==== cloneCodec method
@@ -376,11 +314,11 @@ To test the plugin, start Logstash with:
 
 [source,java]
 -----
-echo "foo,bar" | bin/logstash --java-execution -e 'input { java_stdin { codec => java_codec_example } } }'
+echo "foo,bar" | bin/logstash -e 'input { java_stdin { codec => java_codec_example } } }'
 -----
 
-NOTE: The `--java-execution` flag to enable the Java execution engine is required as Java plugins are not supported
-in the Ruby execution engine.
+NOTE: The Java execution engine, the default execution engine since Logstash 7.0, is required
+as Java plugins are not supported in the Ruby execution engine.
 
 The expected Logstash output (excluding initialization) with the configuration above is:
 
diff --git a/docs/static/java-filter.asciidoc b/docs/static/java-filter.asciidoc
index e2d2a05b089..e526c93ef03 100644
--- a/docs/static/java-filter.asciidoc
+++ b/docs/static/java-filter.asciidoc
@@ -14,8 +14,6 @@
 [[java-filter-plugin]]
 === How to write a Java filter plugin
 
-beta[]
-
 // Pulls in shared section: Setting Up Environment
 include::include/javapluginsetup.asciidoc[]
 
@@ -86,6 +84,8 @@ Notes about the class declaration:
    Logstash pipeline defintion as `filter { java_filter_example => { .... } }`
 ** The value of the `name` property must match the name of the class excluding casing and underscores.
 * The class must implement the `co.elastic.logstash.api.Filter` interface.
+* Java plugins may not be created in the `org.logstash` or `co.elastic.logstash` packages to prevent potential
+clashes with classes in Logstash itself.
 
 [float]
 ==== Plugin settings
@@ -248,11 +248,11 @@ Start Logstash with:
 
 [source,shell]
 -----
-bin/logstash --java-execution -f /path/to/java_filter.conf
+bin/logstash -f /path/to/java_filter.conf
 -----
 
-NOTE: The `--java-execution` flag to enable the Java execution engine is
-required as Java plugins are not supported in the Ruby execution engine.
+NOTE: The Java execution engine, the default execution engine since Logstash 7.0, is required
+as Java plugins are not supported in the Ruby execution engine.
 
 The expected Logstash output (excluding initialization) with the configuration
 above is:
diff --git a/docs/static/java-input.asciidoc b/docs/static/java-input.asciidoc
index 06815c540ee..0f99b7ed3fe 100644
--- a/docs/static/java-input.asciidoc
+++ b/docs/static/java-input.asciidoc
@@ -13,8 +13,6 @@
 [[java-input-plugin]]
 === How to write a Java input plugin
 
-beta[]
-
 // Pulls in shared section: Setting Up Environment
 include::include/javapluginsetup.asciidoc[]
 
@@ -104,6 +102,8 @@ Notes about the class declaration:
    Logstash pipeline defintion as `input { java_input_example => { .... } }`
 ** The value of the `name` property must match the name of the class excluding casing and underscores.
 * The class must implement the `co.elastic.logstash.api.Input` interface.
+* Java plugins may not be created in the `org.logstash` or `co.elastic.logstash` packages to prevent potential
+clashes with classes in Logstash itself.
 
 [float]
 ==== Plugin settings
@@ -274,11 +274,11 @@ Start {ls} with:
 
 [source,shell]
 -----
-bin/logstash --java-execution -f /path/to/java_input.conf
+bin/logstash -f /path/to/java_input.conf
 -----
 
-NOTE: The `--java-execution` flag to enable the Java execution engine is
-required as Java plugins are not supported in the Ruby execution engine.
+NOTE: The Java execution engine, the default execution engine since Logstash 7.0, is required
+as Java plugins are not supported in the Ruby execution engine.
 
 The expected Logstash output (excluding initialization) with the configuration above is:
 
diff --git a/docs/static/java-output.asciidoc b/docs/static/java-output.asciidoc
index 15e57816d62..67de9344ae1 100644
--- a/docs/static/java-output.asciidoc
+++ b/docs/static/java-output.asciidoc
@@ -15,8 +15,6 @@
 [[java-output-plugin]]
 === How to write a Java output plugin
 
-beta[]
-
 // Pulls in shared section: Setting Up Environment
 include::include/javapluginsetup.asciidoc[]
 
@@ -101,6 +99,8 @@ Notes about the class declaration:
    Logstash pipeline definition as `output { java_output_example => { .... } }`
 ** The value of the `name` property must match the name of the class excluding casing and underscores.
 * The class must implement the `co.elastic.logstash.api.Output` interface.
+* Java plugins may not be created in the `org.logstash` or `co.elastic.logstash` packages to prevent potential
+clashes with classes in Logstash itself.
 
 [float]
 ==== Plugin settings
@@ -258,11 +258,11 @@ Logstash should then be started with:
 
 [source,txt]
 -----
-bin/logstash --java-execution -f /path/to/java_output.conf
+bin/logstash -f /path/to/java_output.conf
 -----
 
-NOTE: The `--java-execution` flag to enable the Java execution engine is
-required as Java plugins are not supported in the Ruby execution engine.
+NOTE: The Java execution engine, the default execution engine since Logstash 7.0, is required
+as Java plugins are not supported in the Ruby execution engine.
 
 The expected Logstash output (excluding initialization) with the configuration
 above is:
diff --git a/docs/static/running-logstash-command-line.asciidoc b/docs/static/running-logstash-command-line.asciidoc
index 876a82d5f3e..b5cd5219a7e 100644
--- a/docs/static/running-logstash-command-line.asciidoc
+++ b/docs/static/running-logstash-command-line.asciidoc
@@ -72,6 +72,9 @@ With this command, Logstash concatenates three config files, `/tmp/one`, `/tmp/t
   Specify `false` for this option to revert to the legacy Ruby execution engine instead
   of the default Java execution engine.
 
+*`--plugin-classloaders`*::
+  (Beta) Load Java plugins in independent classloaders to isolate their dependencies.
+
 *`--modules`*::
   Launch the named module.  Works in conjunction with the `-M` option to assign values to
   default variables for the specified module.  If `--modules` is used on the command line,
diff --git a/docs/static/settings-file.asciidoc b/docs/static/settings-file.asciidoc
index 837741b6d8d..df14f9d9618 100644
--- a/docs/static/settings-file.asciidoc
+++ b/docs/static/settings-file.asciidoc
@@ -110,6 +110,10 @@ The `logstash.yml` file includes the following settings. If you are using X-Pack
   have been pushed to the outputs. Enabling this option can lead to data loss during shutdown.
 | `false`
 
+| `pipeline.plugin_classloaders`
+| (Beta) Load Java plugins in independent classloaders to isolate their dependencies.
+| `false`
+
 | `path.config`
 | The path to the Logstash config for the main pipeline. If you specify a directory or wildcard,
   config files are read from the directory in alphabetical order.
diff --git a/logstash-core/lib/logstash/environment.rb b/logstash-core/lib/logstash/environment.rb
index bf70f776259..31df098fafc 100644
--- a/logstash-core/lib/logstash/environment.rb
+++ b/logstash-core/lib/logstash/environment.rb
@@ -43,6 +43,7 @@ module Environment
            Setting::Boolean.new("pipeline.unsafe_shutdown", false),
            Setting::Boolean.new("pipeline.java_execution", true),
            Setting::Boolean.new("pipeline.reloadable", true),
+           Setting::Boolean.new("pipeline.plugin_classloaders", false),
                     Setting.new("path.plugins", Array, []),
     Setting::NullableString.new("interactive", nil, false),
            Setting::Boolean.new("config.debug", false),
diff --git a/logstash-core/lib/logstash/pipeline_settings.rb b/logstash-core/lib/logstash/pipeline_settings.rb
index 95ec76ad16a..9fabab3a7fe 100644
--- a/logstash-core/lib/logstash/pipeline_settings.rb
+++ b/logstash-core/lib/logstash/pipeline_settings.rb
@@ -15,6 +15,7 @@ class PipelineSettings < Settings
       "dead_letter_queue.max_bytes",
       "metric.collect",
       "pipeline.java_execution",
+      "pipeline.plugin_classloaders",
       "path.config",
       "path.dead_letter_queue",
       "path.queue",
diff --git a/logstash-core/lib/logstash/plugins/registry.rb b/logstash-core/lib/logstash/plugins/registry.rb
index 161354799e7..8c7435632c0 100644
--- a/logstash-core/lib/logstash/plugins/registry.rb
+++ b/logstash-core/lib/logstash/plugins/registry.rb
@@ -105,6 +105,7 @@ def initialize
       # but it is the case that we can call lookups from multiple threads,
       # when multiple pipelines are in play, and that a lookup may modify the registry.
       @registry = java.util.concurrent.ConcurrentHashMap.new
+      @java_plugins = java.util.concurrent.ConcurrentHashMap.new
       @hooks = HooksRegistry.new
     end
 
@@ -133,6 +134,15 @@ def load_available_plugins
       require "logstash/plugins/builtin"
 
       GemRegistry.logstash_plugins.each do |plugin_context|
+        if plugin_context.spec.metadata.key?('java_plugin')
+          jar_files = plugin_context.spec.files.select {|f| f =~ /.*\.jar/}
+          expected_jar_name = plugin_context.spec.name + "-" + plugin_context.spec.version.to_s + ".jar"
+          if (jar_files.length != 1 || !jar_files[0].end_with?(expected_jar_name))
+            raise LoadError, "Java plugin '#{plugin_context.spec.name}' does not contain a single jar file with the plugin's name and version"
+          end
+          @java_plugins[plugin_context.spec.name] = [plugin_context.spec.loaded_from, jar_files[0]]
+        end
+
         # When a plugin has a HOOK_FILE defined, its the responsibility of the plugin
         # to register itself to the registry of available plugins.
         #
@@ -262,13 +272,31 @@ def namespace_lookup(type, name)
     # @param name [String] plugin name
     # @return [Boolean] true if klass is a valid plugin for name
     def is_a_plugin?(klass, name)
+      (klass.class == Java::JavaLang::Class && klass.simple_name.downcase == name.gsub('_','')) ||
       (klass.class == Java::JavaClass && klass.simple_name.downcase == name.gsub('_','')) ||
       (klass.ancestors.include?(LogStash::Plugin) && klass.respond_to?(:config_name) && klass.config_name == name)
     end
 
     def add_plugin(type, name, klass)
       if klass.respond_to?("javaClass", true)
-        @registry[key_for(type, name)] = PluginSpecification.new(type, name, klass.javaClass)
+        if LogStash::SETTINGS.get_value('pipeline.plugin_classloaders')
+          full_name = 'logstash-' + key_for(type, name)
+          if @java_plugins.key?(full_name)
+            plugin_paths = @java_plugins[full_name]
+          else
+            raise LoadError,  "Could not find metadata for Java plugin: #{full_name}"
+          end
+
+          java_import org.logstash.plugins.PluginClassLoader
+          java_import org.logstash.Logstash
+
+          classloader = PluginClassLoader.create(plugin_paths[0], plugin_paths[1], Logstash.java_class.class_loader)
+          klazz = classloader.load_class(klass.javaClass.name)
+
+          @registry[key_for(type, name)] = PluginSpecification.new(type, name, klazz.ruby_class.java_class)
+        else
+          @registry[key_for(type, name)] = PluginSpecification.new(type, name, klass.javaClass)
+        end
       elsif !exists?(type, name)
         specification_klass = type == :universal ? UniversalPluginSpecification : PluginSpecification
         @registry[key_for(type, name)] = specification_klass.new(type, name, klass)
diff --git a/logstash-core/lib/logstash/runner.rb b/logstash-core/lib/logstash/runner.rb
index f03ac07c418..45e7fb2316f 100644
--- a/logstash-core/lib/logstash/runner.rb
+++ b/logstash-core/lib/logstash/runner.rb
@@ -113,6 +113,11 @@ class LogStash::Runner < Clamp::StrictCommand
          :attribute_name => "pipeline.java_execution",
          :default => LogStash::SETTINGS.get_default("pipeline.java_execution")
 
+  option ["--plugin-classloaders"], :flag,
+         I18n.t("logstash.runner.flag.plugin-classloaders"),
+         :attribute_name => "pipeline.plugin_classloaders",
+         :default => LogStash::SETTINGS.get_default("pipeline.plugin_classloaders")
+
   option ["-b", "--pipeline.batch.size"], "SIZE",
     I18n.t("logstash.runner.flag.pipeline-batch-size"),
     :attribute_name => "pipeline.batch.size",
diff --git a/logstash-core/locales/en.yml b/logstash-core/locales/en.yml
index 7ff23e787c8..b162808dfab 100644
--- a/logstash-core/locales/en.yml
+++ b/logstash-core/locales/en.yml
@@ -290,6 +290,8 @@ en:
           Sets the number of pipeline workers to run.
         java-execution: |+
           Use Java execution engine.
+        plugin-classloaders: |+
+          (Beta) Load Java plugins in independent classloaders to isolate their dependencies.
         pipeline-batch-size: |+
           Size of batches the pipeline is to work in.
         pipeline-batch-delay: |+
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/Codec.java b/logstash-core/src/main/java/co/elastic/logstash/api/Codec.java
index dba0d201d6d..aa5e18dbb24 100644
--- a/logstash-core/src/main/java/co/elastic/logstash/api/Codec.java
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/Codec.java
@@ -1,6 +1,7 @@
 package co.elastic.logstash.api;
 
-import java.nio.Buffer;
+import java.io.IOException;
+import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.util.Map;
 import java.util.function.Consumer;
@@ -43,28 +44,11 @@ public interface Codec extends Plugin {
     void flush(ByteBuffer buffer, Consumer<Map<String, Object>> eventConsumer);
 
     /**
-     * Encodes an {@link Event} and writes it into the specified {@link ByteBuffer}. Under ideal
-     * circumstances, the entirety of the event's encoding will fit into the supplied buffer. In cases
-     * where the buffer has insufficient space to hold the event's encoding, the buffer will be filled
-     * with as much of the event's encoding as possible, {@code false} will be returned, and the caller
-     * must call this method with the same event and a buffer that has more {@link Buffer#remaining()}
-     * bytes. That is typically done by draining the partial encoding from the supplied buffer. This
-     * process must be repeated until the event's entire encoding is written to the buffer at which
-     * point the method will return {@code true}. Attempting to call this method with a new event
-     * before the entirety of the previous event's encoding has been written to a buffer will result
-     * in an {@link EncodeException}.
-     *
-     * @param event  The event to encode.
-     * @param buffer The buffer into which the encoding of the event should be written. Codec
-     *               implementations are responsible for returning the buffer in a state from which it
-     *               can be read, typically by calling {@link Buffer#flip()} before returning.
-     * @return {@code true} if the entirety or final segment of the event's encoding was written to
-     * the buffer. {@code false} if the buffer was incapable of holding the entirety or remainder of the
-     * event's encoding.
-     * @throws EncodeException if called with a new event before the entirety of the previous event's
-     * encoding was written to a buffer.
+     * Encodes an {@link Event} and writes it to the specified {@link OutputStream}.
+     * @param event The event to encode.
+     * @param output The stream to which the encoded event should be written.
      */
-    boolean encode(Event event, ByteBuffer buffer) throws EncodeException;
+    void encode(Event event, OutputStream output) throws IOException;
 
     /**
      * Clones this {@link Codec}. All codecs should be capable of cloning themselves
@@ -74,13 +58,4 @@ public interface Codec extends Plugin {
      */
     Codec cloneCodec();
 
-    class EncodeException extends Exception {
-
-        private static final long serialVersionUID = 1L;
-
-        public EncodeException(String message) {
-            super(message);
-        }
-
-    }
 }
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/Password.java b/logstash-core/src/main/java/co/elastic/logstash/api/Password.java
new file mode 100644
index 00000000000..9cf0e231c74
--- /dev/null
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/Password.java
@@ -0,0 +1,22 @@
+package co.elastic.logstash.api;
+
+/**
+ * Wraps a password string so that it is not inadvertently printed or logged.
+ */
+public class Password {
+
+    private String password;
+
+    public Password(String password) {
+        this.password = password;
+    }
+
+    public String getPassword() {
+        return password;
+    }
+
+    @Override
+    public String toString() {
+        return "<password>";
+    }
+}
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/PluginConfigSpec.java b/logstash-core/src/main/java/co/elastic/logstash/api/PluginConfigSpec.java
index 8d3abaf7a5d..dad40b2731c 100644
--- a/logstash-core/src/main/java/co/elastic/logstash/api/PluginConfigSpec.java
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/PluginConfigSpec.java
@@ -1,5 +1,6 @@
 package co.elastic.logstash.api;
 
+import java.net.URI;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
@@ -83,6 +84,28 @@ public static PluginConfigSpec<Codec> codecSetting(final String name, final Code
         return new PluginConfigSpec<>(name, Codec.class, defaultValue, deprecated, required);
     }
 
+    public static PluginConfigSpec<URI> uriSetting(final String name) {
+        return new PluginConfigSpec<>(
+                name, URI.class, null, false, false
+        );
+    }
+
+    public static PluginConfigSpec<URI> uriSetting(final String name, final String defaultUri) {
+        PluginConfigSpec<URI> pcs = new PluginConfigSpec<>(
+                name, URI.class, null, false, false
+        );
+        pcs.rawDefaultValue = defaultUri;
+        return pcs;
+    }
+
+    public static PluginConfigSpec<URI> uriSetting(final String name, final String defaultUri, boolean deprecated, boolean required) {
+        PluginConfigSpec<URI> pcs = new PluginConfigSpec<>(
+                name, URI.class, null, deprecated, required
+        );
+        pcs.rawDefaultValue = defaultUri;
+        return pcs;
+    }
+
     public static PluginConfigSpec<Long> numSetting(final String name) {
         return new PluginConfigSpec<>(
             name, Long.class, null, false, false
@@ -95,6 +118,14 @@ public static PluginConfigSpec<Long> numSetting(final String name, final long de
         );
     }
 
+    public static PluginConfigSpec<Double> floatSetting(final String name, final double defaultValue) {
+        return new PluginConfigSpec<>(name, Double.class, defaultValue, false, false);
+    }
+
+    public static PluginConfigSpec<Double> floatSetting(final String name, final double defaultValue, boolean deprecated, boolean required) {
+        return new PluginConfigSpec<>(name, Double.class, defaultValue, deprecated, required);
+    }
+
     public static PluginConfigSpec<Long> numSetting(final String name, final long defaultValue, boolean deprecated, boolean required) {
         return new PluginConfigSpec<>(name, Long.class, defaultValue, deprecated, required);
     }
@@ -135,6 +166,20 @@ public static PluginConfigSpec<List<Object>> arraySetting(final String name, Lis
         return new PluginConfigSpec(name, List.class, defaultValue, deprecated, required);
     }
 
+    public static PluginConfigSpec<Password> passwordSetting(final String name) {
+        return new PluginConfigSpec<>(
+                name, Password.class, null, false, false
+        );
+    }
+
+    public static PluginConfigSpec<Password> passwordSetting(final String name, final String defaultValue, boolean deprecated, boolean required) {
+        PluginConfigSpec<Password> pcs = new PluginConfigSpec<>(
+                name, Password.class, null, false, false
+        );
+        pcs.rawDefaultValue = defaultValue;
+        return pcs;
+    }
+
     public Collection<PluginConfigSpec<?>> children() {
         return children;
     }
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaCodecDelegator.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaCodecDelegator.java
index e65ce23ef5f..aff529b8962 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaCodecDelegator.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaCodecDelegator.java
@@ -10,6 +10,8 @@
 import org.logstash.instrument.metrics.MetricKeys;
 import org.logstash.instrument.metrics.counter.LongCounter;
 
+import java.io.IOException;
+import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.util.Collection;
 import java.util.Map;
@@ -89,16 +91,14 @@ public void flush(final ByteBuffer buffer, final Consumer<Map<String, Object>> e
     }
 
     @Override
-    public boolean encode(final Event event, final ByteBuffer buffer) throws EncodeException {
+    public void encode(final Event event, final OutputStream out) throws IOException {
         encodeMetricIn.increment();
 
         final long start = System.nanoTime();
 
-        final boolean ret = codec.encode(event, buffer);
+        codec.encode(event, out);
 
         decodeMetricTime.increment(TimeUnit.MILLISECONDS.convert(System.nanoTime() - start, TimeUnit.NANOSECONDS));
-
-        return ret;
     }
 
     @Override
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaInputDelegatorExt.java b/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaInputDelegatorExt.java
index 6bdcece18c0..4ceb3f5643a 100644
--- a/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaInputDelegatorExt.java
+++ b/logstash-core/src/main/java/org/logstash/config/ir/compiler/JavaInputDelegatorExt.java
@@ -118,6 +118,11 @@ public IRubyObject doStop(final ThreadContext context) {
         return this;
     }
 
+    @JRubyMethod(name = "reloadable?")
+    public IRubyObject isReloadable(final ThreadContext context) {
+        return context.tru;
+    }
+
     @SuppressWarnings("unchecked")
     private void initializeQueueWriter(Map<String, Object> pluginArgs) {
         List<Function<Map<String, Object>, Map<String, Object>>> inputActions = new ArrayList<>();
diff --git a/logstash-core/src/main/java/org/logstash/plugins/ConfigurationImpl.java b/logstash-core/src/main/java/org/logstash/plugins/ConfigurationImpl.java
index 6b802dba13d..7215a4a24c1 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/ConfigurationImpl.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/ConfigurationImpl.java
@@ -1,10 +1,13 @@
 package org.logstash.plugins;
 
 import co.elastic.logstash.api.Configuration;
+import co.elastic.logstash.api.Password;
 import co.elastic.logstash.api.PluginConfigSpec;
 import co.elastic.logstash.api.Codec;
 import org.logstash.config.ir.compiler.RubyIntegration;
 
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.util.Collection;
 import java.util.Map;
 
@@ -39,9 +42,22 @@ public <T> T get(final PluginConfigSpec<T> configSpec) {
             Object o = rawSettings.get(configSpec.name());
             if (configSpec.type().isAssignableFrom(o.getClass())) {
                 return (T) o;
+            } else if (configSpec.type() == Double.class && o.getClass() == Long.class) {
+                return configSpec.type().cast(((Long)o).doubleValue());
             } else if (configSpec.type() == Codec.class && o instanceof String && pluginFactory != null) {
-                Codec codec = pluginFactory.buildDefaultCodec((String)o);
+                Codec codec = pluginFactory.buildDefaultCodec((String) o);
                 return configSpec.type().cast(codec);
+            } else if (configSpec.type() == URI.class && o instanceof String) {
+                try {
+                    URI uri = new URI((String) o);
+                    return configSpec.type().cast(uri);
+                } catch (URISyntaxException ex) {
+                    throw new IllegalStateException(
+                            String.format("Invalid URI specified for '%s'", configSpec.name()));
+                }
+            } else if (configSpec.type() == Password.class && o instanceof String) {
+                Password p = new Password((String) o);
+                return configSpec.type().cast(p);
             } else {
                 throw new IllegalStateException(
                         String.format("Setting value for '%s' of type '%s' incompatible with defined type of '%s'",
@@ -50,6 +66,17 @@ public <T> T get(final PluginConfigSpec<T> configSpec) {
         } else if (configSpec.type() == Codec.class && configSpec.getRawDefaultValue() != null && pluginFactory != null) {
             Codec codec = pluginFactory.buildDefaultCodec(configSpec.getRawDefaultValue());
             return configSpec.type().cast(codec);
+        } else if (configSpec.type() == URI.class && configSpec.getRawDefaultValue() != null) {
+            try {
+                URI uri = new URI(configSpec.getRawDefaultValue());
+                return configSpec.type().cast(uri);
+            } catch (URISyntaxException ex) {
+                throw new IllegalStateException(
+                        String.format("Invalid default URI specified for '%s'", configSpec.name()));
+            }
+        } else if (configSpec.type() == Password.class && configSpec.getRawDefaultValue() != null) {
+            Password p = new Password(configSpec.getRawDefaultValue());
+            return configSpec.type().cast(p);
         } else {
             return configSpec.defaultValue();
         }
@@ -69,5 +96,4 @@ public boolean contains(final PluginConfigSpec<?> configSpec) {
     public Collection<String> allKeys() {
         return rawSettings.keySet();
     }
-
 }
diff --git a/logstash-core/src/main/java/org/logstash/plugins/PluginClassLoader.java b/logstash-core/src/main/java/org/logstash/plugins/PluginClassLoader.java
new file mode 100644
index 00000000000..f728f08764b
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugins/PluginClassLoader.java
@@ -0,0 +1,69 @@
+package org.logstash.plugins;
+
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+/**
+ * Classloader for Java plugins to isolate their dependencies. Will not load any classes in the
+ * <code>co.elastic.logstash</code> or <code>org.logstash</code> packages to avoid the possibility
+ * of clashes with classes in Logstash core.
+ */
+public class PluginClassLoader extends URLClassLoader {
+
+    private ClassLoader appClassLoader;
+
+    private PluginClassLoader(URL[] urls, ClassLoader appClassLoader) {
+        super(urls, null);
+        this.appClassLoader = appClassLoader;
+    }
+
+    /**
+     * Creates an instance of the plugin classloader.
+     * @param gemPath Path to the Ruby gem containing the Java plugin as reported by
+     *                <code>Gem::BasicSpecification#loaded_from</code>.
+     * @param jarPath Path to the Java plugin's JAR file relative to {@code gemPath}.
+     * @param appClassLoader Application classloader to be used for classes not found
+     *                       in the plugin's JAR file.
+     * @return New instance of the plugin classloader.
+     */
+    public static PluginClassLoader create(String gemPath, String jarPath, ClassLoader appClassLoader) {
+        String pluginPath = gemPath.substring(0, gemPath.lastIndexOf(File.separator)) + File.separator + jarPath;
+        Path pluginJar = Paths.get(pluginPath);
+        if (!Files.exists(pluginJar)) {
+            throw new IllegalStateException("PluginClassLoader unable to locate jar file: " + pluginPath);
+        }
+        try {
+            URL[] pluginJarUrl = new URL[]{pluginJar.toUri().toURL()};
+            return new PluginClassLoader(pluginJarUrl, appClassLoader);
+        } catch (MalformedURLException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    @Override
+    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
+        synchronized (getClassLoadingLock(name)) {
+            Class<?> c = findLoadedClass(name);
+            if (!name.startsWith("co.elastic.logstash.") && !name.startsWith("org.logstash.")) {
+                if (c == null) {
+                    try {
+                        c = findClass(name);
+                    } catch (ClassNotFoundException e) {
+                        c = super.loadClass(name, resolve);
+                    }
+                }
+            } else {
+                c = appClassLoader.loadClass(name);
+            }
+            if (resolve) {
+                resolveClass(c);
+            }
+            return c;
+        }
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java b/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java
index 15453c5de6b..db71fde1407 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/PluginFactoryExt.java
@@ -1,8 +1,8 @@
 package org.logstash.plugins;
 
+import co.elastic.logstash.api.Codec;
 import co.elastic.logstash.api.Configuration;
 import co.elastic.logstash.api.Context;
-import co.elastic.logstash.api.Codec;
 import co.elastic.logstash.api.Filter;
 import co.elastic.logstash.api.Input;
 import co.elastic.logstash.api.Output;
@@ -261,6 +261,12 @@ private IRubyObject plugin(final ThreadContext context, final PluginLookup.Plugi
                     return pluginInstance;
                 }
             } else {
+                if (pluginArgs == null) {
+                    String err = String.format("Cannot start the Java plugin '%s' in the Ruby execution engine." +
+                            " The Java execution engine is required to run Java plugins.", name);
+                    throw new IllegalStateException(err);
+                }
+
                 if (type == PluginLookup.PluginType.OUTPUT) {
                     final Class<Output> cls = (Class<Output>) pluginClass.klass();
                     Output output = null;
@@ -271,6 +277,9 @@ private IRubyObject plugin(final ThreadContext context, final PluginLookup.Plugi
                             output = ctor.newInstance(id, config, executionContext.toContext(type));
                             PluginUtil.validateConfig(output, config);
                         } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException ex) {
+                            if (ex instanceof InvocationTargetException && ex.getCause() != null) {
+                                throw new IllegalStateException((ex).getCause());
+                            }
                             throw new IllegalStateException(ex);
                         }
                     }
@@ -290,6 +299,9 @@ private IRubyObject plugin(final ThreadContext context, final PluginLookup.Plugi
                             filter = ctor.newInstance(id, config, executionContext.toContext(type));
                             PluginUtil.validateConfig(filter, config);
                         } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException ex) {
+                            if (ex instanceof InvocationTargetException && ex.getCause() != null) {
+                                throw new IllegalStateException((ex).getCause());
+                            }
                             throw new IllegalStateException(ex);
                         }
                     }
@@ -309,7 +321,7 @@ private IRubyObject plugin(final ThreadContext context, final PluginLookup.Plugi
                             input = ctor.newInstance(id, config, executionContext.toContext(type));
                             PluginUtil.validateConfig(input, config);
                         } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException ex) {
-                            if (ex instanceof InvocationTargetException) {
+                            if (ex instanceof InvocationTargetException && ex.getCause() != null) {
                                 throw new IllegalStateException((ex).getCause());
                             }
                             throw new IllegalStateException(ex);
@@ -331,7 +343,7 @@ private IRubyObject plugin(final ThreadContext context, final PluginLookup.Plugi
                             codec = ctor.newInstance(config, executionContext.toContext(type));
                             PluginUtil.validateConfig(codec, config);
                         } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException ex) {
-                            if (ex instanceof InvocationTargetException) {
+                            if (ex instanceof InvocationTargetException && ex.getCause() != null) {
                                 throw new IllegalStateException((ex).getCause());
                             }
                             throw new IllegalStateException(ex);
diff --git a/logstash-core/src/main/java/org/logstash/plugins/PluginLookup.java b/logstash-core/src/main/java/org/logstash/plugins/PluginLookup.java
index ef946c065cc..73137bbc24e 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/PluginLookup.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/PluginLookup.java
@@ -2,6 +2,7 @@
 
 import org.jruby.RubyClass;
 import org.jruby.RubyString;
+import org.jruby.java.proxies.JavaProxy;
 import org.jruby.javasupport.JavaClass;
 import org.jruby.runtime.builtin.IRubyObject;
 import org.logstash.RubyUtil;
@@ -24,8 +25,13 @@ private PluginLookup() {
 
     @SuppressWarnings("rawtypes")
     public static PluginLookup.PluginClass lookup(final PluginLookup.PluginType type, final String name) {
-        Class javaClass = PluginRegistry.getPluginClass(type, name);
+        Class<?> javaClass = PluginRegistry.getPluginClass(type, name);
         if (javaClass != null) {
+
+            if (!PluginValidator.validatePlugin(type, javaClass)) {
+                throw new IllegalStateException("Java plugin '" + name + "' is incompatible with the current Logstash plugin API");
+            }
+
             return new PluginLookup.PluginClass() {
 
                 @Override
@@ -48,10 +54,16 @@ public Object klass() {
                     ? PluginLanguage.RUBY
                     : PluginLanguage.JAVA;
 
+            klass = (klass instanceof JavaProxy) ? ((JavaProxy) klass).getObject() : klass;
+
             Object resolvedClass = klass instanceof JavaClass
                     ? ((JavaClass) klass).javaClass()
                     : klass;
 
+            if (language == PluginLanguage.JAVA && !PluginValidator.validatePlugin(type, (Class) resolvedClass)) {
+                throw new IllegalStateException("Java plugin '" + name + "' is incompatible with the current Logstash plugin API");
+            }
+
             return new PluginLookup.PluginClass() {
                 @Override
                 public PluginLookup.PluginLanguage language() {
diff --git a/logstash-core/src/main/java/org/logstash/plugins/PluginValidator.java b/logstash-core/src/main/java/org/logstash/plugins/PluginValidator.java
new file mode 100644
index 00000000000..5011169a38a
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugins/PluginValidator.java
@@ -0,0 +1,57 @@
+package org.logstash.plugins;
+
+import co.elastic.logstash.api.Codec;
+import co.elastic.logstash.api.Filter;
+import co.elastic.logstash.api.Input;
+import co.elastic.logstash.api.Output;
+
+import java.lang.reflect.Method;
+import java.util.Arrays;
+
+/**
+ * Validates that Java plugins support the Java plugin API in this release of Logstash.
+ */
+public class PluginValidator {
+
+    private static final Method[] inputMethods;
+    private static final Method[] filterMethods;
+    private static final Method[] codecMethods;
+    private static final Method[] outputMethods;
+
+    static {
+        inputMethods = Input.class.getMethods();
+        filterMethods = Filter.class.getMethods();
+        codecMethods = Codec.class.getMethods();
+        outputMethods = Output.class.getMethods();
+    }
+
+    public static boolean validatePlugin(PluginLookup.PluginType type, Class<?> pluginClass) {
+        switch (type) {
+            case INPUT:
+                return containsAllMethods(inputMethods, pluginClass.getMethods());
+            case FILTER:
+                return containsAllMethods(filterMethods, pluginClass.getMethods());
+            case CODEC:
+                return containsAllMethods(codecMethods, pluginClass.getMethods());
+            case OUTPUT:
+                return containsAllMethods(outputMethods, pluginClass.getMethods());
+            default:
+                throw new IllegalStateException("Unknown plugin type for validation: " + type);
+        }
+    }
+
+    private static boolean containsAllMethods(Method[] apiMethods, Method[] pluginMethods) {
+        boolean matches = true;
+        for (int k = 0; matches && k < apiMethods.length; k++) {
+            int finalK = k;
+            matches = Arrays.stream(pluginMethods).anyMatch(m -> methodsMatch(apiMethods[finalK], m));
+        }
+        return matches;
+    }
+
+    private static boolean methodsMatch(Method apiMethod, Method pluginMethod) {
+        return apiMethod.getName().equals(pluginMethod.getName()) &&
+                apiMethod.getReturnType() == pluginMethod.getReturnType() &&
+                Arrays.equals(apiMethod.getParameterTypes(), pluginMethod.getParameterTypes());
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/codecs/Dots.java b/logstash-core/src/main/java/org/logstash/plugins/codecs/Dots.java
new file mode 100644
index 00000000000..8430d9496c5
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugins/codecs/Dots.java
@@ -0,0 +1,61 @@
+package org.logstash.plugins.codecs;
+
+import co.elastic.logstash.api.Codec;
+import co.elastic.logstash.api.Configuration;
+import co.elastic.logstash.api.Context;
+import co.elastic.logstash.api.Event;
+import co.elastic.logstash.api.LogstashPlugin;
+import co.elastic.logstash.api.PluginConfigSpec;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Map;
+import java.util.UUID;
+import java.util.function.Consumer;
+
+@LogstashPlugin(name = "jdots")
+public class Dots implements Codec {
+
+    private final String id;
+
+    public Dots(final Configuration configuration, final Context context) {
+        this();
+    }
+
+    private Dots() {
+        this.id = UUID.randomUUID().toString();
+    }
+
+    @Override
+    public void decode(ByteBuffer buffer, Consumer<Map<String, Object>> eventConsumer) {
+        throw new UnsupportedOperationException("Cannot decode with the jdots codec");
+    }
+
+    @Override
+    public void flush(ByteBuffer buffer, Consumer<Map<String, Object>> eventConsumer) {
+    }
+
+    @Override
+    public void encode(Event event, OutputStream out) throws IOException {
+        out.write('.');
+        out.flush();
+    }
+
+    @Override
+    public Codec cloneCodec() {
+        return new Dots();
+    }
+
+    @Override
+    public Collection<PluginConfigSpec<?>> configSchema() {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/codecs/Line.java b/logstash-core/src/main/java/org/logstash/plugins/codecs/Line.java
index 30555c1abf0..5d52b2f09e5 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/codecs/Line.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/codecs/Line.java
@@ -9,12 +9,12 @@
 import org.logstash.StringInterpolation;
 
 import java.io.IOException;
+import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.charset.CharacterCodingException;
 import java.nio.charset.Charset;
 import java.nio.charset.CharsetDecoder;
-import java.nio.charset.CharsetEncoder;
 import java.nio.charset.CoderResult;
 import java.nio.charset.CodingErrorAction;
 import java.util.Arrays;
@@ -52,12 +52,8 @@ public class Line implements Codec {
 
     private final CharBuffer charBuffer = ByteBuffer.allocateDirect(64 * 1024).asCharBuffer();
     private final CharsetDecoder decoder;
-    private final CharsetEncoder encoder;
     private String remainder = "";
 
-    private Event currentEncodedEvent;
-    private CharBuffer currentEncoding;
-
     /**
      * Required constructor.
      *
@@ -76,7 +72,6 @@ private Line(Context context, String delimiter, String charsetName, String forma
         this.format = format;
         decoder = charset.newDecoder();
         decoder.onMalformedInput(CodingErrorAction.IGNORE);
-        encoder = charset.newEncoder();
     }
 
     @Override
@@ -125,34 +120,12 @@ public void flush(ByteBuffer buffer, Consumer<Map<String, Object>> eventConsumer
     }
 
     @Override
-    public boolean encode(Event event, ByteBuffer buffer) throws EncodeException {
-        try {
-            if (currentEncodedEvent != null && event != currentEncodedEvent) {
-                throw new EncodeException("New event supplied before encoding of previous event was completed");
-            } else if (currentEncodedEvent == null) {
-                String eventEncoding = (format == null
-                        ? JSON_MAPPER.writeValueAsString(event.getData())
-                        : StringInterpolation.evaluate(event, format))
-                        + delimiter;
-                currentEncoding = CharBuffer.wrap(eventEncoding);
-            }
-
-            CoderResult result = encoder.encode(currentEncoding, buffer, true);
-            buffer.flip();
-            if (result.isError()) {
-                result.throwException();
-            }
-
-            if (result.isOverflow()) {
-                currentEncodedEvent = event;
-                return false;
-            } else {
-                currentEncodedEvent = null;
-                return true;
-            }
-        } catch (IOException e) {
-            throw new IllegalStateException(e);
-        }
+    public void encode(Event event, OutputStream output) throws IOException {
+        String outputString = (format == null
+                ? JSON_MAPPER.writeValueAsString(event.getData())
+                : StringInterpolation.evaluate(event, format))
+                + delimiter;
+        output.write(outputString.getBytes(charset));
     }
 
     private Map<String, Object> simpleMap(String message) {
diff --git a/logstash-core/src/main/java/org/logstash/plugins/inputs/Generator.java b/logstash-core/src/main/java/org/logstash/plugins/inputs/Generator.java
new file mode 100644
index 00000000000..25cd596d7be
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugins/inputs/Generator.java
@@ -0,0 +1,197 @@
+package org.logstash.plugins.inputs;
+
+import co.elastic.logstash.api.Configuration;
+import co.elastic.logstash.api.Context;
+import co.elastic.logstash.api.Input;
+import co.elastic.logstash.api.LogstashPlugin;
+import co.elastic.logstash.api.PluginConfigSpec;
+import co.elastic.logstash.api.PluginHelper;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+
+@LogstashPlugin(name = "java_generator")
+public class Generator implements Input {
+
+    public static final PluginConfigSpec<Long> COUNT_CONFIG =
+            PluginConfigSpec.numSetting("count", 0);
+    public static final PluginConfigSpec<List<Object>> LINES_CONFIG =
+            PluginConfigSpec.arraySetting("lines");
+    public static final PluginConfigSpec<String> MESSAGE_CONFIG =
+            PluginConfigSpec.stringSetting("message", "Hello world!");
+    public static final PluginConfigSpec<Long> THREADS_CONFIG =
+            PluginConfigSpec.numSetting("threads", 1);
+    public static final PluginConfigSpec<Double> EPS_CONFIG =
+            PluginConfigSpec.floatSetting("eps", 0);
+
+    private final String hostname;
+    private final long count;
+    private final double eps;
+    private String id;
+    private long threads;
+    private volatile boolean stopRequested = false;
+    private final CountDownLatch countDownLatch;
+    private String[] lines;
+    private int[] linesIndex;
+    private long[] sequence;
+    private ScheduledFuture<?>[] futures;
+    private List<Map<String, Object>> events;
+
+    /**
+     * Required constructor.
+     *
+     * @param id            Plugin id
+     * @param configuration Logstash Configuration
+     * @param context       Logstash Context
+     */
+    public Generator(final String id, final Configuration configuration, final Context context) {
+        this.id = id;
+        this.count = configuration.get(COUNT_CONFIG);
+        this.eps = configuration.get(EPS_CONFIG);
+        this.threads = configuration.get(THREADS_CONFIG);
+        if (this.threads < 1) {
+            throw new IllegalStateException("May not specify fewer than one generator thread");
+        }
+        this.countDownLatch = new CountDownLatch((int) threads);
+
+        String host;
+        try {
+            host = InetAddress.getLocalHost().getHostName();
+        } catch (UnknownHostException e) {
+            host = "[unknownHost]";
+        }
+        this.hostname = host;
+
+        // specifying "lines" will override "message"
+        List<Object> linesConfig = configuration.get(LINES_CONFIG);
+        if (linesConfig != null) {
+            lines = new String[linesConfig.size()];
+            for (int k = 0; k < linesConfig.size(); k++) {
+                lines[k] = (String) linesConfig.get(k);
+            }
+
+        } else {
+            lines = new String[]{configuration.get(MESSAGE_CONFIG)};
+        }
+    }
+
+    @Override
+    public void start(Consumer<Map<String, Object>> writer) {
+        if (eps > 0) {
+            startThrottledGenerator(writer);
+        } else {
+            startUnthrottledGenerator(writer);
+        }
+    }
+
+    private void startUnthrottledGenerator(Consumer<Map<String, Object>> writer) {
+        sequence = new long[(int) threads];
+        events = new ArrayList<>();
+        linesIndex = new int[(int) threads];
+
+        for (int k = 0; k < threads; k++) {
+            Map<String, Object> event = new HashMap<>();
+            event.put("hostname", hostname);
+            event.put("thread_number", k);
+            events.add(event);
+            if (k > 0) {
+                final int finalK = k;
+                Thread t = new Thread(() -> {
+                    while (runGenerator(writer, finalK, () -> countDownLatch.countDown())) {
+                    }
+                });
+                t.setName("generator_" + getId() + "_" + k);
+                t.start();
+            }
+        }
+
+        // run first generator on this thread
+        while (runGenerator(writer, 0, () -> countDownLatch.countDown())) {}
+    }
+
+    private void startThrottledGenerator(Consumer<Map<String, Object>> writer) {
+        ScheduledExecutorService ses = Executors.newScheduledThreadPool((int) threads);
+        int delayMilli = (int) (1000.0 / eps);
+        sequence = new long[(int) threads];
+        futures = new ScheduledFuture<?>[(int) threads];
+        events = new ArrayList<>();
+        linesIndex = new int[(int) threads];
+        for (int k = 0; k < threads; k++) {
+            Map<String, Object> event = new HashMap<>();
+            event.put("hostname", hostname);
+            event.put("thread_number", k);
+            events.add(event);
+            final int finalk = k;
+            futures[k] = ses.scheduleAtFixedRate(() -> runGenerator(writer, finalk, () -> {
+                        countDownLatch.countDown();
+                        futures[finalk].cancel(false);
+                    }),0, delayMilli, TimeUnit.MILLISECONDS);
+        }
+
+        boolean finished = false;
+        while (!stopRequested && !finished) {
+            try {
+                Thread.sleep(1000);
+                boolean allCancelled = true;
+                for (int k = 0; k < threads; k++) {
+                    allCancelled = allCancelled && futures[k].isCancelled();
+                }
+                if (allCancelled) {
+                    finished = true;
+                    ses.shutdownNow();
+                }
+            } catch (InterruptedException ex) {
+                // do nothing
+            }
+        }
+    }
+
+    private boolean runGenerator(Consumer<Map<String, Object>> writer, int thread, Runnable finishAction) {
+        if (stopRequested || ((count > 0) && (sequence[thread] >= count))) {
+            finishAction.run();
+            return false;
+        } else {
+            events.get(thread).put("sequence", sequence[thread]);
+            events.get(thread).put("message", lines[linesIndex[thread]++]);
+            writer.accept(events.get(thread));
+            if (linesIndex[thread] == lines.length) {
+                linesIndex[thread] = 0;
+                sequence[thread]++;
+            }
+            return true;
+        }
+    }
+
+    @Override
+    public void stop() {
+        stopRequested = true;
+    }
+
+    @Override
+    public void awaitStop() throws InterruptedException {
+        countDownLatch.await();
+    }
+
+    @Override
+    public Collection<PluginConfigSpec<?>> configSchema() {
+        return PluginHelper.commonInputSettings(Arrays.asList(COUNT_CONFIG, LINES_CONFIG, MESSAGE_CONFIG,
+                THREADS_CONFIG, EPS_CONFIG));
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/outputs/Sink.java b/logstash-core/src/main/java/org/logstash/plugins/outputs/Sink.java
new file mode 100644
index 00000000000..86fc67981ed
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugins/outputs/Sink.java
@@ -0,0 +1,47 @@
+package org.logstash.plugins.outputs;
+
+import co.elastic.logstash.api.Configuration;
+import co.elastic.logstash.api.Context;
+import co.elastic.logstash.api.Event;
+import co.elastic.logstash.api.LogstashPlugin;
+import co.elastic.logstash.api.Output;
+import co.elastic.logstash.api.PluginConfigSpec;
+import co.elastic.logstash.api.PluginHelper;
+
+import java.util.Collection;
+
+@LogstashPlugin(name = "sink")
+public class Sink implements Output {
+
+
+    private final String id;
+
+    public Sink(final String id, final Configuration configuration, final Context context) {
+        this.id = id;
+    }
+
+    @Override
+    public void output(Collection<Event> events) {
+
+    }
+
+    @Override
+    public void stop() {
+
+    }
+
+    @Override
+    public void awaitStop() throws InterruptedException {
+
+    }
+
+    @Override
+    public Collection<PluginConfigSpec<?>> configSchema() {
+        return PluginHelper.commonOutputSettings();
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/outputs/Stdout.java b/logstash-core/src/main/java/org/logstash/plugins/outputs/Stdout.java
index c124fbf4c15..07e70ad993c 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/outputs/Stdout.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/outputs/Stdout.java
@@ -1,17 +1,16 @@
 package org.logstash.plugins.outputs;
 
+import co.elastic.logstash.api.Codec;
 import co.elastic.logstash.api.Configuration;
 import co.elastic.logstash.api.Context;
 import co.elastic.logstash.api.Event;
 import co.elastic.logstash.api.LogstashPlugin;
+import co.elastic.logstash.api.Output;
 import co.elastic.logstash.api.PluginConfigSpec;
 import co.elastic.logstash.api.PluginHelper;
-import co.elastic.logstash.api.Codec;
-import co.elastic.logstash.api.Output;
 
 import java.io.IOException;
 import java.io.OutputStream;
-import java.nio.ByteBuffer;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.concurrent.CountDownLatch;
@@ -26,7 +25,6 @@ public class Stdout implements Output {
     private OutputStream outputStream;
     private final CountDownLatch done = new CountDownLatch(1);
     private String id;
-    private ByteBuffer encodeBuffer = ByteBuffer.wrap(new byte[16 * 1024]);
 
     /**
      * Required constructor.
@@ -51,17 +49,10 @@ public Stdout(final String id, final Configuration configuration, final Context
     @Override
     public void output(final Collection<Event> events) {
         try {
-            boolean encodeCompleted;
             for (Event e : events) {
-                encodeBuffer.clear();
-                do {
-                    encodeCompleted = codec.encode(e, encodeBuffer);
-                    outputStream.write(encodeBuffer.array(), encodeBuffer.position(), encodeBuffer.limit());
-                    encodeBuffer.clear();
-                }
-                while (!encodeCompleted);
+                codec.encode(e, outputStream);
             }
-        } catch (Codec.EncodeException | IOException ex) {
+        } catch (IOException ex) {
             throw new IllegalStateException(ex);
         }
     }
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/compiler/JavaCodecDelegatorTest.java b/logstash-core/src/test/java/org/logstash/config/ir/compiler/JavaCodecDelegatorTest.java
index aef26ccd380..57ff1c7aacd 100644
--- a/logstash-core/src/test/java/org/logstash/config/ir/compiler/JavaCodecDelegatorTest.java
+++ b/logstash-core/src/test/java/org/logstash/config/ir/compiler/JavaCodecDelegatorTest.java
@@ -9,6 +9,9 @@
 import org.junit.Test;
 import org.mockito.Mockito;
 
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.util.Collection;
 import java.util.Map;
@@ -158,36 +161,32 @@ public void flush(final ByteBuffer buffer, final Consumer<Map<String, Object>> e
     }
 
     @Test
-    public void encodeDelegatesCall() throws Codec.EncodeException {
+    public void encodeDelegatesCall() throws IOException {
         codec = Mockito.spy(new AbstractCodec() {
             @Override
-            public boolean encode(final Event event, final ByteBuffer buffer) {
-                return true;
-            }
+            public void encode(final Event event, final OutputStream out) {}
         });
 
         final JavaCodecDelegator codecDelegator = constructCodecDelegator();
 
         final Event e = new org.logstash.Event();
-        final ByteBuffer b = ByteBuffer.wrap(new byte[] {});
+        final OutputStream out = new ByteArrayOutputStream();
 
-        codecDelegator.encode(e, b);
+        codecDelegator.encode(e, out);
 
-        Mockito.verify(codec, Mockito.times(1)).encode(e, b);
+        Mockito.verify(codec, Mockito.times(1)).encode(e, out);
     }
 
     @Test
-    public void encodeIncrementsEventCount() throws Codec.EncodeException {
+    public void encodeIncrementsEventCount() throws IOException {
         codec = new AbstractCodec() {
             @Override
-            public boolean encode(final Event event, final ByteBuffer buffer) {
-                return true;
-            }
+            public void encode(final Event event, final OutputStream out) {}
         };
 
         final JavaCodecDelegator codecDelegator = constructCodecDelegator();
 
-        codecDelegator.encode(new org.logstash.Event(), ByteBuffer.wrap(new byte[] {}));
+        codecDelegator.encode(new org.logstash.Event(), new ByteArrayOutputStream());
 
         assertEquals(1, getMetricLongValue("encode", "writes_in"));
     }
@@ -216,7 +215,7 @@ public void flush(final ByteBuffer buffer, final Consumer<Map<String, Object>> e
         }
 
         @Override
-        public boolean encode(final Event event, final ByteBuffer buffer) throws EncodeException {
+        public void encode(final Event event, final OutputStream out) throws IOException {
             throw new UnsupportedOperationException();
         }
 
diff --git a/logstash-core/src/test/java/org/logstash/plugins/ConfigurationImplTest.java b/logstash-core/src/test/java/org/logstash/plugins/ConfigurationImplTest.java
index 2a171e2f219..6d30bdda2f6 100644
--- a/logstash-core/src/test/java/org/logstash/plugins/ConfigurationImplTest.java
+++ b/logstash-core/src/test/java/org/logstash/plugins/ConfigurationImplTest.java
@@ -1,12 +1,14 @@
 package org.logstash.plugins;
 
 import co.elastic.logstash.api.Configuration;
+import co.elastic.logstash.api.Password;
 import co.elastic.logstash.api.PluginConfigSpec;
 import co.elastic.logstash.api.Codec;
 import org.junit.Assert;
 import org.junit.Test;
 import org.logstash.plugins.codecs.Line;
 
+import java.net.URI;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
@@ -105,5 +107,85 @@ public void testDefaultCodec() {
         Assert.assertTrue(codec instanceof Line);
     }
 
-}
+    @Test
+    public void testDowncastFromLongToDouble() {
+        long defaultValue = 1L;
+        PluginConfigSpec<Double> doubleConfig = PluginConfigSpec.floatSetting(numberKey, defaultValue, false, false);
+        Configuration config = new ConfigurationImpl(Collections.singletonMap(numberKey, defaultValue));
+        double x = config.get(doubleConfig);
+        Assert.assertEquals(defaultValue, x, 0.001);
+    }
+
+    @Test
+    public void testUriValue() {
+        String defaultUri = "https://user:password@www.site.com:99";
+        String uri = "https://user:password@www.site2.com:99";
+        PluginConfigSpec<URI> uriConfig = PluginConfigSpec.uriSetting("test", defaultUri);
+        Configuration config = new ConfigurationImpl(Collections.singletonMap("test", uri));
+        URI u = config.get(uriConfig);
+        Assert.assertEquals(uri, u.toString());
+    }
+
+    @Test
+    public void testUriDefaultValue() {
+        String defaultUri = "https://user:password@www.site.com:99";
+        PluginConfigSpec<URI> uriConfig = PluginConfigSpec.uriSetting("test", defaultUri);
+        Configuration config = new ConfigurationImpl(Collections.emptyMap());
+        URI u = config.get(uriConfig);
+        Assert.assertEquals(defaultUri, u.toString());
+    }
+
+    @Test
+    public void testBadUriThrows() {
+        String uri = "http://www.si%%te.com";
+        PluginConfigSpec<URI> uriConfig = PluginConfigSpec.uriSetting("test", uri);
+        Configuration config = new ConfigurationImpl(Collections.singletonMap("test", uri));
+        try {
+            config.get(uriConfig);
+            Assert.fail("Did not catch invalid URI");
+        } catch (IllegalStateException e1) {
+            Assert.assertTrue(e1.getMessage().contains("Invalid URI specified for"));
+        } catch (Exception e2) {
+            Assert.fail("Did not throw correct exception for invalid URI");
+        }
+    }
+
+    @Test
+    public void testBadDefaultUriThrows() {
+        String uri = "http://www.si%%te.com";
+        PluginConfigSpec<URI> uriConfig = PluginConfigSpec.uriSetting("test", uri);
+        Configuration config = new ConfigurationImpl(Collections.emptyMap());
+        try {
+            config.get(uriConfig);
+            Assert.fail("Did not catch invalid URI");
+        } catch (IllegalStateException e1) {
+            Assert.assertTrue(e1.getMessage().contains("Invalid default URI specified for"));
+        } catch (Exception e2) {
+            Assert.fail("Did not throw correct exception for invalid URI");
+        }
+    }
 
+    @Test
+    public void testPassword() {
+        String myPassword = "mysecret";
+        PluginConfigSpec<Password> passwordConfig = PluginConfigSpec.passwordSetting("passwordTest");
+        Configuration config = new ConfigurationImpl(Collections.singletonMap("passwordTest", myPassword));
+        Password p = config.get(passwordConfig);
+        Assert.assertEquals(Password.class, p.getClass());
+        Assert.assertEquals(myPassword, p.getPassword());
+        Assert.assertEquals("<password>", p.toString());
+    }
+
+    @Test
+    public void testPasswordDefaultValue() {
+        // default values for passwords are a bad idea, but they should still work
+        String myPassword = "mysecret";
+        PluginConfigSpec<Password> passwordConfig = PluginConfigSpec.passwordSetting("passwordTest", myPassword, false, false);
+        Configuration config = new ConfigurationImpl(Collections.emptyMap());
+        Password p = config.get(passwordConfig);
+        Assert.assertEquals(Password.class, p.getClass());
+        Assert.assertEquals(myPassword, p.getPassword());
+        Assert.assertEquals("<password>", p.toString());
+    }
+
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugins/PluginValidatorTest.java b/logstash-core/src/test/java/org/logstash/plugins/PluginValidatorTest.java
new file mode 100644
index 00000000000..68e22563eed
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugins/PluginValidatorTest.java
@@ -0,0 +1,69 @@
+package org.logstash.plugins;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.logstash.plugins.codecs.Line;
+import org.logstash.plugins.filters.Uuid;
+import org.logstash.plugins.inputs.Generator;
+import org.logstash.plugins.inputs.Stdin;
+import org.logstash.plugins.outputs.Stdout;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Enumeration;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;
+
+public class PluginValidatorTest {
+
+    @Test
+    public void testValidInputPlugin() {
+        Assert.assertTrue(PluginValidator.validatePlugin(PluginLookup.PluginType.INPUT, Stdin.class));
+        Assert.assertTrue(PluginValidator.validatePlugin(PluginLookup.PluginType.INPUT, Generator.class));
+    }
+
+    @Test
+    public void testValidFilterPlugin() {
+        Assert.assertTrue(PluginValidator.validatePlugin(PluginLookup.PluginType.FILTER, Uuid.class));
+    }
+
+    @Test
+    public void testValidCodecPlugin() {
+        Assert.assertTrue(PluginValidator.validatePlugin(PluginLookup.PluginType.CODEC, Line.class));
+    }
+
+    @Test
+    public void testValidOutputPlugin() {
+        Assert.assertTrue(PluginValidator.validatePlugin(PluginLookup.PluginType.OUTPUT, Stdout.class));
+    }
+
+    @Test
+    public void testInvalidInputPlugin() throws IOException {
+        Path tempJar = null;
+        try {
+            tempJar = Files.createTempFile("pluginValidationTest", "inputPlugin.jar");
+            final InputStream resourceJar =
+                    getClass().getResourceAsStream("logstash-input-java_input_example-0.0.1.jar");
+            Files.copy(resourceJar, tempJar, REPLACE_EXISTING);
+
+            URL[] jarUrl = {tempJar.toUri().toURL()};
+            URLClassLoader cl = URLClassLoader.newInstance(jarUrl);
+            Class<?> oldInputClass = cl.loadClass("org.logstash.javaapi.JavaInputExample");
+
+            Assert.assertNotNull(oldInputClass);
+            Assert.assertFalse(PluginValidator.validatePlugin(PluginLookup.PluginType.INPUT, oldInputClass));
+        } catch (Exception ex) {
+            Assert.fail("Failed with exception: " + ex);
+        } finally {
+            if (tempJar != null) {
+                Files.deleteIfExists(tempJar);
+            }
+        }
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugins/codecs/LineTest.java b/logstash-core/src/test/java/org/logstash/plugins/codecs/LineTest.java
index 68bcb9df161..abf3afdc1ca 100644
--- a/logstash-core/src/test/java/org/logstash/plugins/codecs/LineTest.java
+++ b/logstash-core/src/test/java/org/logstash/plugins/codecs/LineTest.java
@@ -7,6 +7,8 @@
 import org.logstash.plugins.ConfigurationImpl;
 import org.logstash.plugins.TestContext;
 
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
@@ -239,71 +241,28 @@ public void testDecodeWithCharset() throws Exception {
     }
 
     @Test
-    public void testEncode() throws Codec.EncodeException {
-        String delimiter = "z";
-        String message = "Hello world";
-        String expectedResult = message + delimiter;
-        Map<String, Object> config = new HashMap<>();
-        config.put("delimiter", delimiter);
-        config.put("format", "%{message}");
-        Line line = new Line(new ConfigurationImpl(config), new TestContext());
-        Event e = new Event(Collections.singletonMap("message", message));
-        byte[] b = new byte[100];
-        ByteBuffer buffer = ByteBuffer.wrap(b);
-        boolean result = line.encode(e, buffer);
-        Assert.assertTrue(result);
-        String resultString = new String(buffer.array(), buffer.position(), buffer.limit());
-        Assert.assertEquals(expectedResult, resultString);
-    }
-
-    @Test
-    public void testMultipleEncodesForEvent() throws Codec.EncodeException {
-        String delimiter = "z";
-        String message = "Hello world";
-        String expectedResult = message + delimiter;
-        Map<String, Object> config = new HashMap<>();
-        config.put("delimiter", delimiter);
-        config.put("format", "%{message}");
-        Line line = new Line(new ConfigurationImpl(config), new TestContext());
-        Event e = new Event(Collections.singletonMap("message", message));
-        byte[] b = new byte[10];
-        ByteBuffer buffer = ByteBuffer.wrap(b);
-
-        boolean result = line.encode(e, buffer);
-        Assert.assertFalse(result);
-        String resultString = new String(buffer.array(), buffer.position(), buffer.limit());
-
-        buffer.clear();
-        result = line.encode(e, buffer);
-        Assert.assertTrue(result);
-        resultString += new String(buffer.array(), buffer.position(), buffer.limit());
-
-        Assert.assertEquals(expectedResult, resultString);
+    public void testEncode() throws IOException {
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        Line line = new Line(new ConfigurationImpl(Collections.emptyMap()), null);
+        Event e = new Event();
+        e.setField("myfield1", "myvalue1");
+        e.setField("myfield2", 42L);
+        line.encode(e, outputStream);
+        e.setField("myfield1", "myvalue2");
+        e.setField("myfield2", 43L);
+        line.encode(e, outputStream);
+
+        String delimiter = Line.DEFAULT_DELIMITER;
+        String resultingString = outputStream.toString();
+        // first delimiter should occur at the halfway point of the string
+        assertEquals(resultingString.indexOf(delimiter), (resultingString.length() / 2) - delimiter.length());
+        // second delimiter should occur at end of string
+        assertEquals(resultingString.lastIndexOf(delimiter), resultingString.length() - delimiter.length());
     }
 
     @Test
-    public void testEncodeNewEventBeforeFinishingPreviousThrows() {
-        String delimiter = "z";
-        String message = "Hello world";
-        Map<String, Object> config = new HashMap<>();
-        config.put("delimiter", delimiter);
-        config.put("format", "%{message}");
-        Line line = new Line(new ConfigurationImpl(config), new TestContext());
-        Event e1 = new Event(Collections.singletonMap("message", message));
-        Event e2 = new Event(Collections.singletonMap("message", message));
-        byte[] b = new byte[10];
-        ByteBuffer buffer = ByteBuffer.wrap(b);
-        try {
-            line.encode(e1, buffer);
-            line.encode(e2, buffer);
-            Assert.fail("EncodeException should be thrown because previous event was not fully encoded");
-        } catch (Codec.EncodeException ex) {
-            // this exception should be thrown
-        }
-    }
-
-    @Test
-    public void testEncodeWithUtf8() throws Codec.EncodeException {
+    public void testEncodeWithUtf8() throws IOException {
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
         String delimiter = "z";
         String message = new String("Mnchen ".getBytes(), Charset.forName("UTF-8"));
         Map<String, Object> config = new HashMap<>();
@@ -311,47 +270,14 @@ public void testEncodeWithUtf8() throws Codec.EncodeException {
         config.put("format", "%{message}");
         Line line = new Line(new ConfigurationImpl(config), new TestContext());
         Event e1 = new Event(Collections.singletonMap("message", message));
-        byte[] b = new byte[100];
-        ByteBuffer buffer = ByteBuffer.wrap(b);
-        boolean result = line.encode(e1, buffer);
-        Assert.assertTrue(result);
+        line.encode(e1, outputStream);
         String expectedResult = message + delimiter;
-        Assert.assertEquals(expectedResult, new String(buffer.array(), buffer.position(), buffer.limit(), Charset.forName("UTF-8")));
+        Assert.assertEquals(expectedResult, new String(outputStream.toByteArray(), Charset.forName("UTF-8")));
     }
 
     @Test
-    public void testEncodeAcrossMultibyteCharBoundary() throws Codec.EncodeException {
-        String message = new String("".getBytes(), Charset.forName("UTF-8"));
-        String delimiter = "";
-        Map<String, Object> config = new HashMap<>();
-        config.put("delimiter", delimiter);
-        config.put("format", "%{message}");
-        Line line = new Line(new ConfigurationImpl(config), new TestContext());
-        Event e1 = new Event(Collections.singletonMap("message", message));
-        byte[] b = new byte[10];
-        ByteBuffer buffer = ByteBuffer.wrap(b);
-
-        boolean result = line.encode(e1, buffer);
-        String intermediateResult = new String(buffer.array(), buffer.position(), buffer.limit());
-        Assert.assertFalse(result);
-        Assert.assertEquals("", intermediateResult);
-
-        buffer.clear();
-        result = line.encode(e1, buffer);
-        intermediateResult = new String(buffer.array(), buffer.position(), buffer.limit());
-        Assert.assertFalse(result);
-        Assert.assertEquals("", intermediateResult);
-
-        buffer.clear();
-        result = line.encode(e1, buffer);
-        intermediateResult = new String(buffer.array(), buffer.position(), buffer.limit());
-        Assert.assertTrue(result);
-        Assert.assertEquals("", intermediateResult);
-    }
-
-
-    @Test
-    public void testEncodeWithCharset() throws Exception {
+    public void testEncodeWithCharset() throws IOException {
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
         byte[] rightSingleQuoteInUtf8 = {(byte) 0xE2, (byte) 0x80, (byte) 0x99};
         String rightSingleQuote = new String(rightSingleQuoteInUtf8, Charset.forName("UTF-8"));
 
@@ -361,20 +287,34 @@ public void testEncodeWithCharset() throws Exception {
         config.put("format", "%{message}");
         config.put("delimiter", "");
         Event e1 = new Event(Collections.singletonMap("message", rightSingleQuote));
-        Line cp1252decoder = new Line(new ConfigurationImpl(config), new TestContext());
+        Line cp1252encoder = new Line(new ConfigurationImpl(config), new TestContext());
         byte[] rightSingleQuoteInCp1252 = {(byte) 0x92};
-        byte[] b = new byte[100];
-        ByteBuffer buffer = ByteBuffer.wrap(b);
 
-        boolean result = cp1252decoder.encode(e1, buffer);
-        Assert.assertTrue(result);
-        byte[] resultBytes = new byte[buffer.limit() - buffer.position()];
-        System.arraycopy(buffer.array(), buffer.position(), resultBytes, 0, buffer.limit() - buffer.position());
+        cp1252encoder.encode(e1, outputStream);
+        byte[] resultBytes = outputStream.toByteArray();
         Assert.assertArrayEquals(rightSingleQuoteInCp1252, resultBytes);
     }
 
     @Test
-    public void testClone() throws Codec.EncodeException {
+    public void testEncodeWithFormat() throws IOException {
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        Line line = new Line(new ConfigurationImpl(Collections.singletonMap("format", "%{host}-%{message}")), null);
+        String message = "Hello world";
+        String host = "test";
+        String expectedOutput = host + "-" + message + Line.DEFAULT_DELIMITER;
+        Event e = new Event();
+        e.setField("message", message);
+        e.setField("host", host);
+
+        line.encode(e, outputStream);
+
+        String resultingString = outputStream.toString();
+        assertEquals(expectedOutput, resultingString);
+    }
+
+    @Test
+    public void testClone() throws IOException  {
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
         String delimiter = "x";
         String charset = "cp1252";
         byte[] rightSingleQuoteInUtf8 = {(byte) 0xE2, (byte) 0x80, (byte) 0x99};
@@ -395,14 +335,8 @@ public void testClone() throws Codec.EncodeException {
 
         // verify charset and delimiter
         byte[] rightSingleQuoteAndXInCp1252 = {(byte) 0x92, (byte) 0x78};
-        byte[] b = new byte[100];
-        ByteBuffer buffer = ByteBuffer.wrap(b);
-
-        boolean result = line2.encode(e1, buffer);
-        Assert.assertTrue(result);
-        byte[] resultBytes = new byte[buffer.limit() - buffer.position()];
-        System.arraycopy(buffer.array(), buffer.position(), resultBytes, 0, buffer.limit() - buffer.position());
-        Assert.assertArrayEquals(rightSingleQuoteAndXInCp1252, resultBytes);
+        line2.encode(e1, outputStream);
+        Assert.assertArrayEquals(rightSingleQuoteAndXInCp1252, outputStream.toByteArray());
     }
 
 }
diff --git a/logstash-core/src/test/resources/org/logstash/plugins/logstash-input-java_input_example-0.0.1.jar b/logstash-core/src/test/resources/org/logstash/plugins/logstash-input-java_input_example-0.0.1.jar
new file mode 100644
index 00000000000..e8d0147b939
Binary files /dev/null and b/logstash-core/src/test/resources/org/logstash/plugins/logstash-input-java_input_example-0.0.1.jar differ
diff --git a/rubyUtils.gradle b/rubyUtils.gradle
index c350b64eebb..6f0eec45ed3 100644
--- a/rubyUtils.gradle
+++ b/rubyUtils.gradle
@@ -19,6 +19,7 @@ import org.jruby.Ruby
 import org.jruby.embed.PathType
 import org.jruby.embed.ScriptingContainer
 
+import java.lang.annotation.Annotation
 import java.nio.file.Files
 import java.nio.file.Paths
 
@@ -28,9 +29,13 @@ ext {
     gem = this.&gem
     buildGem = this.&buildGem
     rake = this.&rake
+    generateRubySupportFilesForPlugin = this.&generateRubySupportFilesForPlugin
+    validatePluginJar = this.&validatePluginJar
     versionMap = new HashMap()
+    pluginInfo = new PluginInfo()
 }
 
+
 /**
  * Executes a bundler bin script with given parameters.
  * @param projectDir Gradle projectDir
@@ -249,3 +254,130 @@ task downloadAndInstallJRuby(dependsOn: [verifyFile, installCustomJRuby], type:
 }
 
 downloadAndInstallJRuby.onlyIf { customJRubyDir == "" }
+
+//===============================================================================
+// Ruby auto-gen utilities for Java plugins
+//===============================================================================
+
+class PluginInfo {
+    public String[] licenses
+    public String longDescription
+    public String[] authors
+    public String[] email
+    public String homepage
+    public String pluginType
+    public String pluginClass
+    public String pluginName
+
+    String pluginFullName() {
+        return "logstash-" + pluginType + "-" + pluginName
+    }
+}
+
+void generateRubySupportFilesForPlugin(String projectDescription, String projectGroup, String version) {
+    File gemFile = file("Gemfile")
+    gemFile.write("# AUTOGENERATED BY THE GRADLE SCRIPT. EDITS WILL BE OVERWRITTEN.\n")
+    gemFile.append("source 'https://rubygems.org'\n")
+    gemFile.append("\n")
+    gemFile.append("gemspec\n")
+    gemFile.append("\n")
+    gemFile.append("logstash_path = ENV[\"LOGSTASH_PATH\"] || \"../../logstash\"\n")
+    gemFile.append("use_logstash_source = ENV[\"LOGSTASH_SOURCE\"] && ENV[\"LOGSTASH_SOURCE\"].to_s == \"1\"\n")
+    gemFile.append("\n")
+    gemFile.append("if Dir.exist?(logstash_path) && use_logstash_source\n")
+    gemFile.append("  gem 'logstash-core', :path => \"#{logstash_path}/logstash-core\"\n")
+    gemFile.append("  gem 'logstash-core-plugin-api', :path => \"#{logstash_path}/logstash-core-plugin-api\"\n")
+    gemFile.append("end\n")
+
+    File gemspecFile = file(pluginInfo.pluginFullName() + ".gemspec")
+    gemspecFile.write("# AUTOGENERATED BY THE GRADLE SCRIPT. EDITS WILL BE OVERWRITTEN.\n")
+    gemspecFile.append("Gem::Specification.new do |s|\n")
+    gemspecFile.append("  s.name            = '" + pluginInfo.pluginFullName() + "'\n")
+    gemspecFile.append("  s.version         = ::File.read('VERSION').split('\\n').first\n")
+    gemspecFile.append("  s.licenses        = ['" + String.join("', '", pluginInfo.licenses) + "']\n")
+    gemspecFile.append("  s.summary         = '" + projectDescription + "'\n")
+    gemspecFile.append("  s.description     = '" + pluginInfo.longDescription + "'\n")
+    gemspecFile.append("  s.authors         = ['" + String.join("', '", pluginInfo.authors) + "']\n")
+    gemspecFile.append("  s.email           = ['" + String.join("', '", pluginInfo.email) + "']\n")
+    gemspecFile.append("  s.homepage        = '" + pluginInfo.homepage + "'\n")
+    gemspecFile.append("  s.require_paths = ['lib', 'vendor/jar-dependencies']\n")
+    gemspecFile.append("\n")
+    gemspecFile.append("  s.files = Dir[\"lib/**/*\",\"*.gemspec\",\"*.md\",\"CONTRIBUTORS\",\"Gemfile\",\"LICENSE\",\"NOTICE.TXT\", \"vendor/jar-dependencies/**/*.jar\", \"vendor/jar-dependencies/**/*.rb\", \"VERSION\", \"docs/**/*\"]\n")
+    gemspecFile.append("\n")
+    gemspecFile.append("  # Special flag to let us know this is actually a logstash plugin\n")
+    gemspecFile.append("  s.metadata = { 'logstash_plugin' => 'true', 'logstash_group' => '" + pluginInfo.pluginType + "', 'java_plugin' => 'true'}\n")
+    gemspecFile.append("\n")
+    gemspecFile.append("  # Gem dependencies\n")
+    gemspecFile.append("  s.add_runtime_dependency \"logstash-core-plugin-api\", \">= 1.60\", \"<= 2.99\"\n")
+    gemspecFile.append("  s.add_runtime_dependency 'jar-dependencies'\n")
+    gemspecFile.append("  s.add_development_dependency 'logstash-devutils'\n")
+    gemspecFile.append("end\n")
+
+    String moduleName = pluginInfo.pluginType.substring(0, 1).toUpperCase() + pluginInfo.pluginType.substring(1) + "s"
+    File pluginRb = file("lib/logstash/" + pluginInfo.pluginType + "s/" + pluginInfo.pluginName + ".rb")
+    Files.createDirectories(pluginRb.toPath().getParent())
+    pluginRb.write("# AUTOGENERATED BY THE GRADLE SCRIPT. EDITS WILL BE OVERWRITTEN.\n")
+    pluginRb.append("# encoding: utf-8\n")
+    pluginRb.append("require \"logstash/" + pluginInfo.pluginType + "s/base\"\n")
+    pluginRb.append("require \"logstash/namespace\"\n")
+    pluginRb.append("require \"" + pluginInfo.pluginFullName() + "_jars\"\n")
+    pluginRb.append("require \"java\"\n")
+    pluginRb.append("\n")
+    pluginRb.append("class LogStash::" + moduleName + "::" + pluginInfo.pluginClass + " < LogStash::" + moduleName + "::Base\n")
+    pluginRb.append("  config_name \"" + pluginInfo.pluginName + "\"\n")
+    pluginRb.append("\n")
+    pluginRb.append("  def self.javaClass() Java::" + projectGroup + "." + pluginInfo.pluginClass + ".java_class; end\n")
+    pluginRb.append("end\n")
+
+    File pluginJarsRb = file("lib/" + pluginInfo.pluginFullName() + "_jars.rb")
+    pluginJarsRb.write("# AUTOGENERATED BY THE GRADLE SCRIPT. EDITS WILL BE OVERWRITTEN.\n")
+    pluginJarsRb.append("# encoding: utf-8\n")
+    pluginJarsRb.append("\n")
+    pluginJarsRb.append("require 'jar_dependencies'\n")
+    pluginJarsRb.append("require_jar('" + projectGroup + "', '" + pluginInfo.pluginFullName() + "', '" + version +"')\n")
+}
+
+void validatePluginJar(File pluginJar, String group) {
+    List<String> validationErrors = new ArrayList<>()
+
+    if (group.equals('org.logstash') || group.startsWith('org.logstash.') || group.equals('co.elastic.logstash') || group.startsWith('co.elastic.logstash.')) {
+        validationErrors.add("The plugin should not be placed in the 'org.logstash' or 'co.elastic.logstash' packages")
+        throw new GradleScriptException("Plugin validation errors:" + System.lineSeparator() +
+                String.join(System.lineSeparator(), validationErrors), null)
+    }
+
+    URLClassLoader cl = URLClassLoader.newInstance([pluginJar.toURI().toURL()] as URL[])
+    String pluginClassName = group + "." + pluginInfo.pluginClass
+
+    Class<?> pluginClass = null
+    try {
+        pluginClass = cl.loadClass(pluginClassName)
+    } catch (ClassNotFoundException ex) {
+        validationErrors.add(String.format("Unable to locate plugin class defined in build.gradle as '%s' in jar '%s'", pluginClassName, pluginJar))
+        throw new GradleScriptException("Plugin validation errors:" + System.lineSeparator() +
+                String.join(System.lineSeparator(), validationErrors), null)
+    }
+
+    if (pluginClass != null) {
+
+        Annotation[] logstashPlugin = pluginClass.getAnnotations().findAll({ x -> x.annotationType().toString().equals("interface co.elastic.logstash.api.LogstashPlugin") })
+        if (logstashPlugin.length != 1) {
+            validationErrors.add("There must be a single @LogstashPlugin annotation on the plugin class")
+        } else {
+            String pluginAnnotation = logstashPlugin[0].name()
+
+            if (pluginAnnotation != pluginInfo.pluginName) {
+                validationErrors.add("The 'name' property on the @LogstashPlugin (which is '" + pluginAnnotation + "') must match the 'pluginName' property which is defined as '" + pluginInfo.pluginName + "' in the build.gradle file")
+            }
+
+            if (pluginAnnotation.replace("_", "").toLowerCase() != pluginInfo.pluginClass.toLowerCase()) {
+                validationErrors.add("The 'name' property on the @LogstashPlugin (which is '" + pluginAnnotation + "') must match the plugin class name '" + pluginInfo.pluginClass + "' excluding casing and underscores")
+            }
+        }
+    }
+
+    if (validationErrors.size() > 0) {
+        throw new GradleScriptException("Plugin validation errors:" + System.lineSeparator() +
+                String.join(System.lineSeparator(), validationErrors), null)
+    }
+}
