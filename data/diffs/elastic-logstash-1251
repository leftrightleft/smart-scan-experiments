diff --git a/pkg/build.sh b/pkg/build.sh
index dad55451ac9..ef1be575476 100755
--- a/pkg/build.sh
+++ b/pkg/build.sh
@@ -54,9 +54,9 @@ case $os@$release in
     chmod 0755 $destdir/opt/logstash/bin/logstash
     install -m644 logrotate.conf $destdir/etc/logrotate.d/logstash
     install -m644 logstash.default $destdir/etc/sysconfig/logstash
-    install -m755 logstash.sysv.redhat $destdir/etc/init.d/logstash
+    install -m755 logstash.sysv $destdir/etc/init.d/logstash
     install -m644 logstash-web.default $destdir/etc/sysconfig/logstash
-    install -m755 logstash-web.sysv.redhat $destdir/etc/init.d/logstash-web
+    install -m755 logstash-web.sysv $destdir/etc/init.d/logstash-web
     ;;
   ubuntu@*|debian@*)
     mkdir -p $destdir/etc/logstash/conf.d
@@ -70,10 +70,10 @@ case $os@$release in
     install -m644 logrotate.conf $destdir/etc/logrotate.d/logstash
     install -m644 logstash.default $destdir/etc/default/logstash
     install -m755 logstash.upstart.ubuntu $destdir/etc/init/logstash.conf
-    install -m755 logstash.sysv.debian $destdir/etc/init.d/logstash
+    install -m755 logstash.sysv $destdir/etc/init.d/logstash
     install -m644 logstash-web.default $destdir/etc/default/logstash-web
     install -m755 logstash-web.upstart.ubuntu $destdir/etc/init/logstash-web.conf
-    install -m755 logstash-web.sysv.debian $destdir/etc/init.d/logstash-web
+    install -m755 logstash-web.sysv $destdir/etc/init.d/logstash-web
     ;;
   *) 
     echo "Unknown OS: $os $release"
diff --git a/pkg/logstash-web.sysv b/pkg/logstash-web.sysv
new file mode 100755
index 00000000000..4e3c7a0d82e
--- /dev/null
+++ b/pkg/logstash-web.sysv
@@ -0,0 +1,149 @@
+#!/bin/sh
+# Init script for logstash Webserver
+# Maintained by Elasticsearch
+# Generated by pleaserun.
+# Implemented based on LSB Core 3.1:
+#   * Sections: 20.2, 20.3
+#
+### BEGIN INIT INFO
+# Provides:          logstash-web
+# Required-Start:    $remote_fs $syslog
+# Required-Stop:     $remote_fs $syslog
+# Default-Start:     2 3 4 5
+# Default-Stop:      0 1 6
+# Short-Description: 
+# Description:        Starts Logstash webserveras a daemon.
+### END INIT INFO
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+export PATH
+
+if [ `id -u` -ne 0 ]; then
+   echo "You need root privileges to run this script"
+   exit 1
+fi
+
+name=logstash-web
+pidfile="/var/run/$name.pid"
+
+LS_USER=logstash
+LS_GROUP=logstash
+LS_HOME=/var/lib/logstash
+LS_HEAP_SIZE="500m"
+LS_JAVA_OPTS="-Djava.io.tmpdir=${LS_HOME}"
+LS_LOG_FILE=/var/log/logstash/$name.log
+LS_CONF_DIR=/etc/logstash/conf.d
+LS_OPEN_FILES=16384
+LS_NICE=19
+LS_OPTS=""
+LS_WEB_ADDRESS="0.0.0.0"
+LS_WEB_PORT=9292
+
+[ -r /etc/default/$name ] && . /etc/default/$name
+[ -r /etc/sysconfig/$name ] && . /etc/sysconfig/$name
+
+program=/opt/logstash/bin/logstash
+args="web -a ${LS_WEB_ADDRESS} -p ${LS_WEB_PORT}"
+
+start() {
+
+
+  JAVA_OPTS=${LS_JAVA_OPTS}
+  export PATH HOME JAVA_OPTS LS_HEAP_SIZE LS_JAVA_OPTS LS_USE_GC_LOGGING
+  # Run the program!
+  chroot --userspec $LS_USER:$LS_GROUP / sh -c "
+    cd $LS_HOME
+    nice ${LS_NICE}
+    ulimit -n ${LS_OPEN_FILES}
+    exec \"$program\" $args
+  " > /var/log/logstash/$name.stdout 2> /var/log/logstash/$name.err &
+
+  # Generate the pidfile from here. If we instead made the forked process
+  # generate it there will be a race condition between the pidfile writing
+  # and a process possibly asking for status.
+  echo $! > $pidfile
+
+  echo "$name started."
+  return 0
+}
+
+stop() {
+  # Try a few times to kill TERM the program
+  if status ; then
+    pid=`cat "$pidfile"`
+    echo "Killing $name (pid $pid) with SIGTERM"
+    kill -TERM $pid
+    # Wait for it to exit.
+    for i in 1 2 3 4 5 ; do
+      echo "Waiting $name (pid $pid) to die..."
+      status || break
+      sleep 1
+    done
+    if status ; then
+      echo "$name stop failed; still running."
+    else
+      echo "$name stopped."
+    fi
+  fi
+}
+
+status() {
+  if [ -f "$pidfile" ] ; then
+    pid=`cat "$pidfile"`
+    if kill -0 $pid > /dev/null 2> /dev/null ; then
+      # process by this pid is running.
+      # It may not be our pid, but that's what you get with just pidfiles.
+      # TODO(sissel): Check if this process seems to be the same as the one we
+      # expect. It'd be nice to use flock here, but flock uses fork, not exec,
+      # so it makes it quite awkward to use in this case.
+      return 0
+    else
+      return 2 # program is dead but pid file exists
+    fi
+  else
+    return 3 # program is not running
+  fi
+}
+
+force_stop() {
+  if status ; then
+    stop
+    status && kill -KILL `cat "$pidfile"`
+  fi
+}
+
+
+case "$1" in
+  start)
+    status
+    code=$?
+    if [ $code -eq 0 ]; then
+      echo "$name is already running"
+    else
+      start
+    fi
+    exit $code
+    ;;
+  stop) stop ;;
+  force-stop) force_stop ;;
+  status) 
+    status
+    code=$?
+    if [ $code -eq 0 ] ; then
+      echo "$name is running"
+    else
+      echo "$name is not running"
+    fi
+    exit $code
+    ;;
+  restart) 
+    
+    stop && start 
+    ;;
+  *)
+    echo "Usage: $SCRIPTNAME {start|stop|force-stop|status|restart}" >&2
+    exit 3
+  ;;
+esac
+
+exit $?
diff --git a/pkg/logstash.sysv b/pkg/logstash.sysv
new file mode 100755
index 00000000000..2b501684666
--- /dev/null
+++ b/pkg/logstash.sysv
@@ -0,0 +1,147 @@
+#!/bin/sh
+# Init script for logstash
+# Maintained by Elasticsearch
+# Generated by pleaserun.
+# Implemented based on LSB Core 3.1:
+#   * Sections: 20.2, 20.3
+#
+### BEGIN INIT INFO
+# Provides:          logstash
+# Required-Start:    $remote_fs $syslog
+# Required-Stop:     $remote_fs $syslog
+# Default-Start:     2 3 4 5
+# Default-Stop:      0 1 6
+# Short-Description: 
+# Description:        Starts Logstash as a daemon.
+### END INIT INFO
+
+PATH=/sbin:/usr/sbin:/bin:/usr/bin
+export PATH
+
+if [ `id -u` -ne 0 ]; then
+   echo "You need root privileges to run this script"
+   exit 1
+fi
+
+name=logstash
+pidfile="/var/run/$name.pid"
+
+LS_USER=logstash
+LS_GROUP=logstash
+LS_HOME=/var/lib/logstash
+LS_HEAP_SIZE="500m"
+LS_JAVA_OPTS="-Djava.io.tmpdir=${LS_HOME}"
+LS_LOG_FILE=/var/log/logstash/$name.log
+LS_CONF_DIR=/etc/logstash/conf.d
+LS_OPEN_FILES=16384
+LS_NICE=19
+LS_OPTS=""
+
+[ -r /etc/default/$name ] && . /etc/default/$name
+[ -r /etc/sysconfig/$name ] && . /etc/sysconfig/$name
+
+program=/opt/logstash/bin/logstash
+args="agent -f ${LS_CONF_DIR} -l ${LS_LOG_FILE} ${LS_OPTS}"
+
+start() {
+
+
+  JAVA_OPTS=${LS_JAVA_OPTS}
+  export PATH HOME JAVA_OPTS LS_HEAP_SIZE LS_JAVA_OPTS LS_USE_GC_LOGGING
+  # Run the program!
+  chroot --userspec $LS_USER:$LS_GROUP / sh -c "
+    cd $LS_HOME
+    nice ${LS_NICE}
+    ulimit -n ${LS_OPEN_FILES}
+    exec \"$program\" $args
+  " > /var/log/logstash/$name.stdout 2> /var/log/logstash/$name.err &
+
+  # Generate the pidfile from here. If we instead made the forked process
+  # generate it there will be a race condition between the pidfile writing
+  # and a process possibly asking for status.
+  echo $! > $pidfile
+
+  echo "$name started."
+  return 0
+}
+
+stop() {
+  # Try a few times to kill TERM the program
+  if status ; then
+    pid=`cat "$pidfile"`
+    echo "Killing $name (pid $pid) with SIGTERM"
+    kill -TERM $pid
+    # Wait for it to exit.
+    for i in 1 2 3 4 5 ; do
+      echo "Waiting $name (pid $pid) to die..."
+      status || break
+      sleep 1
+    done
+    if status ; then
+      echo "$name stop failed; still running."
+    else
+      echo "$name stopped."
+    fi
+  fi
+}
+
+status() {
+  if [ -f "$pidfile" ] ; then
+    pid=`cat "$pidfile"`
+    if kill -0 $pid > /dev/null 2> /dev/null ; then
+      # process by this pid is running.
+      # It may not be our pid, but that's what you get with just pidfiles.
+      # TODO(sissel): Check if this process seems to be the same as the one we
+      # expect. It'd be nice to use flock here, but flock uses fork, not exec,
+      # so it makes it quite awkward to use in this case.
+      return 0
+    else
+      return 2 # program is dead but pid file exists
+    fi
+  else
+    return 3 # program is not running
+  fi
+}
+
+force_stop() {
+  if status ; then
+    stop
+    status && kill -KILL `cat "$pidfile"`
+  fi
+}
+
+
+case "$1" in
+  start)
+    status
+    code=$?
+    if [ $code -eq 0 ]; then
+      echo "$name is already running"
+    else
+      start
+    fi
+    exit $code
+    ;;
+  stop) stop ;;
+  force-stop) force_stop ;;
+  status) 
+    status
+    code=$?
+    if [ $code -eq 0 ] ; then
+      echo "$name is running"
+    else
+      echo "$name is not running"
+    fi
+    exit $code
+    ;;
+  restart) 
+    
+    stop && start 
+    ;;
+  *)
+    echo "Usage: $SCRIPTNAME {start|stop|force-stop|status|restart}" >&2
+    exit 3
+  ;;
+esac
+
+exit $?
