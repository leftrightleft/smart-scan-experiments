diff --git a/logstash-core/lib/logstash/agent.rb b/logstash-core/lib/logstash/agent.rb
index f05a3b9f7f6..e0afcc463ae 100644
--- a/logstash-core/lib/logstash/agent.rb
+++ b/logstash-core/lib/logstash/agent.rb
@@ -37,7 +37,7 @@ class LogStash::Agent
   include LogStash::Util::Loggable
   STARTED_AT = Time.now.freeze
 
-  attr_reader :metric, :name, :settings, :dispatcher, :ephemeral_id, :pipeline_bus
+  attr_reader :metric, :name, :settings, :dispatcher, :ephemeral_id, :pipeline_bus, :acknowledge_bus
   attr_accessor :logger
 
   # initialize method for LogStash::Agent
@@ -60,6 +60,11 @@ def initialize(settings = LogStash::SETTINGS, source_loader = nil)
     # Special bus object for inter-pipelines communications. Used by the `pipeline` input/output
     @pipeline_bus = org.logstash.plugins.pipeline.PipelineBus.new
 
+    # Special bus object for pipeline-plugin acknowledge communications.
+    # Used by Acknowledgable plugins, like an external queue plugin.
+    # Also used by `pipeline` input/output
+    @acknowledge_bus = org.logstash.plugins.acknowledge.AcknowledgeBus.new
+
     @pipelines_registry = LogStash::PipelinesRegistry.new
 
     @name = setting("node.name")
diff --git a/logstash-core/lib/logstash/java_pipeline.rb b/logstash-core/lib/logstash/java_pipeline.rb
index 7e7ba301680..1dbd1eda4ba 100644
--- a/logstash-core/lib/logstash/java_pipeline.rb
+++ b/logstash-core/lib/logstash/java_pipeline.rb
@@ -44,6 +44,8 @@ def initialize(pipeline_config, namespaced_metric = nil, agent = nil)
     super pipeline_config, namespaced_metric, @logger, agent
     open_queue
 
+    @acknowledge_bus = agent.nil? ? nil : agent.acknowledge_bus
+
     @worker_threads = []
 
     @drain_queue =  settings.get_value("queue.drain") || settings.get("queue.type") == "memory"
@@ -525,6 +527,7 @@ def init_worker_loop
       org.logstash.execution.WorkerLoop.new(
         lir_execution,
         filter_queue_client,
+        @acknowledge_bus,
         @events_filtered,
         @events_consumed,
         @flushRequested,
diff --git a/logstash-core/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
index ccec00bab8b..8b173d58826 100644
--- a/logstash-core/lib/logstash/pipeline.rb
+++ b/logstash-core/lib/logstash/pipeline.rb
@@ -44,6 +44,8 @@ def initialize(pipeline_config, namespaced_metric = nil, agent = nil)
     @outputs = nil
     @agent = agent
 
+    @acknowledge_bus = agent.nil? ? nil : agent.acknowledge_bus
+
     @plugin_factory = LogStash::Plugins::PluginFactory.new(
       # use NullMetric if called in the BasePipeline context otherwise use the @metric value
       lir, LogStash::Plugins::PluginMetricsFactory.new(pipeline_id, metric),
@@ -374,7 +376,10 @@ def worker_loop(batch_size, batch_delay)
       end
       if events.size > 0
         output_batch(events, output_events_map)
-        filter_queue_client.close_batch(batch)
+      end
+      filter_queue_client.close_batch(batch)
+      unless @acknowledge_bus.nil? || batch_size == 0
+        @acknowledge_bus.acknowledgeEvents(batch.events())
       end
       # keep break at end of loop, after the read_batch operation, some pipeline specs rely on this "final read_batch" before shutdown.
       break if (@worker_shutdown.get && !draining_queue?)
diff --git a/logstash-core/lib/logstash/plugins/builtin.rb b/logstash-core/lib/logstash/plugins/builtin.rb
index 1fb4c9fcbe6..c2076a7e468 100644
--- a/logstash-core/lib/logstash/plugins/builtin.rb
+++ b/logstash-core/lib/logstash/plugins/builtin.rb
@@ -18,7 +18,9 @@
 module ::LogStash::Plugins::Builtin
   require 'logstash/plugins/builtin/pipeline/input'
   require 'logstash/plugins/builtin/pipeline/output'
+  require 'logstash/plugins/builtin/acknowledge/acked_heartbeat'
 
   LogStash::PLUGIN_REGISTRY.add(:input, "pipeline", LogStash::Plugins::Builtin::Pipeline::Input)
   LogStash::PLUGIN_REGISTRY.add(:output, "pipeline", LogStash::Plugins::Builtin::Pipeline::Output)
+  LogStash::PLUGIN_REGISTRY.add(:input, "acked_heartbeat", LogStash::Plugins::Builtin::Acknowledge::AckedHeartbeat)
 end
\ No newline at end of file
diff --git a/logstash-core/lib/logstash/plugins/builtin/acknowledge/acked_heartbeat.rb b/logstash-core/lib/logstash/plugins/builtin/acknowledge/acked_heartbeat.rb
new file mode 100644
index 00000000000..d487d263a2f
--- /dev/null
+++ b/logstash-core/lib/logstash/plugins/builtin/acknowledge/acked_heartbeat.rb
@@ -0,0 +1,99 @@
+# encoding: utf-8
+require "logstash/inputs/threadable"
+require "logstash/namespace"
+require "stud/interval"
+require "socket" # for Socket.gethostname
+require 'concurrent'
+
+# Generate heartbeat messages.
+#
+# The general intention of this is to test the performance and
+# availability of Logstash.
+#
+module ::LogStash; module Plugins; module Builtin; module Acknowledge;
+  class AckedHeartbeat < LogStash::Inputs::Threadable
+    config_name "acked_heartbeat"
+
+    default :codec, "plain"
+
+    # The message string to use in the event.
+    #
+    # If you set this to `epoch` then this plugin will use the current
+    # timestamp in unix timestamp (which is by definition, UTC).  It will
+    # output this value into a field called `clock`
+    #
+    # If you set this to `sequence` then this plugin will send a sequence of
+    # numbers beginning at 0 and incrementing each interval.  It will
+    # output this value into a field called `clock`
+    #
+    # Otherwise, this value will be used verbatim as the event message. It
+    # will output this value into a field called `message`
+    config :message, :validate => :string, :default => "ok"
+
+    # Set how frequently messages should be sent.
+    #
+    # The default, `60`, means send a message every 60 seconds.
+    config :interval, :validate => :number, :default => 60
+
+    # How many times to iterate.
+    # This is typically used only for testing purposes.
+    config :count, :validate => :number, :default => -1
+
+    attr_reader :ack_token_generator, :acknowledge_bus
+
+    def register
+      @host = Socket.gethostname
+      @acknowledge_bus = execution_context.agent.acknowledge_bus
+      @ack_token_generator = @acknowledge_bus.registerPlugin(self)
+      @await_count = Concurrent::AtomicFixnum.new(0)
+    end
+
+    def acknowledge(id)
+      puts "Received acknowledge for " + id
+      res = @await_count.decrement
+      if stop? && res == 0
+        @count_down_latch.count_down
+      end
+      return true
+    end
+
+    def notifyCloned(id)
+      puts "Received notify clone for " + id
+      @await_count.increment
+      return true
+    end
+
+    def run(queue)
+      @count_down_latch = Concurrent::CountDownLatch.new(1)
+      sequence = 0
+
+      while !stop?
+        start = Time.now
+
+        sequence += 1
+        event = generate_message(sequence)
+        decorate(event)
+        queue << event
+        break if sequence == @count || stop?
+
+        sleep_for = @interval - (Time.now - start)
+        Stud.stoppable_sleep(sleep_for) { stop? } if sleep_for > 0
+      end
+      if @await_count.value > 0
+        @count_down_latch.wait()
+      end
+    end
+
+    def generate_message(sequence)
+      token = ack_token_generator.generateToken(sequence.to_s)
+      @await_count.increment
+      if @message == "epoch"
+        LogStash::Event.new("@acknowledge_token" => token, "clock" => Time.now.to_i, "host" => @host)
+      elsif @message == "sequence"
+        LogStash::Event.new("@acknowledge_token" => token, "clock" => sequence, "host" => @host)
+      else
+        LogStash::Event.new("@acknowledge_token" => token, "message" => @message, "host" => @host)
+      end
+    end
+  end
+end; end; end; end
diff --git a/logstash-core/lib/logstash/plugins/builtin/pipeline/output.rb b/logstash-core/lib/logstash/plugins/builtin/pipeline/output.rb
index 05835f8e2e1..d86a468930f 100644
--- a/logstash-core/lib/logstash/plugins/builtin/pipeline/output.rb
+++ b/logstash-core/lib/logstash/plugins/builtin/pipeline/output.rb
@@ -26,14 +26,16 @@ module ::LogStash; module Plugins; module Builtin; module Pipeline; class Output
 
   config :ensure_delivery, :validate => :boolean, :default => true
 
-  attr_reader :pipeline_bus
+  attr_reader :pipeline_bus, :acknowledge_bus
 
   def register
     @pipeline_bus = execution_context.agent.pipeline_bus
+    @acknowledge_bus = execution_context.agent.acknowledge_bus
     pipeline_bus.registerSender(self, @send_to)
   end
 
   def multi_receive(events)
+    acknowledge_bus.notifyClonedEvents(events)
     pipeline_bus.sendEvents(self, events, ensure_delivery)
   end
 
diff --git a/logstash-core/spec/logstash/execution_context_spec.rb b/logstash-core/spec/logstash/execution_context_spec.rb
index d1e529cbf92..e95c4b1e296 100644
--- a/logstash-core/spec/logstash/execution_context_spec.rb
+++ b/logstash-core/spec/logstash/execution_context_spec.rb
@@ -28,6 +28,7 @@
   before do
     allow(pipeline).to receive(:agent).and_return(agent)
     allow(pipeline).to receive(:pipeline_id).and_return(pipeline_id)
+    allow(pipeline).to receive(:acknowledge_bus).and_return(nil)
   end
 
   subject { described_class.new(pipeline, agent, plugin_id, plugin_type, dlq_writer) }
diff --git a/logstash-core/spec/logstash/pipeline_action/create_spec.rb b/logstash-core/spec/logstash/pipeline_action/create_spec.rb
index 1aadf7dc051..cd39c5250e0 100644
--- a/logstash-core/spec/logstash/pipeline_action/create_spec.rb
+++ b/logstash-core/spec/logstash/pipeline_action/create_spec.rb
@@ -30,6 +30,7 @@
 
   before do
     clear_data_dir
+    allow(agent).to receive(:acknowledge_bus).and_return(nil)
   end
 
   subject { described_class.new(pipeline_config, metric) }
diff --git a/logstash-core/spec/logstash/pipeline_action/reload_spec.rb b/logstash-core/spec/logstash/pipeline_action/reload_spec.rb
index d51c5a9d716..bfc6bdf2c27 100644
--- a/logstash-core/spec/logstash/pipeline_action/reload_spec.rb
+++ b/logstash-core/spec/logstash/pipeline_action/reload_spec.rb
@@ -34,6 +34,7 @@
 
   before do
     clear_data_dir
+    allow(agent).to receive(:acknowledge_bus).and_return(nil)
     pipeline.start
   end
 
diff --git a/logstash-core/spec/logstash/plugins/builtin/pipeline_input_output_spec.rb b/logstash-core/spec/logstash/plugins/builtin/pipeline_input_output_spec.rb
index f1184842dd3..2faeeeaba94 100644
--- a/logstash-core/spec/logstash/plugins/builtin/pipeline_input_output_spec.rb
+++ b/logstash-core/spec/logstash/plugins/builtin/pipeline_input_output_spec.rb
@@ -25,6 +25,7 @@
   let(:execution_context) { double("execution_context" )}
   let(:agent) { double("agent") }
   let(:pipeline_bus) { org.logstash.plugins.pipeline.PipelineBus.new }
+  let(:acknowledge_bus) { org.logstash.plugins.acknowledge.AcknowledgeBus.new }
 
   let(:queue) { Queue.new }
 
@@ -36,6 +37,7 @@
 
   before(:each) do
     allow(execution_context).to receive(:agent).and_return(agent)
+    allow(agent).to receive(:acknowledge_bus).and_return(acknowledge_bus)
     allow(agent).to receive(:pipeline_bus).and_return(pipeline_bus)
     inputs.each do |i|
       allow(i).to receive(:execution_context).and_return(execution_context)
@@ -53,7 +55,7 @@ def wait_input_running(input_plugin)
     def start_input
       input.register
 
-      @input_thread = Thread.new do 
+      @input_thread = Thread.new do
         input.run(queue)
       end
 
@@ -93,7 +95,7 @@ def stop_input
           expect(subject.to_hash_with_metadata).not_to match(event.to_hash_with_metadata)
         end
       end
-      
+
       after(:each) do
         stop_input
         output.do_close
@@ -153,7 +155,7 @@ def stop_input
         output.register
 
         @input_threads = inputs_queues.map do |input_plugin,input_queue|
-          Thread.new do 
+          Thread.new do
             input_plugin.run(input_queue)
           end
         end
@@ -197,7 +199,7 @@ def stop_input
           expect(inputs_queues[other_input].size).to eql(0)
         end
       end
-      
+
       after(:each) do
         inputs.each(&:do_stop)
         inputs.each(&:do_close)
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/Acknowledgable.java b/logstash-core/src/main/java/co/elastic/logstash/api/Acknowledgable.java
new file mode 100644
index 00000000000..3767fa557bf
--- /dev/null
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/Acknowledgable.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to Elasticsearch B.V. under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch B.V. licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package co.elastic.logstash.api;
+
+/**
+ * Interface for the acknowledgeTokens added to Events if a
+ * acknoledgement of processing is desired for the event.
+ * Concrete implementations should be threadsafe and should be created
+ * by {@link AcknowledgeTokenFactory} instances managed by {@link AcknowledgeBus}
+ * and not directly by plugins themselves.
+ */
+public interface Acknowledgable {
+
+    /**
+     * Returns acknowledgeToken if it is present
+     * if not it shoudl return null
+     *
+     * @return Returns {@link AcknowledgeToken} or null
+     */
+    AcknowledgeToken getAcknowledgeToken();
+}
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgablePlugin.java b/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgablePlugin.java
new file mode 100644
index 00000000000..3156e6fe48b
--- /dev/null
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgablePlugin.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed to Elasticsearch B.V. under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch B.V. licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package co.elastic.logstash.api;
+
+public interface AcknowledgablePlugin extends Plugin {
+    /**
+     * Accepts an acknowledgeId which was put into the event at creation by the plugin.
+     *
+     * @param acknowledgeId acknowledgeId added to event on creation by the plugin
+     * @return true if the event was successfully received
+     */
+    boolean acknowledge(final String acknowledgeId);
+
+    /**
+     * Accepts an acknowledgeId which was put into the event at creation by the plugin.
+     * Is called when event is a clone event is put onto the acknowledge bus, like when
+     * it is passed to other pipeline in the case of multi pipeline communication.
+     *
+     * @param acknowledgeId acknowledgeId added to event on creation by the plugin
+     * @return true if the event was successfully received
+     */
+    boolean notifyCloned(final String acknowledgeId);
+
+}
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgeBus.java b/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgeBus.java
new file mode 100644
index 00000000000..5c9da1579b5
--- /dev/null
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgeBus.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to Elasticsearch B.V. under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch B.V. licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package co.elastic.logstash.api;
+
+import java.util.Collection;
+
+/**
+ * This class is the communication bus for acknowledgements at pipeline ends.
+ * Implementations should be threadsafe.
+ */
+public interface AcknowledgeBus {
+
+    /**
+     * Acknowledges events if it contains acknowledge token.
+     * Should be called at the end of a pipeline
+     *
+     * @param events A collection of Acknowledgable
+     */
+    void acknowledgeEvents(final Collection<? extends Acknowledgable> events);
+
+
+    /**
+     * Notify clone of events if it contains acknowledge token
+     * when that means an acknowledgeToken can reach end of pipeline
+     * multiple times. Like in the case of inter-pipeline communication.
+     *
+     * @param events A collection of Acknowledgable
+     */
+    void notifyClonedEvents(final Collection<? extends Acknowledgable> events);
+
+    /**
+     * Should be called by a plugin on register
+     *
+     * @param plugin    plugin to be registered
+     * @return an AcknowledgeTokenGenerator instance
+     */
+    AcknowledgeTokenFactory registerPlugin(final AcknowledgablePlugin plugin);
+
+    /**
+     * Should be called by an plugin on close
+     *
+     * @param plugin    output that will be unregistered
+     * @return false if plugin wasn't registered otherwise true
+     */
+    boolean unregisterPlugin(final AcknowledgablePlugin plugin);
+
+}
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgeToken.java b/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgeToken.java
new file mode 100644
index 00000000000..2ae822656a7
--- /dev/null
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgeToken.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to Elasticsearch B.V. under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch B.V. licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package co.elastic.logstash.api;
+
+/**
+ * Interface for the acknowledgeTokens added to Events if a
+ * acknoledgement of processing is desired for the event.
+ * Concrete implementations should be threadsafe and should be created
+ * by {@link AcknowledgeTokenFactory} instances managed by {@link AcknowledgeBus}
+ * and not directly by plugins themselves.
+ */
+public interface AcknowledgeToken {
+
+    /**
+     * Returns unique pluginId that issued acknowledgeToken
+     *
+     * @return Returns pluginId that issued acknowledgeToken
+     */
+    String getPluginId();
+
+    /**
+     * Returns acknowledgeId that identifies the event(s) for the plugin
+     * wanting to receive acknowlegement. The combination acknowledgeId
+     * and pluginId must be unique.
+     *
+     * @return Returns pluginId that issued acknowledgeToken
+     */
+    String getAcknowledgeId();
+
+}
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgeTokenFactory.java b/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgeTokenFactory.java
new file mode 100644
index 00000000000..f189db09363
--- /dev/null
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/AcknowledgeTokenFactory.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to Elasticsearch B.V. under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch B.V. licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package co.elastic.logstash.api;
+
+
+public interface AcknowledgeTokenFactory {
+
+    /**
+     * Should return immutable AcknowledgeToken object to be added
+     * to Events, requiring acknowledgement
+     *
+     * @return Returns AcknowledgeToken object
+     */
+    AcknowledgeToken generateToken(String AcknowledgeId);
+}
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/Context.java b/logstash-core/src/main/java/co/elastic/logstash/api/Context.java
index 80851186bef..1f633fae88e 100644
--- a/logstash-core/src/main/java/co/elastic/logstash/api/Context.java
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/Context.java
@@ -62,4 +62,14 @@ public interface Context {
      */
     EventFactory getEventFactory();
 
+    /**
+     * Provides an {@link AcknowledgeBus}, if configured, to input plugins.
+     * If no bus configured or the plugin is not an input, {@code null} will be returned.
+     *
+     * @return {@link AcknowledgeBus} instance if available or {@code null} otherwise.
+     */
+    default AcknowledgeBus getAcknowledgeBus(){
+        return null;
+    }
+
 }
diff --git a/logstash-core/src/main/java/co/elastic/logstash/api/Event.java b/logstash-core/src/main/java/co/elastic/logstash/api/Event.java
index b15f3aca29d..59ac4e2d359 100644
--- a/logstash-core/src/main/java/co/elastic/logstash/api/Event.java
+++ b/logstash-core/src/main/java/co/elastic/logstash/api/Event.java
@@ -28,10 +28,14 @@
  * Event interface for Java plugins. Java plugins should be not rely on the implementation details of any
  * concrete implementations of the Event interface.
  */
-public interface Event {
+public interface Event extends Acknowledgable {
     Map<String, Object> getData();
 
     Map<String, Object> getMetadata();
+    
+    default AcknowledgeToken getAcknowledgeToken(){
+        return null;
+    }
 
     void cancel();
 
diff --git a/logstash-core/src/main/java/org/logstash/Event.java b/logstash-core/src/main/java/org/logstash/Event.java
index 8b037c55e82..753c3e78a0f 100644
--- a/logstash-core/src/main/java/org/logstash/Event.java
+++ b/logstash-core/src/main/java/org/logstash/Event.java
@@ -17,7 +17,6 @@
  * under the License.
  */
 
-
 package org.logstash;
 
 import com.fasterxml.jackson.core.JsonProcessingException;
@@ -30,11 +29,14 @@
 import org.logstash.ackedqueue.Queueable;
 import org.logstash.ext.JrubyTimestampExtLibrary;
 
+import co.elastic.logstash.api.AcknowledgeToken;
+
 import java.io.IOException;
 import java.io.Serializable;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
@@ -48,19 +50,22 @@ public final class Event implements Cloneable, Queueable, co.elastic.logstash.ap
     private boolean cancelled;
     private ConvertedMap data;
     private ConvertedMap metadata;
+    private AcknowledgeToken acknowledgeToken;
 
     public static final String METADATA = "@metadata";
     public static final String METADATA_BRACKETS = "[" + METADATA + "]";
     public static final String TIMESTAMP = "@timestamp";
+    public static final String ACKNOWLEDGE_TOKEN = "@acknowledge_token";
     public static final String TIMESTAMP_FAILURE_TAG = "_timestampparsefailure";
     public static final String TIMESTAMP_FAILURE_FIELD = "_@timestamp";
     public static final String VERSION = "@version";
     public static final String VERSION_ONE = "1";
     private static final String DATA_MAP_KEY = "DATA";
     private static final String META_MAP_KEY = "META";
+    private static final String ACK_MAP_KEY = "ACK";
 
     private static final FieldReference TAGS_FIELD = FieldReference.from("tags");
-    
+
     private static final Logger logger = LogManager.getLogger(Event.class);
 
     public Event()
@@ -69,9 +74,15 @@ public Event()
         this.data = new ConvertedMap(10);
         this.data.putInterned(VERSION, VERSION_ONE);
         this.cancelled = false;
+        this.acknowledgeToken = null;
         setTimestamp(Timestamp.now());
     }
 
+    public Event(AcknowledgeToken acknowledgeToken){
+        this();
+        this.acknowledgeToken = acknowledgeToken;
+    }
+
     /**
      * Constructor from a map that will be copied and the copy will have its contents converted to
      * Java objects.
@@ -100,6 +111,12 @@ public Event(ConvertedMap data) {
         } else {
             this.metadata = new ConvertedMap(10);
         }
+        if (this.data.containsKey(ACKNOWLEDGE_TOKEN)) {
+            Object token = this.data.remove(ACKNOWLEDGE_TOKEN);
+            if (token instanceof AcknowledgeToken){
+                this.acknowledgeToken = (AcknowledgeToken) token;
+            }
+        }
         this.cancelled = false;
 
         Object providedTimestamp = data.get(TIMESTAMP);
@@ -123,6 +140,11 @@ public ConvertedMap getMetadata() {
         return this.metadata;
     }
 
+    @Override
+    public AcknowledgeToken getAcknowledgeToken(){
+        return this.acknowledgeToken;
+    }
+
     @Override
     public void cancel() {
         this.cancelled = true;
@@ -154,7 +176,7 @@ public void setEventTimestamp(Instant timestamp) {
     }
 
     public Timestamp getTimestamp() {
-        final JrubyTimestampExtLibrary.RubyTimestamp timestamp = 
+        final JrubyTimestampExtLibrary.RubyTimestamp timestamp =
             (JrubyTimestampExtLibrary.RubyTimestamp) data.get(TIMESTAMP);
         return (timestamp != null)
                 ? timestamp.getTimestamp()
@@ -239,6 +261,14 @@ private static Event fromSerializableMap(final byte[] source) throws IOException
         if (metaMap == null) {
             throw new IOException("The deserialized Map must contain the \"META\" key");
         }
+        final Map<String, Object> ackMap = representation.get(ACK_MAP_KEY);
+        if (ackMap != null) {
+            Object acknowledge_token = ackMap.get(ACKNOWLEDGE_TOKEN);
+            if (acknowledge_token != null){
+                dataMap.put(ACKNOWLEDGE_TOKEN, acknowledge_token);
+            }
+
+        }
         dataMap.put(METADATA, metaMap);
         return new Event(dataMap);
     }
@@ -264,7 +294,7 @@ public static Event[] fromJson(String json)
         if (o instanceof Map) {
             result = new Event[]{ new Event((Map<String, Object>)o) };
         } else if (o instanceof List) {
-            final Collection<Map<String, Object>> list = (Collection<Map<String, Object>>) o; 
+            final Collection<Map<String, Object>> list = (Collection<Map<String, Object>>) o;
             result = new Event[list.size()];
             int i = 0;
             for (final Map<String, Object> e : list) {
@@ -341,6 +371,7 @@ public Event clone() {
         final ConvertedMap map =
             ConvertedMap.newFromMap(Cloner.<Map<String, Object>>deep(data));
         map.putInterned(METADATA, Cloner.<Map<String, Object>>deep(metadata));
+        map.putInterned(ACKNOWLEDGE_TOKEN, this.acknowledgeToken);
         return new Event(map);
     }
 
@@ -462,6 +493,9 @@ public byte[] serialize() throws JsonProcessingException {
         final Map<String, Map<String, Object>> map = new HashMap<>(2, 1.0F);
         map.put(DATA_MAP_KEY, this.data);
         map.put(META_MAP_KEY, this.metadata);
+        if(this.acknowledgeToken != null){
+            map.put(ACK_MAP_KEY, Collections.singletonMap(ACKNOWLEDGE_TOKEN, this.acknowledgeToken));
+        }
         return CBOR_MAPPER.writeValueAsBytes(map);
     }
 
diff --git a/logstash-core/src/main/java/org/logstash/Valuefier.java b/logstash-core/src/main/java/org/logstash/Valuefier.java
index e103ba3c1ee..81087b93a27 100644
--- a/logstash-core/src/main/java/org/logstash/Valuefier.java
+++ b/logstash-core/src/main/java/org/logstash/Valuefier.java
@@ -46,6 +46,8 @@
 import org.jruby.runtime.builtin.IRubyObject;
 import org.logstash.ext.JrubyTimestampExtLibrary;
 
+import co.elastic.logstash.api.AcknowledgeToken;
+
 public final class Valuefier {
 
     public static final Valuefier.Converter IDENTITY = input -> input;
@@ -133,6 +135,7 @@ private static Map<Class<?>, Valuefier.Converter> initConverters() {
         converters.put(RubyBoolean.class, IDENTITY);
         converters.put(RubyBignum.class, IDENTITY);
         converters.put(RubyBigDecimal.class, IDENTITY);
+        converters.put(AcknowledgeToken.class, IDENTITY);
         converters.put(String.class, input -> RubyUtil.RUBY.newString((String) input));
         converters.put(Float.class, FLOAT_CONVERTER);
         converters.put(Double.class, FLOAT_CONVERTER);
diff --git a/logstash-core/src/main/java/org/logstash/execution/WorkerLoop.java b/logstash-core/src/main/java/org/logstash/execution/WorkerLoop.java
index b0e974d3d54..107460cf01f 100644
--- a/logstash-core/src/main/java/org/logstash/execution/WorkerLoop.java
+++ b/logstash-core/src/main/java/org/logstash/execution/WorkerLoop.java
@@ -25,6 +25,8 @@
 import org.apache.logging.log4j.Logger;
 import org.logstash.config.ir.CompiledPipeline;
 
+import co.elastic.logstash.api.AcknowledgeBus;
+
 public final class WorkerLoop implements Runnable {
 
     private static final Logger LOGGER = LogManager.getLogger(WorkerLoop.class);
@@ -33,6 +35,8 @@ public final class WorkerLoop implements Runnable {
 
     private final QueueReadClient readClient;
 
+    private final AcknowledgeBus acknowledgeBus;
+
     private final AtomicBoolean flushRequested;
 
     private final AtomicBoolean flushing;
@@ -57,6 +61,21 @@ public WorkerLoop(
         final AtomicBoolean shutdownRequested,
         final boolean drainQueue,
         final boolean preserveEventOrder)
+    {
+        this(pipeline, readClient, null, filteredCounter, consumedCounter, flushRequested, flushing, shutdownRequested, drainQueue, preserveEventOrder);
+    }
+
+    public WorkerLoop(
+        final CompiledPipeline pipeline,
+        final QueueReadClient readClient,
+        final AcknowledgeBus acknowledgeBus,
+        final LongAdder filteredCounter,
+        final LongAdder consumedCounter,
+        final AtomicBoolean flushRequested,
+        final AtomicBoolean flushing,
+        final AtomicBoolean shutdownRequested,
+        final boolean drainQueue,
+        final boolean preserveEventOrder)
     {
         this.consumedCounter = consumedCounter;
         this.filteredCounter = filteredCounter;
@@ -67,6 +86,7 @@ public WorkerLoop(
         this.flushing = flushing;
         this.shutdownRequested = shutdownRequested;
         this.preserveEventOrder = preserveEventOrder;
+        this.acknowledgeBus = acknowledgeBus;
     }
 
     @Override
@@ -86,6 +106,9 @@ public void run() {
                     readClient.addOutputMetrics(filteredCount);
                     readClient.addFilteredMetrics(filteredCount);
                     readClient.closeBatch(batch);
+                    if (acknowledgeBus != null && batch.filteredSize() > 0){
+                        acknowledgeBus.acknowledgeEvents(batch.events());
+                    }
                     if (isFlush) {
                         flushing.set(false);
                     }
diff --git a/logstash-core/src/main/java/org/logstash/ext/JrubyEventExtLibrary.java b/logstash-core/src/main/java/org/logstash/ext/JrubyEventExtLibrary.java
index d69c7e64b9d..8a3d43cf862 100644
--- a/logstash-core/src/main/java/org/logstash/ext/JrubyEventExtLibrary.java
+++ b/logstash-core/src/main/java/org/logstash/ext/JrubyEventExtLibrary.java
@@ -44,10 +44,13 @@
 import org.logstash.Rubyfier;
 import org.logstash.Valuefier;
 
+import co.elastic.logstash.api.Acknowledgable;
+import co.elastic.logstash.api.AcknowledgeToken;
+
 public final class JrubyEventExtLibrary {
 
     @JRubyClass(name = "Event")
-    public static final class RubyEvent extends RubyObject {
+    public static final class RubyEvent extends RubyObject implements Acknowledgable {
 
         private static final long serialVersionUID = 1L;
 
@@ -371,5 +374,10 @@ private static int nextHash() {
             final long sequence = SEQUENCE_GENERATOR.incrementAndGet();
             return (int) (sequence ^ sequence >>> 32) + 31;
         }
+
+        @Override
+        public AcknowledgeToken getAcknowledgeToken() {
+            return (this.event == null) ? null : this.event.getAcknowledgeToken();
+        }
     }
 }
diff --git a/logstash-core/src/main/java/org/logstash/plugins/ContextImpl.java b/logstash-core/src/main/java/org/logstash/plugins/ContextImpl.java
index 0fcbdc0327a..f37b3126765 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/ContextImpl.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/ContextImpl.java
@@ -31,16 +31,24 @@
 
 public class ContextImpl implements Context {
 
-    private DeadLetterQueueWriter dlqWriter;
+    private final DeadLetterQueueWriter dlqWriter;
+
+    private final AcknowledgeBus acknowledgeBus;
 
     /**
      * This is a reference to the [stats, pipelines, *name*, plugins] metric namespace.
      */
     private Metric pluginsScopedMetric;
 
-    public ContextImpl(DeadLetterQueueWriter dlqWriter, Metric metric) {
+    public ContextImpl(DeadLetterQueueWriter dlqWriter, Metric metric, AcknowledgeBus acknowledgeBus) {
         this.dlqWriter = dlqWriter;
         this.pluginsScopedMetric = metric;
+        this.acknowledgeBus = acknowledgeBus;
+    }
+
+
+    public ContextImpl(DeadLetterQueueWriter dlqWriter, Metric metric) {
+        this(dlqWriter, metric, null);
     }
 
     @Override
@@ -80,4 +88,9 @@ public Event newEvent(Map<? extends Serializable, Object> data) {
             }
         };
     }
+
+    @Override
+    public AcknowledgeBus getAcknowledgeBus() {
+        return acknowledgeBus;
+    }
 }
diff --git a/logstash-core/src/main/java/org/logstash/plugins/acknowledge/AcknowledgeBus.java b/logstash-core/src/main/java/org/logstash/plugins/acknowledge/AcknowledgeBus.java
new file mode 100644
index 00000000000..36ef3322ca1
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugins/acknowledge/AcknowledgeBus.java
@@ -0,0 +1,108 @@
+/*
+ * Licensed to Elasticsearch B.V. under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch B.V. licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.logstash.plugins.acknowledge;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import co.elastic.logstash.api.Acknowledgable;
+import co.elastic.logstash.api.AcknowledgablePlugin;
+import co.elastic.logstash.api.AcknowledgeTokenFactory;
+
+import java.util.Collection;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.BiFunction;
+
+/**
+ * This class is the communication bus for the `pipeline` inputs and outputs to
+ * talk to each other.
+ *
+ * This class is threadsafe.
+ */
+public class AcknowledgeBus implements co.elastic.logstash.api.AcknowledgeBus {
+
+    final ConcurrentHashMap<String, AcknowledgablePlugin> acknowledgeIdMapping = new ConcurrentHashMap<>();
+    private static final Logger logger = LogManager.getLogger(AcknowledgeBus.class);
+
+    @Override
+    public void acknowledgeEvents(final Collection<? extends Acknowledgable> events) {
+        logger.debug("Received acknowledgeEvents for {} events", events.size());
+        this.proccessEvents(events, AcknowledgablePlugin::acknowledge, "acknowledgeEvents");
+    }
+
+    @Override
+    public void notifyClonedEvents(final Collection<? extends Acknowledgable> events) {
+        logger.debug("Received notifyClonedEvents for {} events", events.size());
+        this.proccessEvents(events, AcknowledgablePlugin::notifyCloned, "notifyClonedEvents");
+    }
+
+    private void proccessEvents(final Collection<? extends Acknowledgable> events,
+            BiFunction<AcknowledgablePlugin, String, Boolean> processId, String processName) {
+        if (events.isEmpty())
+            return; // This can happen on pipeline shutdown or in some other situations
+
+        long acknowledgeCount = events.stream().map(Acknowledgable::getAcknowledgeToken).filter(token -> token != null)
+                .map(token -> {
+                    final AcknowledgablePlugin plugin = acknowledgeIdMapping.get(token.getPluginId());
+                    if (plugin != null) {
+                        logger.debug("Plugin: {} Token: {}", token.getPluginId(), token.getAcknowledgeId());
+                        if (!processId.apply(plugin, token.getAcknowledgeId())) {
+                            logger.warn("{} for plugin: {} was unsuccesful for id: {}", processName, plugin.getId(),
+                                    token.getAcknowledgeId());
+                        }
+                    } else {
+                        logger.warn("Received {} for unknown plugin: {}", processName, token.getPluginId());
+                    }
+                    return null;
+                }).count();
+        logger.debug("Proccessed {} events succesfully for {} ", acknowledgeCount, processName);
+    }
+
+    /**
+     * Should be called by a plugin on register
+     *
+     * @param plugin plugin to be registered
+     * @return an AcknowledgeTokenGenerator instance is succefully registerd
+     *         otherwise null is returned
+     */
+    @Override
+    public AcknowledgeTokenFactory registerPlugin(final AcknowledgablePlugin plugin) {
+        synchronized (plugin) {
+            if (acknowledgeIdMapping.containsKey(plugin.getId())) {
+                return null;
+            }
+            acknowledgeIdMapping.put(plugin.getId(), plugin);
+            return id -> new AcknowledgeTokenImpl(plugin.getId(), id);
+        }
+    }
+
+    /**
+     * Should be called by an plugin on close
+     *
+     * @param plugin output that will be unregistered
+     */
+    @Override
+    public boolean unregisterPlugin(final AcknowledgablePlugin plugin) {
+        synchronized (plugin) {
+            return acknowledgeIdMapping.remove(plugin.getId()) != null;
+        }
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/plugins/acknowledge/AcknowledgeTokenImpl.java b/logstash-core/src/main/java/org/logstash/plugins/acknowledge/AcknowledgeTokenImpl.java
new file mode 100644
index 00000000000..24badcc9599
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugins/acknowledge/AcknowledgeTokenImpl.java
@@ -0,0 +1,76 @@
+package org.logstash.plugins.acknowledge;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+import co.elastic.logstash.api.AcknowledgeToken;
+
+public final class AcknowledgeTokenImpl implements AcknowledgeToken {
+    private final String pluginId;
+    private final String acknowledgeId;
+    // private String pluginId;
+    // private String acknowledgeId;
+
+    // AcknowledgeTokenImpl(){}
+
+    @JsonCreator
+    AcknowledgeTokenImpl(@JsonProperty("pluginId") final String pluginId, @JsonProperty("acknowledgeId") final String acknowledgeId) {
+        if (pluginId == null)
+            throw new IllegalArgumentException("pluginId cannot be null");
+        if (acknowledgeId == null)
+            throw new IllegalArgumentException("acknowledgeId cannot be null");
+        this.pluginId = pluginId;
+        this.acknowledgeId = acknowledgeId;
+    }
+
+    @Override
+    public String getPluginId() {
+        return pluginId;
+    }
+
+    // public void setPluginId(String pluginId) {
+    //     this.pluginId = pluginId;
+    // }
+
+    @Override
+    public String getAcknowledgeId() {
+        return acknowledgeId;
+    }
+
+
+    // public void setAcknowledgeId(String acknowledgeId) {
+    //     this.acknowledgeId = acknowledgeId;
+    // }
+
+    @Override
+    public boolean equals(final Object o) {
+        if (o == this)
+            return true;
+        if (!(o instanceof AcknowledgeToken))
+            return false;
+        final AcknowledgeTokenImpl other = (AcknowledgeTokenImpl) o;
+        if (!other.canEqual((Object) this))
+            return false;
+        if (this.getPluginId() == null ? other.getPluginId() != null
+                : !this.getPluginId().equals(other.getPluginId()))
+            return false;
+        if (this.getAcknowledgeId() == null ? other.getAcknowledgeId() != null
+                : !this.getAcknowledgeId().equals(other.getAcknowledgeId()))
+            return false;
+        return true;
+    }
+
+    protected boolean canEqual(final Object other) {
+        return other instanceof AcknowledgeTokenImpl;
+    }
+
+    @Override
+    public int hashCode() {
+        final int PRIME = 59;
+        int result = 1;
+        result = (result * PRIME) + (this.pluginId == null ? 43 : this.pluginId.hashCode());
+        result = (result * PRIME) + (this.acknowledgeId == null ? 43 : this.acknowledgeId.hashCode());
+        return result;
+    }
+}
+
diff --git a/logstash-core/src/main/java/org/logstash/plugins/factory/ExecutionContextFactoryExt.java b/logstash-core/src/main/java/org/logstash/plugins/factory/ExecutionContextFactoryExt.java
index d72ef4a5cd9..c82d2a3d0b4 100644
--- a/logstash-core/src/main/java/org/logstash/plugins/factory/ExecutionContextFactoryExt.java
+++ b/logstash-core/src/main/java/org/logstash/plugins/factory/ExecutionContextFactoryExt.java
@@ -1,5 +1,6 @@
 package org.logstash.plugins.factory;
 
+import co.elastic.logstash.api.AcknowledgeBus;
 import co.elastic.logstash.api.Context;
 import co.elastic.logstash.api.DeadLetterQueueWriter;
 import org.jruby.Ruby;
@@ -30,6 +31,8 @@ public final class ExecutionContextFactoryExt extends RubyBasicObject {
 
     private IRubyObject dlqWriter;
 
+    private AcknowledgeBus acknowledgeBus;
+
     public ExecutionContextFactoryExt(final Ruby runtime, final RubyClass metaClass) {
         super(runtime, metaClass);
     }
@@ -40,6 +43,13 @@ public ExecutionContextFactoryExt initialize(final ThreadContext context, final
         this.agent = agent;
         this.pipeline = pipeline;
         this.dlqWriter = dlqWriter;
+        this.acknowledgeBus = null;
+        if (agent != null && !agent.isNil()){
+            IRubyObject bus = agent.callMethod(RubyUtil.RUBY.getCurrentContext(), "acknowledge_bus");
+            if (bus != null && !bus.isNil() && AcknowledgeBus.class.isAssignableFrom(bus.getJavaClass())){
+                this.acknowledgeBus = bus.toJava(AcknowledgeBus.class);
+            }
+        }
         return this;
     }
 
@@ -67,8 +77,12 @@ Context toContext(PluginLookup.PluginType pluginType, AbstractNamespacedMetricEx
         } else if (dlqWriter.getJavaClass().equals(DeadLetterQueueWriter.class)) {
             dlq = dlqWriter.toJava(DeadLetterQueueWriter.class);
         }
+        AcknowledgeBus ack_bus = null;
+        if (pluginType == PluginLookup.PluginType.INPUT){
+            ack_bus = this.acknowledgeBus;
+        }
 
-        return new ContextImpl(dlq, new NamespacedMetricImpl(RubyUtil.RUBY.getCurrentContext(), metric));
+        return new ContextImpl(dlq, new NamespacedMetricImpl(RubyUtil.RUBY.getCurrentContext(), metric), ack_bus);
     }
 
     IRubyObject getPipeline() {
diff --git a/logstash-core/src/main/java/org/logstash/plugins/inputs/AckedGenerator.java b/logstash-core/src/main/java/org/logstash/plugins/inputs/AckedGenerator.java
new file mode 100644
index 00000000000..becdc702ac6
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/plugins/inputs/AckedGenerator.java
@@ -0,0 +1,126 @@
+/*
+ * Licensed to Elasticsearch B.V. under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch B.V. licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.logstash.plugins.inputs;
+
+import co.elastic.logstash.api.AcknowledgablePlugin;
+import co.elastic.logstash.api.AcknowledgeBus;
+import co.elastic.logstash.api.AcknowledgeTokenFactory;
+import co.elastic.logstash.api.Configuration;
+import co.elastic.logstash.api.Context;
+import co.elastic.logstash.api.LogstashPlugin;
+import co.elastic.logstash.api.PluginConfigSpec;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Consumer;
+
+import org.apache.logging.log4j.Logger;
+import org.joda.time.DateTime;
+
+@LogstashPlugin(name = "java_acked_generator")
+public class AckedGenerator extends Generator implements AcknowledgablePlugin {
+
+    private final Logger logger;
+    private final AcknowledgeBus acknowledgeBus;
+    private final AcknowledgeTokenFactory acknowledgeTokenFactory;
+    private final AtomicLong tokenCount;
+    private final AtomicLong awaitCount;
+    private final CountDownLatch countDownLatch;
+    private boolean isStopping;
+
+    /**
+     * Required constructor.
+     *
+     * @param id            Plugin id
+     * @param configuration Logstash Configuration
+     * @param context       Logstash Context
+     */
+    public AckedGenerator(final String id, final Configuration configuration, final Context context) {
+        super(id, configuration, context);
+        this.logger = context.getLogger(this);
+        this.acknowledgeBus = context.getAcknowledgeBus();
+        this.tokenCount = new AtomicLong();
+        this.awaitCount = new AtomicLong();
+        this.countDownLatch = new CountDownLatch(1);
+        this.isStopping = false;
+        if (this.acknowledgeBus == null
+                || (this.acknowledgeTokenFactory = this.acknowledgeBus.registerPlugin(this)) == null) {
+            throw new RuntimeException("Unable to register plugin on acknowledgeBus");
+        }
+    }
+
+    @Override
+    public void start(Consumer<Map<String, Object>> writer) {
+        Consumer<Map<String, Object>> wrappedWriter = (map) -> {
+            String token = Long.toString(this.tokenCount.getAndIncrement());
+            this.awaitCount.incrementAndGet();
+            map.put("@acknowledge_token",
+                    acknowledgeTokenFactory.generateToken(token));
+            logger.info("[{}] Pushing generated event number: {}", DateTime.now(), token);
+            writer.accept(map);
+        };
+        super.start(wrappedWriter);
+    }
+
+    @Override
+    public void stop() {
+        super.stop();
+        this.isStopping = true;
+    }
+
+    @Override
+    public void awaitStop() throws InterruptedException {
+        super.awaitStop();
+        if (this.awaitCount.get() > 0) {
+            logger.info("Awaiting {} acknowledges before stopping", this.awaitCount.get());
+            this.countDownLatch.await();
+        }
+    }
+
+    @Override
+    public Collection<PluginConfigSpec<?>> configSchema() {
+        return super.configSchema();
+    }
+
+    @Override
+    public String getId() {
+        return super.getId();
+    }
+
+    @Override
+    public boolean acknowledge(String acknowledgeId) {
+        logger.info("Acknowledged generated event number: {}", acknowledgeId);
+        long count = this.awaitCount.decrementAndGet();
+        logger.info("Awaiting {} acknowledges", count);
+        if (this.isStopping && count == 0){
+            this.countDownLatch.countDown();
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notifyCloned(String acknowledgeId) {
+        logger.info("Generated event number: {} crossed pipeline boundries/was cloned", acknowledgeId);
+        this.awaitCount.incrementAndGet();
+        return false;
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/plugins/acknowledge/AcknowledgeBusTest.java b/logstash-core/src/test/java/org/logstash/plugins/acknowledge/AcknowledgeBusTest.java
new file mode 100644
index 00000000000..ea9aea34b2a
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/plugins/acknowledge/AcknowledgeBusTest.java
@@ -0,0 +1,229 @@
+/*
+ * Licensed to Elasticsearch B.V. under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch B.V. licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.logstash.plugins.acknowledge;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+import org.logstash.Event;
+import org.logstash.RubyUtil;
+import org.logstash.ext.JrubyEventExtLibrary;
+
+import co.elastic.logstash.api.AcknowledgablePlugin;
+import co.elastic.logstash.api.AcknowledgeBus;
+import co.elastic.logstash.api.AcknowledgeToken;
+import co.elastic.logstash.api.AcknowledgeTokenFactory;
+import co.elastic.logstash.api.PluginConfigSpec;
+
+public class AcknowledgeBusTest {
+
+    AcknowledgeBus bus;
+    TestAcknowledgePlugin plugin;
+    static String pluginId = "test_acknowledge_input";
+
+    @Before
+    public void setup() {
+        bus = new org.logstash.plugins.acknowledge.AcknowledgeBus();
+        plugin = new TestAcknowledgePlugin(pluginId);
+    }
+
+    @Test
+    public void registerUnregister() throws InterruptedException {
+        Object factory = bus.registerPlugin(plugin);
+        assertThat(factory).isInstanceOf(AcknowledgeTokenFactory.class);
+
+        assertThat(bus.unregisterPlugin(plugin)).isTrue();
+        assertThat(bus.unregisterPlugin(plugin)).isFalse();
+    }
+
+    @Test
+    public void registerAndReceiveAcknowledge() throws InterruptedException {
+        AcknowledgeTokenFactory factory = bus.registerPlugin(plugin);
+        Collection<JrubyEventExtLibrary.RubyEvent> events = Arrays.asList(
+            rubyEvent(),
+            rubyEvent(factory.generateToken("1")),
+            rubyEvent(),
+            rubyEvent(factory.generateToken("2")),
+            rubyEvent()
+        );
+        bus.acknowledgeEvents(events);
+        assertThat(plugin.acknowledged.size()).isEqualTo(2);
+        assertThat(plugin.acknowledged).contains("2", "1");
+        assertThat(plugin.cloned.size()).isEqualTo(0);
+    }
+
+    @Test
+    public void registerAndReceiveCloned() throws InterruptedException {
+        AcknowledgeTokenFactory factory = bus.registerPlugin(plugin);
+        Collection<JrubyEventExtLibrary.RubyEvent> events = Arrays.asList(
+            rubyEvent(),
+            rubyEvent(factory.generateToken("1")),
+            rubyEvent(),
+            rubyEvent(factory.generateToken("2")),
+            rubyEvent()
+        );
+        bus.notifyClonedEvents(events);
+        assertThat(plugin.cloned.size()).isEqualTo(2);
+        assertThat(plugin.cloned).contains("2", "1");
+        assertThat(plugin.acknowledged.size()).isEqualTo(0);
+    }
+
+    @Test
+    public void registerUnregisterNoReceiveCloned() throws InterruptedException {
+        AcknowledgeTokenFactory factory = bus.registerPlugin(plugin);
+        Collection<JrubyEventExtLibrary.RubyEvent> events = Arrays.asList(
+            rubyEvent(),
+            rubyEvent(factory.generateToken("1")),
+            rubyEvent(),
+            rubyEvent(factory.generateToken("2")),
+            rubyEvent()
+        );
+        assertThat(bus.unregisterPlugin(plugin)).isTrue();
+
+        bus.notifyClonedEvents(events);
+        assertThat(plugin.cloned.size()).isEqualTo(0);
+        assertThat(plugin.acknowledged.size()).isEqualTo(0);
+    }
+
+    @Test
+    public void registerUnregisterNoReceiveAcknowledged() throws InterruptedException {
+        AcknowledgeTokenFactory factory = bus.registerPlugin(plugin);
+        Collection<JrubyEventExtLibrary.RubyEvent> events = Arrays.asList(
+            rubyEvent(),
+            rubyEvent(factory.generateToken("1")),
+            rubyEvent(),
+            rubyEvent(factory.generateToken("2")),
+            rubyEvent()
+        );
+        assertThat(bus.unregisterPlugin(plugin)).isTrue();
+
+        bus.acknowledgeEvents(events);
+        assertThat(plugin.cloned.size()).isEqualTo(0);
+        assertThat(plugin.acknowledged.size()).isEqualTo(0);
+    }
+
+    @Test
+    public void registerDoubleIdReturnsNull() throws InterruptedException {
+        TestAcknowledgePlugin plugin2 = new TestAcknowledgePlugin(pluginId);
+        Object factory1 = bus.registerPlugin(plugin);
+        Object factory2 = bus.registerPlugin(plugin2);
+
+        assertThat(factory1).isNotNull();
+        assertThat(factory1).isInstanceOf(AcknowledgeTokenFactory.class);
+        assertThat(factory2).isNull();
+    }
+
+    @Test
+    public void registerMultipleReceiveBySingle() throws InterruptedException {
+        TestAcknowledgePlugin plugin2 = new TestAcknowledgePlugin("plugin2");
+        AcknowledgeTokenFactory factory1 = bus.registerPlugin(plugin);
+        AcknowledgeTokenFactory factory2 = bus.registerPlugin(plugin2);
+        Collection<JrubyEventExtLibrary.RubyEvent> events = Arrays.asList(
+            rubyEvent(),
+            rubyEvent(factory1.generateToken("1")),
+            rubyEvent(factory2.generateToken("1")),
+            rubyEvent(factory1.generateToken("2")),
+            rubyEvent(factory1.generateToken("3")),
+            rubyEvent(factory2.generateToken("4"))
+        );
+        bus.acknowledgeEvents(events);
+        bus.notifyClonedEvents(events);
+        assertThat(plugin.cloned.size()).isEqualTo(3);
+        assertThat(plugin.cloned).contains("2", "3", "1");
+        assertThat(plugin.acknowledged.size()).isEqualTo(3);
+        assertThat(plugin.acknowledged).contains("2", "3", "1");
+        assertThat(plugin2.cloned.size()).isEqualTo(2);
+        assertThat(plugin2.cloned).contains("4", "1");
+        assertThat(plugin2.acknowledged.size()).isEqualTo(2);
+        assertThat(plugin2.acknowledged).contains("4", "1");
+    }
+
+    @Test
+    public void receiveAcknowledgeUnknownPlugin() throws InterruptedException {
+        bus.registerPlugin(plugin);
+        AcknowledgeToken token = new AcknowledgeToken(){
+            @Override
+            public String getPluginId() {
+                return "Non_existing_plugin";
+            }
+
+            @Override
+            public String getAcknowledgeId() {
+                return "dummyId";
+            }
+        };
+        Collection<JrubyEventExtLibrary.RubyEvent> events = Arrays.asList(
+            rubyEvent(token),
+            rubyEvent()
+        );
+
+        bus.acknowledgeEvents(events);
+        bus.notifyClonedEvents(events);
+
+        assertThat(plugin.cloned.size()).isEqualTo(0);
+        assertThat(plugin.acknowledged.size()).isEqualTo(0);
+    }
+
+    private JrubyEventExtLibrary.RubyEvent rubyEvent() {
+        return JrubyEventExtLibrary.RubyEvent.newRubyEvent(RubyUtil.RUBY);
+    }
+    private JrubyEventExtLibrary.RubyEvent rubyEvent(AcknowledgeToken token) {
+        return JrubyEventExtLibrary.RubyEvent.newRubyEvent(RubyUtil.RUBY, new Event(token));
+    }
+
+    static class TestAcknowledgePlugin implements AcknowledgablePlugin {
+        public List<String> acknowledged = new ArrayList<>();
+        public List<String> cloned = new ArrayList<>();
+
+        private String id;
+
+        TestAcknowledgePlugin(String id){
+            this.id = id;
+        }
+
+        @Override
+        public Collection<PluginConfigSpec<?>> configSchema() {
+            return null;
+        }
+
+        @Override
+        public String getId() {
+            return id;
+        }
+
+        @Override
+        public boolean acknowledge(String acknowledgeId) {
+            return acknowledged.add(acknowledgeId);
+        }
+
+        @Override
+        public boolean notifyCloned(String acknowledgeId) {
+            return cloned.add(acknowledgeId);
+        }
+    }
+
+}
\ No newline at end of file
