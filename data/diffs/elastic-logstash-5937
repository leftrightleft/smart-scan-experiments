diff --git a/.gitignore b/.gitignore
index 0bf92be54e3..aba71f73b20 100644
--- a/.gitignore
+++ b/.gitignore
@@ -37,3 +37,4 @@ qa/Gemfile.lock
 *.iml
 .gradle
 .idea
+**/.gradle
\ No newline at end of file
diff --git a/logstash-core/lib/logstash/compiler.rb b/logstash-core/lib/logstash/compiler.rb
new file mode 100644
index 00000000000..38573330f74
--- /dev/null
+++ b/logstash-core/lib/logstash/compiler.rb
@@ -0,0 +1,12 @@
+module LogStash; class Compiler
+  def self.compile(config_str, filename="<unknown>")
+    grammar = LogStashConfigParser.new
+    config = grammar.parse(config_str)
+
+    if config.nil?
+      raise ConfigurationError, grammar.failure_reason
+    end
+    
+    compiled = config.compile(filename)
+  end
+end; end
diff --git a/logstash-core/lib/logstash/config/config_ast.rb b/logstash-core/lib/logstash/config/config_ast.rb
index ce6295a6933..bc2de0c34d3 100644
--- a/logstash-core/lib/logstash/config/config_ast.rb
+++ b/logstash-core/lib/logstash/config/config_ast.rb
@@ -1,15 +1,11 @@
 # encoding: utf-8
 require 'logstash/errors'
 require "treetop"
+java_import Java::OrgLogstashConfigIr::DSL
+java_import Java::OrgLogstashConfigIr::SourceMetadata
 
 class Treetop::Runtime::SyntaxNode
-
-  def compile
-    return "" if elements.nil?
-    return elements.collect(&:compile).reject(&:empty?).join("")
-  end
-
-  # Traverse the syntax tree recursively.
+  # Traverse the sourceComponent tree recursively.
   # The order should respect the order of the configuration file as it is read
   # and written by humans (and the order in which it is parsed).
   def recurse(e, depth=0, &block)
@@ -30,15 +26,15 @@ def recursive_inject(results=[], &block)
     end
     return results
   end
-
+  
   # When Treetop parses the configuration file
   # it will generate a tree, the generated tree will contain
   # a few `Empty` nodes to represent the actual space/tab or newline in the file.
   # Some of theses node will point to our concrete class.
   # To fetch a specific types of object we need to follow each branch
   # and ignore the empty nodes.
-  def recursive_select(klass)
-    return recursive_inject { |e| e.is_a?(klass) }
+  def recursive_select(*klasses)
+    return recursive_inject { |e| klasses.any? {|k| e.is_a?(k)} }
   end
 
   def recursive_inject_parent(results=[], &block)
@@ -59,164 +55,105 @@ def recursive_select_parent(results=[], klass)
 
 
 module LogStash; module Config; module AST
+  module JDSL                                  
+    def source_meta
+      line, column = line_and_column
+      filename = Thread.current[:current_treetop_filename]
+      Java::OrgLogstashConfigIr::SourceMetadata.new(nil, line, column, self.text_value)
+    end
 
-  def self.defered_conditionals=(val)
-    @defered_conditionals = val
-  end
-
-  def self.defered_conditionals
-    @defered_conditionals
-  end
-
-  def self.defered_conditionals_index
-    @defered_conditionals_index
-  end
-
-  def self.defered_conditionals_index=(val)
-    @defered_conditionals_index = val
-  end
-
-  def self.plugin_instance_index
-    @plugin_instance_index
-  end
+    def line_and_column
+      lines_to_first_char = self.input[0..self.interval.first].split("\n")
 
-  def self.plugin_instance_index=(val)
-    @plugin_instance_index = val
+      line = lines_to_first_char.size
+      column = lines_to_first_char.last.size
+      
+      [line, column]
+    end
+  
+    def empty_source_meta()
+      Java::OrgLogstashConfigIr::SourceMetadata.new()
+    end
+    
+    def jdsl
+      Java::OrgLogstashConfigIr::DSL
+    end
   end
-
+  
   class Node < Treetop::Runtime::SyntaxNode
+    include JDSL
+    
     def text_value_for_comments
       text_value.gsub(/[\r\n]/, " ")
     end
+
+    def ssym(text, meta={})
+      SyntaxSymbol.new(text, meta)
+    end
   end
 
   class Config < Node
-    def compile
-      LogStash::Config::AST.defered_conditionals = []
-      LogStash::Config::AST.defered_conditionals_index = 0
-      LogStash::Config::AST.plugin_instance_index = 0
-      code = []
-
-      code << <<-CODE
-        @inputs = []
-        @filters = []
-        @outputs = []
-        @periodic_flushers = []
-        @shutdown_flushers = []
-        @generated_objects = {}
-      CODE
-
+    def compile(filename="<unknown>")
+      # There is no way to move vars across nodes in treetop :(
+      Thread.current[:current_treetop_filename] = filename
+      
       sections = recursive_select(LogStash::Config::AST::PluginSection)
-      sections.each do |s|
-        code << s.compile_initializer
-      end
-
-      # start inputs
-      definitions = []
-
-      ["filter", "output"].each do |type|
-        # defines @filter_func and @output_func
-
-        # This need to be defined as a singleton method
-        # so each instance of the pipeline has his own implementation
-        # of the output/filter function
-        definitions << "define_singleton_method :#{type}_func do |event|"
-        definitions << "  targeted_outputs = []" if type == "output"
-        definitions << "  events = [event]" if type == "filter"
-        definitions << "  @logger.debug? && @logger.debug(\"#{type} received\", \"event\" => event.to_hash)"
-
-        sections.select { |s| s.plugin_type.text_value == type }.each do |s|
-          definitions << s.compile.split("\n", -1).map { |e| "  #{e}" }
+      
+      section_map = {
+        :input  => [],
+        :filter => [],
+        :output => []
+      }
+            
+      sections.each do |section|
+        section_name = section.plugin_type.text_value.to_sym
+        section_expr = section.expr
+        raise "Unknown section name #{section_name}!" if ![:input, :output, :filter].include?(section_name)
+        # Don't include nil section exprs!
+        ::Array[section_expr].each do |se|
+          section_map[section_name].concat se
         end
-
-        definitions << "  events" if type == "filter"
-        definitions << "  targeted_outputs" if type == "output"
-        definitions << "end"
       end
 
-      code += definitions.join("\n").split("\n", -1).collect { |l| "  #{l}" }
+      # Represent filter / output blocks as a single composed statement
+      section_map.keys.each do |key|
+        section_map[key] = jdsl.iCompose(empty_source_meta, *section_map[key])
+      end
+      
+      section_map
+    end
+  end
 
-      code += LogStash::Config::AST.defered_conditionals
+  class Comment < Node
+    def significant
+      false
+    end
 
-      return code.join("\n")
+  end
+  
+  class Whitespace < Node
+    def significant
+      false
     end
   end
-
-  class Comment < Node; end
-  class Whitespace < Node; end
   class PluginSection < Node
     # Global plugin numbering for the janky instance variable naming we use
     # like @filter_<name>_1
-    def initialize(*args)
-      super(*args)
+    def expr
+      [*recursive_select(Branch, Plugin).map(&:expr)]
     end
 
-    # Generate ruby code to initialize all the plugins.
-    def compile_initializer
-      generate_variables
-      code = []
-      @variables.each do |plugin, name|
-
-
-        code << <<-CODE
-          @generated_objects[:#{name}] = #{plugin.compile_initializer}
-          @#{plugin.plugin_type}s << @generated_objects[:#{name}]
-        CODE
-
-        # The flush method for this filter.
-        if plugin.plugin_type == "filter"
-
-          code << <<-CODE
-            @generated_objects[:#{name}_flush] = lambda do |options, &block|
-              @logger.debug? && @logger.debug(\"Flushing\", :plugin => @generated_objects[:#{name}])
-
-              events = @generated_objects[:#{name}].flush(options)
-
-              return if events.nil? || events.empty?
-
-              @logger.debug? && @logger.debug(\"Flushing\", :plugin => @generated_objects[:#{name}], :events => events.map { |x| x.to_hash  })
-
-              #{plugin.compile_starting_here.gsub(/^/, "  ")}
-
-              events.each{|e| block.call(e)}
-            end
-
-            if @generated_objects[:#{name}].respond_to?(:flush)
-              @periodic_flushers << @generated_objects[:#{name}_flush] if @generated_objects[:#{name}].periodic_flush
-              @shutdown_flushers << @generated_objects[:#{name}_flush]
-            end
-          CODE
-
-        end
-      end
-      return code.join("\n")
-    end
-
-    def variable(object)
-      generate_variables
-      return @variables[object]
+    def section_type
+      self.elements.first.text_value.to_sym
     end
-
-    def generate_variables
-      return if !@variables.nil?
-      @variables = {}
-      plugins = recursive_select(Plugin)
-
-      plugins.each do |plugin|
-        # Unique number for every plugin.
-        LogStash::Config::AST.plugin_instance_index += 1
-        # store things as ivars, like @filter_grok_3
-        var = :"#{plugin.plugin_type}_#{plugin.plugin_name}_#{LogStash::Config::AST.plugin_instance_index}"
-        # puts("var=#{var.inspect}")
-        @variables[plugin] = var
-      end
-      return @variables
-    end
-
   end
 
   class Plugins < Node; end
   class Plugin < Node
+    def expr
+      jdsl.iPlugin(source_meta, self.plugin_name, self.expr_attributes)
+    end
+
     def plugin_type
       if recursive_select_parent(Plugin).any?
         return "codec"
@@ -233,122 +170,59 @@ def variable_name
       return recursive_select_parent(PluginSection).first.variable(self)
     end
 
-    def compile_initializer
-      # If any parent is a Plugin, this must be a codec.
-
-      if attributes.elements.nil?
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect})" << (plugin_type == "codec" ? "" : "\n")
-      else
-        settings = attributes.recursive_select(Attribute).collect(&:compile).reject(&:empty?)
-
-        attributes_code = "LogStash::Util.hash_merge_many(#{settings.map { |c| "{ #{c} }" }.join(", ")})"
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, #{attributes_code})" << (plugin_type == "codec" ? "" : "\n")
-      end
-    end
-
-    def compile
-      case plugin_type
-      when "input"
-        return "start_input(@generated_objects[:#{variable_name}])"
-      when "filter"
-        return <<-CODE
-          events = @generated_objects[:#{variable_name}].multi_filter(events)
-        CODE
-      when "output"
-        return "targeted_outputs << @generated_objects[:#{variable_name}]\n"
-      when "codec"
-        settings = attributes.recursive_select(Attribute).collect(&:compile).reject(&:empty?)
-        attributes_code = "LogStash::Util.hash_merge_many(#{settings.map { |c| "{ #{c} }" }.join(", ")})"
-        return "plugin(#{plugin_type.inspect}, #{plugin_name.inspect}, #{attributes_code})"
-      end
-    end
-
-    def compile_starting_here
-      return unless plugin_type == "filter" # only filter supported.
-
-      expressions = [
-        LogStash::Config::AST::Branch,
-        LogStash::Config::AST::Plugin
-      ]
-      code = []
-
-      # Find the branch we are in, if any (the 'if' statement, etc)
-      self_branch = recursive_select_parent(LogStash::Config::AST::BranchEntry).first
-
-      # Find any siblings to our branch so we can skip them later.  For example,
-      # if we are in an 'else if' we want to skip any sibling 'else if' or
-      # 'else' blocks.
-      branch_siblings = []
-      if self_branch
-        branch_siblings = recursive_select_parent(LogStash::Config::AST::Branch).first \
-          .recursive_select(LogStash::Config::AST::BranchEntry) \
-          .reject { |b| b == self_branch }
-      end
-
-      #ast = recursive_select_parent(LogStash::Config::AST::PluginSection).first
-      ast = recursive_select_parent(LogStash::Config::AST::Config).first
-
-      found = false
-      recurse(ast) do |element, depth|
-        next false if element.is_a?(LogStash::Config::AST::PluginSection) && element.plugin_type.text_value != "filter"
-        if element == self
-          found = true
-          next false
-        end
-        if found && expressions.include?(element.class)
-          code << element.compile
-          next false
+    def expr_attributes
+      # Turn attributes into a hash map
+      self.attributes.recursive_select(Attribute).map(&:expr).map {|k,v|
+        if v.java_kind_of?(Java::OrgLogstashConfigIrExpression::ValueExpression)
+          [k, v.get]
+        else
+          [k,v]
         end
-        next false if branch_siblings.include?(element)
-        next true
+      }.reduce({}) do |hash,kv|
+        k,v = kv
+        hash[k] = v
+        hash
       end
-
-      return code.collect { |l| "#{l}\n" }.join("")
-    end # def compile_starting_here
+       
+    end
   end
 
   class Name < Node
-    def compile
-      return text_value.inspect
+    def expr
+      return text_value
     end
   end
   class Attribute < Node
-    def compile
-      return %Q(#{name.compile} => #{value.compile})
+    def expr
+      [name.text_value, value.expr]
     end
   end
   class RValue < Node; end
   class Value < RValue; end
 
-  module Unicode
-    def self.wrap(text)
-      return "(" + text.force_encoding(Encoding::UTF_8).inspect + ")"
-    end
-  end
-
   class Bareword < Value
-    def compile
-      return Unicode.wrap(text_value)
+    def expr
+      jdsl.eValue(source_meta, text_value)
     end
   end
   class String < Value
-    def compile
-      return Unicode.wrap(text_value[1...-1])
+    def expr
+      jdsl.eValue(source_meta, text_value[1...-1])
     end
   end
   class RegExp < Value
-    def compile
-      return "Regexp.new(" + Unicode.wrap(text_value[1...-1]) + ")"
+    def expr
+      jdsl.eRegex(text_value[1..-2])
     end
   end
   class Number < Value
-    def compile
-      return text_value
+    def expr
+      jdsl.eValue(source_meta, text_value.include?(".") ? text_value.to_f : text_value.to_i)
     end
   end
   class Array < Value
-    def compile
-      return "[" << recursive_select(Value).collect(&:compile).reject(&:empty?).join(", ") << "]"
+    def expr
+      jdsl.eValue(source_meta, recursive_select(Value).map(&:expr).map(&:get))
     end
   end
   class Hash < Value
@@ -373,9 +247,9 @@ def find_duplicate_keys
       values.find_all { |v| values.count(v) > 1 }.uniq
     end
 
-    def compile
+    def expr
       validate!
-      return "{" << recursive_select(HashEntry).collect(&:compile).reject(&:empty?).join(", ") << "}"
+      ::Hash[recursive_select(HashEntry).map(&:expr)]
     end
   end
 
@@ -383,111 +257,228 @@ class HashEntries < Node
   end
 
   class HashEntry < Node
-    def compile
-      return %Q(#{name.compile} => #{value.compile})
+    def expr
+      return [name.expr.get, value.expr.get()]
     end
   end
 
-  class BranchOrPlugin < Node; end
-
   class Branch < Node
-    def compile
-
-      # this construct is non obvious. we need to loop through each event and apply the conditional.
-      # each branch of a conditional will contain a construct (a filter for example) that also loops through
-      # the events variable so we have to initialize it to [event] for the branch code.
-      # at the end, events is returned to handle the case where no branch match and no branch code is executed
-      # so we must make sure to return the current event.
-
-      type = recursive_select_parent(PluginSection).first.plugin_type.text_value
-
-      if type == "filter"
-        i = LogStash::Config::AST.defered_conditionals_index += 1
-        source = <<-CODE
-          @generated_objects[:cond_func_#{i}] = lambda do |input_events|
-            result = []
-            input_events.each do |event|
-              events = [event]
-              #{super}
-              end
-              result += events
-            end
-            result
-          end
-        CODE
-        LogStash::Config::AST.defered_conditionals << source
-
-        <<-CODE
-          events = @generated_objects[:cond_func_#{i}].call(events)
-        CODE
-      else # Output
-        <<-CODE
-          #{super}
+    def expr
+      # Build this stuff as s-expressions for convenience at first (they're mutable)
+      
+      exprs = []
+      else_stack = [] # For turning if / elsif / else into nested ifs
+
+      self.recursive_select(Plugin, If, Elsif, Else).each do |node|        
+        if node.is_a?(If)
+          exprs << :if
+          exprs << expr_cond(node)
+          exprs << expr_body(node)
+        elsif node.is_a?(Elsif)
+          condition = expr_cond(node)
+          body = expr_body(node)
+          
+          else_stack << [:if, condition, body]
+        elsif node.is_a?(Else)
+          body = expr_body(node)
+          if else_stack.size >= 1
+            else_stack.last << body
+          else
+            exprs << body
           end
-        CODE
+        end
+      end
+
+      else_stack.reverse.each_cons(2) do |cons|
+        later,earlier = cons
+        earlier << later
       end
+      exprs << else_stack.first
+
+      # Then convert to the imperative java IR
+      javaify_sexpr(exprs)
+    end
+
+    def javaify_sexpr(sexpr)
+      return nil if sexpr.nil?
+      
+      head, tail = sexpr.first
+      tail = sexpr[1..-1]
+
+      if head == :if
+        condition, t_branch, f_branch = tail
+
+        java_t_branch = t_branch && javaify_sexpr(t_branch)
+        java_f_branch = f_branch && javaify_sexpr(f_branch)
+        
+        if java_t_branch || java_f_branch
+          # Invert the expression and make the f_branch the t_branch
+          
+          jdsl.iIf(condition, java_t_branch || jdsl.noop, java_f_branch || jdsl.noop)
+        else
+          jdsl.noop()
+        end
+      elsif head == :compose
+        tail && tail.size > 0 ? jdsl.iCompose(*tail) : jdsl.noop
+      else
+        raise "Unknown expression #{head}!"
+      end
+    end
+
+    def expr_cond(node)
+      node.elements.find {|e| e.is_a?(Condition)}.expr
+    end
+
+    def expr_body(node)
+      [:compose, *node.recursive_select(Plugin, Branch).map(&:expr)]
     end
   end
 
   class BranchEntry < Node; end
 
   class If < BranchEntry
-    def compile
-      children = recursive_inject { |e| e.is_a?(Branch) || e.is_a?(Plugin) }
-      return "if #{condition.compile} # if #{condition.text_value_for_comments}\n" \
-        << children.collect(&:compile).map { |s| s.split("\n", -1).map { |l| "  " + l }.join("\n") }.join("") << "\n"
-    end
   end
   class Elsif < BranchEntry
-    def compile
-      children = recursive_inject { |e| e.is_a?(Branch) || e.is_a?(Plugin) }
-      return "elsif #{condition.compile} # else if #{condition.text_value_for_comments}\n" \
-        << children.collect(&:compile).map { |s| s.split("\n", -1).map { |l| "  " + l }.join("\n") }.join("") << "\n"
-    end
   end
   class Else < BranchEntry
-    def compile
-      children = recursive_inject { |e| e.is_a?(Branch) || e.is_a?(Plugin) }
-      return "else\n" \
-        << children.collect(&:compile).map { |s| s.split("\n", -1).map { |l| "  " + l }.join("\n") }.join("") << "\n"
-    end
   end
 
   class Condition < Node
-    def compile
-      return "(#{super})"
+    def expr
+      first_element = elements.first
+      rest_elements = elements.size > 1 ? elements[1].recursive_select(BooleanOperator, Expression, SelectorElement) : []
+
+      all_elements = [first_element, *rest_elements]
+
+      if all_elements.size == 1
+        elem = all_elements.first
+        if elem.is_a?(Selector)
+          eventValue = elem.recursive_select(SelectorElement).first.expr
+          jdsl.eNotNull(eventValue)
+        elsif elem.is_a?(RegexpExpression)
+          elem.value
+        else
+          join_conditions(all_elements)
+        end
+      else
+      
+        join_conditions(all_elements) # Is this necessary?
+      end 
+    end
+
+    def precedence(op)
+      #  Believe this is right for logstash?
+      case op
+      when :and
+        2
+      when :or
+        1
+      else
+        raise ArgumentError, "Unexpected operator #{op}"
+      end
+    end
+
+    def jconvert(sexpr)
+      return sexpr if sexpr.java_kind_of?(Java::OrgLogstashConfigIrExpression::BooleanExpression)
+      
+      op, left, right = sexpr
+      jop = case op
+            when :and
+              org.logstash.config.ir.expression.BinaryBooleanExpression::Operator::AND
+            when :or
+              org.logstash.config.ir.expression.BinaryBooleanExpression::Operator::OR
+            else
+              raise "Unknown op #{jop}"
+            end
+
+      right_converted = right(left) if right.is_a?(Array)
+      jdsl.eBinaryBoolean(jop, jconvert(left), jconvert(right))
+    end
+
+    def join_conditions(all_elements)
+      # Use Dijkstra's shunting yard algorithm
+      out = []
+      operators = []
+
+      all_elements.each do |e|
+        e_exp = e.expr
+
+        if e.is_a?(BooleanOperator)
+          if operators.last && precedence(operators.last) > precedence(e_exp)
+            out << operators.pop
+          end
+          operators << e_exp
+        else
+          out << e_exp
+        end
+      end
+      operators.reverse.each {|o| out << o}
+
+      stack = []
+      expr = []
+      x = false
+      out.each do |e|
+        if e.is_a?(Symbol)
+          x = 1
+          rval, lval = stack.pop, stack.pop
+          stack << jconvert([e, lval, rval])
+        else
+          stack << e
+        end
+      end
+
+      if stack.size > 1
+        raise "Stack size should never be > than 1!"
+      end
+      return stack.first
     end
   end
 
   module Expression
-    def compile
-      return "(#{super})"
+    def expr
+      return self.value if self.respond_to?(:value) 
+
+      self.recursive_select(Condition, Expression).map {|e| e.respond_to?(:value) ? e.value : e.expr }.first
     end
   end
 
   module NegativeExpression
-    def compile
-      return "!(#{super})"
+    include JDSL
+    
+    def value
+      jdsl.eNot(self.recursive_select(Condition).map(&:expr).first)
     end
   end
 
-  module ComparisonExpression; end
+  module ComparisonExpression
+    include JDSL
+    
+    def value
+      lval, op, rval = self.recursive_select(Selector, ComparisonOperator, Number, String).map(&:expr)
+      jdsl.eBinaryBoolean(source_meta, op, lval, rval)
+    end
+  end
 
   module InExpression
-    def compile
+    include JDSL
+    
+    def value # Because this is somehow higher up the inheritance chain than Expression
       item, list = recursive_select(LogStash::Config::AST::RValue)
-      return "(x = #{list.compile}; x.respond_to?(:include?) && x.include?(#{item.compile}))"
+      jdsl.eIn(item.expr, list.expr)
     end
   end
 
   module NotInExpression
-    def compile
+    include JDSL
+    
+    def value
       item, list = recursive_select(LogStash::Config::AST::RValue)
-      return "(x = #{list.compile}; !x.respond_to?(:include?) || !x.include?(#{item.compile}))"
+      jdsl.eNot(jdsl.eIn(item.expr, list.expr))
     end
   end
 
   class MethodCall < Node
+    # TBD: Can we delete this? Who uses the method call syntax?
     def compile
       arguments = recursive_inject { |e| [String, Number, Selector, Array, MethodCall].any? { |c| e.is_a?(c) } }
       return "#{method.text_value}(" << arguments.collect(&:compile).join(", ") << ")"
@@ -495,40 +486,67 @@ def compile
   end
 
   class RegexpExpression < Node
-    def compile
-      operator = recursive_select(LogStash::Config::AST::RegExpOperator).first.text_value
-      item, regexp = recursive_select(LogStash::Config::AST::RValue)
-      # Compile strings to regexp's
-      if regexp.is_a?(LogStash::Config::AST::String)
-        regexp = "/#{regexp.text_value[1..-2]}/"
-      else
-        regexp = regexp.compile
-      end
-      return "(#{item.compile} #{operator} #{regexp})"
+    def value
+      selector, operator, regexp = recursive_select(Selector, LogStash::Config::AST::RegExpOperator, LogStash::Config::AST::RegExp).map(&:expr)
+
+      raise "Expected a selector #{text_value}!" unless selector
+      raise "Expected a regexp #{text_value}!" unless regexp
+
+      jdsl.eBinaryBoolean(source_meta, operator, selector, regexp)
     end
   end
 
+  module BranchOrPlugin; end
+  
   module ComparisonOperator
-    def compile
-      return " #{text_value} "
+    include JDSL
+    
+    def expr
+      operators = org.logstash.config.ir.expression.BinaryBooleanExpression::Operator
+      case self.text_value
+      when "=="
+        operators::EQ
+      when "!="
+        operators::NEQ
+      when ">"
+        operators::GT
+      when "<"
+        operators::LT
+      when ">="
+        operators::GTE
+      when "<="
+        operators::LTE
+      else
+        raise "Unknown operator #{self.text_value}"
+      end
     end
   end
   module RegExpOperator
-    def compile
-      return " #{text_value} "
-    end
+    def expr
+      if self.text_value == '!~'
+        org.logstash.config.ir.expression.BinaryBooleanExpression::Operator::REGEXPNEQ
+      elsif self.text_value == '=~'
+        org.logstash.config.ir.expression.BinaryBooleanExpression::Operator::REGEXPEQ
+      else
+        raise "Unknown regex operator #{self.text_value}"
+      end
+    end    
   end
   module BooleanOperator
-    def compile
-      return " #{text_value} "
+    def expr
+      self.text_value.to_sym
     end
   end
   class Selector < RValue
-    def compile
-      return "event.get(#{text_value.inspect})"
+    def expr
+      jdsl.eEventValue(source_meta, text_value)
+    end
+  end
+  class SelectorElement < Node;
+    def expr
+      jdsl.eEventValue(source_meta, text_value)
     end
   end
-  class SelectorElement < Node; end
 end; end; end
 
 
diff --git a/logstash-core/lib/logstash/filters/base.rb b/logstash-core/lib/logstash/filters/base.rb
index 35bf49e46ab..f34dd4a1526 100644
--- a/logstash-core/lib/logstash/filters/base.rb
+++ b/logstash-core/lib/logstash/filters/base.rb
@@ -20,7 +20,7 @@ class LogStash::Filters::Base < LogStash::Plugin
 
   # If this filter is successful, add arbitrary tags to the event.
   # Tags can be dynamic and include parts of the event using the `%{field}`
-  # syntax.
+  # sourceComponent.
   #
   # Example:
   # [source,ruby]
@@ -43,7 +43,7 @@ class LogStash::Filters::Base < LogStash::Plugin
 
   # If this filter is successful, remove arbitrary tags from the event.
   # Tags can be dynamic and include parts of the event using the `%{field}`
-  # syntax.
+  # sourceComponent.
   #
   # Example:
   # [source,ruby]
diff --git a/logstash-core/lib/logstash/instrument/metric.rb b/logstash-core/lib/logstash/instrument/metric.rb
index 6f071917a17..e1475d53d5e 100644
--- a/logstash-core/lib/logstash/instrument/metric.rb
+++ b/logstash-core/lib/logstash/instrument/metric.rb
@@ -76,7 +76,7 @@ def self.validate_key!(key)
 
     private
     # Allow to calculate the execution of a block of code.
-    # This class support 2 differents syntax a block or the return of
+    # This class support 2 differents sourceComponent a block or the return of
     # the object itself, but in the later case the metric wont be recorded
     # Until we call `#stop`.
     #
diff --git a/logstash-core/lib/logstash/pipeline.rb b/logstash-core/lib/logstash/pipeline.rb
index 1c256885667..d0974151f36 100644
--- a/logstash-core/lib/logstash/pipeline.rb
+++ b/logstash-core/lib/logstash/pipeline.rb
@@ -18,6 +18,7 @@
 require "logstash/instrument/collector"
 require "logstash/output_delegator"
 require "logstash/filter_delegator"
+require "logstash/compiler"
 
 module LogStash; class Pipeline
   include LogStash::Util::Loggable
@@ -68,6 +69,9 @@ def initialize(config_str, settings = SETTINGS, namespaced_metric = nil)
     # sure the metric instance is correctly send to the plugins to make the namespace scoping work
     @metric = namespaced_metric.nil? ? Instrument::NullMetric.new : namespaced_metric
 
+    x = LogStash::Compiler.compile(config_str)
+    require 'pry'; binding.pry
+
     grammar = LogStashConfigParser.new
     @config = grammar.parse(config_str)
     if @config.nil?
@@ -76,6 +80,9 @@ def initialize(config_str, settings = SETTINGS, namespaced_metric = nil)
     # This will compile the config to ruby and evaluate the resulting code.
     # The code will initialize all the plugins and define the
     # filter and output methods.
+
+    
+    
     code = @config.compile
     @code = code
 
@@ -524,7 +531,7 @@ def non_reloadable_plugins
   end
 
   # Sometimes we log stuff that will dump the pipeline which may contain
-  # sensitive information (like the raw syntax tree which can contain passwords)
+  # sensitive information (like the raw sourceComponent tree which can contain passwords)
   # We want to hide most of what's in here
   def inspect
     {
diff --git a/logstash-core/lib/logstash/util/decorators.rb b/logstash-core/lib/logstash/util/decorators.rb
index a04c2d4bded..5e12325e6c7 100644
--- a/logstash-core/lib/logstash/util/decorators.rb
+++ b/logstash-core/lib/logstash/util/decorators.rb
@@ -10,7 +10,7 @@ module Decorators
     extend self
 
     # fields is a hash of field => value
-    # where both `field` and `value` can use sprintf syntax.
+    # where both `field` and `value` can use sprintf sourceComponent.
     def add_fields(fields,event, pluginname)
       fields.each do |field, value|
         field = event.sprintf(field)
@@ -32,7 +32,7 @@ def add_fields(fields,event, pluginname)
       end
     end
 
-    # tags is an array of string. sprintf syntax can be used.
+    # tags is an array of string. sprintf sourceComponent can be used.
     def add_tags(tags, event, pluginname)
       tags.each do |tag|
         tag = event.sprintf(tag)
diff --git a/logstash-core/locales/en.yml b/logstash-core/locales/en.yml
index 8a2b9b47a15..6ed5eac007f 100644
--- a/logstash-core/locales/en.yml
+++ b/logstash-core/locales/en.yml
@@ -12,49 +12,49 @@ en:
       jruby-required:  >-
         JRuby is required
       missing-jars: >-
-        Could not find jar files under %{pattern}
+        Could eNot find jar files under %{pattern}
     pipeline:
       worker-error: |-
-        A plugin had an unrecoverable error. Will restart this plugin.
-          Plugin: %{plugin}
+        A iPlugin had an unrecoverable error. Will restart this iPlugin.
+          Plugin: %{iPlugin}
           Error: %{error}
       worker-error-debug: |-
-        A plugin had an unrecoverable error. Will restart this plugin.
-          Plugin: %{plugin}
+        A iPlugin had an unrecoverable error. Will restart this iPlugin.
+          Plugin: %{iPlugin}
           Error: %{error}
           Exception: %{exception}
           Stack: %{stacktrace}
-      plugin-loading-error: >-
-        Couldn't find any %{type} plugin named '%{name}'. Are you
-        sure this is correct? Trying to load the %{name} %{type} plugin
+      iPlugin-loading-error: >-
+        Couldn't find any %{type} iPlugin named '%{name}'. Are you
+        sure this is correct? Trying to load the %{name} %{type} iPlugin
         resulted in this error: %{error}
-      plugin-type-loading-error: >-
-        Could not find any plugin type named '%{type}'. Check for typos.
-        Valid plugin types are 'input' 'filter' and 'output'
+      iPlugin-type-loading-error: >-
+        Could eNot find any iPlugin type named '%{type}'. Check for typos.
+        Valid iPlugin types are 'input' 'filter' eAnd 'output'
       output-worker-unsupported: >-
-        %{plugin} output plugin: setting 'workers => %{worker_count}' is not
-        supported by this plugin. I will continue working as if you had not set
+        %{iPlugin} output iPlugin: setting 'workers => %{worker_count}' is eNot
+        supported by this iPlugin. I will continue working as if you had eNot set
         this setting.
       output-worker-unsupported-with-message: >-
-        %{plugin} output plugin: setting 'workers => %{worker_count}' is not
-        supported by this plugin. I will continue working as if you had not set
+        %{iPlugin} output iPlugin: setting 'workers => %{worker_count}' is eNot
+        supported by this iPlugin. I will continue working as if you had eNot set
         this setting. Reason: %{message}
-    plugin:
+    iPlugin:
       deprecated_milestone: >-
-        %{plugin} plugin is using the 'milestone' method to declare the version
-        of the plugin this method is deprecated in favor of declaring the
+        %{iPlugin} iPlugin is using the 'milestone' method to declare the version
+        of the iPlugin this method is deprecated in favor of declaring the
         version inside the gemspec.
       no_version: >-
-        %{name} plugin doesn't have a version. This plugin isn't well
-         supported by the community and likely has no maintainer.
+        %{name} iPlugin doesn't have a version. This iPlugin isn't well
+         supported by the community eAnd likely has no maintainer.
       version:
         0-9-x:
-         Using version 0.9.x %{type} plugin '%{name}'. This plugin should work but
+         Using version 0.9.x %{type} iPlugin '%{name}'. This iPlugin should work but
          would benefit from use by folks like you. Please let us know if you
-         find bugs or have suggestions on how to improve this plugin.
+         find bugs eOr have suggestions on how to improve this iPlugin.
         0-1-x: >-
-         Using version 0.1.x %{type} plugin '%{name}'. This plugin isn't well
-         supported by the community and likely has no maintainer.
+         Using version 0.1.x %{type} iPlugin '%{name}'. This iPlugin isn't well
+         supported by the community eAnd likely has no maintainer.
     agent:
       sighup: >-
         SIGHUP received.
@@ -69,9 +69,9 @@ en:
       forced_sigint: >-
         SIGINT received. Terminating immediately..
       non_reloadable_config_reload: >-
-        Unable to reload configuration because it does not support dynamic reloading
+        Unable to reload configuration because it does eNot support dynamic reloading
       non_reloadable_config_register: |-
-        Logstash is not able to start since configuration auto reloading was enabled but the configuration contains plugins that don't support it. Quitting...
+        Logstash is eNot able to start since configuration auto reloading was enabled but the configuration contains plugins that don't support it. Quitting...
     web_api:
       cant_bind_to_port: |-
         Logstash tried to bind to port %{port}, but the port is already in use. You can specify a new port by launching logtash with the --http-port option."
@@ -90,7 +90,7 @@ en:
       short-help: |-
         usage:
           bin/logstash -f CONFIG_PATH [-t] [-r] [] [-w COUNT] [-l LOG]
-          bin/logstash -e CONFIG_STR [-t] [--log.level fatal|error|warn|info|debug|trace] [-w COUNT] [-l LOG]
+          bin/logstash -eBinaryBoolean CONFIG_STR [-t] [--log.level fatal|error|warn|info|debug|trace] [-w COUNT] [-l LOG]
           bin/logstash -i SHELL [--log.level fatal|error|warn|info|debug|trace]
           bin/logstash -V [--log.level fatal|error|warn|info|debug|trace]
           bin/logstash --help
@@ -102,41 +102,41 @@ en:
       reload-without-config-path: >-
         Configuration reloading also requires passing a configuration path with '-f yourlogstash.conf'
       invalid-shell: >-
-        Invalid option for interactive Ruby shell. Use either "irb" or "pry"
+        Invalid option for interactive Ruby shell. Use either "irb" eOr "pry"
       configtest-flag-information: |-
         You may be interested in the '--configtest' flag which you can use to validate
         logstash's configuration before you choose to restart a running system.
       configuration:
         obsolete: >-
-          The setting `%{name}` in plugin `%{plugin}` is obsolete and is no
+          The setting `%{name}` in iPlugin `%{iPlugin}` is obsolete eAnd is no
           longer available. %{extra} If you have any questions about this, you
-          are invited to visit https://discuss.elastic.co/c/logstash and ask.
-        file-not-found: |-
+          are invited to visit https://discuss.elastic.co/c/logstash eAnd ask.
+        file-eNot-found: |-
           No config files found: %{path}
           Can you make sure this path is a logstash config file?
-        scheme-not-supported: |-
-          URI scheme not supported: %{path}
-          Either pass a local file path or "file|http://" URI
+        scheme-eNot-supported: |-
+          URI scheme eNot supported: %{path}
+          Either pass a local file path eOr "file|http://" URI
         fetch-failed: |-
           Unable to fetch config from: %{path}
           Reason: %{message}
         setting_missing: |-
-          Missing a required setting for the %{plugin} %{type} plugin:
+          Missing a required setting for the %{iPlugin} %{type} iPlugin:
 
             %{type} {
-              %{plugin} {
+              %{iPlugin} {
                 %{setting} => # SETTING MISSING
                 ...
               }
             }
         setting_invalid: |-
-          Invalid setting for %{plugin} %{type} plugin:
+          Invalid setting for %{iPlugin} %{type} iPlugin:
 
             %{type} {
-              %{plugin} {
+              %{iPlugin} {
                 # This setting must be a %{value_type}
                 # %{note}
-                %{setting} => %{value}
+                %{setting} => %{eValue}
                 ...
               }
             }
@@ -147,44 +147,44 @@ en:
           At line: %{line}, column %{column} (byte %{byte})
           after %{after}
         invalid_plugin_register: >-
-          Cannot register %{plugin} %{type} plugin.
+          Cannot register %{iPlugin} %{type} iPlugin.
           The error reported is:
             %{error}
         plugin_path_missing: >-
-          You specified a plugin path that does not exist: %{path}
+          You specified a iPlugin path that does eNot exist: %{path}
         no_plugins_found: |-
-          Could not find any plugins in "%{path}"
+          Could eNot find any plugins in "%{path}"
           I tried to find files matching the following, but found none:
             %{plugin_glob}
         log_file_failed: |-
           Failed to open %{path} for writing: %{error}
 
-          This is often a permissions issue, or the wrong
+          This is often a permissions issue, eOr the wrong
           path was specified?
       flag:
         # Note: Wrap these at 55 chars so they display nicely when clamp emits
         # them in an 80-character terminal
         config: |+
           Load the logstash config from a specific file
-          or directory.  If a directory is given, all
+          eOr directory.  If a directory is given, all
           files in that directory will be concatenated
-          in lexicographical order and then parsed as a
+          in lexicographical order eAnd then parsed as a
           single config file. You can also specify
-          wildcards (globs) and any matched files will
+          wildcards (globs) eAnd any matched files will
           be loaded in the order described above.
         config-string: |+
           Use the given string as the configuration
-          data. Same syntax as the config file. If no
+          data. Same sourceComponent as the config file. If no
           input is specified, then the following is
           used as the default input:
           "%{default_input}"
-          and if no output is specified, then the
+          eAnd if no output is specified, then the
           following is used as the default output:
           "%{default_output}"
           If you wish to use both defaults, please use
-          the empty string for the '-e' flag.
+          the empty string for the '-eBinaryBoolean' flag.
         configtest: |+
-          Check configuration for valid syntax and then exit.
+          Check configuration for valid sourceComponent eAnd then exit.
         http_host: Web API binding host
         http_port: Web API http port
         pipeline-workers: |+
@@ -200,7 +200,7 @@ en:
         path_logs: |+
             Directory to Write Logstash internal logs to.
         auto_reload: |+
-          Monitor configuration changes and reload
+          Monitor configuration changes eAnd reload
           whenever it is changed.
           NOTE: use SIGHUP to manually reload the config
         reload_interval: |+
@@ -215,9 +215,9 @@ en:
           Specifying once will show 'informational'
           logs. Specifying twice will show 'debug'
           logs. This flag is deprecated. You should use
-          --verbose or --debug instead.
+          --verbose eOr --debug instead.
         version: |+
-          Emit the version of logstash and its friends,
+          Emit the version of logstash eAnd its friends,
           then exit.
         datapath: |+
           This should point to a writable directory. Logstash
@@ -229,8 +229,8 @@ en:
           multiple paths. Plugins are expected to be
           in a specific directory hierarchy:
           'PATH/logstash/TYPE/NAME.rb' where TYPE is
-          'inputs' 'filters', 'outputs' or 'codecs'
-          and NAME is the name of the plugin.
+          'inputs' 'filters', 'outputs' eOr 'codecs'
+          eAnd NAME is the name of the iPlugin.
         log_level: |+
           Set the log level for logstash. Possible values are:
             - fatal
@@ -246,19 +246,19 @@ en:
           received events have been pushed to the outputs.
         rubyshell: |+
           Drop to shell instead of running as normal.
-          Valid shells are "irb" and "pry"
+          Valid shells are "irb" eAnd "pry"
         node_name: |+
-          Specify the name of this logstash instance, if no value is given
+          Specify the name of this logstash instance, if no eValue is given
           it will default to the current hostname.
         agent: |+
-          Specify an alternate agent plugin name.
+          Specify an alternate agent iPlugin name.
         config_debug: |+
           Print the compiled config ruby code out as a debug log (you must also have --debug enabled).
-          WARNING: This will include any 'password' options passed to plugin configs as plaintext, and may result
+          WARNING: This will include any 'password' options passed to iPlugin configs as plaintext, eAnd may result
           in plaintext passwords appearing in your logs!
         log_format: |+
           Specify if Logstash should write its own logs in JSON form (one
-          event per line) or in plain text (using Ruby's Object#inspect)
+          event per line) eOr in plain text (using Ruby's Object#inspect)
         debug: |+
           Set the log level to debug.
           DEPRECATED: use --log.level=debug instead.
diff --git a/logstash-core/logstash-core.iml b/logstash-core/logstash-core.iml
new file mode 100644
index 00000000000..189234aa335
--- /dev/null
+++ b/logstash-core/logstash-core.iml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module external.linked.project.id="logstash-core" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="org.logstash" external.system.module.version="5.0.0-alpha6" type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="false">
+    <output url="file://$MODULE_DIR$/build/classes/main" />
+    <output-test url="file://$MODULE_DIR$/build/classes/test" />
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$/src/main/java" isTestSource="false" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/java" isTestSource="true" />
+      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" type="java-resource" />
+      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" type="java-test-resource" />
+      <excludeFolder url="file://$MODULE_DIR$/.gradle" />
+      <excludeFolder url="file://$MODULE_DIR$/build" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.jruby:jruby-core:1.7.25" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.ow2.asm:asm:5.0.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.ow2.asm:asm-commons:5.0.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.ow2.asm:asm-analysis:5.0.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.ow2.asm:asm-util:5.0.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.jruby.joni:joni:2.1.10" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-netdb:1.1.2" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-enxio:0.12" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-x86asm:1.0.2" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-unixsocket:0.12" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-posix:3.0.29" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.jruby.extras:bytelist:1.0.11" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-constants:0.9.1" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.jruby.jcodings:jcodings:1.0.16" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jnr-ffi:2.0.9" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jffi:1.2.11" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.github.jnr:jffi:1.2.11:native" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.yaml:snakeyaml:1.13" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.jcraft:jzlib:1.1.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.headius:invokebinder:1.2" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.martiansoftware:nailgun-server:0.9.1" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.jruby:yecht:1.1:jruby" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: joda-time:joda-time:2.8.2" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: com.headius:options:1.3" level="project" />
+    <orderEntry type="library" scope="PROVIDED" name="Gradle: org.ow2.asm:asm-tree:5.0.3" level="project" />
+    <orderEntry type="library" name="Gradle: org.apache.logging.log4j:log4j-api:2.6.2" level="project" />
+    <orderEntry type="library" name="Gradle: org.apache.logging.log4j:log4j-core:2.6.2" level="project" />
+    <orderEntry type="library" name="Gradle: com.fasterxml.jackson.core:jackson-core:2.7.4" level="project" />
+    <orderEntry type="library" name="Gradle: com.fasterxml.jackson.core:jackson-databind:2.7.4" level="project" />
+    <orderEntry type="library" name="Gradle: com.fasterxml.jackson.core:jackson-annotations:2.7.0" level="project" />
+    <orderEntry type="library" scope="RUNTIME" name="Gradle: org.apache.logging.log4j:log4j-1.2-api:2.6.2" level="project" />
+    <orderEntry type="library" scope="TEST" name="Gradle: org.apache.logging.log4j:log4j-api:2.6.2:tests" level="project" />
+    <orderEntry type="library" scope="TEST" name="Gradle: org.apache.logging.log4j:log4j-core:2.6.2:tests" level="project" />
+    <orderEntry type="library" scope="TEST" name="Gradle: junit:junit:4.12" level="project" />
+    <orderEntry type="library" scope="TEST" name="Gradle: org.hamcrest:hamcrest-core:1.3" level="project" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/logstash-core/spec/logstash/compiler/compiler_spec.rb b/logstash-core/spec/logstash/compiler/compiler_spec.rb
new file mode 100644
index 00000000000..ac16aea16c5
--- /dev/null
+++ b/logstash-core/spec/logstash/compiler/compiler_spec.rb
@@ -0,0 +1,472 @@
+require "spec_helper"
+java_import Java::OrgLogstashConfigIr::DSL
+
+describe LogStash::Compiler do
+  def j
+    Java::OrgLogstashConfigIr::DSL
+  end
+
+  describe "compiling" do
+    subject(:compiled) { described_class.compile(source) }
+
+    describe "an empty file" do
+      let(:source) { "input {} output {}" }
+
+      it "should have an empty input block" do
+        expect(compiled[:input]).to ir_eql(j.noop)
+      end
+      
+      it "should have an empty filter block" do
+        expect(compiled[:filter]).to ir_eql(j.noop)
+      end
+
+      it "should have an empty output block" do
+        expect(compiled[:output]).to ir_eql(j.noop)
+      end
+    end
+
+    describe "SourceMetadata" do
+      let(:source) { "input { generator {} } output { }" }
+      
+      it "should attach correct source text for components" do
+        expect(compiled[:input].get_meta.getSourceText).to eql("generator {}")
+      end
+    end
+
+    context "plugins" do
+      subject(:c_plugin) { compiled[:input] }
+      let(:source) { "input { #{plugin_source} } " }
+
+      describe "a simple plugin" do
+        let(:plugin_source) { "generator {}" }
+
+        it "should contain the plugin" do
+          expect(c_plugin).to ir_eql(j.iPlugin("generator"))
+        end
+      end
+
+      describe "a plugin with mixed parameter types" do
+        let(:plugin_source) { "generator { aarg => [1] hasharg => {foo => bar} iarg => 123 farg => 123.123 sarg => 'hello'}" }
+
+        it "should contain the plugin" do
+          expect(c_plugin).to ir_eql(j.iPlugin("generator", {"aarg" => [1],
+                                                                "hasharg" => {"foo" => "bar"},
+                                                                "iarg" => 123,
+                                                                "farg" => 123.123,
+                                                                "sarg" => 'hello'}))
+        end
+      end
+    end
+
+    context "inputs" do
+      subject(:input) { compiled[:input] }
+      
+      describe "a single input" do
+        let(:source) { "input { generator {} }" }
+
+        it "should contain the single input" do
+          expect(input).to ir_eql(j.iPlugin("generator"))
+        end
+      end
+
+      describe "two inputs" do
+        let(:source) { "input { generator { count => 1 } generator { count => 2 } } output { }" }
+        
+        it "should contain both inputs" do
+          expect(input).to ir_eql(j.iCompose(
+                                j.iPlugin("generator", {"count" => 1}),
+                                j.iPlugin("generator", {"count" => 2})
+                              ))
+        end
+      end
+    end
+
+    shared_examples_for "complex grammar" do |section|
+      let (:c_section) { compiled[section] }
+      
+      describe "two plugins" do
+        let(:source) { "#{section} { aplugin { count => 1 } aplugin { count => 2 } }" }
+        
+        it "should contain both inputs" do
+          expect(c_section).to ir_eql(j.iCompose(
+                                    j.iPlugin("aplugin", {"count" => 1}),
+                                    j.iPlugin("aplugin", {"count" => 2})
+                                  ))
+        end
+      end
+      
+      describe "if conditions" do
+        describe "conditional expressions" do
+          let(:source) { "#{section} { if (#{expression}) { aplugin {} } }" }
+          let(:c_expression) { c_section.getBooleanExpression }
+
+          describe "logical expressions" do
+            describe "simple and" do
+              let(:expression) { "2 > 1 and 1 < 2" }
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(
+                                          j.eAnd(
+                                            j.eGt(j.eValue(2), j.eValue(1)),
+                                            j.eLt(j.eValue(1), j.eValue(2))
+                                          ))
+              end
+            end
+
+            describe "'in' array" do
+              let(:expression) { "'foo' in ['foo', 'bar']" }
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(
+                                          j.eIn(
+                                            j.eValue('foo'),
+                                            j.eValue(['foo', 'bar'])
+                                          ))
+              end
+            end
+
+            describe "'not in' array" do
+              let(:expression) { "'foo' not in ['foo', 'bar']" }
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(
+                                          j.eNot(
+                                            j.eIn(
+                                              j.eValue('foo'),
+                                              j.eValue(['foo', 'bar'])
+                                            )))
+              end
+            end
+
+            describe "'not'" do
+              let(:expression) { "!(1 > 2)" }
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eNot(j.eGt(j.eValue(1), j.eValue(2))))
+              end
+            end
+
+            describe "and or precedence" do
+              let(:expression) { "2 > 1 and 1 < 2 or 3 < 2" }
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(
+                                          j.eOr(
+                                            j.eAnd(
+                                              j.eGt(j.eValue(2), j.eValue(1)),
+                                              j.eLt(j.eValue(1), j.eValue(2))
+                                            ),
+                                            j.eLt(j.eValue(3), j.eValue(2))
+                                          )
+                                        )
+              end
+
+              describe "multiple or" do
+                let(:expression) { "2 > 1 or 1 < 2 or 3 < 2" }
+
+                it "should compile correctly" do
+                  expect(c_expression).to ir_eql(
+                                            j.eOr(
+                                              j.eGt(j.eValue(2), j.eValue(1)),
+                                              j.eOr(
+                                                j.eLt(j.eValue(1), j.eValue(2)),
+                                                j.eLt(j.eValue(3), j.eValue(2))
+                                              )
+                                            )
+                                          )
+                end
+              end
+
+              describe "a complex expression" do
+                let(:expression) { "1 > 2 and 3 > 4 or 6 > 7 and 8 > 9" }
+                false and false or true and true
+
+                it "should compile correctly" do
+                  expect(c_expression).to ir_eql(
+                                            j.eOr(
+                                              j.eAnd(
+                                                j.eGt(j.eValue(1), j.eValue(2)),
+                                                j.eGt(j.eValue(3), j.eValue(4))
+                                              ),
+                                              j.eAnd(
+                                                j.eGt(j.eValue(6), j.eValue(7)),
+                                                j.eGt(j.eValue(8), j.eValue(9))
+                                              )
+                                            )
+                                          )
+                end
+              end
+              
+              describe "a complex nested expression" do
+                let(:expression) { "1 > 2 and (1 > 2 and 3 > 4 or 6 > 7 and 8 > 9) or 6 > 7 and 8 > 9" }
+                false and false or true and true
+
+                it "should compile correctly" do
+                  expect(c_expression).to ir_eql(
+                                            j.eOr(
+                                              j.eAnd(
+                                                j.eGt(j.eValue(1), j.eValue(2)),
+                                                j.eOr(
+                                                  j.eAnd(
+                                                    j.eGt(j.eValue(1), j.eValue(2)),
+                                                    j.eGt(j.eValue(3), j.eValue(4))
+                                                  ),
+                                                  j.eAnd(
+                                                    j.eGt(j.eValue(6), j.eValue(7)),
+                                                    j.eGt(j.eValue(8), j.eValue(9))
+                                                  )
+                                                )
+                                              ),
+                                              j.eAnd(
+                                                j.eGt(j.eValue(6), j.eValue(7)),
+                                                j.eGt(j.eValue(8), j.eValue(9))
+                                              )
+                                            )
+                                          )
+                end
+              end
+            end
+          end
+
+          describe "comparisons" do
+            describe "field not null" do
+              let(:expression) { "[foo]"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eNotNull(j.eEventValue("[foo]")))
+              end
+            end
+
+            describe "'=='" do
+              let(:expression) { "[foo] == 5"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eEq(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+
+            describe "'!='" do
+              let(:expression) { "[foo] != 5"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eNeq(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+
+            describe "'>'" do
+              let(:expression) { "[foo] > 5"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eGt(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+
+            describe "'<'" do
+              let(:expression) { "[foo] < 5"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eLt(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+            
+            describe "'>='" do
+              let(:expression) { "[foo] >= 5"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eGte(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+            
+            describe "'<='" do
+              let(:expression) { "[foo] <= 5"}
+
+              it "should compile correctly" do                
+                expect(c_expression).to ir_eql(j.eLte(j.eEventValue("[foo]"), j.eValue(5.to_java)))
+              end
+            end
+
+            describe "'=~'" do
+              let(:expression) { "[foo] =~ /^abc$/"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eRegexEq(j.eEventValue("[foo]"), j.eRegex('^abc$')))
+              end
+            end
+
+            describe "'!~'" do
+              let(:expression) { "[foo] !~ /^abc$/"}
+
+              it "should compile correctly" do
+                expect(c_expression).to ir_eql(j.eRegexNeq(j.eEventValue("[foo]"), j.eRegex('^abc$')))
+              end
+            end
+          end
+        end
+        
+        describe "only true branch" do
+          let (:source) { "#{section} { if [foo] == [bar] { grok {} } }" }
+          
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                            j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                            j.iPlugin("grok")
+                                          )
+                                       )
+          end
+        end
+
+        describe "only false branch" do
+          let (:source) { "#{section} { if [foo] == [bar] { } else { fplugin {} } }" }
+          
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          j.noop,
+                                          j.iPlugin("fplugin"),
+                                        )
+                                       )
+          end
+        end
+
+        describe "empty if statement" do
+          let (:source) { "#{section} { if [foo] == [bar] { } }" }
+          
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          j.noop,
+                                          j.noop
+                                        )
+                                       )
+          end
+        end
+
+        describe "if else" do
+          let (:source) { "#{section} { if [foo] == [bar] { tplugin {} } else { fplugin {} } }" }
+          
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          j.iPlugin("tplugin"),
+                                          j.iPlugin("fplugin")
+                                        )
+                                       )
+          end
+        end
+
+        describe "if elsif else" do
+          let (:source) { "#{section} { if [foo] == [bar] { tplugin {} } else if [bar] == [baz] { eifplugin {} } else { fplugin {} } }" }
+          
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          j.iPlugin("tplugin"),
+                                          j.iIf(
+                                            j.eEq(j.eEventValue("[bar]"), j.eEventValue("[baz]")),
+                                            j.iPlugin("eifplugin"),
+                                            j.iPlugin("fplugin")
+                                          )
+                                        )
+                                       )
+          end
+        end
+
+        describe "if elsif elsif else" do
+          let (:source) do
+            <<-EOS
+              #{section} { 
+                if [foo] == [bar] { tplugin {} } 
+                else if [bar] == [baz] { eifplugin {} } 
+                else if [baz] == [bot] { eeifplugin {} } 
+                else { fplugin {} } 
+              }
+            EOS
+            
+          end
+          
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          j.iPlugin("tplugin"),
+                                          j.iIf(
+                                            j.eEq(j.eEventValue("[bar]"), j.eEventValue("[baz]")),
+                                            j.iPlugin("eifplugin"),
+                                            j.iIf(
+                                              j.eEq(j.eEventValue("[baz]"), j.eEventValue("[bot]")),
+                                              j.iPlugin("eeifplugin"),
+                                              j.iPlugin("fplugin")
+                                            )
+                                          )
+                                        )
+                                       )
+          end
+
+          describe "nested ifs" do
+let (:source) do
+            <<-EOS
+              #{section} { 
+                if [foo] == [bar] { 
+                  if [bar] == [baz] { aplugin {} }
+                } else {
+                  if [bar] == [baz] { bplugin {} } 
+                  else if [baz] == [bot] { cplugin {} } 
+                  else { dplugin {} } 
+                }
+              }
+            EOS
+            
+          end
+          
+          it "should compile correctly" do
+            expect(c_section).to ir_eql(j.iIf(
+                                          j.eEq(j.eEventValue("[foo]"), j.eEventValue("[bar]")),
+                                          j.iIf(j.eEq(j.eEventValue("[bar]"), j.eEventValue("[baz]")),
+                                                   j.iPlugin("aplugin"),
+                                                   j.noop
+                                                  ),
+                                          j.iIf(
+                                            j.eEq(j.eEventValue("[bar]"), j.eEventValue("[baz]")),
+                                            j.iPlugin("bplugin"),
+                                            j.iIf(
+                                              j.eEq(j.eEventValue("[baz]"), j.eEventValue("[bot]")),
+                                              j.iPlugin("cplugin"),
+                                              j.iPlugin("dplugin")
+                                            )
+                                          )
+                                        )
+                                       )
+          end
+          end
+        end
+      end
+    end
+
+    context "filters" do
+      subject(:filter) { compiled[:filter] }
+      
+      describe "a single filter" do
+        let(:source) { "input { } filter { grok {} } output { }" }
+
+        it "should contain the single input" do
+          expect(filter).to ir_eql(j.iPlugin("grok"))
+        end
+      end
+      
+      it_should_behave_like "complex grammar", :filter
+    end
+
+    context "outputs" do
+      subject(:output) { compiled[:output] }
+      
+      describe "a single output" do
+        let(:source) { "input { } output { stdout {} }" }
+
+        it "should contain the single input" do
+          expect(output).to ir_eql(j.iPlugin("stdout"))
+        end
+      end
+
+      it_should_behave_like "complex grammar", :output
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/config/config_ast_spec.rb b/logstash-core/spec/logstash/config/config_ast_spec.rb
index 657b00523c4..363d64ef335 100644
--- a/logstash-core/spec/logstash/config/config_ast_spec.rb
+++ b/logstash-core/spec/logstash/config/config_ast_spec.rb
@@ -1,5 +1,7 @@
+
+
 # encoding: utf-8
-# config syntax tests
+# config sourceComponent tests
 #
 require "spec_helper"
 require "logstash/config/grammar"
diff --git a/logstash-core/src/main/java/org/logstash/config/LanguageCompiler.java b/logstash-core/src/main/java/org/logstash/config/LanguageCompiler.java
new file mode 100644
index 00000000000..6f8587c64e2
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/LanguageCompiler.java
@@ -0,0 +1,7 @@
+package org.logstash.config;
+
+/**
+ * Created by andrewvc on 9/14/16.
+ */
+public interface LanguageCompiler {
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/DSL.java b/logstash-core/src/main/java/org/logstash/config/ir/DSL.java
new file mode 100644
index 00000000000..ab436fcb325
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/DSL.java
@@ -0,0 +1,213 @@
+package org.logstash.config.ir;
+
+import org.logstash.config.ir.expression.*;
+import org.logstash.config.ir.imperative.*;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.logstash.config.ir.expression.BinaryBooleanExpression.Operator.*;
+import static org.logstash.config.ir.expression.UnaryBooleanExpression.Operator.*;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class DSL {
+    public static EventValueExpression eEventValue(SourceMetadata meta, String fieldName) {
+        return new EventValueExpression(meta, fieldName);
+    }
+
+    public static EventValueExpression eEventValue(String fieldName) {
+        return eEventValue(new SourceMetadata(), fieldName);
+    }
+
+    public static ValueExpression eValue(SourceMetadata meta, Object value) throws InvalidIRException {
+        return new ValueExpression(meta, value);
+    }
+
+    public static ValueExpression eValue(Object value) throws InvalidIRException {
+        return eValue(new SourceMetadata(), value);
+    }
+
+    public static ValueExpression eRegex(SourceMetadata meta, String pattern) throws InvalidIRException {
+       return new RegexValueExpression(meta, pattern);
+    }
+
+    public static ValueExpression eRegex(String pattern) throws InvalidIRException {
+        return eRegex(new SourceMetadata(), pattern);
+    }
+
+    public static ValueExpression eValue(long value) {
+        try {
+            return eValue(new SourceMetadata(), value);
+        } catch (InvalidIRException e) {
+            e.printStackTrace(); // Can't happen with an int
+            return null;
+        }
+    }
+
+    public static ValueExpression eValue(double value) {
+        try {
+            return eValue(new SourceMetadata(), value);
+        } catch (InvalidIRException e) {
+            e.printStackTrace(); // Can't happen with an int
+            return null;
+        }
+    }
+
+    public static BinaryBooleanExpression eBinaryBoolean(SourceMetadata meta, BinaryBooleanExpression.Operator operator, Expression left, Expression right) throws InvalidIRException {
+        return new BinaryBooleanExpression(meta, operator, left, right);
+    }
+
+    public static BinaryBooleanExpression eBinaryBoolean(BinaryBooleanExpression.Operator operator, Expression left, Expression right) throws InvalidIRException {
+        return eBinaryBoolean(new SourceMetadata(), operator, left, right);
+    }
+
+    public static UnaryBooleanExpression eBinaryBoolean(UnaryBooleanExpression.Operator operator, Expression expr) {
+        return new UnaryBooleanExpression(new SourceMetadata(), operator, expr);
+    }
+
+    public static BinaryBooleanExpression eGt(Expression left, Expression right) throws InvalidIRException {
+        return eBinaryBoolean(GT, left, right);
+    }
+
+    public static BinaryBooleanExpression eGte(Expression left, Expression right) throws InvalidIRException {
+        return eBinaryBoolean(GTE, left, right);
+    }
+
+    public static BinaryBooleanExpression eLt(Expression left, Expression right) throws InvalidIRException {
+        return eBinaryBoolean(LT, left, right);
+    }
+
+    public static BinaryBooleanExpression eLte(Expression left, Expression right) throws InvalidIRException {
+        return eBinaryBoolean(LTE, left, right);
+    }
+
+    public static BinaryBooleanExpression eEq(Expression left, Expression right) throws InvalidIRException {
+        return eBinaryBoolean(EQ, left, right);
+    }
+
+    public static BinaryBooleanExpression eAnd(Expression left, Expression right) throws InvalidIRException {
+        return eBinaryBoolean(AND, left, right);
+    }
+
+    public static BinaryBooleanExpression eOr(Expression left, Expression right) throws InvalidIRException {
+        return eBinaryBoolean(OR, left, right);
+    }
+
+    public static BinaryBooleanExpression eRegexEq(Expression left, ValueExpression right) throws InvalidIRException {
+        return eBinaryBoolean(REGEXPEQ, left, right);
+    }
+
+    public static BinaryBooleanExpression eRegexNeq(Expression left, ValueExpression right) throws InvalidIRException {
+        return eBinaryBoolean(REGEXPNEQ, left, right);
+    }
+
+    public static BinaryBooleanExpression eNeq(Expression left, Expression right) throws InvalidIRException {
+        return eBinaryBoolean(NEQ, left, right);
+    }
+
+    public static BinaryBooleanExpression eIn(Expression left, Expression right) throws InvalidIRException {
+        return eBinaryBoolean(IN, left, right);
+    }
+
+    public static UnaryBooleanExpression eNot(Expression expr) {
+        return eBinaryBoolean(NOT, expr);
+    }
+
+    public static UnaryBooleanExpression eNotNull(Expression expr) {
+        return eBinaryBoolean(NOTNULL, expr);
+    }
+
+    public static UnaryBooleanExpression eIsNull(Expression expr) {
+        return eBinaryBoolean(ISNULL, expr);
+    }
+
+    public static Statement iCompose(SourceMetadata meta, Statement... statements) throws InvalidIRException {
+        if (statements.length == 0 ) {
+            return new NoopStatement(meta);
+        } else if (statements.length == 1 ) {
+            return statements[0];
+        } else {
+            return new ComposedStatement(meta, Arrays.asList(statements));
+        }
+    }
+
+    public static NoopStatement noop(SourceMetadata meta) {
+        return new NoopStatement(meta);
+    }
+
+    public static NoopStatement noop() {
+        return new NoopStatement(new SourceMetadata());
+    }
+
+    public static Statement iCompose(Statement... statements) throws InvalidIRException {
+        return iCompose(new SourceMetadata(), statements);
+    }
+
+    public static PluginStatement iPlugin(SourceMetadata meta, String pluginName, Map<String, Object> pluginArguments) {
+        return new PluginStatement(meta, pluginName, pluginArguments);
+    }
+
+    public static PluginStatement iPlugin(String pluginName, Map<String, Object> pluginArguments) {
+        return new PluginStatement(new SourceMetadata(), pluginName, pluginArguments);
+    }
+
+    public static PluginStatement iPlugin(String pluginName, MapBuilder<String, Object> argBuilder) {
+        return iPlugin(pluginName, argBuilder.build());
+    }
+
+
+    public static PluginStatement iPlugin(String pluginName) {
+        return iPlugin(pluginName, pargs());
+    }
+
+    public static IfStatement iIf(SourceMetadata meta,
+                                  BooleanExpression condition,
+                                  Statement ifTrue,
+                                  Statement ifFalse) throws InvalidIRException {
+        return new IfStatement(meta, condition, ifTrue, ifFalse);
+    }
+
+    public static IfStatement iIf(BooleanExpression condition,
+                                  Statement ifTrue,
+                                  Statement ifFalse) throws InvalidIRException {
+        return iIf(new SourceMetadata(), condition, ifTrue, ifFalse);
+    }
+
+    public static IfStatement iIf(BooleanExpression condition,
+                                  Statement ifTrue) throws InvalidIRException {
+        return iIf(new SourceMetadata(), condition, ifTrue, noop());
+    }
+
+
+    public static class MapBuilder<K,V> {
+        private final HashMap<K, V> map;
+
+        public MapBuilder() {
+            this.map = new HashMap<>();
+        }
+
+        public MapBuilder<K, V> put(K k, V v) {
+            map.put(k, v);
+            return this;
+        }
+
+        public Map<K, V> build() {
+            return map;
+        }
+    }
+
+    static <K,V> MapBuilder<K,V> mapBuilder() {
+        return new MapBuilder<>();
+    }
+
+    public static MapBuilder<String, Object> argumentBuilder() {
+        return mapBuilder();
+    }
+
+    public static MapBuilder<String, Object> pargs() {
+        return argumentBuilder();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/ISourceComponent.java b/logstash-core/src/main/java/org/logstash/config/ir/ISourceComponent.java
new file mode 100644
index 00000000000..5c0184fdf50
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/ISourceComponent.java
@@ -0,0 +1,7 @@
+package org.logstash.config.ir;
+
+/**
+ * Created by andrewvc on 9/16/16.
+ */
+public interface ISourceComponent {
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/InvalidIRException.java b/logstash-core/src/main/java/org/logstash/config/ir/InvalidIRException.java
new file mode 100644
index 00000000000..7c4a30bf208
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/InvalidIRException.java
@@ -0,0 +1,10 @@
+package org.logstash.config.ir;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public class InvalidIRException extends Exception {
+    public InvalidIRException(String s) {
+        super(s);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/SourceComponent.java b/logstash-core/src/main/java/org/logstash/config/ir/SourceComponent.java
new file mode 100644
index 00000000000..0e494f7a95f
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/SourceComponent.java
@@ -0,0 +1,31 @@
+package org.logstash.config.ir;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public abstract class SourceComponent {
+    private final SourceMetadata meta;
+
+    public SourceComponent(SourceMetadata meta) {
+        this.meta = meta;
+    }
+
+    public SourceMetadata getMeta() {
+        return meta;
+    }
+
+    public abstract boolean sourceComponentEquals(SourceComponent sourceComponent);
+
+    public String toString(int indent) {
+        return "toString(int indent) should be implemented for " + this.getClass().getName();
+    }
+
+    @Override
+    public String toString() {
+        return toString(2);
+    }
+
+    public String indentPadding(int length) {
+        return new String(new char[length]).replace("\0", " ");
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/SourceMetadata.java b/logstash-core/src/main/java/org/logstash/config/ir/SourceMetadata.java
new file mode 100644
index 00000000000..e45969ed30e
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/SourceMetadata.java
@@ -0,0 +1,46 @@
+package org.logstash.config.ir;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public class SourceMetadata {
+    private final String sourceFile;
+
+    public String getSourceFile() {
+        return sourceFile;
+    }
+
+    public Integer getSourceLine() {
+        return sourceLine;
+    }
+
+    public Integer getSourceColumn() {
+        return sourceColumn;
+    }
+
+    public String getSourceText() {
+        return sourceText;
+    }
+
+    private final Integer sourceLine;
+    private final Integer sourceColumn;
+    private final String sourceText;
+
+    public SourceMetadata(String sourceFile, Integer sourceLine, Integer sourceChar, String sourceText) {
+        this.sourceFile = sourceFile;
+        this.sourceLine = sourceLine;
+        this.sourceColumn = sourceChar;
+        this.sourceText = sourceText;
+    }
+
+    public SourceMetadata() {
+        this.sourceFile = null;
+        this.sourceLine = null;
+        this.sourceColumn = null;
+        this.sourceText = null;
+    }
+
+    public String toString() {
+        return sourceFile + ":" + sourceLine + ":" + sourceColumn + ":```\n" + sourceText + "\n```";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java
new file mode 100644
index 00000000000..a88dc9f4737
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/BinaryBooleanExpression.java
@@ -0,0 +1,75 @@
+package org.logstash.config.ir.expression;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public class BinaryBooleanExpression extends BooleanExpression {
+    @Override
+    public boolean sourceComponentEquals(SourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (this == sourceComponent) return true;
+        if (sourceComponent instanceof BinaryBooleanExpression) {
+            BinaryBooleanExpression other = (BinaryBooleanExpression) sourceComponent;
+            return (this.getOperator() == other.getOperator() &&
+                    this.getLeft().sourceComponentEquals(other.getLeft()) &&
+                    this.getRight().sourceComponentEquals(other.getRight()));
+        }
+        return false;
+    }
+
+    public enum Operator {
+        GT,
+        LT,
+        GTE,
+        LTE,
+        EQ,
+        NEQ,
+        IN,
+        REGEXPEQ,
+        REGEXPNEQ,
+        AND,
+        OR
+    }
+
+    private final Operator operator;
+    private final Expression left;
+    private final Expression right;
+
+    public Expression getRight() {
+        return right;
+    }
+
+    public Expression getLeft() {
+        return left;
+    }
+
+    public Operator getOperator() {
+        return operator;
+    }
+
+    public BinaryBooleanExpression(SourceMetadata meta,
+                                   Operator operator,
+                                   Expression left,
+                                   Expression right) throws InvalidIRException {
+        super(meta);
+
+        boolean isRegexpOp = ((operator == Operator.REGEXPEQ || operator == Operator.REGEXPNEQ));
+        boolean isRegexRval = (right instanceof RegexValueExpression);
+        if (isRegexpOp ^ isRegexRval) {
+            throw new InvalidIRException("You must use a regexp operator with a regexp rval! Op: " + operator + " rval " + right);
+        }
+
+        this.operator = operator;
+        this.left = left;
+        this.right = right;
+    }
+
+    @Override
+    public String toString(int indent) {
+        return indentPadding(indent) + "(" + operator.toString().toLowerCase() + " " + left.toString(0) + " " + right.toString(0) + ")";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/BooleanExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/BooleanExpression.java
new file mode 100644
index 00000000000..533d20f5c56
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/BooleanExpression.java
@@ -0,0 +1,13 @@
+package org.logstash.config.ir.expression;
+
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.Expression;
+
+/**
+ * Created by andrewvc on 9/14/16.
+ */
+public abstract class BooleanExpression extends Expression {
+    public BooleanExpression(SourceMetadata meta) {
+        super(meta);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/EventValueExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/EventValueExpression.java
new file mode 100644
index 00000000000..ece7f547171
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/EventValueExpression.java
@@ -0,0 +1,36 @@
+package org.logstash.config.ir.expression;
+
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+
+/**
+ * Created by andrewvc on 9/13/16.
+ */
+public class EventValueExpression extends Expression {
+    private final String fieldName;
+
+    public EventValueExpression(SourceMetadata meta, String fieldName) {
+        super(meta);
+        this.fieldName = fieldName;
+    }
+
+    public String getFieldName() {
+        return fieldName;
+    }
+
+    @Override
+    public boolean sourceComponentEquals(SourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (this == sourceComponent) return true;
+        if (sourceComponent instanceof EventValueExpression) {
+            EventValueExpression other = (EventValueExpression) sourceComponent;
+            return (this.getFieldName().equals(other.getFieldName()));
+        }
+        return false;
+    }
+
+    @Override
+    public String toString(int indent) {
+        return indentPadding(indent) + "(eventget " + fieldName + ")";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java
new file mode 100644
index 00000000000..18056dd4f61
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/Expression.java
@@ -0,0 +1,18 @@
+package org.logstash.config.ir.expression;
+
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+
+/**
+ * [foo] == "foostr" eAnd [bar] > 10
+ * eAnd(eEq(eventValueExpr("foo"), value("foostr")), eEq(eEventValue("bar"), value(10)))
+ *
+ * if [foo]
+ * notnull(eEventValue("foo"))
+ * Created by andrewvc on 9/6/16.
+ */
+public abstract class Expression extends SourceComponent {
+    public Expression(SourceMetadata meta) {
+        super(meta);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/RegexValueExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/RegexValueExpression.java
new file mode 100644
index 00000000000..d9c1bd1d5c0
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/RegexValueExpression.java
@@ -0,0 +1,47 @@
+package org.logstash.config.ir.expression;
+
+import org.joni.Option;
+import org.joni.Regex;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class RegexValueExpression extends ValueExpression {
+    private final Regex regex;
+
+    public RegexValueExpression(SourceMetadata meta, Object value) throws InvalidIRException {
+        super(meta, value);
+
+        if (!(value instanceof String)) {
+            throw new InvalidIRException("Regex value expressions can only take strings!");
+        }
+
+        byte[] patternBytes = getSource().getBytes();
+        this.regex = new Regex(patternBytes, 0, patternBytes.length, Option.NONE);
+    }
+
+    @Override
+    public Object get() {
+        return this.regex;
+    }
+
+    public String getSource() {
+        return (String) value;
+    }
+
+    public String toString(int indent) {
+        return this.value.toString();
+    }
+
+    @Override
+    public boolean sourceComponentEquals(SourceComponent other) {
+        if (other == null) return false;
+        if (other instanceof RegexValueExpression) {
+            return (((RegexValueExpression) other).getSource().equals(getSource()));
+        }
+        return false;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/UnaryBooleanExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/UnaryBooleanExpression.java
new file mode 100644
index 00000000000..bc5a9363863
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/UnaryBooleanExpression.java
@@ -0,0 +1,53 @@
+package org.logstash.config.ir.expression;
+
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+
+/**
+ * Created by andrewvc on 9/13/16.
+ */
+public class UnaryBooleanExpression extends BooleanExpression {
+    @Override
+    public boolean sourceComponentEquals(SourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (sourceComponent == this) return true;
+        if (sourceComponent instanceof UnaryBooleanExpression) {
+            UnaryBooleanExpression other = (UnaryBooleanExpression) sourceComponent;
+            return (this.operator == other.getOperator() &&
+                    ((this.getExpression() == null && other.getExpression() == null) ||
+                            (this.getExpression().sourceComponentEquals(other.getExpression()))));
+        }
+        return false;
+    }
+
+    public enum Operator {
+        NOT,
+        NOTNULL,
+        ISNULL
+    }
+
+    private final Operator operator;
+    private final Expression expression;
+
+    public Expression getExpression() {
+        return expression;
+    }
+
+    public Operator getOperator() {
+        return operator;
+    }
+
+    public UnaryBooleanExpression(SourceMetadata meta,
+                                   Operator operator,
+                                   Expression expression) {
+        super(meta);
+        this.operator = operator;
+        this.expression = expression;
+    }
+
+    @Override
+    public String toString(int indent) {
+        String exStr = expression == null ? "null" : expression.toString(0);
+        return indentPadding(indent) + "(" + operator.toString().toLowerCase() + " " + exStr + ")";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/expression/ValueExpression.java b/logstash-core/src/main/java/org/logstash/config/ir/expression/ValueExpression.java
new file mode 100644
index 00000000000..3a0cb3ddc6a
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/expression/ValueExpression.java
@@ -0,0 +1,63 @@
+package org.logstash.config.ir.expression;
+
+import org.joni.Regex;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+
+import java.math.BigDecimal;
+import java.util.List;
+
+/**
+ * Created by andrewvc on 9/13/16.
+ */
+public class ValueExpression extends Expression {
+    protected final Object value;
+
+    public ValueExpression(SourceMetadata meta, Object value) throws InvalidIRException {
+        super(meta);
+
+        if (!(value == null ||
+                value instanceof Short ||
+                value instanceof Long ||
+                value instanceof Integer ||
+                value instanceof Float ||
+                value instanceof Double ||
+                value instanceof BigDecimal ||
+                value instanceof String ||
+                value instanceof List ||
+                value instanceof java.time.Instant
+        )) {
+            throw new InvalidIRException("Invalid eValue " + value + " with class " + value.getClass().getName());
+        }
+
+        this.value = value;
+    }
+
+    public Object get() {
+        return value;
+    }
+
+    @Override
+    public boolean sourceComponentEquals(SourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (this == sourceComponent) return true;
+        if (sourceComponent instanceof ValueExpression) {
+            ValueExpression other = (ValueExpression) sourceComponent;
+            return (this.get().equals(other.get()));
+        }
+        return false;
+    }
+
+    @Override
+    public String toString(int indent) {
+        if (value == null) {
+            return "null";
+        }
+        if (value instanceof String) {
+            return "'" + get() + "'";
+        }
+
+        return indentPadding(indent) + get().toString();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/BooleanEdge.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/BooleanEdge.java
new file mode 100644
index 00000000000..41598688f87
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/BooleanEdge.java
@@ -0,0 +1,39 @@
+package org.logstash.config.ir.graph;
+
+import java.util.Collection;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class BooleanEdge extends Edge {
+    public static class BooleanEdgeFactory extends EdgeFactory {
+        private final Boolean edgeType;
+
+        public BooleanEdgeFactory(Boolean edgeType) {
+            this.edgeType = edgeType;
+        }
+
+        public BooleanEdge make(Vertex in, Vertex out) {
+            return new BooleanEdge(edgeType, in, out);
+        }
+    }
+
+    public static Collection<Edge> trueThreadVertices(Vertex... vertices) {
+        return threadVertices(new BooleanEdgeFactory(true), vertices);
+    }
+
+    public static Collection<Edge> falseThreadVertices(Vertex... vertices) {
+        return threadVertices(new BooleanEdgeFactory(false), vertices);
+    }
+
+    private final Boolean edgeType;
+
+    public BooleanEdge(Boolean edgeType, Vertex outVertex, Vertex inVertex) {
+        super(outVertex, inVertex);
+        this.edgeType = edgeType;
+    }
+
+    public String toString() {
+        return getFrom() + " -|" + this.edgeType + "|-> " + getTo();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/Edge.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/Edge.java
new file mode 100644
index 00000000000..10e2894d9ad
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/Edge.java
@@ -0,0 +1,55 @@
+package org.logstash.config.ir.graph;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class Edge {
+    public static class EdgeFactory {
+        public Edge make(Vertex out, Vertex in) {
+            return new Edge(out, in);
+        }
+    }
+
+    private final Vertex to;
+    private final Vertex from;
+
+    public static Collection<Edge> threadVertices(Vertex... vertices) {
+        return threadVertices(new EdgeFactory());
+    }
+
+    public static Collection<Edge> threadVertices(EdgeFactory edgeFactory, Vertex... vertices) {
+        Collection<Edge> edges = new ArrayList<>();
+
+        for (int i = 0; i < vertices.length-1; i++) {
+            Vertex from = vertices[i];
+            Vertex to = vertices[i+1];
+
+            Edge edge = edgeFactory.make(from, to);
+            to.addInEdge(edge);
+            from.addOutEdge(edge);
+            edges.add(edge);
+        }
+
+        return edges;
+    }
+
+    public Edge(Vertex from, Vertex to) {
+        this.from = from;
+        this.to = to;
+    }
+
+    public Vertex getTo() {
+        return to;
+    }
+
+    public Vertex getFrom() {
+        return from;
+    }
+
+    public String toString() {
+        return getFrom() + " -> " + getTo();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java
new file mode 100644
index 00000000000..14d3500c7bc
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/Graph.java
@@ -0,0 +1,117 @@
+package org.logstash.config.ir.graph;
+
+import org.logstash.config.ir.InvalidIRException;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class Graph {
+    private final Set<Vertex> vertices = new HashSet<>();
+    private final Set<Edge> edges = new HashSet<>();
+
+    public static Graph empty() {
+        return new Graph();
+    }
+
+    public Graph(Collection<Vertex> vertices, Collection<Edge> edges) {
+        this.vertices.addAll(vertices);
+        this.edges.addAll(edges);
+    }
+
+    public Graph() {
+    }
+
+    public Graph addVertex(Vertex v) {
+        this.vertices.add(v);
+        return this;
+    }
+
+    public Graph addByThreading(Edge.EdgeFactory edgeFactory, Vertex... vertices) {
+        Collection<Edge> newEdges = Edge.threadVertices(edgeFactory, vertices);
+        addEdges(newEdges);
+
+        return this;
+    }
+
+    public Graph addByThreading(Vertex... vertices) {
+        return addByThreading(new Edge.EdgeFactory(), vertices);
+    }
+
+    private void addEdge(Edge e) {
+        this.getEdges().add(e);
+        refresh();
+    }
+
+    public void refresh() {
+        walk(e -> {
+            this.edges.add(e);
+            this.vertices.add(e.getTo());
+            this.vertices.add(e.getFrom());
+        });
+    }
+
+    public void walk(Consumer<Edge> consumer) {
+        for (Vertex root : roots().collect(Collectors.toList())) {
+            walk(consumer, root);
+        }
+    }
+
+    // TODO check for cycles with a topological sort
+    private void walk(Consumer<Edge> consumer, Vertex vertex) {
+        for (Edge edge : vertex.getOutgoingEdges()) {
+            consumer.accept(edge);
+            walk(consumer, edge.getTo());
+        }
+    }
+
+    public Graph addEdges(Collection<Edge> edges) {
+        this.edges.addAll(edges);
+
+        this.edges.stream().forEach(edge -> {
+            this.vertices.add(edge.getTo());
+            this.vertices.add(edge.getFrom());
+        });
+
+        refresh();
+
+        return this;
+    }
+
+    public Optional<Vertex> root() throws InvalidIRException {
+        refresh();
+        if ( roots().count() > 1 ) {
+            throw new InvalidIRException("Expected one root, got multiple!");
+        }
+        return roots().findFirst();
+    }
+
+    public Stream<Vertex> roots() {
+        return vertices.stream().filter(Vertex::isRoot);
+    }
+
+    public Stream<Vertex> leaves() {
+        return vertices.stream().filter(Vertex::isLeaf);
+    }
+
+    public Set<Vertex> getVertices() {
+        return vertices;
+    }
+
+    public Set<Edge> getEdges() {
+        return edges;
+    }
+
+    public String toString() {
+        return "<<< GRAPH >>>\n" +
+                getEdges().stream().map(Edge::toString).collect(Collectors.joining("\n")) +
+                "\n<<< /GRAPH >>>";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java
new file mode 100644
index 00000000000..2446c0cb6d2
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/IfVertex.java
@@ -0,0 +1,18 @@
+package org.logstash.config.ir.graph;
+
+import org.logstash.config.ir.expression.BooleanExpression;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class IfVertex extends Vertex {
+    private final BooleanExpression booleanExpression;
+
+    public IfVertex(BooleanExpression booleanExpression) {
+        this.booleanExpression = booleanExpression;
+    }
+
+    public String toString() {
+        return "[if " + booleanExpression.toString(0) + "]";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java
new file mode 100644
index 00000000000..e7651ace932
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/PluginVertex.java
@@ -0,0 +1,24 @@
+package org.logstash.config.ir.graph;
+
+import org.logstash.config.ir.SourceMetadata;
+
+import java.util.Map;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class PluginVertex extends Vertex {
+    private final Map<String, Object> pluginArguments;
+    private final String pluginName;
+    private final SourceMetadata meta;
+
+    public PluginVertex(SourceMetadata meta, String pluginName, Map<String, Object> pluginArguments) {
+        this.meta = meta;
+        this.pluginName = pluginName;
+        this.pluginArguments = pluginArguments;
+    }
+
+    public String toString() {
+        return "P[" + pluginName + " " + pluginArguments + "]";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/SpecialVertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/SpecialVertex.java
new file mode 100644
index 00000000000..b92702a7ab5
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/SpecialVertex.java
@@ -0,0 +1,39 @@
+package org.logstash.config.ir.graph;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class SpecialVertex extends Vertex {
+    private final Type type;
+
+    public SpecialVertex() {
+        this.type = Type.QUEUE;
+    }
+
+    public SpecialVertex(Type type) {
+        this.type = type;
+
+    }
+
+    enum Type {
+        FILTER_IN ("FILTER_IN"),
+        FILTER_OUT ("FILTER OUT"),
+        OUTPUT_IN ("OUTPUT IN"),
+        OUTPUT_OUT ("OUTPUT OUT"),
+        QUEUE ("QUEUE");
+
+        private final String name;
+
+        Type(String s) {
+            this.name = s;
+        }
+
+        public String toString() {
+            return this.name;
+        }
+    }
+
+    public String toString() {
+        return "S[" + this.type + "]";
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java b/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java
new file mode 100644
index 00000000000..831b7151a2c
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/graph/Vertex.java
@@ -0,0 +1,50 @@
+package org.logstash.config.ir.graph;
+
+import java.util.Collection;
+import java.util.HashSet;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class Vertex {
+    private final Collection<Edge> incoming = new HashSet<Edge>();
+    private final Collection<Edge> outgoingEdges = new HashSet<Edge>();
+
+    public Vertex() {
+    }
+
+    public Vertex(Collection<Edge> incoming, Collection<Edge> outgoingEdges) {
+        this.incoming.addAll(incoming);
+        this.outgoingEdges.addAll(outgoingEdges);
+    }
+
+    public Vertex addInEdge(Edge e) {
+        this.incoming.add(e);
+        return this;
+    }
+
+    public Vertex addOutEdge(Edge e) {
+        this.outgoingEdges.add(e);
+        return this;
+    }
+
+    public boolean isRoot() {
+        return incoming.size() == 0;
+    }
+
+    public boolean isLeaf() {
+        return outgoingEdges.size() == 0;
+    }
+
+    public boolean hasOutEdges() {
+        return incoming.size() > 0;
+    }
+
+    public Collection<Edge> getIncoming() {
+        return incoming;
+    }
+
+    public Collection<Edge> getOutgoingEdges() {
+        return outgoingEdges;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedStatement.java
new file mode 100644
index 00000000000..78c63a32381
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/ComposedStatement.java
@@ -0,0 +1,83 @@
+package org.logstash.config.ir.imperative;
+
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public class ComposedStatement extends Statement {
+    private final List<Statement> statements;
+
+    public ComposedStatement(SourceMetadata meta, List<Statement> statements) throws InvalidIRException {
+        super(meta);
+        if (statements == null || statements.stream().anyMatch(s -> s == null)) {
+            throw new InvalidIRException("Nulls eNot allowed for list eOr in statement list");
+        }
+        this.statements = statements;
+    }
+
+    public List<Statement> getStatements() {
+        return this.statements;
+    }
+
+    public int size() {
+        return getStatements().size();
+    }
+
+    @Override
+    public boolean sourceComponentEquals(SourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (this == sourceComponent) return true;
+        if (sourceComponent instanceof ComposedStatement) {
+            ComposedStatement other = (ComposedStatement) sourceComponent;
+            if (this.size() != other.size()) {
+                return false;
+            }
+            for (int i = 0; i < size(); i++) {
+                Statement s = this.getStatements().get(i);
+                Statement os = other.getStatements().get(i);
+                if (!(s.sourceComponentEquals(os))) return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public String toString(int indent) {
+        return indentPadding(indent) + "(compose \n" +
+                statements.stream().map(s -> s.toString(indent+2)).collect(Collectors.joining("\n")) +
+                "\n)";
+    }
+
+    @Override
+    public Graph toGraph() throws InvalidIRException {
+        Graph g = Graph.empty();
+
+
+        Collection<Vertex> previousLeaves = null;
+        for (Statement statement : statements) {
+            Graph sg = statement.toGraph();
+            Vertex root = sg.root().get();
+
+            if (previousLeaves != null) {
+                for (Vertex previousLeaf : previousLeaves) {
+                    g.addByThreading(previousLeaf, root);
+                }
+            }
+
+            previousLeaves = sg.leaves().collect(Collectors.toSet());
+        }
+
+        g.refresh();
+        return g;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/IfStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/IfStatement.java
new file mode 100644
index 00000000000..9577649b367
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/IfStatement.java
@@ -0,0 +1,104 @@
+package org.logstash.config.ir.imperative;
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.expression.BooleanExpression;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.graph.*;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ * if 5 {
+ *
+ * }
+ */
+
+public class IfStatement extends Statement {
+    private final BooleanExpression booleanExpression;
+    private final Statement trueStatement;
+    private final Statement falseStatement;
+
+    public BooleanExpression getBooleanExpression() {
+        return booleanExpression;
+    }
+
+    public Statement getTrueStatement() {
+        return trueStatement;
+    }
+
+    public Statement getFalseStatement() {
+        return falseStatement;
+    }
+
+    public IfStatement(SourceMetadata meta,
+                       BooleanExpression booleanExpression,
+                       Statement trueStatement,
+                       Statement falseStatement
+    ) throws InvalidIRException {
+        super(meta);
+
+        if (booleanExpression == null) throw new InvalidIRException("Boolean expr must eNot be null!");
+        if (trueStatement == null) throw new InvalidIRException("If Statement needs true statement!");
+        if (falseStatement == null) throw new InvalidIRException("If Statement needs false statement!");
+
+        this.booleanExpression = booleanExpression;
+        this.trueStatement = trueStatement;
+        this.falseStatement = falseStatement;
+    }
+
+    @Override
+    public boolean sourceComponentEquals(SourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (sourceComponent == this) return true;
+        if (sourceComponent instanceof IfStatement) {
+            IfStatement other = (IfStatement) sourceComponent;
+
+
+            return (this.booleanExpression.sourceComponentEquals(other.getBooleanExpression()) &&
+                    this.trueStatement.sourceComponentEquals(other.trueStatement) &&
+                    this.falseStatement.sourceComponentEquals(other.falseStatement));
+        }
+        return false;
+    }
+
+    @Override
+    public String toString(int indent) {
+        return indentPadding(indent) +
+                    "(if " + booleanExpression.toString(0) +
+                    "\n" +
+                    this.trueStatement +
+                    "\n" +
+                    this.falseStatement +
+                    ")";
+    }
+
+    @Override
+    public Graph toGraph() throws InvalidIRException {
+        Graph graph = new Graph();
+        Vertex ifVertex = new IfVertex(this.booleanExpression);
+
+        if (!(getTrueStatement() instanceof NoopStatement)) {
+            graph.addByThreading(
+                    new BooleanEdge.BooleanEdgeFactory(true),
+                    ifVertex,
+                    this.getTrueStatement().toGraph().root().get()
+            );
+        }
+
+        if (!(getFalseStatement() instanceof NoopStatement)) {
+            Graph fStatement = getFalseStatement().toGraph();
+            List<Vertex> fStatementRoots = fStatement.roots().collect(Collectors.toList());
+            Vertex fStatementRoot = fStatement.root().get();
+            System.out.println(fStatementRoot + fStatementRoots.toString());
+            graph.addByThreading(
+                    new BooleanEdge.BooleanEdgeFactory(false),
+                    ifVertex,
+                    this.getFalseStatement().toGraph().root().get()
+            );
+        }
+        return graph;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/NoopStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/NoopStatement.java
new file mode 100644
index 00000000000..840afa166ed
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/NoopStatement.java
@@ -0,0 +1,39 @@
+package org.logstash.config.ir.imperative;
+
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.graph.Edge;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class NoopStatement extends Statement {
+
+    public NoopStatement(SourceMetadata meta) {
+        super(meta);
+    }
+
+    @Override
+    public boolean sourceComponentEquals(SourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (sourceComponent instanceof NoopStatement) return true;
+        return false;
+    }
+
+    @Override
+    public String toString(int indent) {
+        return indentPadding(indent) + "(Noop)";
+    }
+
+    @Override
+    public Graph toGraph() {
+        return Graph.empty();
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/PluginStatement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/PluginStatement.java
new file mode 100644
index 00000000000..bfd1fdc52a2
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/PluginStatement.java
@@ -0,0 +1,53 @@
+package org.logstash.config.ir.imperative;
+
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.PluginVertex;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.Map;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public class PluginStatement extends Statement {
+    private final Map<String, Object> pluginArguments;
+    private final String pluginName;
+
+    public String getPluginName() {
+        return pluginName;
+    }
+
+    public Map<String, Object> getPluginArguments() {
+        return pluginArguments;
+    }
+
+    public PluginStatement(SourceMetadata meta, String pluginName, Map<String, Object> pluginArguments) {
+        super(meta);
+        this.pluginName = pluginName;
+        this.pluginArguments = pluginArguments;
+    }
+
+    @Override
+    public boolean sourceComponentEquals(SourceComponent sourceComponent) {
+        if (sourceComponent == null) return false;
+        if (sourceComponent == this) return true;
+        if (sourceComponent instanceof PluginStatement) {
+            PluginStatement other = (PluginStatement) sourceComponent;
+            return (this.pluginName.equals(other.pluginName) && this.pluginArguments.equals(other.getPluginArguments()));
+        }
+        return false;
+    }
+
+    @Override
+    public String toString(int indent) {
+        return indentPadding(indent) + "(plugin '" + pluginName + "' " + getPluginArguments().toString() + ")";
+    }
+
+    @Override
+    public Graph toGraph() {
+        Vertex pluginVertex = new PluginVertex(getMeta(), pluginName, pluginArguments);
+        return Graph.empty().addVertex(pluginVertex);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/ir/imperative/Statement.java b/logstash-core/src/main/java/org/logstash/config/ir/imperative/Statement.java
new file mode 100644
index 00000000000..e1403498241
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/ir/imperative/Statement.java
@@ -0,0 +1,21 @@
+package org.logstash.config.ir.imperative;
+
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.SourceMetadata;
+import org.logstash.config.ir.graph.Edge;
+import org.logstash.config.ir.graph.Graph;
+import org.logstash.config.ir.graph.Vertex;
+
+import java.util.Collection;
+
+/**
+ * Created by andrewvc on 9/6/16.
+ */
+public abstract class Statement extends SourceComponent {
+    public Statement(SourceMetadata meta) {
+        super(meta);
+    }
+
+    public abstract Graph toGraph() throws InvalidIRException;
+}
diff --git a/logstash-core/src/main/java/org/logstash/log/StructuredMessage.java b/logstash-core/src/main/java/org/logstash/log/StructuredMessage.java
index 2145acea746..5350e67c996 100644
--- a/logstash-core/src/main/java/org/logstash/log/StructuredMessage.java
+++ b/logstash-core/src/main/java/org/logstash/log/StructuredMessage.java
@@ -29,7 +29,7 @@ public StructuredMessage(String message, Object[] params) {
                     paramsMap.put(params[i].toString(), params[i + 1]);
                 }
             } catch (IndexOutOfBoundsException e) {
-                throw new IllegalArgumentException("must log key-value pairs");
+                throw new IllegalArgumentException("must log key-eValue pairs");
             }
         }
         this.message = message;
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/imperative/DSLTest.java b/logstash-core/src/test/java/org/logstash/config/ir/imperative/DSLTest.java
new file mode 100644
index 00000000000..77dea1516f1
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/imperative/DSLTest.java
@@ -0,0 +1,67 @@
+package org.logstash.config.ir.imperative;
+
+import org.hamcrest.MatcherAssert;
+import org.junit.Test;
+import org.logstash.config.ir.SourceComponent;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.SourceMetadata;
+
+import java.util.ArrayList;
+
+import static org.logstash.config.ir.DSL.*;
+
+
+/**
+ * Created by andrewvc on 9/13/16.
+ */
+public class DSLTest {
+    @Test
+    public void testDSLOnePluginEquality() {
+        assertSyntaxEquals(iPlugin("foo"), iPlugin("foo"));
+    }
+
+    @Test
+    public void testComposedPluginEquality() throws InvalidIRException {
+        assertSyntaxEquals(composedPlugins(), composedPlugins());
+    }
+
+    @Test
+    public void testDSLComplexEquality() throws InvalidIRException {
+        assertSyntaxEquals(complexExpression(), complexExpression());
+    }
+
+    @Test
+    public void testComposeSingle() throws InvalidIRException {
+        assertSyntaxEquals(iPlugin("grok"), iCompose(iPlugin("grok")));
+    }
+
+    @Test
+    public void testComposeMulti() throws InvalidIRException {
+        ArrayList<Statement> pluginList = new ArrayList<Statement>();
+        pluginList.add(iPlugin("grok"));
+        pluginList.add(iPlugin("foo"));
+        ComposedStatement composed = new ComposedStatement(new SourceMetadata(), pluginList);
+        assertSyntaxEquals(iCompose(iPlugin("grok"), iPlugin("foo")), composed);
+    }
+
+
+    public SourceComponent composedPlugins() throws InvalidIRException {
+        return iCompose(iPlugin("json"), iPlugin("stuff"));
+    }
+
+    public SourceComponent complexExpression() throws InvalidIRException {
+        return iCompose(
+                iPlugin("grok"),
+                iPlugin("kv"),
+                iIf(eAnd(eNotNull(eValue(5l)), eNotNull(null)),
+                        iPlugin("grok"),
+                        iCompose(iPlugin("json"), iPlugin("stuff"))
+                )
+        );
+    }
+
+    public void assertSyntaxEquals(SourceComponent left, SourceComponent right) {
+        String message = String.format("Expected '%s' to equal '%s'", left, right);
+        MatcherAssert.assertThat(message, left.sourceComponentEquals(right));
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/ir/imperative/ImperativeToGraphtest.java b/logstash-core/src/test/java/org/logstash/config/ir/imperative/ImperativeToGraphtest.java
new file mode 100644
index 00000000000..12736cf203c
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/ir/imperative/ImperativeToGraphtest.java
@@ -0,0 +1,33 @@
+package org.logstash.config.ir.imperative;
+
+import org.junit.Test;
+import org.logstash.config.ir.InvalidIRException;
+import org.logstash.config.ir.graph.Graph;
+
+import static org.logstash.config.ir.DSL.*;
+import static org.logstash.config.ir.DSL.eNotNull;
+import static org.logstash.config.ir.DSL.eValue;
+
+/**
+ * Created by andrewvc on 9/15/16.
+ */
+public class ImperativeToGraphtest {
+    @Test
+    public void convertSimpleExpression() throws InvalidIRException {
+        Graph g =  iCompose(iPlugin("json"), iPlugin("stuff")).toGraph();
+        System.out.println(g);
+    }
+
+    @Test
+    public void convertComplexExpression() throws InvalidIRException {
+        Graph g = iCompose(
+                iPlugin("grok"),
+                iPlugin("kv"),
+                iIf(eAnd(eNotNull(eValue(5l)), eNotNull(null)),
+                        iPlugin("grok"),
+                        iCompose(iPlugin("json"), iPlugin("stuff"))
+                )
+        ).toGraph();
+        System.out.println(g);
+    }
+}
diff --git a/spec/spec_helper.rb b/spec/spec_helper.rb
index 9bec90f640c..5c4a768e438 100644
--- a/spec/spec_helper.rb
+++ b/spec/spec_helper.rb
@@ -26,3 +26,17 @@ def puts(payload)
 def installed_plugins
   Gem::Specification.find_all.select { |spec| spec.metadata["logstash_plugin"] }.map { |plugin| plugin.name }
 end
+
+RSpec::Matchers.define :ir_eql do |expected|
+  match do |actual|
+    if expected.java_kind_of?(org.logstash.config.ir.SourceComponent) && actual.java_kind_of?(org.logstash.config.ir.SourceComponent)
+      expected.sourceComponentEquals(actual)
+    else
+      return false
+    end    
+  end
+  
+  failure_message do |actual|
+    "actual value \n#{actual.to_s}\nis not .sourceComponentEquals to the expected value: \n#{expected.to_s}\n"
+  end
+end
