diff --git a/.gitignore b/.gitignore
index 0210c3075e6..008404d5a0b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -53,3 +53,4 @@ qa/integration/fixtures/offline_wrapper/offline
 qa/integration/fixtures/offline_wrapper/offline.o
 logstash-core/versions-gem-copy.yml
 logstash-core-plugin-api/versions-gem-copy.yml
+config/logstash.keystore
diff --git a/bin/logstash-keystore b/bin/logstash-keystore
new file mode 100755
index 00000000000..8e0fdc020e8
--- /dev/null
+++ b/bin/logstash-keystore
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+unset CDPATH
+. "$(cd `dirname $0`/..; pwd)/bin/logstash.lib.sh"
+setup
+
+# bin/logstash-keystore is a short lived ruby script thus we can use aggressive "faster starting JRuby options"
+# see https://github.com/jruby/jruby/wiki/Improving-startup-time
+export JRUBY_OPTS="$JRUBY_OPTS -J-XX:+TieredCompilation -J-XX:TieredStopAtLevel=1 -J-noverify -X-C -Xcompile.invokedynamic=false"
+
+ruby_exec "${LOGSTASH_HOME}/lib/secretstore/cli.rb" "$@"
diff --git a/bin/logstash-keystore.bat b/bin/logstash-keystore.bat
new file mode 100644
index 00000000000..900376c97eb
--- /dev/null
+++ b/bin/logstash-keystore.bat
@@ -0,0 +1,17 @@
+@echo off
+setlocal enabledelayedexpansion
+
+call "%~dp0setup.bat" || exit /b 1
+if errorlevel 1 (
+	if not defined nopauseonerror (
+		pause
+	)
+	exit /B %ERRORLEVEL%
+)
+
+%JRUBY_BIN% "%LS_HOME%\lib\secretstore\cli.rb" %*
+if errorlevel 1 (
+  exit /B 1
+)
+
+endlocal
diff --git a/lib/secretstore/cli.rb b/lib/secretstore/cli.rb
new file mode 100644
index 00000000000..ae4b8b5d485
--- /dev/null
+++ b/lib/secretstore/cli.rb
@@ -0,0 +1,43 @@
+$LOAD_PATH.push(File.expand_path(File.dirname(__FILE__) + "/../../logstash-core/lib"))
+require_relative "../bootstrap/environment"
+LogStash::Bundler.setup!({:without => [:build, :development]})
+
+require "logstash/namespace"
+require "logstash-core/logstash-core"
+require "logstash/util/settings_helper"
+require "logstash/util/secretstore"
+
+java_import "org.logstash.secret.store.SecretStoreFactory"
+java_import "org.logstash.secret.SecretIdentifier"
+java_import "org.logstash.secret.store.SecureConfig"
+java_import "org.logstash.secret.cli.SecretStoreCli"
+java_import "org.logstash.secret.cli.Terminal"
+
+# Thin wrapper to the Java SecretStore Command Line Interface
+class LogStash::SecretStoreCli
+  include LogStash::Util::Loggable
+
+  begin
+    index = ARGV.find_index("--path.settings")
+    # strip out any path.settings from the command line
+    unless index.nil?
+      path_settings_value = ARGV.slice!(index, 2)[1]
+      if path_settings_value.nil?
+        logger.error("''--path.settings' found, but it is empty. Please remove '--path.settings' from arguments or provide a value") if path_settings_value.nil?
+        exit 1
+      end
+    end
+
+    LogStash::Util::SettingsHelper.pre_process
+    LogStash::Util::SettingsHelper.from_yaml(["--path.settings", path_settings_value])
+    LogStash::Util::SettingsHelper.post_process
+    secure_config = LogStash::Util::SecretStore.get_config
+    cli = SecretStoreCli.new(Terminal.new)
+    cli.command(ARGV[0], secure_config, ARGV[1])
+    exit 0
+  rescue => e
+    logger.error(e.message, :cause => e.cause, :backtrace => e.backtrace)
+    exit 1
+  end
+
+end
\ No newline at end of file
diff --git a/logstash-core/lib/logstash/environment.rb b/logstash-core/lib/logstash/environment.rb
index 1b40ff0916e..a40803bbc3a 100644
--- a/logstash-core/lib/logstash/environment.rb
+++ b/logstash-core/lib/logstash/environment.rb
@@ -66,9 +66,14 @@ module Environment
             Setting::TimeValue.new("slowlog.threshold.warn", "-1"),
             Setting::TimeValue.new("slowlog.threshold.info", "-1"),
             Setting::TimeValue.new("slowlog.threshold.debug", "-1"),
-            Setting::TimeValue.new("slowlog.threshold.trace", "-1")
+            Setting::TimeValue.new("slowlog.threshold.trace", "-1"),
+            Setting::String.new("keystore.classname", "org.logstash.secret.store.backend.JavaKeyStore"),
+            Setting::String.new("keystore.file", ::File.join(::File.join(LogStash::Environment::LOGSTASH_HOME, "config"), "logstash.keystore"), false) # will be populated on
+  # post_process
   ].each {|setting| SETTINGS.register(setting) }
 
+
+
   # Compute the default queue path based on `path.data`
   default_queue_file_path = ::File.join(SETTINGS.get("path.data"), "queue")
   SETTINGS.register Setting::WritableDirectory.new("path.queue", default_queue_file_path)
@@ -76,6 +81,7 @@ module Environment
   default_dlq_file_path = ::File.join(SETTINGS.get("path.data"), "dead_letter_queue")
   SETTINGS.register Setting::WritableDirectory.new("path.dead_letter_queue", default_dlq_file_path)
 
+
   SETTINGS.on_post_process do |settings|
     # If the data path is overridden but the queue path isn't recompute the queue path
     # We need to do this at this stage because of the weird execution order
diff --git a/logstash-core/lib/logstash/settings.rb b/logstash-core/lib/logstash/settings.rb
index c4b12dba989..41f5891b3b0 100644
--- a/logstash-core/lib/logstash/settings.rb
+++ b/logstash-core/lib/logstash/settings.rb
@@ -9,6 +9,7 @@ module LogStash
   class Settings
 
     include LogStash::Util::SubstitutionVariables
+    include LogStash::Util::Loggable
     
     def initialize
       @settings = {}
@@ -27,6 +28,10 @@ def register(setting)
       end
     end
 
+    def registered?(setting_name)
+       @settings.key?(setting_name)
+    end
+
     def get_setting(setting_name)
       setting = @settings[setting_name]
       raise ArgumentError.new("Setting \"#{setting_name}\" hasn't been registered") if setting.nil?
diff --git a/logstash-core/lib/logstash/util/secretstore.rb b/logstash-core/lib/logstash/util/secretstore.rb
new file mode 100644
index 00000000000..b5a726f29d0
--- /dev/null
+++ b/logstash-core/lib/logstash/util/secretstore.rb
@@ -0,0 +1,36 @@
+# encoding: utf-8
+
+# Ruby helper to work with the secret store
+module ::LogStash::Util::SecretStore
+
+  java_import "org.logstash.secret.store.SecretStoreFactory"
+  java_import "org.logstash.secret.SecretIdentifier"
+  java_import "org.logstash.secret.store.SecureConfig"
+  java_import "org.logstash.secret.cli.SecretStoreCli"
+
+  # Return the configuration necessary to work with a secret store
+  def self.get_config
+    secure_config = SecureConfig.new
+    secure_config.add("keystore.file", LogStash::SETTINGS.get_setting("keystore.file").value.chars)
+    pass = ENV["LOGSTASH_KEYSTORE_PASS"]
+    secure_config.add("keystore.pass", pass.chars) unless pass.nil?
+    secure_config.add("keystore.classname", LogStash::SETTINGS.get_setting("keystore.classname").value.chars)
+    secure_config
+  end
+
+  # Check to see if the secret store exists, return true if exists, false otherwise
+  def self.exists?
+    SecretStoreFactory.exists(get_config)
+  end
+
+  # Returns a org.logstash.secret.store.SecretStore if it exists, nil otherwise
+  def self.get_if_exists
+    SecretStoreFactory.load(get_config) if exists?
+  end
+
+  # Returns a org.org.logstash.secret.SecretIdentifier for use with the secret store
+  def self.get_store_id(id)
+    SecretIdentifier.new(id)
+  end
+
+end
diff --git a/logstash-core/lib/logstash/util/settings_helper.rb b/logstash-core/lib/logstash/util/settings_helper.rb
index adb21db6bc0..77b5c003c44 100644
--- a/logstash-core/lib/logstash/util/settings_helper.rb
+++ b/logstash-core/lib/logstash/util/settings_helper.rb
@@ -32,6 +32,7 @@ def self.from_yaml(args)
     settings_path = fetch_settings_path(args)
 
     LogStash::SETTINGS.set("path.settings", settings_path) if settings_path
+    LogStash::SETTINGS.set("keystore.file", ::File.join(settings_path, "logstash.keystore")) if settings_path
 
     begin
       LogStash::SETTINGS.from_yaml(LogStash::SETTINGS.get("path.settings"))
diff --git a/logstash-core/lib/logstash/util/substitution_variables.rb b/logstash-core/lib/logstash/util/substitution_variables.rb
index aa574fd3f32..229b20fbd32 100644
--- a/logstash-core/lib/logstash/util/substitution_variables.rb
+++ b/logstash-core/lib/logstash/util/substitution_variables.rb
@@ -1,9 +1,15 @@
 # encoding: utf-8
+require "logstash/logging"
+require "logstash/util/loggable"
+require "logstash/util/secretstore"
+
 module ::LogStash::Util::SubstitutionVariables
 
+  include LogStash::Util::Loggable
+
   SUBSTITUTION_PLACEHOLDER_REGEX = /\${(?<name>[a-zA-Z_.][a-zA-Z0-9_.]*)(:(?<default>[^}]*))?}/
 
-  # Recursive method to replace environment variable references in parameters
+  # Recursive method to replace substitution variable references in parameters
   def deep_replace(value)
     if value.is_a?(Hash)
       value.each do |valueHashKey, valueHashValue|
@@ -22,7 +28,7 @@ def deep_replace(value)
 
   # Replace all substitution variable references in the 'value' param and returns the substituted value, or the original value if a substitution can not be made
   # Process following patterns : ${VAR}, ${VAR:defaultValue}
-  # If value matches the pattern, returns the following precedence : Environment entry value, default value as provided in the pattern
+  # If value matches the pattern, returns the following precedence : Secret store value, Environment entry value, default value as provided in the pattern
   # If the value does not match the pattern, the 'value' param returns as-is
   def replace_placeholders(value)
     return value unless value.is_a?(String)
@@ -34,12 +40,19 @@ def replace_placeholders(value)
       # [1] http://ruby-doc.org/core-2.1.1/Regexp.html#method-c-last_match
       name = Regexp.last_match(:name)
       default = Regexp.last_match(:default)
+      logger.debug("Replacing `#{placeholder}` with actual value")
 
-      replacement = ENV.fetch(name, default)
+      #check the secret store if it exists
+      secret_store = LogStash::Util::SecretStore.get_if_exists
+      replacement = secret_store.nil? ? nil : secret_store.retrieveSecret(LogStash::Util::SecretStore.get_store_id(name))
+      #check the environment
+      replacement = ENV.fetch(name, default) if replacement.nil?
       if replacement.nil?
-        raise LogStash::ConfigurationError, "Cannot evaluate `#{placeholder}`. Environment variable `#{name}` is not set and there is no default value given."
+        raise LogStash::ConfigurationError, "Cannot evaluate `#{placeholder}`. Replacement variable `#{name}` is not defined in a Logstash secret store " +
+            "or as an Environment entry and there is no default value given."
       end
-      replacement
+      replacement.to_s
     end
   end # def replace_placeholders
+
 end
diff --git a/logstash-core/spec/logstash/settings_spec.rb b/logstash-core/spec/logstash/settings_spec.rb
index 5479d0f8022..3e9ed5fda49 100644
--- a/logstash-core/spec/logstash/settings_spec.rb
+++ b/logstash-core/spec/logstash/settings_spec.rb
@@ -15,11 +15,17 @@
       it "should raise an exception" do
         expect { subject.register(numeric_setting) }.to raise_error
       end
+      it "registered? should return true" do
+        expect( subject.registered?(numeric_setting_name)).to be_truthy
+      end
     end
     context "if setting hasn't been registered" do
       it "should not raise an exception" do
         expect { subject.register(numeric_setting) }.to_not raise_error
       end
+      it "registered? should return false" do
+        expect( subject.registered?(numeric_setting_name)).to be_falsey
+      end
     end
   end
   describe "#get_setting" do
@@ -150,23 +156,31 @@
 
   describe "#from_yaml" do
 
-    context "env placeholders in flat logstash.yml" do
+    before :each do
+      LogStash::SETTINGS.set("keystore.file", File.join(File.dirname(__FILE__), "../../src/test/resources/logstash.keystore.with.default.pass"))
+    end
+
+    context "placeholders in flat logstash.yml" do
+
 
       after do
         ENV.delete('SOME_LOGSTASH_SPEC_ENV_VAR')
         ENV.delete('some.logstash.spec.env.var')
+        ENV.delete('a')
       end
       
       subject do
         settings = described_class.new
-        settings.register(LogStash::Setting::String.new("interpolated", "missing"))
-        settings.register(LogStash::Setting::String.new("with_dot", "missing"))
+        settings.register(LogStash::Setting::String.new("interpolated_env", "missing"))
+        settings.register(LogStash::Setting::String.new("with_dot_env", "missing"))
+        settings.register(LogStash::Setting::String.new("interpolated_store", "missing"))
         settings
       end
 
       let(:values) {{
-        "interpolated" => "${SOME_LOGSTASH_SPEC_ENV_VAR}",
-        "with_dot" => "${some.logstash.spec.env.var}"
+        "interpolated_env" => "${SOME_LOGSTASH_SPEC_ENV_VAR}",
+        "with_dot_env" => "${some.logstash.spec.env.var}",
+        "interpolated_store" => "${a}"
       }}
       let(:yaml_path) do
         p = Stud::Temporary.pathname
@@ -178,28 +192,37 @@
         p
       end
 
-      it "can interpolate environment into settings" do
-        expect(subject.get('interpolated')).to eq("missing")
-        expect(subject.get('with_dot')).to eq("missing")
-        ENV['SOME_LOGSTASH_SPEC_ENV_VAR'] = "correct_setting"
-        ENV['some.logstash.spec.env.var'] = "correct_setting_for_dotted"
+      it "can interpolate into settings" do
+        expect(subject.get('interpolated_env')).to eq("missing")
+        expect(subject.get('with_dot_env')).to eq("missing")
+        expect(subject.get('interpolated_store')).to eq("missing")
+        ENV['SOME_LOGSTASH_SPEC_ENV_VAR'] = "correct_setting_env"
+        ENV['some.logstash.spec.env.var'] = "correct_setting_for_dotted_env"
+        ENV['a'] = "wrong_value" # the store should take precedence
         subject.from_yaml(yaml_path)
-        expect(subject.get('interpolated')).to eq("correct_setting")
-        expect(subject.get('with_dot')).to eq("correct_setting_for_dotted")
+        expect(subject.get('interpolated_env')).to eq("correct_setting_env")
+        expect(subject.get('with_dot_env')).to eq("correct_setting_for_dotted_env")
+        expect(subject.get('interpolated_store')).to eq("A")
       end
     end
   end
 
-  context "env placeholders in nested logstash.yml" do
+  context "placeholders in nested logstash.yml" do
+
+    before :each do
+      LogStash::SETTINGS.set("keystore.file", File.join(File.dirname(__FILE__), "../../src/test/resources/logstash.keystore.with.default.pass"))
+    end
 
     before do
-      ENV['lsspecdomain'] = "domain1"
-      ENV['lsspecdomain2'] = "domain2"
+      ENV['lsspecdomain_env'] = "domain1"
+      ENV['lsspecdomain2_env'] = "domain2"
+      ENV['a'] = "wrong_value" # the store should take precedence
     end
 
     after do
-      ENV.delete('lsspecdomain')
-      ENV.delete('lsspecdomain2')
+      ENV.delete('lsspecdomain_env')
+      ENV.delete('lsspecdomain2_env')
+      ENV.delete('a')
     end
 
     subject do
@@ -210,10 +233,12 @@
     end
 
     let(:values) {{
-      "host" => ["dev1.${lsspecdomain}", "dev2.${lsspecdomain}"],
+      "host" => ["dev1.${lsspecdomain_env}", "dev2.${lsspecdomain_env}", "dev3.${a}"],
       "modules" => [
-        {"name" => "${lsspecdomain}", "testing" => "${lsspecdomain}"}, 
-        {"name" => "${lsspecdomain2}", "testing" => "${lsspecdomain2}"}
+        {"name" => "${lsspecdomain_env}", "testing" => "${lsspecdomain_env}"},
+        {"name" => "${lsspecdomain2_env}", "testing" => "${lsspecdomain2_env}"},
+        {"name" => "${a}", "testing" => "${a}"},
+        {"name" => "${b}", "testing" => "${b}"}
       ]
     }}
     let(:yaml_path) do
@@ -230,10 +255,12 @@
       expect(subject.get('host')).to match_array([])
       expect(subject.get('modules')).to match_array([])
       subject.from_yaml(yaml_path)
-      expect(subject.get('host')).to match_array(["dev1.domain1", "dev2.domain1"])
+      expect(subject.get('host')).to match_array(["dev1.domain1", "dev2.domain1", "dev3.A"])
       expect(subject.get('modules')).to match_array([
                                                       {"name" => "domain1", "testing" => "domain1"},
-                                                      {"name" => "domain2", "testing" => "domain2"}
+                                                      {"name" => "domain2", "testing" => "domain2"},
+                                                      {"name" => "A", "testing" => "A"},
+                                                      {"name" => "B", "testing" => "B"}
                                                     ])
     end
   end
diff --git a/logstash-core/spec/logstash/util/secretstore_spec.rb b/logstash-core/spec/logstash/util/secretstore_spec.rb
new file mode 100644
index 00000000000..59974dbffc4
--- /dev/null
+++ b/logstash-core/spec/logstash/util/secretstore_spec.rb
@@ -0,0 +1,69 @@
+require "logstash/util/secretstore"
+require "logstash/settings"
+
+describe LogStash::Util::SecretStore do
+
+  subject {LogStash::Util::SecretStore}
+
+  describe "with missing keystore" do
+    before :each do
+      LogStash::SETTINGS.set("keystore.file", File.join(File.dirname(__FILE__), "nothing_here"))
+    end
+
+    it "should be not exist" do
+      expect(subject.exists?).to be_falsy
+      expect(subject.get_if_exists).to be_nil
+    end
+  end
+
+  describe "with implicit password keystore" do
+    before :each do
+      LogStash::SETTINGS.set("keystore.file", File.join(File.dirname(__FILE__), "../../../src/test/resources/logstash.keystore.with.default.pass"))
+    end
+
+    it "should be readable" do
+      expect(subject.get_if_exists.list).to include(subject.get_store_id("keystore.seed"))
+    end
+  end
+
+  describe "with explicit password keystore" do
+    before :each do
+      LogStash::SETTINGS.set("keystore.file", File.join(File.dirname(__FILE__), "../../../src/test/resources/logstash.keystore.with.defined.pass"))
+    end
+
+    describe "and correct password" do
+      before do
+        ENV['LOGSTASH_KEYSTORE_PASS'] = "mypassword"
+      end
+
+      after do
+        ENV.delete('LOGSTASH_KEYSTORE_PASS')
+      end
+
+      it "should be readable" do
+        expect(subject.get_if_exists.list).to include(subject.get_store_id("keystore.seed"))
+      end
+    end
+
+    describe "and wrong password" do
+      before do
+        ENV['LOGSTASH_KEYSTORE_PASS'] = "not_the_correct_password"
+      end
+
+      after do
+        ENV.delete('LOGSTASH_KEYSTORE_PASS')
+      end
+
+      it "should be not readable" do
+        expect {subject.get_if_exists}.to raise_error.with_message(/Can not access Logstash keystore/)
+      end
+    end
+
+    describe "and missing password" do
+      it "should be not readable" do
+        expect {subject.get_if_exists}.to raise_error.with_message(/Could not determine keystore password/)
+      end
+    end
+  end
+
+end
\ No newline at end of file
diff --git a/logstash-core/src/main/java/org/logstash/secret/SecretIdentifier.java b/logstash-core/src/main/java/org/logstash/secret/SecretIdentifier.java
new file mode 100644
index 00000000000..b28d4549646
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/SecretIdentifier.java
@@ -0,0 +1,101 @@
+package org.logstash.secret;
+
+import java.util.Locale;
+import java.util.regex.Pattern;
+
+/**
+ * <p>A URN based identifier for a given secret. The URN is constructed as such: {@code urn:logstash:secret:v1:<key>}</p>
+ * <p><em>Note - v1 is the version of the URN (not the key). This allows for passive changes to the URN for anything to the right of v1</em></p>
+ */
+public class SecretIdentifier {
+
+    private final static Pattern colonPattern = Pattern.compile(":");
+    private final static String VERSION = "v1";
+    private final static Pattern urnPattern = Pattern.compile("urn:logstash:secret:"+ VERSION + ":.*$");
+    private final String key;
+
+    /**
+     * Constructor
+     *
+     * @param key The unique part of the identifier. This is the key to reference the secret, and the key itself should not be sensitive. For example: {@code db.pass}
+     */
+    public SecretIdentifier(String key) {
+        this.key = validateWithTransform(key, "key");
+    }
+
+    /**
+     * Converts an external URN format to a {@link SecretIdentifier} object.
+     *
+     * @param urn The {@link String} formatted identifier obtained originally from {@link SecretIdentifier#toExternalForm()}
+     * @return The {@link SecretIdentifier} object used to identify secrets, null if not valid external form.
+     */
+    public static SecretIdentifier fromExternalForm(String urn) {
+        if (urn == null || !urnPattern.matcher(urn).matches()) {
+            throw new IllegalArgumentException("Invalid external form " + urn);
+        }
+        String[] parts = colonPattern.split(urn, 5);
+        return new SecretIdentifier(validateWithTransform(parts[4], "key"));
+    }
+
+    /**
+     * Minor validation and downcases the parts
+     *
+     * @param part     The part of the URN to validate
+     * @param partName The name of the part used for logging.
+     * @return The validated and transformed part.
+     */
+    private static String validateWithTransform(String part, String partName) {
+        if (part == null || part.isEmpty()) {
+            throw new IllegalArgumentException(String.format("%s may not be null or empty", partName));
+        }
+        return part.toLowerCase(Locale.US);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        SecretIdentifier that = (SecretIdentifier) o;
+
+        if (key != null ? !key.equals(that.key) : that.key != null) return false;
+        return VERSION != null ? VERSION.equals(that.VERSION) : that.VERSION == null;
+    }
+
+    /**
+     * Get the key (unique part) of the identifier
+     *
+     * @return the unique part of the identifier
+     */
+    public String getKey() {
+        return key;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = key != null ? key.hashCode() : 0;
+        result = 31 * result + (VERSION != null ? VERSION.hashCode() : 0);
+        return result;
+    }
+
+    /**
+     * Converts this object to a format acceptable external {@link String} format. Note - no gauruntees are made with respect to encoding or safe use. For example, the external
+     * format may not be URL safely encoded.
+     *
+     * @return the externally formatted {@link String}
+     */
+    public String toExternalForm() {
+        StringBuilder sb = new StringBuilder(100);
+        sb.append("urn").append(":");
+        sb.append("logstash").append(":");
+        sb.append("secret").append(":");
+        sb.append(VERSION).append(":");
+        sb.append(this.key);
+        return sb.toString();
+    }
+
+    @Override
+    public String toString() {
+        return toExternalForm();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/cli/SecretStoreCli.java b/logstash-core/src/main/java/org/logstash/secret/cli/SecretStoreCli.java
new file mode 100644
index 00000000000..ca9227fdb0c
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/cli/SecretStoreCli.java
@@ -0,0 +1,189 @@
+package org.logstash.secret.cli;
+
+import org.logstash.secret.SecretIdentifier;
+import org.logstash.secret.store.*;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+import static org.logstash.secret.store.SecretStoreFactory.LOGSTASH_MARKER;
+
+/**
+ * Command line interface for the {@link SecretStore}. <p>Currently expected to be called from Ruby since all the required configuration is currently read from Ruby.</p>
+ * <p>Note - this command line user interface intentionally mirrors Elasticsearch's </p>
+ */
+public class SecretStoreCli {
+
+    private final Terminal terminal;
+    enum Command {
+        CREATE("create"), LIST("list"), ADD("add"), REMOVE("remove"), HELP("--help");
+
+        private final String option;
+
+        Command(String option) {
+            this.option = option;
+        }
+
+        static Optional<Command> fromString(final String input) {
+            Optional<Command> command = EnumSet.allOf(Command.class).stream().filter(c -> c.option.equals(input)).findFirst();
+            return command;
+        }
+    }
+
+    public SecretStoreCli(Terminal terminal){
+        this.terminal = terminal;
+    }
+
+    /**
+     * Entry point to issue a command line command.
+     * @param primaryCommand The string representation of a {@link Command}, if the String does not map to a {@link Command}, then it will show the help menu.
+     * @param config The configuration needed to work a secret store. May be null for help.
+     * @param argument This can be either the identifier for a secret, or a sub command like --help. May be null.
+     */
+    public void command(String primaryCommand, SecureConfig config, String argument) {
+        terminal.writeLine("");
+        final Command command = Command.fromString(primaryCommand).orElse(Command.HELP);
+        final Optional<Command> sub = Command.fromString(argument);
+        boolean help = Command.HELP.equals(sub.orElse(null));
+        switch (command) {
+            case CREATE: {
+                if (help){
+                    terminal.writeLine("Creates a new keystore. For example: 'bin/logstash-keystore create'");
+                    return;
+                }
+                if (SecretStoreFactory.exists(config.clone())) {
+                    terminal.write("An Logstash keystore already exists. Overwrite ? [y/N] ");
+                    if (isYes(terminal.readLine())) {
+                        create(config);
+                    }
+                } else {
+                    create(config);
+                }
+                break;
+            }
+            case LIST: {
+                if (help){
+                    terminal.writeLine("List all secret identifiers from the keystore. For example: " +
+                            "`bin/logstash-keystore list`. Note - only the identifiers will be listed, not the secrets.");
+                    return;
+                }
+                Collection<SecretIdentifier> ids = SecretStoreFactory.load(config).list();
+                List<String> keys = ids.stream().filter(id -> !id.equals(LOGSTASH_MARKER)).map(id -> id.getKey()).collect(Collectors.toList());
+                Collections.sort(keys);
+                keys.forEach(terminal::writeLine);
+                break;
+            }
+            case ADD: {
+                if (help){
+                    terminal.writeLine("Adds a new secret to the keystore. For example: " +
+                            "`bin/logstash-keystore add my-secret`, at the prompt enter your secret. You will use the identifier ${my-secret} in your Logstash configuration.");
+                    return;
+                }
+                if (argument == null || argument.isEmpty()) {
+                    terminal.writeLine("ERROR: You must supply a identifier to add. (e.g. bin/logstash-keystore add my-secret)");
+                    return;
+                }
+                if (SecretStoreFactory.exists(config.clone())) {
+                    SecretIdentifier id = new SecretIdentifier(argument);
+                    SecretStore secretStore = SecretStoreFactory.load(config);
+                    byte[] s = secretStore.retrieveSecret(id);
+                    if (s == null) {
+                        terminal.write(String.format("Enter value for %s: ", argument));
+                        char[] secret = terminal.readSecret();
+                        if(secret == null || secret.length == 0){
+                            terminal.writeLine("ERROR: You must supply a identifier to add. (e.g. bin/logstash-keystore add my-secret)");
+                            return;
+                        }
+                        add(secretStore, id, SecretStoreUtil.asciiCharToBytes(secret));
+                    } else {
+                        SecretStoreUtil.clearBytes(s);
+                        terminal.write(String.format("%s already exists. Overwrite ? [y/N] ", argument));
+                        if (isYes(terminal.readLine())) {
+                            terminal.write(String.format("Enter value for %s: ", argument));
+                            char[] secret = terminal.readSecret();
+                            add(secretStore, id, SecretStoreUtil.asciiCharToBytes(secret));
+                        }
+                    }
+                } else {
+                    terminal.writeLine(String.format("ERROR: Logstash keystore not found. Use 'create' command to create one."));
+                }
+                break;
+            }
+            case REMOVE: {
+                if (help){
+                    terminal.writeLine("Removes a secret from the keystore. For example: " +
+                            "`bin/logstash-keystore remove my-secret`");
+                    return;
+                }
+                if (argument == null || argument.isEmpty()) {
+                    terminal.writeLine("ERROR: You must supply a value to remove. (e.g. bin/logstash-keystore remove my-secret)");
+                    return;
+                }
+                SecretIdentifier id = new SecretIdentifier(argument);
+
+                SecretStore secretStore = SecretStoreFactory.load(config);
+                byte[] s = secretStore.retrieveSecret(id);
+                if (s == null) {
+                    terminal.writeLine(String.format("ERROR: '%s' does not exist in the Logstash keystore.", argument));
+                } else {
+                    SecretStoreUtil.clearBytes(s);
+                    secretStore.purgeSecret(id);
+                    terminal.writeLine(String.format("Removed '%s' from the Logstash keystore.", id.getKey()));
+                }
+                break;
+            }
+            case HELP: {
+                terminal.writeLine("Usage:");
+                terminal.writeLine("--------");
+                terminal.writeLine("bin/logstash-keystore [option] command [argument]");
+                terminal.writeLine("");
+                terminal.writeLine("Commands:");
+                terminal.writeLine("--------");
+                terminal.writeLine("create - Creates a new Logstash keystore  (e.g. bin/logstash-keystore create)");
+                terminal.writeLine("list   - List entries in the keystore  (e.g. bin/logstash-keystore list)");
+                terminal.writeLine("add    - Add a value to the keystore (e.g. bin/logstash-keystore add my-secret)");
+                terminal.writeLine("remove - Remove a value from the keystore  (e.g. bin/logstash-keystore remove my-secret)");
+                terminal.writeLine("");
+                terminal.writeLine("Argument:");
+                terminal.writeLine("--------");
+                terminal.writeLine("--help - Display command specific help  (e.g. bin/logstash-keystore add --help)");
+                terminal.writeLine("");
+                terminal.writeLine("Options:");
+                terminal.writeLine("--------");
+                terminal.writeLine("--path.settings - Set the directory for the keystore. This is should be the same directory as the logstash.yml settings file. " +
+                        "The default is the config directory under Logstash home. (e.g. bin/logstash-keystore --path.settings /tmp/foo create)");
+                terminal.writeLine("");
+                break;
+            }
+        }
+    }
+
+    private void add(SecretStore secretStore, SecretIdentifier id, byte[] secret) {
+        secretStore.persistSecret(id, secret);
+        terminal.writeLine(String.format("Added '%s' to the Logstash keystore.", id.getKey()));
+        SecretStoreUtil.clearBytes(secret);
+    }
+
+    private void create(SecureConfig config) {
+        if (System.getenv(SecretStoreFactory.ENVIRONMENT_PASS_KEY) == null) {
+            terminal.write(String.format("WARNING: The keystore password is not set. Please set the environment variable `%s`. Failure to do so will result in" +
+                    " reduced security. Continue without password protection on the keystore? [y/N] ", SecretStoreFactory.ENVIRONMENT_PASS_KEY));
+            if (isYes(terminal.readLine())) {
+                deleteThenCreate(config);
+            }
+        } else {
+            deleteThenCreate(config);
+        }
+    }
+
+    private void deleteThenCreate(SecureConfig config) {
+        SecretStoreFactory.delete(config.clone());
+        SecretStoreFactory.create(config.clone());
+        char[] fileLocation = config.getPlainText("keystore.file");
+        terminal.writeLine("Created Logstash keystore" + (fileLocation == null ? "." : " at " + new String(fileLocation)));
+    }
+
+    private static boolean isYes(String response) {
+        return "y".equalsIgnoreCase(response) || "yes".equalsIgnoreCase(response);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/cli/Terminal.java b/logstash-core/src/main/java/org/logstash/secret/cli/Terminal.java
new file mode 100644
index 00000000000..6009ea17c0a
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/cli/Terminal.java
@@ -0,0 +1,69 @@
+package org.logstash.secret.cli;
+
+import java.util.Scanner;
+
+/**
+ * Abstraction over System.console to allow graceful fallback to System.out
+ */
+public class Terminal {
+
+    private static final boolean useConsole = Boolean.valueOf(System.getProperty("cli.console", String.valueOf(System.console() != null)));
+    private static final Scanner scanner = new Scanner(System.in);
+
+    /**
+     * Writes a single line to the output.
+     *
+     * @param line the line to write.
+     */
+    public void writeLine(String line) {
+        if (useConsole) {
+            System.console().writer().println(line);
+            System.console().writer().flush();
+        } else {
+            System.out.println(line);
+        }
+    }
+
+    /**
+     * Writes text to the output, but does not include a new line.
+     *
+     * @param text the text to write.
+     */
+    public void write(String text) {
+        if (useConsole) {
+            System.console().writer().print(text);
+            System.console().writer().flush();
+        } else {
+            System.out.print(text);
+        }
+    }
+
+    /**
+     * Reads a single line
+     *
+     * @return the line
+     */
+    public String readLine() {
+        if (useConsole) {
+            return System.console().readLine();
+        } else {
+            return scanner.next();
+        }
+
+    }
+
+    /**
+     * Reads a secret
+     *
+     * @return the char[] representation of the secret.
+     */
+    public char[] readSecret() {
+        if (useConsole) {
+            return System.console().readPassword();
+        } else {
+            return scanner.next().toCharArray();
+        }
+    }
+
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStore.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStore.java
new file mode 100644
index 00000000000..44e3a1e722d
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStore.java
@@ -0,0 +1,77 @@
+package org.logstash.secret.store;
+
+
+import org.logstash.secret.SecretIdentifier;
+
+import java.util.Collection;
+
+/**
+ * <p>Contract with a store that can persist, retrieve, and purge sensitive data.</p>
+ * <p>Implementations <strong>MUST</strong> ensure proper security for the storage of the secrets.</p>
+ * <p>Implementations should throw a {@link SecretStoreException} if and only if errors are encountered while performing the action. </p>
+ */
+public interface SecretStore {
+
+    /**
+     * Creates a new secret store
+     *
+     * @param secureConfig the configuration necessary to create the store
+     * @return the newly created secret store.
+     */
+    SecretStore create(SecureConfig secureConfig);
+
+    /**
+     * Delete secret store
+     *
+     * @param secureConfig the configuration necessary to delete the store
+     */
+    void delete(SecureConfig secureConfig);
+
+    /**
+     * Queries if a secret store matching this configuration exists
+     *
+     * @param secureConfig the configuration necessary to determine if the secret store exists
+     * @return true if the secret store exists, false other wise. Note - this does not provide any validity of the keystore, merely it's existence or not. It is recommended to
+     * use the {@link SecretStoreFactory#LOGSTASH_MARKER} to test validity.
+     */
+    boolean exists(SecureConfig secureConfig);
+
+    /**
+     * Gets all of the known {@link SecretIdentifier}
+     *
+     * @return a Collection of {@link SecretIdentifier}
+     */
+    Collection<SecretIdentifier> list();
+
+    /**
+     * Loads an existing secret store
+     *
+     * @param secureConfig the configuration necessary to load the store
+     * @return the loaded secret store.
+     */
+    SecretStore load(SecureConfig secureConfig);
+
+    /**
+     * Persist a secret to the store. Implementations should overwrite existing secrets with same identifier without error unless explicitly documented otherwise.
+     *
+     * @param id     The {@link SecretIdentifier} to identify the secret to persist
+     * @param secret The byte[] representation of the secret. Implementations should zero out this byte[] once it has been persisted.
+     */
+    void persistSecret(SecretIdentifier id, byte[] secret);
+
+    /**
+     * Purges the secret from the store.
+     *
+     * @param id The {@link SecretIdentifier} to identify the secret to purge
+     */
+    void purgeSecret(SecretIdentifier id);
+
+    /**
+     * Retrieves a secret.
+     *
+     * @param id The {@link SecretIdentifier} to identify the secret to retrieve
+     * @return the byte[] of the secret, null if no secret is found.
+     */
+    byte[] retrieveSecret(SecretIdentifier id);
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java
new file mode 100644
index 00000000000..64d765718d7
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreException.java
@@ -0,0 +1,97 @@
+package org.logstash.secret.store;
+
+import org.logstash.secret.SecretIdentifier;
+
+/**
+ * Exceptions when working a {@link SecretStore}
+ */
+public class SecretStoreException extends RuntimeException {
+
+    private SecretStoreException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    private SecretStoreException(String message) {
+        super(message);
+    }
+
+    static public class RetrievalException extends SecretStoreException {
+        public RetrievalException(SecretIdentifier secretIdentifier, Throwable cause) {
+            super(String.format("Error while trying to retrieve secret %s", secretIdentifier.toExternalForm()), cause);
+        }
+    }
+
+    static public class ListException extends SecretStoreException {
+        public ListException(Throwable cause) {
+            super("Error while trying to list keys in secret store", cause);
+        }
+    }
+
+    static public class CreateException extends SecretStoreException {
+        public CreateException(String message, Throwable cause) {
+            super(message, cause);
+        }
+
+        public CreateException(String message) {
+            super(message);
+        }
+    }
+
+    static public class LoadException extends SecretStoreException {
+        public LoadException(String message, Throwable cause) {
+            super(message, cause);
+        }
+
+        public LoadException(String message) {
+            super(message);
+        }
+    }
+
+    static public class PersistException extends SecretStoreException {
+        public PersistException(SecretIdentifier secretIdentifier, Throwable cause) {
+            super(String.format("Error while trying to store secret %s", secretIdentifier.toExternalForm()), cause);
+        }
+    }
+
+    static public class PurgeException extends SecretStoreException {
+        public PurgeException(SecretIdentifier secretIdentifier, Throwable cause) {
+            super(String.format("Error while trying to purge secret %s", secretIdentifier.toExternalForm()), cause);
+        }
+    }
+
+    static public class UnknownException extends SecretStoreException {
+        public UnknownException(String message, Throwable cause) {
+            super(message, cause);
+        }
+    }
+
+    static public class ImplementationNotFoundException extends SecretStoreException {
+        public ImplementationNotFoundException(String message, Throwable throwable) {
+            super(message, throwable);
+        }
+    }
+
+    static public class AccessException extends SecretStoreException {
+        public AccessException(String message, Throwable throwable) {
+            super(message, throwable);
+        }
+
+        public AccessException(String message) {
+            super(message);
+        }
+    }
+
+    static public class AlreadyExistsException extends SecretStoreException {
+        public AlreadyExistsException(String message) {
+            super(message);
+        }
+    }
+
+    static public class InvalidConfigurationException extends SecretStoreException {
+        public InvalidConfigurationException(String message) {
+            super(message);
+        }
+    }
+
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreFactory.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreFactory.java
new file mode 100644
index 00000000000..8280bf0b842
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreFactory.java
@@ -0,0 +1,114 @@
+package org.logstash.secret.store;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.logstash.secret.SecretIdentifier;
+
+/**
+ * <p>A factory to load the implementation of a {@link SecretStore}. Implementation may be defined via the {@link SecureConfig} via with a key of "keystore.classname" and
+ * value equal to the fqn of the class that implements {@link SecretStore}
+ * </p>
+ */
+public class SecretStoreFactory {
+
+    public static final String KEYSTORE_ACCESS_KEY = "keystore.pass";
+    //secret stores should create a secret with this as the key and value to identify a logstash secret
+    public final static SecretIdentifier LOGSTASH_MARKER = new SecretIdentifier("keystore.seed");
+
+    public final static String ENVIRONMENT_PASS_KEY = "LOGSTASH_KEYSTORE_PASS";
+
+    /**
+     * Private constructor
+     */
+    private SecretStoreFactory() {
+    }
+
+    private static final Logger LOGGER = LogManager.getLogger(SecretStoreFactory.class);
+
+    private enum MODE {LOAD, CREATE, EXISTS, DELETE}
+
+    /**
+     * Determine if this secret store currently exists
+     * @return true if the secret store exists, false otherwise
+     */
+    public static boolean exists(SecureConfig secureConfig) {
+        return doIt(MODE.EXISTS, secureConfig).exists(secureConfig);
+    }
+
+    /**
+     * Creates a new {@link SecretStore} based on the provided configuration
+     *
+     * @param secureConfig The configuration to pass to the implementation
+     * @return the newly created SecretStore, throws {@link SecretStoreException} if errors occur while loading, or if store already exists
+     */
+    static public SecretStore create(SecureConfig secureConfig) {
+        return doIt(MODE.CREATE, secureConfig);
+    }
+
+    /**
+     * Deletes a {@link SecretStore} based on the provided configuration
+     *
+     * @param secureConfig The configuration to pass to the implementation
+     * throws {@link SecretStoreException} if errors occur
+     */
+    static public void delete(SecureConfig secureConfig) {
+        doIt(MODE.DELETE, secureConfig);
+    }
+
+    /**
+     * Loads an existing {@link SecretStore} based on the provided configuration
+     *
+     * @param secureConfig The configuration to pass to the implementation
+     * @return the loaded SecretStore, throws {@link SecretStoreException} if errors occur while loading, or if store does not exist
+     */
+    static public SecretStore load(SecureConfig secureConfig) {
+        return doIt(MODE.LOAD, secureConfig);
+    }
+
+    @SuppressWarnings({"unchecked", "JavaReflectionMemberAccess"})
+    private static SecretStore doIt(MODE mode, SecureConfig secureConfig) {
+        char[] configuredClassName = secureConfig.getPlainText("keystore.classname");
+        String className = configuredClassName != null ? new String(configuredClassName) : "org.logstash.secret.store.backend.JavaKeyStore";
+        try {
+            LOGGER.debug("Attempting to {} or secret store with implementation: {}", mode.name().toLowerCase(), className);
+            Class<? extends SecretStore> implementation = (Class<? extends SecretStore>) Class.forName(className);
+
+            addSecretStoreAccess(secureConfig);
+
+            if (MODE.LOAD.equals(mode)) {
+                return implementation.newInstance().load(secureConfig);
+            } else if (MODE.CREATE.equals(mode)) {
+                return implementation.newInstance().create(secureConfig);
+            } else if (MODE.DELETE.equals(mode)) {
+                implementation.newInstance().delete(secureConfig);
+                return null;
+            } else if (MODE.EXISTS.equals(mode)) {
+                return implementation.newInstance();
+            } else {
+                throw new IllegalStateException("missing mode. This is bug in Logstash.");
+            }
+        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
+            throw new SecretStoreException.ImplementationNotFoundException(
+                    String.format("Could not %s class %s, please validate the `keystore.classname` is configured correctly and that the class can be loaded by Logstash ", mode
+                                    .name().toLowerCase(), className), e);
+        }
+    }
+
+    /**
+     * <p>Adds the credential to the {@link SecureConfig} that is needed to access the {@link SecretStore}. Value read from environment variable "LOGSTASH_KEYSTORE_PASS"</p>
+     *
+     * @param secureConfig The configuration to add the secret store access
+     */
+    private static void addSecretStoreAccess(SecureConfig secureConfig) {
+        String environment = System.getenv(ENVIRONMENT_PASS_KEY);
+
+        char[] pass = null;
+        if (environment != null) {
+            secureConfig.add(KEYSTORE_ACCESS_KEY, environment.toCharArray());
+            environment = null;
+        }
+
+        //futile attempt to remove the original pass from memory
+        System.gc();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreUtil.java b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreUtil.java
new file mode 100644
index 00000000000..85639af0a4e
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecretStoreUtil.java
@@ -0,0 +1,163 @@
+package org.logstash.secret.store;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.Base64;
+import java.util.Random;
+
+/**
+ * Conversion utility between String, bytes, and chars. All methods attempt to keep sensitive data out of memory. Sensitive data should avoid using Java {@link String}'s.
+ */
+final public class SecretStoreUtil {
+
+    /**
+     * Private constructor. Utility class.
+     */
+    private SecretStoreUtil() {
+    }
+
+    private static final Random RANDOM = new Random();
+
+    /**
+     * Converts bytes from ascii encoded text to a char[] and zero outs the original byte[]
+     *
+     * @param bytes the bytes from an ascii encoded text (note - no validation is done to ensure ascii encoding)
+     * @return the corresponding char[]
+     */
+    public static char[] asciiBytesToChar(byte[] bytes) {
+        char[] chars = new char[bytes.length];
+        for (int i = 0; i < bytes.length; i++) {
+            chars[i] = (char) bytes[i];
+            bytes[i] = '\0';
+        }
+        return chars;
+    }
+
+    /**
+     * Converts characters from ascii encoded text to a byte[] and zero outs the original char[]
+     *
+     * @param chars the chars from an ascii encoded text (note - no validation is done to ensure ascii encoding)
+     * @return the corresponding byte[]
+     */
+    public static byte[] asciiCharToBytes(char[] chars) {
+        byte[] bytes = new byte[chars.length];
+        for (int i = 0; i < chars.length; i++) {
+            bytes[i] = (byte) chars[i];
+            chars[i] = '\0';
+        }
+        return bytes;
+    }
+
+    /**
+     * Base64 encode the given byte[], then zero the original byte[]
+     *
+     * @param b the byte[] to base64 encode
+     * @return the base64 encoded bytes
+     */
+    public static byte[] base64Encode(byte[] b) {
+        byte[] bytes = Base64.getEncoder().encode(b);
+        clearBytes(b);
+        return bytes;
+    }
+
+    /**
+     * Base64 encode the given byte[], then zero out the original byte[]
+     *
+     * @param bytes the byte[] to base64 encode
+     * @return the char[] representation of the base64 encoding
+     */
+    public static char[] base64EncodeToChars(byte[] bytes) {
+        return asciiBytesToChar(base64Encode(bytes));
+    }
+
+    /**
+     * Base64 encode the given char[], then zero out the original char[]
+     *
+     * @param chars the char[] to base64 encode
+     * @return the char[] representation of the base64 encoding
+     */
+    public static char[] base64Encode(char[] chars) {
+        return asciiBytesToChar(base64Encode(asciiCharToBytes(chars)));
+    }
+
+    /**
+     * Decodes a Base64 encoded byte[], then zero out the original byte[]
+     *
+     * @param b the base64 bytes
+     * @return the non-base64 encoded bytes
+     */
+    public static byte[] base64Decode(byte[] b) {
+        byte[] bytes = Base64.getDecoder().decode(b);
+        clearBytes(b);
+        return bytes;
+    }
+
+    /**
+     * Decodes a Base64 encoded char[], then zero out the original char[]
+     *
+     * @param chars the base64 chars
+     * @return the non-base64 encoded chars
+     */
+    public static byte[] base64Decode(char[] chars) {
+        return base64Decode(asciiCharToBytes(chars));
+    }
+
+    /**
+     * Attempt to keep data out of the heap.
+     *
+     * @param chars the bytes to zero out
+     */
+    public static void clearChars(char[] chars) {
+        Arrays.fill(chars, '\0');
+    }
+
+    /**
+     * Attempt to keep data out of the heap.
+     *
+     * @param bytes the bytes to zero out
+     */
+    public static void clearBytes(byte[] bytes) {
+        Arrays.fill(bytes, (byte) '\0');
+    }
+
+
+    /**
+     * De-obfuscates the obfuscated char[] generated by {@link SecretStoreUtil#obfuscate(char[])}
+     *
+     * @param chars The chars to de-obscure
+     * @return the de-obscured chars
+     */
+    public static char[] deObfuscate(char[] chars) {
+        byte[] bytes = asciiCharToBytes(chars);
+        byte[] random = Arrays.copyOfRange(bytes, bytes.length / 2, bytes.length);
+        byte[] deObfuscated = new byte[random.length];
+        for (int i = 0; i < random.length; i++) {
+            int xor = bytes[i] ^ random[i];
+            deObfuscated[i] = ((byte) (xor & 0xff));
+        }
+        return asciiBytesToChar(deObfuscated);
+    }
+
+    /**
+     * <p>Simple obfuscation that adds a bit of randomness and shuffles the bits of a char[].</p>
+     * <p>Note - this is NOT security and will only deter the lazy.</p>
+     *
+     * @param chars The chars to obscure
+     * @return the obscured bytes
+     */
+    public static char[] obfuscate(char[] chars) {
+        byte[] bytes = asciiCharToBytes(chars);
+        byte[] random = new byte[bytes.length];
+        RANDOM.nextBytes(random);
+
+        ByteBuffer obfuscated = ByteBuffer.allocate(bytes.length * 2);
+        for (int i = 0; i < bytes.length; i++) {
+            int xor = bytes[i] ^ random[i];
+            obfuscated.put((byte) (0xff & xor));
+        }
+        obfuscated.put(random);
+        char[] result = asciiBytesToChar(obfuscated.array());
+        clearBytes(obfuscated.array());
+        return result;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/SecureConfig.java b/logstash-core/src/main/java/org/logstash/secret/store/SecureConfig.java
new file mode 100644
index 00000000000..07b70e90a93
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/SecureConfig.java
@@ -0,0 +1,77 @@
+package org.logstash.secret.store;
+
+import java.nio.CharBuffer;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * A String to char[] container that holds a referenced char[] obfuscated in memory and allows for easy clearing all values from memory.
+ */
+public class SecureConfig {
+
+    private Map<String, CharBuffer> config = new ConcurrentHashMap<>();
+
+    //package private for testing
+    volatile boolean cleared;
+
+    /**
+     * adds a value to the secure config
+     *
+     * @param key   the reference to the configuration value
+     * @param value the configuration value
+     * @throws IllegalStateException if this configuration has been cleared
+     */
+    public void add(String key, char[] value) {
+        if(cleared){
+            throw new IllegalStateException("This configuration has been cleared and can not be re-used.");
+        }
+        config.put(key, CharBuffer.wrap(SecretStoreUtil.obfuscate(value)));
+    }
+
+    /**
+     * Zero outs all internally held char[]
+     */
+    public void clearValues() {
+        config.forEach((k, v) -> SecretStoreUtil.clearChars(v.array()));
+        cleared = true;
+    }
+
+    /**
+     * Creates a full clone of this object.
+     *
+     * @return a copy of this {@link SecureConfig}
+     * @throws IllegalStateException if this configuration has been cleared
+     */
+    public SecureConfig clone() {
+        if(cleared){
+            throw new IllegalStateException("This configuration has been cleared and can not be re-used.");
+        }
+        SecureConfig clone = new SecureConfig();
+        config.forEach((k, v) -> clone.add(k, SecretStoreUtil.deObfuscate(v.array().clone())));
+        return clone;
+    }
+
+    /**
+     * Retrieve the un-obfuscated value
+     *
+     * @param key the reference to the configuration value
+     * @return the un-obfuscated configuration value.
+     */
+    public char[] getPlainText(String key) {
+        if(cleared){
+            throw new IllegalStateException("This configuration has been cleared and can not be re-used.");
+        }
+        return config.get(key) == null ? null : SecretStoreUtil.deObfuscate(config.get(key).array().clone());
+    }
+
+    /**
+     * Determine if a value for this key exists. No guarantees if the value has been zero'ed (cleared) or not.
+     *
+     * @param key the reference to the configuration value.
+     * @return true if this key has ever been added, false otherwise
+     */
+    public boolean has(String key) {
+        return config.get(key) != null;
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java b/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java
new file mode 100644
index 00000000000..ca635d24ce1
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/secret/store/backend/JavaKeyStore.java
@@ -0,0 +1,403 @@
+package org.logstash.secret.store.backend;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.logstash.secret.SecretIdentifier;
+import org.logstash.secret.store.*;
+
+import javax.crypto.SecretKey;
+import javax.crypto.SecretKeyFactory;
+import javax.crypto.spec.PBEKeySpec;
+import java.io.*;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.channels.FileLock;
+import java.nio.channels.SeekableByteChannel;
+import java.nio.charset.CharsetEncoder;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.*;
+import java.nio.file.attribute.PosixFileAttributeView;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.security.KeyStore;
+import java.security.KeyStore.PasswordProtection;
+import java.security.KeyStore.ProtectionParameter;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.CertificateException;
+import java.util.*;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import static org.logstash.secret.store.SecretStoreFactory.LOGSTASH_MARKER;
+
+/**
+ * <p>Java Key Store implementation for the {@link SecretStore}.</p>
+ * <p>Note this implementation should not be used for high volume or large datasets.</p>
+ * <p>This class is threadsafe.</p>
+ */
+public final class JavaKeyStore implements SecretStore {
+    private static final String KEYSTORE_TYPE = "pkcs12";
+    private static final Logger LOGGER = LogManager.getLogger(JavaKeyStore.class);
+    private static final String PATH_KEY = "keystore.file";
+    private static final CharsetEncoder asciiEncoder = StandardCharsets.US_ASCII.newEncoder();
+    private KeyStore keyStore;
+    private char[] keyStorePass;
+    private Path keyStorePath;
+    private ProtectionParameter protectionParameter;
+    private Lock readLock;
+    private boolean useDefaultPass = false;
+    private Lock writeLock;
+    //package private for testing
+    static String filePermissions = "rw-rw----";
+
+    /**
+     * {@inheritDoc}
+     *
+     * @param config The configuration for this keystore <p>Requires "keystore.file" in the configuration,</p><p>WARNING! this method clears all values
+     *               from this configuration, meaning this config is NOT reusable after passed in here.</p>
+     * @throws SecretStoreException.CreateException if the store can not be created
+     * @throws SecretStoreException                 (of other sub types) if contributing factors prevent the creation
+     */
+    @Override
+    public JavaKeyStore create(SecureConfig config) {
+        if (exists(config)) {
+            throw new SecretStoreException.AlreadyExistsException(String.format("Logstash keystore at %s already exists.",
+                    new String(config.getPlainText(PATH_KEY))));
+        }
+        try {
+            init(config);
+            writeLock.lock();
+            LOGGER.debug("Creating new keystore at {}.", keyStorePath.toAbsolutePath());
+            String keyStorePermissions = filePermissions;
+            //create the keystore on disk with a default entry to identify this as a logstash keystore
+            Files.createFile(keyStorePath, PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(keyStorePermissions)));
+            try {
+                keyStore = KeyStore.Builder.newInstance(KEYSTORE_TYPE, null, protectionParameter).getKeyStore();
+                SecretKeyFactory factory = SecretKeyFactory.getInstance("PBE");
+                byte[] base64 = SecretStoreUtil.base64Encode(LOGSTASH_MARKER.getKey().getBytes(StandardCharsets.UTF_8));
+                SecretKey secretKey = factory.generateSecret(new PBEKeySpec(SecretStoreUtil.asciiBytesToChar(base64)));
+                keyStore.setEntry(LOGSTASH_MARKER.toExternalForm(), new KeyStore.SecretKeyEntry(secretKey), protectionParameter);
+                saveKeyStore();
+                PosixFileAttributeView attrs = Files.getFileAttributeView(keyStorePath, PosixFileAttributeView.class);
+                if (attrs != null) {
+                    //the directory umask applies when creating the file, so re-apply permissions here
+                    attrs.setPermissions(PosixFilePermissions.fromString(keyStorePermissions));
+                }
+                LOGGER.info("Created Logstash keystore at {}", keyStorePath.toAbsolutePath());
+                return this;
+            } catch (Exception e) {
+                throw new SecretStoreException.CreateException("Failed to create Logstash keystore.", e);
+            }
+        } catch (SecretStoreException sse) {
+            throw sse;
+        } catch (NoSuchFileException | AccessDeniedException fe) {
+            throw new SecretStoreException.CreateException("Error while trying to create the Logstash keystore. Please ensure that path to " + keyStorePath.toAbsolutePath() +
+                    " exists and is writable", fe);
+        } catch (Exception e) { //should never happen
+            throw new SecretStoreException.UnknownException("Error while trying to create the Logstash keystore. ", e);
+        } finally {
+            releaseLock(writeLock);
+            config.clearValues();
+        }
+    }
+
+    @Override
+    public void delete(SecureConfig config) {
+        try {
+            initLocks();
+            writeLock.lock();
+            if (exists(config)) {
+                Files.delete(Paths.get(new String(config.getPlainText(PATH_KEY))));
+            }
+        } catch (SecretStoreException sse) {
+            throw sse;
+        } catch (Exception e) { //should never happen
+            throw new SecretStoreException.UnknownException("Error while trying to delete the Logstash keystore", e);
+        } finally {
+            releaseLock(writeLock);
+            config.clearValues();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @param config The configuration for this keystore <p>Requires "keystore.file" in the configuration</p>
+     */
+    @Override
+    public boolean exists(SecureConfig config) {
+        char[] path = config.getPlainText(PATH_KEY);
+        if (!valid(path)) {
+            LOGGER.warn("keystore.file configuration is not defined"); // should only every happen via tests
+            return false;
+        }
+        return new File(new String(path)).exists();
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        SecretStoreUtil.clearChars(keyStorePass);
+    }
+
+    /**
+     * Obtains the keystore password depending on if the password is explicitly defined and/or if this is a new keystore.
+     *
+     * @param config the configuration
+     * @return the char[] of the keystore password
+     * @throws IOException on io errors
+     */
+    private char[] getKeyStorePassword(SecureConfig config) throws IOException {
+        char[] plainText = config.getPlainText(SecretStoreFactory.KEYSTORE_ACCESS_KEY);
+        boolean existing = exists(config);
+
+        //ensure if a password is configured, that we don't allow empty passwords
+        if (config.has(SecretStoreFactory.KEYSTORE_ACCESS_KEY) && (plainText == null || plainText.length == 0)) {
+            String message = String.format("Empty keystore passwords are not allowed. Please ensure configured password is not empty for Logstash keystore %s.",
+                    keyStorePath.toAbsolutePath());
+            if (existing) {
+                throw new SecretStoreException.AccessException(message);
+            } else {
+                throw new SecretStoreException.CreateException(message);
+            }
+        }
+
+        useDefaultPass = !config.has(SecretStoreFactory.KEYSTORE_ACCESS_KEY);
+
+        if (useDefaultPass) {
+            if (existing) {
+                //read the pass
+                SeekableByteChannel byteChannel = Files.newByteChannel(keyStorePath, StandardOpenOption.READ);
+                if (byteChannel.size() > 1) {
+                    byteChannel.position(byteChannel.size() - 1);
+                    ByteBuffer byteBuffer = ByteBuffer.allocate(1);
+                    byteChannel.read(byteBuffer);
+                    int size = byteBuffer.array()[0] & 0xff;
+                    if (size > 0 && byteChannel.size() >= size + 1) {
+                        byteBuffer = ByteBuffer.allocate(size);
+                        byteChannel.position(byteChannel.size() - size - 1);
+                        byteChannel.read(byteBuffer);
+                        return SecretStoreUtil.deObfuscate(SecretStoreUtil.asciiBytesToChar(byteBuffer.array()));
+                    }
+                }
+            } else {
+                //create the pass
+                byte[] randomBytes = new byte[32];
+                new Random().nextBytes(randomBytes);
+                return SecretStoreUtil.base64EncodeToChars(randomBytes);
+            }
+        } else {
+            //explicit user defined pass
+            //keystore passwords require ascii encoding, only base64 encode if necessary
+            return asciiEncoder.canEncode(CharBuffer.wrap(plainText)) ? plainText : SecretStoreUtil.base64Encode(plainText);
+        }
+        throw new SecretStoreException.AccessException(
+                String.format("Could not determine keystore password. Please ensure the file at %s is a valid Logstash keystore", keyStorePath.toAbsolutePath()));
+    }
+
+    private void init(SecureConfig config) throws IOException, KeyStoreException {
+        char[] path = config.getPlainText(PATH_KEY);
+        if (!valid(path)) {
+            throw new IllegalArgumentException("Logstash keystore path must be defined");
+        }
+        this.keyStorePath = Paths.get(new String(path));
+        this.keyStorePass = getKeyStorePassword(config);
+        this.keyStore = KeyStore.getInstance(KEYSTORE_TYPE);
+        this.protectionParameter = new PasswordProtection(this.keyStorePass);
+        initLocks();
+    }
+
+    private void initLocks(){
+        ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
+        readLock = readWriteLock.readLock();
+        writeLock = readWriteLock.writeLock();
+    }
+
+    @Override
+    public Collection<SecretIdentifier> list() {
+        Set<SecretIdentifier> identifiers = new HashSet<>();
+        try {
+            readLock.lock();
+            loadKeyStore();
+            Enumeration<String> aliases = keyStore.aliases();
+            while (aliases.hasMoreElements()) {
+                String alias = aliases.nextElement();
+                identifiers.add(SecretIdentifier.fromExternalForm(alias));
+            }
+        } catch (Exception e) {
+            throw new SecretStoreException.ListException(e);
+        } finally {
+            releaseLock(readLock);
+        }
+        return identifiers;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * @param config The configuration for this keystore <p>Requires "keystore.file" in the configuration</p><p>WARNING! this method clears all values
+     *               from this configuration, meaning this config is NOT reusable after passed in here.</p>
+     * @throws SecretStoreException.CreateException if the store can not be created
+     * @throws SecretStoreException                 (of other sub types) if contributing factors prevent the creation
+     */
+    @Override
+    public JavaKeyStore load(SecureConfig config) {
+        if (!exists(config)) {
+            throw new SecretStoreException.LoadException(
+                    String.format("Can not find Logstash keystore at %s. Please verify this file exists and is a valid Logstash keystore.",
+                            config.getPlainText("keystore.file") == null ? "<undefined>" : new String(config.getPlainText("keystore.file"))));
+        }
+        try {
+            init(config);
+            readLock.lock();
+            try (final InputStream is = Files.newInputStream(keyStorePath)) {
+                try {
+                    keyStore.load(is, this.keyStorePass);
+                } catch (IOException ioe) {
+                    if (ioe.getCause() instanceof UnrecoverableKeyException) {
+                        throw new SecretStoreException.AccessException(
+                                String.format("Can not access Logstash keystore at %s. Please verify correct file permissions and keystore password.",
+                                        keyStorePath.toAbsolutePath()), ioe);
+                    } else {
+                        throw new SecretStoreException.LoadException(String.format("Found a file at %s, but it is not a valid Logstash keystore.",
+                                keyStorePath.toAbsolutePath().toString()), ioe);
+                    }
+                }
+                byte[] marker = retrieveSecret(LOGSTASH_MARKER);
+                if (marker == null) {
+                    throw new SecretStoreException.LoadException(String.format("Found a keystore at %s, but it is not a Logstash keystore.",
+                            keyStorePath.toAbsolutePath().toString()));
+                }
+                LOGGER.debug("Using existing keystore at {}", keyStorePath.toAbsolutePath());
+                return this;
+            }
+        } catch (SecretStoreException sse) {
+            throw sse;
+        } catch (Exception e) { //should never happen
+            throw new SecretStoreException.UnknownException("Error while trying to load the Logstash keystore", e);
+        } finally {
+            releaseLock(readLock);
+            config.clearValues();
+        }
+    }
+
+    /**
+     * Need to load the keystore before any operations in case an external (or different JVM) has modified the keystore on disk.
+     */
+    private void loadKeyStore() throws CertificateException, NoSuchAlgorithmException, IOException {
+        try (final InputStream is = Files.newInputStream(keyStorePath)) {
+            keyStore.load(is, keyStorePass);
+        }
+    }
+
+    @Override
+    public void persistSecret(SecretIdentifier identifier, byte[] secret) {
+        try {
+            writeLock.lock();
+            loadKeyStore();
+            SecretKeyFactory factory = SecretKeyFactory.getInstance("PBE");
+            //PBEKey requires an ascii password, so base64 encode it
+            byte[] base64 = SecretStoreUtil.base64Encode(secret);
+            PBEKeySpec passwordBasedKeySpec = new PBEKeySpec(SecretStoreUtil.asciiBytesToChar(base64));
+            SecretKey secretKey = factory.generateSecret(passwordBasedKeySpec);
+            keyStore.setEntry(identifier.toExternalForm(), new KeyStore.SecretKeyEntry(secretKey), protectionParameter);
+            try {
+                saveKeyStore();
+            } finally {
+                passwordBasedKeySpec.clearPassword();
+                SecretStoreUtil.clearBytes(secret);
+            }
+            LOGGER.debug("persisted secret {}", identifier.toExternalForm());
+        } catch (Exception e) {
+            throw new SecretStoreException.PersistException(identifier, e);
+        } finally {
+            releaseLock(writeLock);
+        }
+    }
+
+    @Override
+    public void purgeSecret(SecretIdentifier identifier) {
+        try {
+            writeLock.lock();
+            loadKeyStore();
+            keyStore.deleteEntry(identifier.toExternalForm());
+            saveKeyStore();
+            LOGGER.debug("purged secret {}", identifier.toExternalForm());
+        } catch (Exception e) {
+            throw new SecretStoreException.PurgeException(identifier, e);
+        } finally {
+            releaseLock(writeLock);
+        }
+    }
+
+    private void releaseLock(Lock lock) {
+        if (lock != null) {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public byte[] retrieveSecret(SecretIdentifier identifier) {
+        if (identifier != null && identifier.getKey() != null && !identifier.getKey().isEmpty()) {
+            try {
+                readLock.lock();
+                loadKeyStore();
+                SecretKeyFactory factory = SecretKeyFactory.getInstance("PBE");
+                KeyStore.SecretKeyEntry secretKeyEntry = (KeyStore.SecretKeyEntry) keyStore.getEntry(identifier.toExternalForm(), protectionParameter);
+                //not found
+                if (secretKeyEntry == null) {
+                    LOGGER.debug("requested secret {} not found", identifier.toExternalForm());
+                    return null;
+                }
+                PBEKeySpec passwordBasedKeySpec = (PBEKeySpec) factory.getKeySpec(secretKeyEntry.getSecretKey(), PBEKeySpec.class);
+                //base64 encoded char[]
+                char[] base64secret = passwordBasedKeySpec.getPassword();
+                byte[] secret = SecretStoreUtil.base64Decode(base64secret);
+                passwordBasedKeySpec.clearPassword();
+                LOGGER.debug("retrieved secret {}", identifier.toExternalForm());
+                return secret;
+            } catch (Exception e) {
+                throw new SecretStoreException.RetrievalException(identifier, e);
+            } finally {
+                releaseLock(readLock);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Saves the keystore with some extra meta data if needed. Note - need two output streams here to allow checking the with the append flag, and the other without an append.
+     */
+    private void saveKeyStore() throws IOException, CertificateException, NoSuchAlgorithmException, KeyStoreException {
+        FileLock fileLock;
+        try (final FileOutputStream appendOs = new FileOutputStream(keyStorePath.toFile(), true)) {
+            fileLock = appendOs.getChannel().tryLock();
+            if (fileLock == null) {
+                throw new IllegalStateException("Can not save Logstash keystore. Some other process has a lock on the file: " + keyStorePath.toAbsolutePath());
+            }
+            try (final OutputStream os = Files.newOutputStream(keyStorePath, StandardOpenOption.WRITE)) {
+                keyStore.store(os, keyStorePass);
+                if (useDefaultPass) {
+                    byte[] obfuscatedPass = SecretStoreUtil.asciiCharToBytes(SecretStoreUtil.obfuscate(keyStorePass.clone()));
+                    DataOutputStream dataOutputStream = new DataOutputStream(os);
+                    os.write(obfuscatedPass);
+                    dataOutputStream.write(obfuscatedPass.length); // 1 byte integer
+                }
+            } finally {
+                if (fileLock != null) {
+                    fileLock.release();
+                }
+            }
+        }
+    }
+
+    /**
+     * @param chars char[] to check for null or empty
+     * @return true if not null, and not empty, false otherwise
+     */
+    private boolean valid(char[] chars) {
+        return !(chars == null || chars.length == 0);
+    }
+}
+
diff --git a/logstash-core/src/test/java/org/logstash/secret/EnvironmentUtil.java b/logstash-core/src/test/java/org/logstash/secret/EnvironmentUtil.java
new file mode 100644
index 00000000000..f731aaab08a
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/EnvironmentUtil.java
@@ -0,0 +1,61 @@
+package org.logstash.secret;
+
+import java.lang.reflect.Field;
+import java.util.Collections;
+import java.util.Map;
+
+/**
+ * Tool to change the in-memory environment settings, does not change actual environment
+ */
+public class EnvironmentUtil {
+
+    //near exact copy from https://stackoverflow.com/questions/318239/how-do-i-set-environment-variables-from-java
+    //thanks @pushy and @Edward Campbell !
+    @SuppressWarnings("unchecked")
+    private static void setEnv(Map<String, String> newenv, String removeKey) throws Exception {
+        try {
+            Class<?> processEnvironmentClass = Class.forName("java.lang.ProcessEnvironment");
+            Field theEnvironmentField = processEnvironmentClass.getDeclaredField("theEnvironment");
+            theEnvironmentField.setAccessible(true);
+            Map<String, String> env = (Map<String, String>) theEnvironmentField.get(null);
+            if(removeKey == null){
+                env.putAll(newenv);
+            }else{
+                env.remove(removeKey);
+            }
+            Field theCaseInsensitiveEnvironmentField = processEnvironmentClass.getDeclaredField("theCaseInsensitiveEnvironment");
+            theCaseInsensitiveEnvironmentField.setAccessible(true);
+            Map<String, String> cienv = (Map<String, String>) theCaseInsensitiveEnvironmentField.get(null);
+            if(removeKey == null){
+                cienv.putAll(newenv);
+            }else{
+                cienv.remove(removeKey);
+            }
+        } catch (NoSuchFieldException e) {
+            Class[] classes = Collections.class.getDeclaredClasses();
+            Map<String, String> env = System.getenv();
+            for (Class cl : classes) {
+                if ("java.util.Collections$UnmodifiableMap".equals(cl.getName())) {
+                    Field field = cl.getDeclaredField("m");
+                    field.setAccessible(true);
+                    Object obj = field.get(env);
+                    Map<String, String> map = (Map<String, String>) obj;
+                    map.clear();
+                    if(removeKey == null){
+                        map.putAll(newenv);
+                    }else{
+                        map.remove(removeKey);
+                    }
+                }
+            }
+        }
+    }
+
+    public static void add(Map<String, String> environment) throws Exception {
+        setEnv(environment, null);
+    }
+
+    public static void remove(String key) throws Exception {
+        setEnv(null, key);
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/secret/SecretIdentifierTest.java b/logstash-core/src/test/java/org/logstash/secret/SecretIdentifierTest.java
new file mode 100644
index 00000000000..1f537c518b2
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/SecretIdentifierTest.java
@@ -0,0 +1,70 @@
+package org.logstash.secret;
+
+
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Unit tests for {@link SecretIdentifier}
+ */
+public class SecretIdentifierTest {
+
+    /**
+     * Example usage
+     */
+    @Test
+    public void testBasic() {
+        SecretIdentifier id = new SecretIdentifier("foo");
+        assertThat(id.toExternalForm()).isEqualTo("urn:logstash:secret:v1:foo");
+        assertThat(id.getKey()).isEqualTo("foo");
+    }
+
+    /**
+     * identifiers are case insensitive
+     */
+    @Test
+    public void testCase() {
+        SecretIdentifier id = new SecretIdentifier("FOO");
+        assertThat(id.toExternalForm()).isEqualTo("urn:logstash:secret:v1:foo");
+        SecretIdentifier id2 = new SecretIdentifier("foo");
+        assertThat(id).isEqualTo(id2);
+        assertThat(id.getKey()).isEqualTo(id2.getKey());
+        assertThat(id.toExternalForm()).isEqualTo(id.toExternalForm()).isEqualTo(id.toString()).isEqualTo(id2.toString());
+    }
+
+    /**
+     * Colon in the key don't cause issues with parsing the colon separated URN
+     */
+    @Test
+    public void testColon() {
+        SecretIdentifier id = new SecretIdentifier("foo:bar");
+        assertThat(id.toExternalForm()).isEqualTo("urn:logstash:secret:v1:foo:bar");
+        assertThat(id.getKey()).isEqualTo("foo:bar");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testEmptyKey() {
+        new SecretIdentifier("");
+    }
+
+    /**
+     * valid urns should be able to be constructed from the urn
+     */
+    @Test
+    public void testFromExternal() {
+        assertThat(SecretIdentifier.fromExternalForm("urn:logstash:secret:v1:foo")).isEqualTo(new SecretIdentifier("foo"));
+        assertThat(SecretIdentifier.fromExternalForm("urn:logstash:secret:v1:foo:bar")).isEqualTo(new SecretIdentifier("foo:bar"));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testFromExternalInvalid() {
+        SecretIdentifier.fromExternalForm("urn:logstash:secret:invalid:foo");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testNullKey() {
+        new SecretIdentifier(null);
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/secret/cli/SecretStoreCliTest.java b/logstash-core/src/test/java/org/logstash/secret/cli/SecretStoreCliTest.java
new file mode 100644
index 00000000000..e45684d40ac
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/cli/SecretStoreCliTest.java
@@ -0,0 +1,240 @@
+package org.logstash.secret.cli;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.logstash.secret.EnvironmentUtil;
+import org.logstash.secret.store.SecureConfig;
+
+import java.nio.file.Paths;
+import java.util.UUID;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.logstash.secret.store.SecretStoreFactory.ENVIRONMENT_PASS_KEY;
+
+public class SecretStoreCliTest {
+
+    private TestTerminal terminal;
+    private SecretStoreCli cli;
+    private SecureConfig existingStoreConfig;
+    private SecureConfig newStoreConfig;
+
+    @Rule
+    public TemporaryFolder folder = new TemporaryFolder();
+
+    @Before
+    public void _setup() throws Exception {
+        terminal = new TestTerminal();
+        cli = new SecretStoreCli(terminal);
+        existingStoreConfig = new SecureConfig();
+        existingStoreConfig.add("keystore.file",
+                Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore.with.default.pass").toURI()).toString().toCharArray());
+        char[] keyStorePath = folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray();
+        newStoreConfig = new SecureConfig();
+        newStoreConfig.add("keystore.file", keyStorePath.clone());
+        EnvironmentUtil.remove(ENVIRONMENT_PASS_KEY);
+    }
+
+    @Test
+    public void testBadCommand() {
+        cli.command("nonsense", null, null);
+        assertPrimaryHelped();
+    }
+
+    @Test
+    public void testHelpAdd() {
+        cli.command("add", null, "--help");
+        assertThat(terminal.out).containsIgnoringCase("Adds a new secret to the keystore");
+    }
+
+    @Test
+    public void testHelpCreate() {
+        cli.command("create", null, "--help");
+        assertThat(terminal.out).containsIgnoringCase("Creates a new keystore");
+    }
+
+    @Test
+    public void testHelpList() {
+        cli.command("list", null, "--help");
+        assertThat(terminal.out).containsIgnoringCase("List all secret identifiers from the keystore");
+    }
+
+    @Test
+    public void testHelpRemove() {
+        cli.command("remove", null, "--help");
+        assertThat(terminal.out).containsIgnoringCase("Removes a secret from the keystore");
+    }
+
+    @Test
+    public void testList() {
+        cli.command("list", existingStoreConfig, null);
+
+       // contents of the existing store is a-z for both the key and value
+        for (int i = 65; i <= 90; i++) {
+            String expected = new String(new byte[]{(byte) i});
+            assertListed(expected.toLowerCase());
+        }
+        assertThat(terminal.out).doesNotContain("keystore.seed");
+    }
+
+    @Test
+    public void testCreateNewAllYes() {
+        terminal.in = "y";
+        cli.command("create", newStoreConfig, null);
+        assertCreated();
+    }
+
+    @Test
+    public void testCreateNewAllNo() {
+        terminal.in = "n";
+        cli.command("create", newStoreConfig, null);
+        assertNotCreated();
+    }
+
+    @Test
+    public void testCreateNoEnvironmentWarning() {
+        cli.command("create", newStoreConfig, null);
+        assertThat(terminal.out).contains("Please set the environment variable `LOGSTASH_KEYSTORE_PASS`. Failure to do so will result in reduced security.");
+    }
+
+
+    @Test
+    public void testDoubleCreateWarning() {
+        terminal.in = "y";
+        cli.command("create", newStoreConfig, null);
+        assertCreated();
+        terminal.reset();
+
+        cli.command("create", newStoreConfig, null);
+        assertThat(terminal.out).contains("Overwrite");
+        assertNotCreated();
+    }
+
+    @Test
+    public void testAddEmptyValue() {
+        terminal.in = "y";
+        cli.command("create", newStoreConfig, null);
+        assertCreated();
+        terminal.reset();
+
+        terminal.in = ""; // sets the value
+        String id = UUID.randomUUID().toString();
+        cli.command("add", newStoreConfig.clone(), id);
+        assertThat(terminal.out).containsIgnoringCase("ERROR");
+    }
+
+    @Test
+    public void testAdd() {
+        terminal.in = "y";
+        cli.command("create", newStoreConfig, null);
+        assertCreated();
+        terminal.reset();
+
+        terminal.in = UUID.randomUUID().toString(); // sets the value
+        String id = UUID.randomUUID().toString();
+        cli.command("add", newStoreConfig.clone(), id);
+        terminal.reset();
+
+        cli.command("list", newStoreConfig, null);
+        assertListed(id);
+    }
+
+    @Test
+    public void testRemove() {
+        terminal.in = "y";
+        cli.command("create", newStoreConfig, null);
+        assertCreated();
+        terminal.reset();
+
+        terminal.in = UUID.randomUUID().toString(); // sets the value
+        String id = UUID.randomUUID().toString();
+        cli.command("add", newStoreConfig.clone(), id);
+        System.out.println(terminal.out);
+        terminal.reset();
+
+        cli.command("list", newStoreConfig.clone(), null);
+        assertListed(id);
+        terminal.reset();
+
+        cli.command("remove", newStoreConfig.clone(), id);
+        terminal.reset();
+
+        cli.command("list", newStoreConfig, null);
+        assertThat(terminal.out).doesNotContain(id);
+    }
+
+    @Test
+    public void testRemoveMissing() {
+        terminal.in = "y";
+        cli.command("create", newStoreConfig, null);
+        assertCreated();
+        terminal.reset();
+
+        terminal.in = UUID.randomUUID().toString(); // sets the value
+        String id = UUID.randomUUID().toString();
+        cli.command("add", newStoreConfig.clone(), id);
+        System.out.println(terminal.out);
+        terminal.reset();
+
+        cli.command("list", newStoreConfig.clone(), null);
+        assertListed(id);
+        terminal.reset();
+
+        cli.command("remove", newStoreConfig.clone(), "notthere");
+        assertThat(terminal.out).containsIgnoringCase("error");
+    }
+
+
+    private void assertNotCreated() {
+        assertThat(terminal.out).doesNotContain("Created Logstash keystore");
+    }
+
+    private void assertCreated() {
+        assertThat(terminal.out).contains("Created Logstash keystore");
+    }
+
+    private void assertListed(String expected) {
+        assertThat(terminal.out).contains(expected);
+    }
+
+    private void assertPrimaryHelped() {
+        assertThat(terminal.out).
+                containsIgnoringCase("Commands").
+                containsIgnoringCase("create").
+                containsIgnoringCase("list").
+                containsIgnoringCase("add").
+                containsIgnoringCase("remove");
+    }
+
+
+    class TestTerminal extends Terminal {
+        public String out = "";
+        public String in = "";
+
+        @Override
+        public void writeLine(String text) {
+            out += text + "\n";
+        }
+
+        @Override
+        public void write(String text) {
+            out += text;
+        }
+
+        @Override
+        public String readLine() {
+            return in;
+        }
+
+        @Override
+        public char[] readSecret() {
+            return in.toCharArray();
+        }
+
+        public void reset() {
+            in = "";
+            out = "";
+        }
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreFactoryTest.java b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreFactoryTest.java
new file mode 100644
index 00000000000..aaed17cefeb
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreFactoryTest.java
@@ -0,0 +1,188 @@
+package org.logstash.secret.store;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TemporaryFolder;
+import org.logstash.secret.EnvironmentUtil;
+import org.logstash.secret.SecretIdentifier;
+import org.logstash.secret.store.backend.JavaKeyStore;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.logstash.secret.store.SecretStoreFactory.ENVIRONMENT_PASS_KEY;
+import static org.logstash.secret.store.SecretStoreFactory.KEYSTORE_ACCESS_KEY;
+import static org.logstash.secret.store.SecretStoreFactory.LOGSTASH_MARKER;
+
+/**
+ * Unit tests for {@link SecretStoreFactory}
+ */
+public class SecretStoreFactoryTest {
+
+    @Rule
+    public TemporaryFolder folder = new TemporaryFolder();
+
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+
+
+
+    @Test
+    public void testAlternativeImplementation() {
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.classname", "org.logstash.secret.store.SecretStoreFactoryTest$MemoryStore".toCharArray());
+        SecretStore secretStore = SecretStoreFactory.load(secureConfig);
+        assertThat(secretStore).isInstanceOf(MemoryStore.class);
+        validateMarker(secretStore);
+    }
+
+    @Test
+    public void testAlternativeImplementationInvalid() {
+        thrown.expect(SecretStoreException.ImplementationNotFoundException.class);
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.classname", "junk".toCharArray());
+        SecretStore secretStore = SecretStoreFactory.load(secureConfig);
+        assertThat(secretStore).isInstanceOf(MemoryStore.class);
+        validateMarker(secretStore);
+    }
+
+    @Test
+    public void testCreateLoad() throws IOException {
+        SecretIdentifier id = new SecretIdentifier(UUID.randomUUID().toString());
+        String value = UUID.randomUUID().toString();
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.file", folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray());
+        SecretStore secretStore = SecretStoreFactory.create(secureConfig.clone());
+
+        byte[] marker = secretStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+        secretStore.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        byte[] retrievedValue = secretStore.retrieveSecret(id);
+        assertThat(new String(retrievedValue, StandardCharsets.UTF_8)).isEqualTo(value);
+
+
+        secretStore = SecretStoreFactory.load(secureConfig);
+        marker = secretStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+        secretStore.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        retrievedValue = secretStore.retrieveSecret(id);
+        assertThat(new String(retrievedValue, StandardCharsets.UTF_8)).isEqualTo(value);
+    }
+
+    @Test
+    public void testDefaultLoadWithEnvPass() throws Exception {
+        try {
+            String pass = UUID.randomUUID().toString();
+            EnvironmentUtil.add(new HashMap<String, String>() {{
+                put(ENVIRONMENT_PASS_KEY, pass);
+            }});
+
+            //Each usage of the secure config requires it's own instance since implementations can/should clear all the values once used.
+            SecureConfig secureConfig1 = new SecureConfig();
+            secureConfig1.add("keystore.file", folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray());
+            SecureConfig secureConfig2 = secureConfig1.clone();
+            SecureConfig secureConfig3 = secureConfig1.clone();
+            SecureConfig secureConfig4 = secureConfig1.clone();
+
+            //ensure that with only the environment we can retrieve the marker from the store
+            SecretStore secretStore = SecretStoreFactory.create(secureConfig1);
+            validateMarker(secretStore);
+
+            //ensure that aren't simply using the defaults
+            boolean expectedException = false;
+            try {
+                new JavaKeyStore().create(secureConfig2);
+            } catch (SecretStoreException e) {
+                expectedException = true;
+            }
+            assertThat(expectedException).isTrue();
+
+            //ensure that direct key access using the system key wil work
+            secureConfig3.add(KEYSTORE_ACCESS_KEY, pass.toCharArray());
+            secretStore = new JavaKeyStore().load(secureConfig3);
+            validateMarker(secretStore);
+
+            //ensure that pass will work again
+            secretStore = SecretStoreFactory.load(secureConfig4);
+            validateMarker(secretStore);
+
+        } finally {
+            EnvironmentUtil.remove(ENVIRONMENT_PASS_KEY);
+        }
+    }
+
+    /**
+     * Ensures that load failure is the correct type.
+     */
+    @Test
+    public void testErrorLoading() {
+        thrown.expect(SecretStoreException.LoadException.class);
+        //default implementation requires a path
+        SecretStoreFactory.load(new SecureConfig());
+    }
+
+    private void validateMarker(SecretStore secretStore) {
+        byte[] marker = secretStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+    }
+
+    /**
+     * Valid alternate implementation
+     */
+    static class MemoryStore implements SecretStore {
+
+        Map<SecretIdentifier, ByteBuffer> secrets = new HashMap(1);
+
+        public MemoryStore() {
+            persistSecret(LOGSTASH_MARKER, LOGSTASH_MARKER.getKey().getBytes(StandardCharsets.UTF_8));
+        }
+
+        @Override
+        public SecretStore create(SecureConfig secureConfig) {
+            return this;
+        }
+
+        @Override
+        public void delete(SecureConfig secureConfig) {
+            secrets.clear();
+        }
+
+        @Override
+        public SecretStore load(SecureConfig secureConfig) {
+            return this;
+        }
+
+        @Override
+        public boolean exists(SecureConfig secureConfig) {
+            return true;
+        }
+
+        @Override
+        public Collection<SecretIdentifier> list() {
+            return secrets.keySet();
+        }
+
+        @Override
+        public void persistSecret(SecretIdentifier id, byte[] secret) {
+            secrets.put(id, ByteBuffer.wrap(secret));
+        }
+
+        @Override
+        public void purgeSecret(SecretIdentifier id) {
+            secrets.remove(id);
+        }
+
+        @Override
+        public byte[] retrieveSecret(SecretIdentifier id) {
+            return secrets.get(id).array();
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreUtilTest.java b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreUtilTest.java
new file mode 100644
index 00000000000..48a472f7c85
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/store/SecretStoreUtilTest.java
@@ -0,0 +1,83 @@
+package org.logstash.secret.store;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.nio.charset.StandardCharsets;
+import java.util.UUID;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Unit tests for {@link SecretStoreUtil}
+ */
+public class SecretStoreUtilTest {
+
+    private String asciiString;
+
+    @Before
+    public void _setup() {
+        asciiString = UUID.randomUUID().toString();
+    }
+
+    @Test
+    public void testAsciiBytesToChar() {
+        byte[] asciiBytes = asciiString.getBytes(StandardCharsets.US_ASCII);
+        char[] asciiChars = SecretStoreUtil.asciiBytesToChar(asciiBytes);
+        assertThat(asciiChars).isEqualTo(asciiString.toCharArray());
+        assertThat(asciiBytes).containsOnly('\0');
+    }
+
+    @Test
+    public void testAsciiCharToBytes() {
+        char[] asciiChars = asciiString.toCharArray();
+        byte[] asciiBytes = SecretStoreUtil.asciiCharToBytes(asciiChars);
+        assertThat(asciiBytes).isEqualTo(asciiString.getBytes(StandardCharsets.US_ASCII));
+        assertThat(asciiChars).contains('\0');
+    }
+
+    @Test
+    public void testBase64EncodeBytes() {
+        byte[] asciiBytes = asciiString.getBytes(StandardCharsets.US_ASCII);
+        byte[] base64Bytes = SecretStoreUtil.base64Encode(asciiBytes);
+        assertThat(asciiBytes).containsOnly('\0');
+        asciiBytes = SecretStoreUtil.base64Decode(base64Bytes);
+        assertThat(base64Bytes).containsOnly('\0');
+        assertThat(asciiBytes).isEqualTo(asciiString.getBytes(StandardCharsets.US_ASCII));
+    }
+
+    @Test
+    public void testBase64EncodeBytesToChars() {
+        byte[] asciiBytes = asciiString.getBytes(StandardCharsets.US_ASCII);
+        char[] base64Chars = SecretStoreUtil.base64EncodeToChars(asciiBytes);
+        assertThat(asciiBytes).containsOnly('\0');
+        asciiBytes = SecretStoreUtil.base64Decode(base64Chars);
+        assertThat(base64Chars).containsOnly('\0');
+        assertThat(asciiBytes).isEqualTo(asciiString.getBytes(StandardCharsets.US_ASCII));
+    }
+
+    @Test
+    public void testBase64EncodeChars() {
+        char[] asciiChars = asciiString.toCharArray();
+        char[] base64Chars = SecretStoreUtil.base64Encode(asciiChars);
+        assertThat(asciiChars).containsOnly('\0');
+        byte[] asciiBytes = SecretStoreUtil.base64Decode(base64Chars);
+        assertThat(base64Chars).containsOnly('\0');
+        assertThat(asciiBytes).isEqualTo(asciiString.getBytes(StandardCharsets.US_ASCII));
+    }
+
+    @Test
+    public void testClear() {
+        byte[] asciiBytes = asciiString.getBytes(StandardCharsets.US_ASCII);
+        char[] base64Chars = SecretStoreUtil.base64EncodeToChars(asciiBytes);
+        SecretStoreUtil.clearChars(base64Chars);
+        assertThat(base64Chars).containsOnly('\0');
+    }
+
+    @Test
+    public void testObfuscate() {
+        String original = UUID.randomUUID().toString();
+        assertThat(SecretStoreUtil.deObfuscate(SecretStoreUtil.obfuscate(original.toCharArray()))).isEqualTo(original.toCharArray());
+    }
+
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/SecureConfigTest.java b/logstash-core/src/test/java/org/logstash/secret/store/SecureConfigTest.java
new file mode 100644
index 00000000000..72c4758bd60
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/store/SecureConfigTest.java
@@ -0,0 +1,60 @@
+package org.logstash.secret.store;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.IntStream;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Unit tests for {@link SecureConfig}
+ */
+public class SecureConfigTest {
+
+    private SecureConfig secureConfig;
+
+    @Before
+    public void _setup() {
+        secureConfig = new SecureConfig();
+    }
+
+    @Test
+    public void test() throws Exception {
+        Set<String> expected = new HashSet(100);
+        IntStream.range(0, 100).forEach(i -> expected.add(UUID.randomUUID().toString()));
+        expected.forEach(s -> secureConfig.add(s, s.toCharArray()));
+        expected.forEach(s -> assertThat(secureConfig.getPlainText(s)).isEqualTo(s.toCharArray()));
+        expected.forEach(s -> assertThat(secureConfig.has(s)));
+        SecureConfig clone = secureConfig.clone();
+        expected.forEach(s -> assertThat(clone.getPlainText(s)).isEqualTo(s.toCharArray()));
+        expected.forEach(s -> assertThat(clone.has(s)));
+        secureConfig.clearValues();
+        //manually reset cleared flag to allow the assertions
+        secureConfig.cleared = false;
+        expected.forEach(s -> assertThat(secureConfig.getPlainText(s)).containsOnly('\0'));
+        //clone is not zero'ed
+        expected.forEach(s -> assertThat(clone.getPlainText(s)).isEqualTo(s.toCharArray()));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testClearedAdd() {
+        secureConfig.clearValues();
+        secureConfig.add("foo", "bar".toCharArray());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testClearedClone() {
+        secureConfig.clearValues();
+        secureConfig.clone();
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testClearedGet() {
+        secureConfig.clearValues();
+        secureConfig.getPlainText("foo");
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java b/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java
new file mode 100644
index 00000000000..7594976ad3d
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/secret/store/backend/JavaKeyStoreTest.java
@@ -0,0 +1,667 @@
+package org.logstash.secret.store.backend;
+
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.rules.TemporaryFolder;
+import org.logstash.secret.SecretIdentifier;
+import org.logstash.secret.store.SecretStore;
+import org.logstash.secret.store.SecretStoreException;
+import org.logstash.secret.store.SecretStoreFactory;
+import org.logstash.secret.store.SecureConfig;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.channels.FileLock;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.NoSuchFileException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.attribute.PosixFileAttributeView;
+import java.nio.file.attribute.PosixFilePermission;
+import java.util.*;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+
+import static java.nio.file.attribute.PosixFilePermission.*;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Fail.fail;
+import static org.hamcrest.CoreMatchers.isA;
+import static org.logstash.secret.store.SecretStoreFactory.LOGSTASH_MARKER;
+
+/**
+ * Unit tests for the {@link JavaKeyStore}
+ */
+public class JavaKeyStoreTest {
+
+    private final static String EXTERNAL_TEST_FILE_LOCK = "test_file_lock";
+    private final static String EXTERNAL_TEST_WRITE = "test_external_write";
+    @Rule
+    public TemporaryFolder folder = new TemporaryFolder();
+    @Rule
+    public ExpectedException thrown = ExpectedException.none();
+    private JavaKeyStore keyStore;
+    private char[] keyStorePath;
+    private SecureConfig withDefaultPassConfig;
+    private SecureConfig withDefinedPassConfig;
+
+    /**
+     * Launch a second JVM with the expected args
+     * <ul>
+     * <li>arg[0] - the descriptor to identify which test this is for</li>
+     * <li>arg[1] - path to file to write as marker that the second JVM is ready to be tested</li>
+     * <li>arg[2..n] - any additional information needed for the test</li>
+     * </ul>
+     *
+     * @param args the args as described
+     * @throws IOException when i/o exceptions happen
+     */
+    public static void main(String... args) throws IOException, InterruptedException {
+
+        Path magicFile = Paths.get(args[1]);
+
+        //Use a second JVM to lock the keystore for 2 seconds
+        if (EXTERNAL_TEST_FILE_LOCK.equals(args[0])) {
+            Path keystoreFile = Paths.get(args[2]);
+            FileLock fileLock = null;
+            try (final FileOutputStream keystore = new FileOutputStream(keystoreFile.toFile(), true)) {
+                fileLock = keystore.getChannel().tryLock();
+                assertThat(fileLock).isNotNull();
+                //write the magic file to let the other process know the test is ready
+                try (final OutputStream os = Files.newOutputStream(magicFile)) {
+                    os.write(args[0].getBytes(StandardCharsets.UTF_8));
+                    Thread.sleep(2000);
+                } finally {
+                    Files.delete(magicFile);
+                }
+            } finally {
+                if (fileLock != null) {
+                    fileLock.release();
+                }
+            }
+        } else if (EXTERNAL_TEST_WRITE.equals(args[0])) {
+            Path keyStoreFile = Paths.get(args[2]);
+            SecureConfig config = new SecureConfig();
+            config.add("keystore.file", keyStoreFile.toAbsolutePath().toString().toCharArray());
+            JavaKeyStore keyStore = new JavaKeyStore().create(config);
+            writeAtoZ(keyStore);
+            validateAtoZ(keyStore);
+            //write the magic file to let the other process know the test is ready
+            try (final OutputStream os = Files.newOutputStream(magicFile)) {
+                os.write(args[0].getBytes(StandardCharsets.UTF_8));
+            } finally {
+                Files.delete(magicFile);
+            }
+        }
+    }
+
+    private static void validateAtoZ(JavaKeyStore keyStore) {
+        //contents of the existing is a-z for both the key and value
+        for (int i = 65; i <= 90; i++) {
+            byte[] expected = new byte[]{(byte) i};
+            SecretIdentifier id = new SecretIdentifier(new String(expected, StandardCharsets.UTF_8));
+            assertThat(keyStore.retrieveSecret(id)).isEqualTo(expected);
+        }
+    }
+
+    private static void writeAtoZ(JavaKeyStore keyStore) {
+        //a-z key and value
+        for (int i = 65; i <= 90; i++) {
+            byte[] expected = new byte[]{(byte) i};
+            SecretIdentifier id = new SecretIdentifier(new String(expected, StandardCharsets.UTF_8));
+            keyStore.persistSecret(id, expected);
+        }
+    }
+
+    @Before
+    public void _setup() throws Exception {
+        keyStorePath = folder.newFolder().toPath().resolve("logstash.keystore").toString().toCharArray();
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.file", keyStorePath.clone());
+        keyStore = new JavaKeyStore().create(secureConfig);
+
+        withDefinedPassConfig = new SecureConfig();
+        withDefinedPassConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "mypassword".toCharArray());
+        withDefinedPassConfig.add("keystore.file",
+                Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore.with.defined.pass").toURI()).toString().toCharArray());
+
+        withDefaultPassConfig = new SecureConfig();
+        withDefaultPassConfig.add("keystore.file",
+                Paths.get(this.getClass().getClassLoader().getResource("logstash.keystore.with.default.pass").toURI()).toString().toCharArray());
+    }
+
+    /**
+     * Simple example usage.
+     */
+    @Test
+    public void basicTest() {
+        String password = "pAssW3rd!";
+        //persist
+        keyStore.persistSecret(new SecretIdentifier("mysql.password"), password.getBytes(StandardCharsets.UTF_8));
+        //retrieve
+        byte[] secret = keyStore.retrieveSecret(new SecretIdentifier("mysql.password"));
+        assertThat(new String(secret, StandardCharsets.UTF_8)).isEqualTo(password);
+        //purge
+        keyStore.purgeSecret(new SecretIdentifier("mysql.password"));
+        secret = keyStore.retrieveSecret(new SecretIdentifier("mysql.password"));
+        assertThat(secret).isNull();
+    }
+
+    @Test (expected = SecretStoreException.CreateException.class)
+    public void invalidDirectory() throws IOException {
+        keyStorePath = Paths.get("/doesnt_exist_root_volume").resolve("logstash.keystore").toString().toCharArray();
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.file", keyStorePath.clone());
+        keyStore = new JavaKeyStore().create(secureConfig);
+    }
+
+    /**
+     * Tests that the magic marker that identifies this a logstash keystore is present.  This marker helps to ensure that we are only dealing with our keystore, we do not want
+     * to support arbitrary keystores.
+     *
+     * @throws Exception when ever it wants to.
+     */
+    @Test
+    public void isLogstashKeystore() throws Exception {
+        //newly created
+        byte[] marker = keyStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+
+        //exiting
+        JavaKeyStore existingKeyStore = new JavaKeyStore().load(withDefinedPassConfig);
+        marker = existingKeyStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+    }
+
+    /**
+     * Tests that trying to read a random file throws the right error.
+     *
+     * @throws Exception when ever it wants to.
+     */
+    @Test
+    public void notLogstashKeystore() throws Exception {
+        thrown.expect(SecretStoreException.LoadException.class);
+        SecureConfig altConfig = new SecureConfig();
+        Path altPath = folder.newFolder().toPath().resolve("alt.not.a.logstash.keystore");
+        try (OutputStream out = Files.newOutputStream(altPath)) {
+            byte[] randomBytes = new byte[300];
+            new Random().nextBytes(randomBytes);
+            out.write(randomBytes);
+        }
+        altConfig.add("keystore.file", altPath.toString().toCharArray());
+        new JavaKeyStore().load(altConfig);
+    }
+
+    /**
+     * Tests that when the magic marker that identifies this a logstash keystore is not present the correct exception is thrown.
+     *
+     * @throws Exception when ever it wants to.
+     */
+    @Test
+    public void notLogstashKeystoreNoMarker() throws Exception {
+        thrown.expect(SecretStoreException.LoadException.class);
+        withDefinedPassConfig.add("keystore.file", Paths.get(this.getClass().getClassLoader().getResource("not.a.logstash.keystore").toURI()).toString().toCharArray().clone());
+        new JavaKeyStore().load(withDefinedPassConfig);
+    }
+
+    /**
+     * Overwrite should be no-error overwrite
+     */
+    @Test
+    public void overwriteExisting() {
+        SecretIdentifier id = new SecretIdentifier("myId");
+        int originalSize = keyStore.list().size();
+
+        keyStore.persistSecret(id, "password1".getBytes(StandardCharsets.UTF_8));
+        assertThat(keyStore.list().size()).isEqualTo(originalSize + 1);
+        assertThat(new String(keyStore.retrieveSecret(id), StandardCharsets.UTF_8)).isEqualTo("password1");
+
+        keyStore.persistSecret(id, "password2".getBytes(StandardCharsets.UTF_8));
+        assertThat(keyStore.list().size()).isEqualTo(originalSize + 1);
+        assertThat(new String(keyStore.retrieveSecret(id), StandardCharsets.UTF_8)).isEqualTo("password2");
+    }
+
+    /**
+     * Purging missing secrets should be no-error no-op
+     */
+    @Test
+    public void purgeMissingSecret() {
+        Collection<SecretIdentifier> original = keyStore.list();
+        keyStore.purgeSecret(new SecretIdentifier("does-not-exist"));
+        assertThat(keyStore.list().toArray()).containsExactlyInAnyOrder(original.toArray());
+    }
+
+    /**
+     * Tests that we can read a pre-existing keystore from disk.
+     *
+     * @throws Exception when ever it wants to.
+     */
+    @Test
+    public void readExisting() throws Exception {
+        //uses an explicit password
+        validateAtoZ(new JavaKeyStore().load(this.withDefinedPassConfig));
+
+        //uses an implicit password
+        validateAtoZ(new JavaKeyStore().load(this.withDefaultPassConfig));
+    }
+
+    /**
+     * Comprehensive tests that uses a freshly created keystore to write 26 entries, list them, read them, and delete them.
+     */
+    @Test
+    public void readWriteListDelete() {
+        writeAtoZ(keyStore);
+        Collection<SecretIdentifier> foundIds = keyStore.list();
+        assertThat(keyStore.list().size()).isEqualTo(26 + 1);
+        validateAtoZ(keyStore);
+        foundIds.stream().filter(id -> !id.equals(LOGSTASH_MARKER)).forEach(id -> keyStore.purgeSecret(id));
+        assertThat(keyStore.list().size()).isEqualTo(1);
+        assertThat(keyStore.list().stream().findFirst().get()).isEqualTo(LOGSTASH_MARKER);
+    }
+
+    /**
+     * Retrieving missing should be no-error, null result
+     */
+    @Test
+    public void retrieveMissingSecret() {
+        assertThat(keyStore.retrieveSecret(new SecretIdentifier("does-not-exist"))).isNull();
+    }
+
+    /**
+     * Invalid input should be no-error, null result
+     */
+    @Test
+    public void retrieveWithInvalidInput() {
+        assertThat(keyStore.retrieveSecret(null)).isNull();
+    }
+
+    /**
+     * Test to ensure that keystore is tamper proof.  This really ends up testing the Java's KeyStore implementation, not the code here....but an important attribute to ensure
+     * for any type of secret store.
+     *
+     * @throws Exception when ever it wants to
+     */
+    @Test
+    public void tamperedKeystore() throws Exception {
+        thrown.expect(SecretStoreException.AccessException.class);
+        byte[] keyStoreAsBytes = Files.readAllBytes(Paths.get(new String(keyStorePath)));
+        //bump the middle byte by 1
+        int tamperLocation = keyStoreAsBytes.length / 2;
+        keyStoreAsBytes[tamperLocation] = (byte) (keyStoreAsBytes[tamperLocation] + 1);
+        Path tamperedPath = folder.newFolder().toPath().resolve("tampered.logstash.keystore");
+        Files.write(tamperedPath, keyStoreAsBytes);
+        SecureConfig sc = new SecureConfig();
+        sc.add("keystore.file", tamperedPath.toString().toCharArray());
+        new JavaKeyStore().load(sc);
+    }
+
+    /**
+     * Ensures correct error when trying to re-create a pre-existing store
+     *
+     * @throws IOException when it goes boom.
+     */
+    @Test
+    public void testAlreadyCreated() throws IOException {
+        thrown.expect(SecretStoreException.AlreadyExistsException.class);
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.file", keyStorePath.clone());
+        new JavaKeyStore().create(secureConfig);
+    }
+
+    /**
+     * The default permissions should be restrictive for Posix filesystems.
+     *
+     * @throws Exception when it goes boom.
+     */
+    @Test
+    public void testDefaultPermissions() throws Exception {
+        PosixFileAttributeView attrs = Files.getFileAttributeView(Paths.get(new String(keyStorePath)), PosixFileAttributeView.class);
+
+        boolean isWindows = System.getProperty("os.name").startsWith("Windows");
+        //not all Windows FS are Posix
+        if (!isWindows && attrs == null) {
+            fail("Can not determine POSIX file permissions for " + keyStore + " this is likely an error in the test");
+        }
+        // if we got attributes, lets assert them.
+        if (attrs != null) {
+            Set<PosixFilePermission> permissions = attrs.readAttributes().permissions();
+            EnumSet<PosixFilePermission> expected = EnumSet.of(OWNER_READ, OWNER_WRITE, GROUP_READ, GROUP_WRITE);
+            assertThat(permissions.toArray()).containsExactlyInAnyOrder(expected.toArray());
+        }
+    }
+
+    @Test
+    public void testDelete() throws IOException {
+        thrown.expect(SecretStoreException.LoadException.class);
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig altConfig = new SecureConfig();
+        altConfig.add("keystore.file", altPath.toString().toCharArray());
+        SecretStore secretStore = new JavaKeyStore().create(altConfig.clone());
+        assertThat(secretStore.exists(altConfig.clone())).isTrue();
+        byte[] marker = keyStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+        secretStore.delete(altConfig.clone());
+        assertThat(secretStore.exists(altConfig.clone())).isFalse();
+       new JavaKeyStore().load(altConfig.clone());
+
+    }
+
+    /**
+     * Empty passwords are not allowed
+     *
+     * @throws IOException when ever it wants to
+     */
+    @Test
+    public void testEmptyNotAllowedOnCreate() throws IOException {
+        thrown.expect(SecretStoreException.CreateException.class);
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig altConfig = new SecureConfig();
+        altConfig.add("keystore.file", altPath.toString().toCharArray());
+        altConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "".toCharArray());
+        new JavaKeyStore().create(altConfig);
+    }
+
+    /**
+     * Empty passwords should always throw an Access Exception
+     *
+     * @throws Exception when ever it wants to
+     */
+    @Test
+    public void testEmptyNotAllowedOnExisting() throws Exception {
+        thrown.expect(SecretStoreException.AccessException.class);
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig altConfig = new SecureConfig();
+        altConfig.add("keystore.file", altPath.toString().toCharArray());
+        SecureConfig altConfig2 = altConfig.clone();
+        altConfig2.add("keystore.file", altPath.toString().toCharArray());
+        altConfig2.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "".toCharArray());
+        new JavaKeyStore().create(altConfig);
+        new JavaKeyStore().load(altConfig2);
+    }
+
+    /**
+     * Simulates different JVMs modifying the keystore and ensure a consistent list view
+     *
+     * @throws IOException when it goes boom.
+     */
+    @Test
+    public void testExternalUpdateList() throws IOException {
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.file", altPath.toString().toCharArray());
+        JavaKeyStore keyStore1 = new JavaKeyStore().create(secureConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore().load(secureConfig);
+        String value = UUID.randomUUID().toString();
+        SecretIdentifier id = new SecretIdentifier(value);
+        //jvm1 persist, jvm2 list
+        keyStore1.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        assertThat(keyStore2.list().stream().map(k -> keyStore2.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8)).collect(Collectors.toSet())).contains(value);
+        //purge from jvm1
+        assertThat(new String(keyStore2.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
+        keyStore1.purgeSecret(id);
+        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value))).isNull();
+    }
+
+    /**
+     * Simulates different JVMs modifying the keystore and ensure a consistent view
+     *
+     * @throws IOException when it goes boom.
+     */
+    @Test
+    public void testExternalUpdatePersist() throws IOException {
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.file", altPath.toString().toCharArray());
+        JavaKeyStore keyStore1 = new JavaKeyStore().create(secureConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore().load(secureConfig);
+        String value1 = UUID.randomUUID().toString();
+        String value2 = UUID.randomUUID().toString();
+        SecretIdentifier id1 = new SecretIdentifier(value1);
+        SecretIdentifier id2 = new SecretIdentifier(value2);
+        //jvm1 persist id1, jvm2 persist id2
+        keyStore1.persistSecret(id1, value1.getBytes(StandardCharsets.UTF_8));
+        keyStore2.persistSecret(id2, value2.getBytes(StandardCharsets.UTF_8));
+        //both keystores should contain both values
+        assertThat(keyStore1.list().stream().map(k -> keyStore1.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8))
+                .collect(Collectors.toSet())).contains(value1, value2);
+        assertThat(keyStore2.list().stream().map(k -> keyStore2.retrieveSecret(k)).map(v -> new String(v, StandardCharsets.UTF_8))
+                .collect(Collectors.toSet())).contains(value1, value2);
+        //purge from jvm1
+        keyStore1.purgeSecret(id1);
+        keyStore1.purgeSecret(id2);
+        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value1))).isNull();
+        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value2))).isNull();
+        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value1))).isNull();
+        assertThat(keyStore2.retrieveSecret(new SecretIdentifier(value2))).isNull();
+    }
+
+    /**
+     * Simulates different JVMs modifying the keystore and ensure a consistent read view
+     *
+     * @throws IOException when it goes boom.
+     */
+    @Test
+    public void testExternalUpdateRead() throws IOException {
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.file", altPath.toString().toCharArray());
+        secureConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "mypass".toCharArray());
+        JavaKeyStore keyStore1 = new JavaKeyStore().create(secureConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore().load(secureConfig);
+        String value = UUID.randomUUID().toString();
+        SecretIdentifier id = new SecretIdentifier(value);
+        //jvm1 persist, jvm2 read
+        keyStore1.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        assertThat(new String(keyStore2.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
+        //purge from jvm2
+        assertThat(new String(keyStore1.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
+        keyStore2.purgeSecret(id);
+        assertThat(keyStore1.retrieveSecret(new SecretIdentifier(value))).isNull();
+    }
+
+    /**
+     * Spins up a second VM, locks the underlying keystore, asserts correct exception, once lock is released and now can write
+     *
+     * @throws Exception when exceptions happen
+     */
+    @Test
+    public void testFileLock() throws Exception {
+        Path magicFile = folder.newFolder().toPath().resolve(EXTERNAL_TEST_FILE_LOCK);
+
+        String java = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
+        ProcessBuilder builder = new ProcessBuilder(java, "-cp", System.getProperty("java.class.path"), getClass().getCanonicalName(),
+                EXTERNAL_TEST_FILE_LOCK, magicFile.toAbsolutePath().toString(), new String(keyStorePath));
+        Future<Integer> future = Executors.newScheduledThreadPool(1).submit(() -> builder.start().waitFor());
+
+        boolean passed = false;
+        while (!future.isDone()) {
+            try {
+                Files.readAllBytes(magicFile);
+            } catch (NoSuchFileException sfe) {
+                Thread.sleep(100);
+                continue;
+            }
+            try {
+                keyStore.persistSecret(new SecretIdentifier("foo"), "bar".getBytes(StandardCharsets.UTF_8));
+            } catch (SecretStoreException.PersistException e) {
+                assertThat(e.getCause()).isInstanceOf(IllegalStateException.class);
+                assertThat(e.getCause().getMessage()).contains("has a lock on the file");
+                passed = true;
+            }
+            break;
+        }
+        assertThat(passed).isTrue();
+
+        //can still read
+        byte[] marker = keyStore.retrieveSecret(LOGSTASH_MARKER);
+        assertThat(new String(marker, StandardCharsets.UTF_8)).isEqualTo(LOGSTASH_MARKER.getKey());
+
+        //block until other JVM finishes
+        future.get();
+        //can write/read now
+        SecretIdentifier id = new SecretIdentifier("foo2");
+        keyStore.persistSecret(id, "bar".getBytes(StandardCharsets.UTF_8));
+        assertThat(new String(keyStore.retrieveSecret(id), StandardCharsets.UTF_8)).isEqualTo("bar");
+    }
+
+    /**
+     * Simulates different JVMs can read using a default (non-provided) password
+     *
+     * @throws IOException when it goes boom.
+     */
+    @Test
+    public void testGeneratedSecret() throws IOException {
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig altConfig = new SecureConfig();
+        altConfig.add("keystore.file", altPath.toString().toCharArray());
+        //note - no password given here.
+        JavaKeyStore keyStore1 = new JavaKeyStore().create(altConfig.clone());
+        JavaKeyStore keyStore2 = new JavaKeyStore().load(altConfig);
+        String value = UUID.randomUUID().toString();
+        SecretIdentifier id = new SecretIdentifier(value);
+        //jvm1 persist, jvm2 read
+        keyStore1.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+        assertThat(new String(keyStore2.retrieveSecret(new SecretIdentifier(value)), StandardCharsets.UTF_8)).isEqualTo(value);
+    }
+
+    /**
+     * Test upper sane bounds.
+     */
+    @Test
+    public void testLargeKeysAndValues() {
+        int keySize = 1000;
+        int valueSize = 100000;
+        StringBuilder keyBuilder = new StringBuilder(keySize);
+        IntStream.range(0, keySize).forEach(i -> keyBuilder.append('k'));
+        String key = keyBuilder.toString();
+
+        StringBuilder valueBuilder = new StringBuilder(valueSize);
+        IntStream.range(0, valueSize).forEach(i -> valueBuilder.append('v'));
+        String value = valueBuilder.toString();
+
+        SecretIdentifier id = new SecretIdentifier(key);
+        keyStore.persistSecret(id, value.getBytes(StandardCharsets.UTF_8));
+
+        byte[] secret = keyStore.retrieveSecret(id);
+        assertThat(new String(secret, StandardCharsets.UTF_8)).isEqualTo(value);
+
+        keyStore.purgeSecret(id);
+    }
+
+    @Test
+    public void testLoadNotCreated() throws IOException {
+        thrown.expect(SecretStoreException.LoadException.class);
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+        SecureConfig secureConfig = new SecureConfig();
+        secureConfig.add("keystore.file", altPath.toString().toCharArray());
+        new JavaKeyStore().load(secureConfig.clone());
+    }
+
+    @Test
+    public void testNoPathDefined() {
+        thrown.expect(SecretStoreException.LoadException.class);
+        new JavaKeyStore().load(new SecureConfig());
+    }
+
+    /**
+     * Ensure that non-ascii keys and values are properly handled.
+     *
+     * @throws Exception when the clowns cry
+     */
+    @Test
+    public void testNonAscii() throws Exception {
+        int[] codepoints = {0xD83E, 0xDD21, 0xD83E, 0xDD84};
+        String nonAscii = new String(codepoints, 0, codepoints.length);
+
+        SecureConfig sc = new SecureConfig();
+        sc.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, nonAscii.toCharArray());
+        sc.add("keystore.file", (new String(keyStorePath) + ".nonAscii").toCharArray());
+        JavaKeyStore nonAsciiKeyStore = new JavaKeyStore().create(sc);
+
+        SecretIdentifier id = new SecretIdentifier(nonAscii);
+        nonAsciiKeyStore.persistSecret(id, nonAscii.getBytes(StandardCharsets.UTF_8));
+        assertThat(new String(nonAsciiKeyStore.retrieveSecret(id), StandardCharsets.UTF_8)).isEqualTo(nonAscii);
+    }
+
+    /**
+     * Ensure the permissions can be set to be set more restrictive then default
+     *
+     * @throws Exception when it goes boom.
+     */
+    @Test
+    public void testRestrictivePermissions() throws Exception {
+        String beforeTest = JavaKeyStore.filePermissions;
+        JavaKeyStore.filePermissions = "rw-------";
+        try {
+            Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+            SecureConfig secureConfig = new SecureConfig();
+            secureConfig.add("keystore.file", altPath.toString().toCharArray());
+
+            keyStore = new JavaKeyStore().create(secureConfig);
+            assertThat(altPath.toFile().exists()).isTrue();
+            PosixFileAttributeView attrs = Files.getFileAttributeView(altPath, PosixFileAttributeView.class);
+
+            boolean isWindows = System.getProperty("os.name").startsWith("Windows");
+            //not all Windows FS are Posix
+            if (!isWindows && attrs == null) {
+                fail("Can not determine POSIX file permissions for " + keyStore + " this is likely an error in the test");
+            }
+            // if we got attributes, lets assert them.
+            if (attrs != null) {
+                Set<PosixFilePermission> permissions = attrs.readAttributes().permissions();
+                EnumSet<PosixFilePermission> expected = EnumSet.of(OWNER_READ, OWNER_WRITE);
+                assertThat(permissions.toArray()).containsExactlyInAnyOrder(expected.toArray());
+            }
+        } finally {
+            JavaKeyStore.filePermissions = beforeTest;
+        }
+    }
+
+    /**
+     * Spins up a second JVM, writes all the data, then read it from this JVM
+     *
+     * @throws Exception when exceptions happen
+     */
+    @Test
+    public void testWithRealSecondJvm() throws Exception {
+        Path magicFile = folder.newFolder().toPath().resolve(EXTERNAL_TEST_FILE_LOCK);
+        Path altPath = folder.newFolder().toPath().resolve("alt.logstash.keystore");
+
+        String java = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
+        ProcessBuilder builder = new ProcessBuilder(java, "-cp", System.getProperty("java.class.path"), getClass().getCanonicalName(),
+                EXTERNAL_TEST_WRITE, magicFile.toAbsolutePath().toString(), altPath.toAbsolutePath().toString());
+        Future<Integer> future = Executors.newScheduledThreadPool(1).submit(() -> builder.start().waitFor());
+
+        while (!future.isDone()) {
+            try {
+                Files.readAllBytes(magicFile);
+            } catch (NoSuchFileException sfe) {
+                Thread.sleep(100);
+                continue;
+            }
+        }
+        SecureConfig config = new SecureConfig();
+        config.add("keystore.file", altPath.toAbsolutePath().toString().toCharArray());
+        JavaKeyStore keyStore = new JavaKeyStore().load(config);
+        validateAtoZ(keyStore);
+    }
+
+    /**
+     * Ensure that the when the wrong password is presented the corrected exception is thrown.
+     *
+     * @throws Exception when ever it wants to
+     */
+    @Test
+    public void wrongPassword() throws Exception {
+        thrown.expect(SecretStoreException.AccessException.class);
+        withDefinedPassConfig.add(SecretStoreFactory.KEYSTORE_ACCESS_KEY, "wrongpassword".toCharArray());
+        new JavaKeyStore().load(withDefinedPassConfig);
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/resources/logstash.keystore.with.default.pass b/logstash-core/src/test/resources/logstash.keystore.with.default.pass
new file mode 100644
index 00000000000..db1419c373d
Binary files /dev/null and b/logstash-core/src/test/resources/logstash.keystore.with.default.pass differ
diff --git a/logstash-core/src/test/resources/logstash.keystore.with.defined.pass b/logstash-core/src/test/resources/logstash.keystore.with.defined.pass
new file mode 100644
index 00000000000..a21d9a88270
Binary files /dev/null and b/logstash-core/src/test/resources/logstash.keystore.with.defined.pass differ
diff --git a/logstash-core/src/test/resources/not.a.logstash.keystore b/logstash-core/src/test/resources/not.a.logstash.keystore
new file mode 100644
index 00000000000..70ebb48bcf4
Binary files /dev/null and b/logstash-core/src/test/resources/not.a.logstash.keystore differ
diff --git a/rakelib/artifacts.rake b/rakelib/artifacts.rake
index 0bc0dad1456..80e1d2947c1 100644
--- a/rakelib/artifacts.rake
+++ b/rakelib/artifacts.rake
@@ -16,6 +16,7 @@ namespace "artifact" do
       "lib/bootstrap/**/*",
       "lib/pluginmanager/**/*",
       "lib/systeminstall/**/*",
+      "lib/secretstore/**/*",
 
       "logstash-core/lib/**/*",
       "logstash-core/locales/**/*",
