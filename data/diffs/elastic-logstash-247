diff --git a/spec/filters/dns.rb b/spec/filters/dns.rb
index 1e481f074ba..3257c23e60c 100644
--- a/spec/filters/dns.rb
+++ b/spec/filters/dns.rb
@@ -4,7 +4,6 @@
 describe LogStash::Filters::DNS do
   extend LogStash::RSpec
 
-
   describe "dns reverse lookup, replace (on event.source)" do
     config <<-CONFIG
       filter {
@@ -126,6 +125,21 @@
     end
   end
 
+  describe "dns resolve lookup, append with multi-value does nothing" do
+    config <<-CONFIG
+      filter {
+        dns {
+          resolve => "foo"
+          action => "append"
+        }
+      }
+    CONFIG
+
+    sample({"@fields" => { "foo" => ["carrera.databits.net", "foo.databits.net"]}}) do
+      insist { subject["foo"] } == ["carrera.databits.net", "foo.databits.net"]
+    end
+  end
+
   describe "dns resolve lookup, not a valid hostname" do
     config <<-CONFIG
       filter {
@@ -139,10 +153,4 @@
       insist { subject["foo"] } == "does.not.exist"
     end
   end
-end
-
-
-
-
-
-
+end
\ No newline at end of file
diff --git a/spec/filters/grep.rb b/spec/filters/grep.rb
index 515152135cf..922f7551315 100644
--- a/spec/filters/grep.rb
+++ b/spec/filters/grep.rb
@@ -5,8 +5,6 @@
   extend LogStash::RSpec
 
   describe "single grep match" do
-    # The logstash config goes here.
-    # At this time, only filters are supported.
     config <<-CONFIG
       filter {
         grep {
diff --git a/spec/filters/multiline.rb b/spec/filters/multiline.rb
index 4d914cc9ee4..a6e91cada9a 100644
--- a/spec/filters/multiline.rb
+++ b/spec/filters/multiline.rb
@@ -5,8 +5,6 @@
   extend LogStash::RSpec
 
   describe "simple multiline" do
-    # The logstash config goes here.
-    # At this time, only filters are supported.
     config <<-CONFIG
     filter {
       multiline {
@@ -24,8 +22,6 @@
   end
 
   describe "multiline using grok patterns" do
-    # The logstash config goes here.
-    # At this time, only filters are supported.
     config <<-CONFIG
     filter {
       multiline {
@@ -43,8 +39,6 @@
   end
 
   describe "multiline safety among multiple concurrent streams" do
-    # The logstash config goes here.
-    # At this time, only filters are supported.
     config <<-CONFIG
       filter {
         multiline {
diff --git a/spec/filters/mutate.rb b/spec/filters/mutate.rb
index fb301179e37..c94b556e43b 100644
--- a/spec/filters/mutate.rb
+++ b/spec/filters/mutate.rb
@@ -5,8 +5,6 @@
   extend LogStash::RSpec
 
   describe "basics" do
-    # The logstash config goes here.
-    # At this time, only filters are supported.
     config <<-CONFIG
       filter {
         mutate {
@@ -15,31 +13,126 @@
           convert => [ "intme", "integer", "floatme", "float" ]
           rename => [ "rename1", "rename2" ]
           replace => [ "replaceme", "hello world" ]
-          remove => [ "removeme" ] 
+          remove => [ "removeme" ]
         }
       }
     CONFIG
 
-    event = { "@fields" => { 
-      "lowerme" => [ "ExAmPlE" ], "upperme" => [ "ExAmPlE" ],
-      "intme" => [ "1234" ], "floatme" => [ "1234.455" ],
+    event = { "@fields" => {
+      "lowerme" => [ "ExAmPlE" ],
+      "upperme" => [ "ExAmPlE" ],
+      "intme" => [ "1234", "7890.4", "7.9" ],
+      "floatme" => [ "1234.455" ],
       "rename1" => [ "hello world" ],
       "replaceme" => [ "who cares" ],
-      "removeme" => [ "something" ] 
-      } 
-    } 
-    
+      "removeme" => [ "something" ]
+      }
+    }
+
     sample event do
-      insist { subject["lowerme"] } == subject["lowerme"].collect(&:downcase)
-      insist { subject["upperme"] } == subject["lowerme"].collect(&:upcase)
-      insist { subject["intme"] } == subject["intme"].collect(&:to_i)
-      insist { subject["floatme"] } == subject["floatme"].collect(&:to_f)
+      insist { subject["lowerme"] } == ['example']
+      insist { subject["upperme"] } == ['EXAMPLE']
+      insist { subject["intme"] }   == [1234, 7890, 7]
+      insist { subject["floatme"] } == [1234.455]
       reject { subject }.include?("rename1")
       insist { subject["rename2"] } == [ "hello world" ]
       reject { subject }.include?("removeme")
     end
   end
 
+  describe "remove multiple fields" do
+    config '
+      filter {
+        mutate {
+          remove => [ "remove-me", "remove-me2", "diedie" ]
+        }
+      }'
+
+    sample "@fields" => {
+      "remove-me"  => "Goodbye!",
+      "remove-me2" => 1234,
+      "diedie"     => [1, 2, 3, 4],
+      "survivor"   => "Hello."
+    } do
+      insist { subject.fields } == { "survivor" => "Hello." }
+    end
+  end
+
+  describe "convert one field to string" do
+    config '
+      filter {
+        mutate {
+          convert => [ "unicorns", "string" ]
+        }
+      }'
+
+    sample "@fields" => {
+      "unicorns" => 1234
+    } do
+      insist { subject.fields } == { "unicorns" => "1234" }
+    end
+  end
+
+  describe "gsub on a String" do
+    config '
+      filter {
+        mutate {
+          gsub => [ "unicorns", "but extinct", "and common" ]
+        }
+      }'
+
+    sample "@fields" => {
+      "unicorns" => "Magnificient, but extinct, animals"
+    } do
+      insist { subject.fields } == {
+        "unicorns" => "Magnificient, and common, animals"
+      }
+    end
+  end
+
+  describe "gsub on an Array of Strings" do
+    config '
+      filter {
+        mutate {
+          gsub => [ "unicorns", "extinct", "common" ]
+        }
+      }'
+
+    sample "@fields" => {
+      "unicorns" => [
+        "Magnificient extinct animals",
+        "Other extinct ideas"
+      ]
+    } do
+      insist { subject.fields } == {
+        "unicorns" => [
+          "Magnificient common animals",
+          "Other common ideas"
+        ]
+      }
+    end
+  end
+
+  describe "gsub on multiple fields" do
+    config '
+      filter {
+        mutate {
+          gsub => [ "colors", "red", "blue",
+                    "shapes", "square", "circle" ]
+        }
+      }'
+
+    sample "@fields" => {
+      "colors" => "One red car",
+      "shapes" => "Four red squares"
+    } do
+      insist { subject.fields } == {
+        "colors" => "One blue car",
+        "shapes" => "Four red circles"
+      }
+    end
+  end
+
   describe "regression - check grok+mutate" do
     config <<-CONFIG
       filter {
@@ -53,7 +146,7 @@
     CONFIG
 
     sample "HELLO WORLD" do
-      insist { subject["foo"] } == subject["foo"].collect(&:downcase)
+      insist { subject["foo"] } == ['hello']
     end
   end
 end
diff --git a/test/logstash/filters/test_csv.rb b/test/logstash/filters/test_csv.rb
deleted file mode 100644
index bfbec248411..00000000000
--- a/test/logstash/filters/test_csv.rb
+++ /dev/null
@@ -1,79 +0,0 @@
-require "rubygems"
-require File.join(File.dirname(__FILE__), "..", "minitest")
-
-require "logstash/loadlibs"
-require "logstash"
-require "logstash/filters"
-require "logstash/filters/csv"
-require "logstash/event"
-
-describe LogStash::Filters::Csv do
-  before do
-    @filter = LogStash::Filters.from_name("csv", {})
-    @typename = "csv"
-  end
-
-  def config(cfg)
-    cfg["type"] = @typename
-    cfg.each_key do |key|
-      if cfg[key].is_a?(String)
-        cfg[key] = [cfg[key]]
-      end
-    end
-
-    @filter = LogStash::Filters::Csv.new(cfg)
-    @filter.register
-  end # def config
-
-  test "parse csv with field names" do
-    config "raw" => "data",
-           "fields" => ["custom1", "custom2", "custom3"]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = "val1,val2,val3"
-    @filter.filter(event)
-    assert_equal({"custom1" => "val1",
-                  "custom2" => "val2",
-                  "custom3" => "val3"},
-                 event["data"])
-  end
-
-  test "parse csv without field names" do
-    config "raw" => "data"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = "val1,val2,val3"
-    @filter.filter(event)
-    assert_equal({"field1" => "val1",
-                  "field2" => "val2",
-                  "field3" => "val3"},
-                 event["data"])
-  end
-
-  test "parse csv with more data than defined field names" do
-    config "raw" => "data",
-           "fields" => ["custom1", "custom2"]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = "val1,val2,val3"
-    @filter.filter(event)
-    assert_equal({"custom1" => "val1",
-                  "custom2" => "val2",
-                  "field3" => "val3"},
-                 event["data"])
-  end
-
-  test "fail to parse any data in a multi-value field" do
-    config "raw" => "data",
-           "fields" => ["custom1", "custom2"]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = ["val1,val2,val3", "val1,val2,val3"]
-    @filter.filter(event)
-    assert_equal(nil, event["data"])
-  end
-end # Test 'csv' filter
diff --git a/test/logstash/filters/test_date.rb b/test/logstash/filters/test_date.rb
deleted file mode 100644
index 154f891b318..00000000000
--- a/test/logstash/filters/test_date.rb
+++ /dev/null
@@ -1,154 +0,0 @@
-require "rubygems"
-require File.join(File.dirname(__FILE__), "..", "minitest")
-
-require "logstash"
-require "logstash/loadlibs"
-require "logstash/filters"
-require "logstash/filters/date"
-require "logstash/event"
-require "timeout"
-
-describe LogStash::Filters::Date do
-  before do
-    @typename = "foozle"
-  end
-
-  def config(cfg)
-    cfg["type"] = @typename
-    cfg.each_key do |key|
-      if cfg[key].is_a?(String)
-        cfg[key] = [cfg[key]]
-      end
-    end
-
-    @filter = LogStash::Filters::Date.new(cfg)
-    @filter.register
-  end
-
-  test "ISO8601 date parsing" do
-    config "field1" => "ISO8601"
-
-    times = {
-      "2001-01-01T00:00:00-0800"         => "2001-01-01T08:00:00.000Z",
-      "1974-03-02T04:09:09-0800"         => "1974-03-02T12:09:09.000Z",
-      "2010-05-03T08:18:18+00:00"        => "2010-05-03T08:18:18.000Z",
-      "2004-07-04T12:27:27-00:00"        => "2004-07-04T12:27:27.000Z",
-      "2001-09-05T16:36:36+0000"         => "2001-09-05T16:36:36.000Z",
-      "2001-11-06T20:45:45-0000"         => "2001-11-06T20:45:45.000Z",
-      "2001-12-07T23:54:54Z"             => "2001-12-07T23:54:54.000Z",
-
-      # TODO: This test assumes PDT
-      #"2001-01-01T00:00:00.123"          => "2001-01-01T08:00:00.123Z",
-
-      "2010-05-03T08:18:18.123+00:00"    => "2010-05-03T08:18:18.123Z",
-      "2004-07-04T12:27:27.123-04:00"    => "2004-07-04T16:27:27.123Z",
-      "2001-09-05T16:36:36.123+0700"     => "2001-09-05T09:36:36.123Z",
-      "2001-11-06T20:45:45.123-0000"     => "2001-11-06T20:45:45.123Z",
-      "2001-12-07T23:54:54.123Z"         => "2001-12-07T23:54:54.123Z",
-    }
-    
-    event = LogStash::Event.new
-    event.type = @typename
-    times.each do |input, output|
-      event.fields["field1"] = input
-      @filter.filter(event)
-      assert_equal(output, event.timestamp,
-                   "Time '#{input}' should parse to '#{output}' but got '#{event.timestamp}'")
-    end # times.each
-  end # testing ISO8601
-
-  test "parsing with java SimpleDateFormat syntax" do
-    config "field1" => "MMM dd HH:mm:ss Z"
-
-    now = Time.now
-    year = now.year
-    require 'java'
-
-    times = {
-      "Nov 24 01:29:01 -0800" => "#{year}-11-24T09:29:01.000Z",
-    }
-
-    event = LogStash::Event.new
-    event.type = @typename
-    times.each do |input, output|
-      event.fields["field1"] = input
-      @filter.filter(event)
-      assert_equal(output, event.timestamp)
-    end
-  end # SimpleDateFormat tests
-
-  test "performance" do
-    config "field1" => "MMM dd HH:mm:ss Z"
-    iterations = 50000
-
-    start = Time.now
-    year = start.year
-
-    input = "Nov 24 01:29:01 -0800" 
-    output = "#{year}-11-24T09:29:01.000Z"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event.fields["field1"] = input
-    check_interval = 997
-    max_duration = 10
-    Timeout.timeout(max_duration) do 
-      1.upto(iterations).each do |i|
-        @filter.filter(event)
-        if i % check_interval == 0
-          assert_equal(event.timestamp, output)
-        end
-      end
-    end # Timeout.timeout
-
-    duration = Time.now - start
-    puts "filters/date speed test; #{iterations} iterations: #{duration} seconds (#{iterations / duration} per sec)"
-    assert(duration < 10, "Should be able to do #{iterations} date parses in less than #{max_duration} seconds, got #{duration} seconds")
-  end # performance test
-
-  test "UNIX date parsing" do
-    config "field1" => "UNIX"
-
-    times = {
-      "0"          => "1970-01-01T00:00:00.000Z",
-      "1000000000" => "2001-09-09T01:46:40.000Z",
-
-      # LOGSTASH-279 - sometimes the field is a number.
-      0          => "1970-01-01T00:00:00.000Z",
-      1000000000 => "2001-09-09T01:46:40.000Z"
-    }
-    
-    event = LogStash::Event.new
-    event.type = @typename
-    times.each do |input, output|
-      event.fields["field1"] = input
-      @filter.filter(event)
-      assert_equal(output, event.timestamp,
-                   "Time '#{input}' should parse to '#{output}' but got '#{event.timestamp}'")
-    end # times.each
-  end # testing UNIX date parse
-
-  test "UNIX_MS date parsing" do
-    config "field1" => "UNIX_MS"
-
-    times = {
-      "0"          => "1970-01-01T00:00:00.000Z",
-      "456"          => "1970-01-01T00:00:00.456Z",
-      "1000000000123" => "2001-09-09T01:46:40.123Z",
-
-      # LOGSTASH-279 - sometimes the field is a number.
-      0          => "1970-01-01T00:00:00.000Z",
-      456          => "1970-01-01T00:00:00.456Z",
-      1000000000123 => "2001-09-09T01:46:40.123Z"
-    }
-    
-    event = LogStash::Event.new
-    event.type = @typename
-    times.each do |input, output|
-      event.fields["field1"] = input
-      @filter.filter(event)
-      assert_equal(output, event.timestamp,
-                   "Time '#{input}' should parse to '#{output}' but got '#{event.timestamp}'")
-    end # times.each
-  end # testing UNIX date parse
-end # describe LogStash::Filters::Date
diff --git a/test/logstash/filters/test_dns.rb b/test/logstash/filters/test_dns.rb
deleted file mode 100644
index 3ca79801bd9..00000000000
--- a/test/logstash/filters/test_dns.rb
+++ /dev/null
@@ -1,138 +0,0 @@
-require "rubygems"
-require File.join(File.dirname(__FILE__), "..", "minitest")
-
-require "logstash"
-require "logstash/loadlibs"
-require "logstash/filters"
-require "logstash/filters/dns"
-require "logstash/event"
-require "timeout"
-
-describe LogStash::Filters::DNS do
-  before do
-    @typename = "foozle"
-  end
-
-  def config(cfg)
-    cfg["type"] = @typename
-    cfg.each_key do |key|
-      if cfg[key].is_a?(String)
-        cfg[key] = [cfg[key]]
-      end
-    end
-
-    @filter = LogStash::Filters::DNS.new(cfg)
-    @filter.register
-  end
-
-  ## REVERSE tests
-
-  test "dns reverse lookup, replace (on event.source)" do
-    config "reverse" => "@source",
-           "action" => "replace"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event.source = "199.192.228.250"
-    @filter.filter(event)
-
-    assert_equal("carrera.databits.net", event.source)
-  end # dns reverse lookup, replace (on event.source)
-
-  test "dns reverse lookup, replace" do
-    config "reverse" => "foo",
-           "action" => "replace"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["foo"] = ["199.192.228.250"]
-    @filter.filter(event)
-
-    assert_equal(["carrera.databits.net"], event["foo"])
-  end # dns reverse lookup, replace
-
-  test "dns reverse lookup, append" do
-    config "reverse" => "foo",
-           "action" => "append"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["foo"] = ["199.192.228.250"]
-    @filter.filter(event)
-
-    assert_equal(["199.192.228.250", "carrera.databits.net"], event["foo"])
-  end # dns reverse lookup, replace
-
-  test "dns reverse lookup, not an IP" do
-    config "reverse" => "foo"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["foo"] = ["not.an.ip"]
-    @filter.filter(event)
-
-    assert_equal(["not.an.ip"], event["foo"])
-  end # dns reverse lookup, not an IP
-
-
-  ## RESOLVE tests
-
-  test "dns resolve lookup, replace (on event.source)" do
-    config "resolve" => "@source",
-           "action" => "replace"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event.source = "carrera.databits.net"
-    @filter.filter(event)
-
-    assert_equal("199.192.228.250", event.source)
-  end # dns reverse lookup, replace (on event.source)
-
-  test "dns resolve lookup, replace" do
-    config "resolve" => "foo",
-           "action" => "replace"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["foo"] = ["carrera.databits.net"]
-    @filter.filter(event)
-
-    assert_equal(["199.192.228.250"], event["foo"])
-  end # dns resolve lookup, replace
-
-  test "dns resolve lookup, skip multi-value" do
-    config "resolve" => "foo",
-           "action" => "replace"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["foo"] = ["carrera.databits.net", "foo.databits.net"]
-    @filter.filter(event)
-
-    assert_equal(["carrera.databits.net", "foo.databits.net"], event["foo"])
-  end # dns resolve lookup, replace
-
-  test "dns resolve lookup, append" do
-    config "resolve" => "foo",
-           "action" => "append"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["foo"] = ["carrera.databits.net"]
-    @filter.filter(event)
-
-    assert_equal(["carrera.databits.net", "199.192.228.250"], event["foo"])
-  end # dns resolve lookup, replace
-
-  test "dns resolve lookup, not a valid hostname" do
-    config "resolve" => "foo"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["foo"] = ["does.not.exist"]
-    @filter.filter(event)
-
-    assert_equal(["does.not.exist"], event["foo"])
-  end # dns resolve lookup, not a valid hostname
-end # describe LogStash::Filters::DNS
diff --git a/test/logstash/filters/test_grep.rb b/test/logstash/filters/test_grep.rb
deleted file mode 100644
index a20c36056e5..00000000000
--- a/test/logstash/filters/test_grep.rb
+++ /dev/null
@@ -1,204 +0,0 @@
-require "rubygems"
-require File.join(File.dirname(__FILE__), "..", "minitest")
-
-require "logstash/loadlibs"
-require "logstash"
-require "logstash/filters"
-require "logstash/filters/grep"
-require "logstash/event"
-
-describe LogStash::Filters::Grep do
-  before do
-    @filter = LogStash::Filters.from_name("grep", {})
-    @typename = "grepper"
-  end
-
-  def config(cfg)
-    cfg["type"] = @typename
-    cfg.each_key do |key|
-      if cfg[key].is_a?(String)
-        cfg[key] = [cfg[key]]
-      end
-    end
-
-    @filter = LogStash::Filters::Grep.new(cfg)
-    @filter.register
-  end # def config
-
-  test "single grep match" do
-    config "str" => "test"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "test: this should not be dropped"
-    @filter.filter(event)
-    assert_equal(false, event.cancelled?)
-  end # testing a single match
-
-  test "single match failure does not cancel the event with drop set to false" do
-    config "str"  => "test",
-           "drop" => "false"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "foo: this should not be dropped"
-    @filter.filter(event)
-    assert_equal(false, event.cancelled?)
-  end
-
-  test "single match failure cancels the event" do
-    config "str" => "test"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "foo: this should be dropped"
-    @filter.filter(event)
-    assert_equal(true, event.cancelled?)
-  end
-
-  test "multiple match conditions" do
-    config "str" => "test", "bar" => "baz"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "test: this should not be dropped"
-    event["bar"] = "foo baz foo"
-    @filter.filter(event)
-    assert_equal(false, event.cancelled?)
-  end # test_multiple_match
-
-  test "multiple match conditions should cancel on failure" do
-    config "str" => "test", "bar" => "baz"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "test: this should be dropped"
-    event["bar"] = "foo bAz foo"
-    @filter.filter(event)
-    assert_equal(true, event.cancelled?)
-  end # test_multiple_match_drop
-
-  test "single condition with regexp syntax" do
-    config "str" => "(?i)test.*foo"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "TeST regexp match FoO"
-    @filter.filter(event)
-    assert_equal(false, event.cancelled?)
-  end
-
-  test "single condition with regexp syntax cancels on failure" do
-    config "str" => "test.*foo"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "TeST regexp match FoO"
-    @filter.filter(event)
-    assert_equal(true, event.cancelled?)
-  end # def test_single_match_regexp_drop
-
-  test "adding fields on success" do
-    config "str" => "test",
-           "add_field" => ["new_field", "new_value"]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "test"
-    @filter.filter(event)
-    assert_equal(["new_value"], event["new_field"])
-  end # def test_add_fields
-
-  test "adding fields with a sprintf value" do
-    config "str" => "test",
-           "add_field" => ["new_field", "%{@type}"]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "test"
-    @filter.filter(event)
-    assert_equal([event.type], event["new_field"])
-  end # def test_add_fields_with_format
-
-  def __DISABLED_FOR_NOW_test_add_fields_multiple_match
-    #config "match" => {"str" => "test"},
-           #"add_fields" => {"new_field" => "new_value"}},
-           #"match" => {"str" => ".*"},
-             #"add_fields" => {"new_field" => "new_value_2"}},
-           #]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "test"
-    @filter.filter(event)
-    assert_equal(["new_value", "new_value_2"], event["new_field"])
-  end # def test_add_fields_multiple_match
-
-  test "add tags" do
-    config "str" => "test",
-           "add_tag" => ["new_tag"]
-
-    event = LogStash::Event.new
-    event.tags << "tag"
-    event.type = @typename
-    event["str"] = "test"
-    @filter.filter(event)
-    assert_equal(["tag", "new_tag"], event.tags)
-  end # def test_add_tags
-
-  test "add tags with drop set to false tags matching events" do
-    config "str" => "test",
-           "drop" => "false",
-           "add_tag" => ["new_tag"]
-
-    event = LogStash::Event.new
-    event.tags << "tag"
-    event.type = @typename
-    event["str"] = "test"
-    @filter.filter(event)
-    assert_equal(["tag", "new_tag"], event.tags)
-    assert_equal(false, event.cancelled?)
-  end # def test_add_tags
-
-  test "add tags with drop set to false allows non-matching events through" do
-    config "str" => "test",
-           "drop" => "false",
-           "add_tag" => ["new_tag"]
-
-    event = LogStash::Event.new
-    event.tags << "tag"
-    event.type = @typename
-    event["str"] = "non-matching"
-    @filter.filter(event)
-    assert_equal(["tag"], event.tags)
-    assert_equal(false, event.cancelled?)
-  end # def test_add_tags
-
-  test "add tags with sprintf value" do
-    config "str" => "test",
-           "add_tag" => ["%{str}"]
-
-    event = LogStash::Event.new
-    event.tags << "tag"
-    event.type = @typename
-    event["str"] = "test"
-    @filter.filter(event)
-    assert_equal(["tag", event["str"]], event.tags)
-  end # def test_add_tags
-
-  test "negate=true should not cause drops when field is nil" do
-    # Set negate to true; the pattern being searched doesn't actually matter
-    # here. We're testing to make sure "grep -v" behavior doesn't drop events
-    # that don't even have the field being filtered for.
-    config "negate" => "true", "str" => "doesn't matter lol"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    # Make an event where the field in question is nil
-    event["str"] = nil
-    @filter.filter(event)
-    # Event should not have been canceled
-    assert_equal(false, event.cancelled?)
-  end # testing negate=true and nil field
-
-end # TestFilterGrep
diff --git a/test/logstash/filters/test_grok.rb b/test/logstash/filters/test_grok.rb
index fe3601a22df..ea4684757b4 100644
--- a/test/logstash/filters/test_grok.rb
+++ b/test/logstash/filters/test_grok.rb
@@ -19,63 +19,10 @@ def config(cfg)
         cfg[key] = [cfg[key]]
       end
     end
-
-    #p :config => cfg
-    #p :filter => @filter
     @filter = LogStash::Filters::Grok.new(cfg)
     @filter.register
   end
 
-  test "normal grok" do
-    config "pattern" => [ "%{SYSLOGLINE}" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-
-    logsource = "evita"
-    timestamp = "Mar 16 00:01:25"
-    message = "connect from camomile.cloud9.net[168.100.1.3]"
-    program = "postfix/smtpd"
-    pid = "1713"
-
-    #event.message = "Mar 16 00:01:25 evita postfix/smtpd[1713]: connect from camomile.cloud9.net[168.100.1.3]"
-    event.message = "#{timestamp} #{logsource} #{program}[#{pid}]: #{message}"
-
-    @filter.filter(event)
-    assert_equal(event.fields["logsource"], [logsource],
-                 "Expected field 'logsource' to be [#{logsource.inspect}], " \
-                 "is #{event.fields["logsource"].inspect}")
-
-    assert_equal(event.fields["timestamp"], [timestamp],
-                 "Expected field 'timestamp' to be [#{timestamp.inspect}], " \
-                 "is #{event.fields["timestamp"].inspect}")
-
-    assert_equal(event.fields["message"], [message],
-                 "Expected field 'message' to be ['#{message.inspect}'], " \
-                 "is #{event.fields["message"].inspect}")
-
-    assert_equal(event.fields["program"], [program],
-                 "Expected field 'program' to be ['#{program.inspect}'], " \
-                 "is #{event.fields["program"].inspect}")
-
-    assert_equal(event.fields["pid"], [pid],
-                 "Expected field 'pid' to be ['#{pid.inspect}'], " \
-                 "is #{event.fields["pid"].inspect}")
-  end # test normal
-
-  test "parsing an event with multiple messages (array of strings)" do
-    config "pattern" => [ "(?:hello|world) %{NUMBER}" ],
-           "named_captures_only" => "false"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event.message = [ "hello 12345", "world 23456" ]
-
-    @filter.filter(event)
-    $stderr.puts event.to_hash.inspect
-    assert_equal(event.fields["NUMBER"].sort, ["12345", "23456"])
-  end # parsing event with multiple messages
-
   test "performance" do
     config "pattern" => [ "%{SYSLOGLINE}" ]
     puts "Doing performance test"
@@ -104,159 +51,4 @@ def config(cfg)
            "than #{max_duration} seconds, got #{duration} seconds")
   end # performance test
 
-  test "grok pattern type coercion to integer" do
-    config "pattern" => [ "%{NUMBER:foo:int}" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-
-    expect = 12345
-    event.message = "#{expect}"
-
-    @filter.filter(event)
-    assert_equal(expect.class, event.fields["foo"].first.class,
-                 "Expected field 'foo' to be of type #{expect.class.name} " \
-                 "but got #{event.fields["foo"].first.class.name}")
-    assert_equal([expect], event.fields["foo"],
-                 "Expected field 'foo' to be [#{expect.inspect}], is " \
-                 "#{event.fields["expect"].inspect}")
-  end # test int type coercion
-
-  test "pattern type coercion to float" do
-    config "pattern" => [ "%{NUMBER:foo:float}" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-
-    expect = 3.1415
-    event.message = "#{expect}"
-
-    @filter.filter(event)
-    assert_equal(expect.class, event.fields["foo"].first.class,
-                 "Expected field 'foo' to be of type #{expect.class.name} " \
-                 "but got #{event.fields["foo"].first.class.name}")
-    assert_equal([expect], event.fields["foo"],
-                 "Expected field 'foo' to be [#{expect.inspect}], " \
-                 "is #{event.fields["foo"].inspect}")
-  end # test float coercion
-
-  test "in-line pattern definitions" do
-    config "pattern" => [ "%{FIZZLE=\\d+}" ], "named_captures_only" => "false"
-
-    event = LogStash::Event.new
-    event.type = @typename
-
-    expect = "1234"
-    event.message = "hello #{expect}"
-
-    @filter.filter(event)
-    assert_equal(expect.class, event.fields["FIZZLE"].first.class,
-                 "Expected field 'FIZZLE' to be of type #{expect.class.name} " \
-                 "but got #{event.fields["FIZZLE"].first.class.name}")
-    assert_equal([expect], event.fields["FIZZLE"],
-                 "Expected field 'FIZZLE' to be [#{expect.inspect}], " \
-                 "is #{event.fields["FIZZLE"].inspect}")
-  end # test in-line definitions
-
-  test "processing fields other than the @message" do
-    config "rum" => [ "%{FIZZLE=\\d+}" ], "named_captures_only" => "false"
-
-    event = LogStash::Event.new
-    event.type = @typename
-
-    expect = "1234"
-    event.fields["rum"] = "hello #{expect}"
-
-    @filter.filter(event)
-    assert_equal(expect.class, event.fields["FIZZLE"].first.class,
-                 "Expected field 'FIZZLE' to be of type #{expect.class.name}, " \
-                 "but got #{event.fields["FIZZLE"].first.class.name}")
-    assert_equal([expect], event.fields["FIZZLE"],
-                 "Expected field 'FIZZLE' to be [#{expect.inspect}], " \
-                 "is #{event.fields["FIZZLE"].inspect}")
-  end # test processing custom fields
-
-  test "parsing custom fields and default @message" do
-    config "rum" => [ "%{FIZZLE=\\d+}" ], "pattern" => "%{WORD}",
-      "break_on_match" => "false", "named_captures_only" => "false"
-
-    event = LogStash::Event.new
-    event.type = @typename
-
-    expect = "1234"
-    event.fields["rum"] = "hello #{expect}"
-    event.message = "something fizzle"
-
-    @filter.filter(event)
-    assert_equal(expect.class, event.fields["FIZZLE"].first.class,
-                 "Expected field 'FIZZLE' to be of type #{expect.class.name} " \
-                 "but got #{event.fields["FIZZLE"].first.class.name}")
-    assert_equal([expect], event.fields["FIZZLE"],
-                 "Expected field 'FIZZLE' to be [#{expect.inspect}], is " \
-                 "#{event.fields["FIZZLE"].inspect}")
-    assert_equal(["something"], event.fields["WORD"],
-                 "Expected field 'WORD' to be ['something'], is " \
-                 "#{event.fields["WORD"].inspect}")
-  end # def test_grok_field_name_attribute
-
-  test "adding fields on match" do
-    config "str" => "test",
-           "add_field" => ["new_field", "new_value"]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "test"
-    @filter.filter(event)
-    assert_equal(["new_value"], event["new_field"])
-  end # adding fields on match
-
-  test "should not add fields if match fails" do
-    config "str" => "test",
-           "add_field" => ["new_field", "new_value"]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["str"] = "fizzle"
-    @filter.filter(event)
-    assert_equal(nil, event["new_field"],
-                "Grok should not add fields on failed matches")
-  end # should not add fields if match fails
-
-  test "drop empty fields by default" do
-    config "pattern" => "1=%{WORD:foo1} *(2=%{WORD:foo2})?"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event.message = "1=test"
-    @filter.filter(event)
-    assert_equal(["test"], event["foo1"])
-    assert_equal(nil, event["foo2"])
-  end
-
-  test "keep empty fields" do
-    config "pattern" => "1=%{WORD:foo1} *(2=%{WORD:foo2})?",
-           "keep_empty_captures" => "true"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event.message = "1=test"
-    @filter.filter(event)
-    assert_equal(["test"], event["foo1"])
-    assert_equal([], event["foo2"])
-  end
-
-  test "named_captures_only set to false" do
-    config "pattern" => "Hello %{WORD}. %{WORD:foo}", "named_captures_only" => "false"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event.message = "Hello World, yo!"
-    @filter.filter(event)
-    assert(event.fields.include?("WORD"),
-           "The event must have the 'WORD' field")
-    assert(event.fields.include?("foo"),
-           "The event must have the 'foo' field")
-    assert_equal("World", event.fields["WORD"].first)
-    assert_equal("yo", event.fields["foo"].first)
-  end
 end # tests for LogStash::Filters::Grok
diff --git a/test/logstash/filters/test_json.rb b/test/logstash/filters/test_json.rb
deleted file mode 100644
index c68c32d1990..00000000000
--- a/test/logstash/filters/test_json.rb
+++ /dev/null
@@ -1,67 +0,0 @@
-require "rubygems"
-require File.join(File.dirname(__FILE__), "..", "minitest")
-
-require "logstash/loadlibs"
-require "logstash"
-require "logstash/filters"
-require "logstash/filters/json"
-require "logstash/event"
-
-describe LogStash::Filters::Json do
-  before do
-    @filter = LogStash::Filters.from_name("json", {})
-    @typename = "json"
-  end
-
-  def config(cfg)
-    cfg["type"] = @typename
-    cfg.each_key do |key|
-      if cfg[key].is_a?(String)
-        cfg[key] = [cfg[key]]
-      end
-    end
-
-    @filter = LogStash::Filters::Json.new(cfg)
-    @filter.register
-  end # def config
-
-  test "parse standard json" do
-    config "raw" => "data"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = '{"key": "value"}'
-    @filter.filter(event)
-    assert_equal(event["data"], {"key" => "value"})
-  end # parse standard json
-
-  test "parse json with array as a value" do
-    config "raw" => "data"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = '{"key": ["value1", "value2"]}'
-    @filter.filter(event)
-    assert_equal(event["data"], {"key" => ["value1", "value2"]})
-  end # parse json with array as a value
-
-  test "parse json with hash as a value" do
-    config "raw" => "data"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = '{"key1": {"key2": "value"}}'
-    @filter.filter(event)
-    assert_equal(event["data"], {"key1" => {"key2" => "value"}})
-  end # parse json with array as a value
-
-  test "bad json" do
-    config "raw" => "data"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = '{"key1": {"key2", "value"}'
-    @filter.filter(event)
-    assert_equal(event.tags, ["_jsonparsefailure"])
-  end # bad json
-end # Test 'json' filter
diff --git a/test/logstash/filters/test_mutate.rb b/test/logstash/filters/test_mutate.rb
deleted file mode 100644
index 6170740ee27..00000000000
--- a/test/logstash/filters/test_mutate.rb
+++ /dev/null
@@ -1,209 +0,0 @@
-require "rubygems"
-require File.join(File.dirname(__FILE__), "..", "minitest")
-
-require "logstash/loadlibs"
-require "logstash"
-require "logstash/filters"
-require "logstash/filters/mutate"
-require "logstash/event"
-
-describe LogStash::Filters::Mutate do
-  before do
-    @filter = LogStash::Filters.from_name("mutate", {})
-    @typename = "mutator"
-  end
-
-  def config(cfg)
-    cfg["type"] = @typename
-    cfg.each_key do |key|
-      if cfg[key].is_a?(String)
-        cfg[key] = [cfg[key]]
-      end
-    end
-
-    @filter = LogStash::Filters::Mutate.new(cfg)
-    @filter.register
-  end # def config
-
-  test "replace field value with plain string" do
-    config "replace" => [ "foo", "bar" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["foo"] = "this will be replaced"
-    @filter.filter(event)
-    assert_equal(event["foo"], "bar")
-  end # replace field value with plain string
-
-  test "replace field value with sprintf string" do
-    config "replace" => [ "foo", "hello %{world}" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["world"] = "earth"
-    event["foo"] = "this will be replaced"
-    @filter.filter(event)
-    assert_equal(event["foo"], "hello earth")
-  end # replace field value with sprintf string
-
-  test "remove field" do
-    config "remove" => [ "remove-me" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["remove-me"] = "Goodbye!"
-    event["foo"] = "Hello."
-    @filter.filter(event)
-    assert_equal(event["foo"], "Hello.")
-    assert(!event.include?("remove-me"),
-           "The 'remove-me' field should have been removed, it was not.")
-  end # replace field value with sprintf string
-
-  test "remove multiple fields " do
-    config "remove" => [ "remove-me", "remove-me2", "diedie" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["remove-me"] = "Goodbye!"
-    event["remove-me2"] = 1234
-    event["diedie"] = [1,2,3,4]
-    event["foo"] = "Hello."
-    @filter.filter(event)
-    assert_equal(event["foo"], "Hello.")
-    assert(!event.include?("remove-me"),
-           "The 'remove-me' field should have been removed, it was not.")
-    assert(!event.include?("remove-me2"),
-           "The 'remove-me2' field should have been removed, it was not.")
-    assert(!event.include?("diedie"),
-           "The 'diedie' field should have been removed, it was not.")
-  end # remove multiple fields
-
-  test "rename one field" do
-    config "rename" => [ "oldname", "newname" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["oldname"] = "whoa"
-    event["foo"] = "Hello."
-
-    @filter.filter(event)
-    assert_equal(event["foo"], "Hello.")
-
-    assert(!event.include?("oldname"),
-           "The 'oldname' field should have been removed, it was not.")
-    assert_equal(event["newname"], "whoa",
-                 "The 'newname' field was not renamed properly?")
-  end # rename one field
-
-  test "convert one field to integer" do
-    config "convert" => [ "foo", "integer" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["foo"] = "1234"
-
-    @filter.filter(event)
-    assert_equal(1234, event["foo"],
-                 "Field 'foo' should now be an integer (1234), but is " \
-                 " a #{event["foo"].class.inspect} (#{event["foo"].inspect})")
-  end # convert one field
-
-  test "convert one field to string" do
-    config "convert" => [ "foo", "string" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["foo"] = 1234
-
-    @filter.filter(event)
-    assert_equal("1234", event["foo"],
-                 "Field 'foo' should now be a string ('1234'), but is " \
-                 " a #{event["foo"].class.inspect} (#{event["foo"].inspect})")
-  end # convert one field
-
-  test "convert one field to float" do
-    config "convert" => [ "foo", "float" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["foo"] = "1234.10"
-
-    @filter.filter(event)
-    assert_equal(1234.10, event["foo"],
-                 "Field 'foo' should now be an float (1234.10), but is " \
-                 " a #{event["foo"].class.inspect} (#{event["foo"].inspect})")
-  end # convert one field
-
-  test "gsub on a String" do
-    config "gsub" => ["test", "foo", "bar"]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["test"] = "test foo test"
-
-    @filter.filter(event)
-    assert_equal("test bar test", event["test"])
-  end
-
-  test "gsub on an Array of Strings" do
-    config "gsub" => ["test", "foo", "bar"]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["test"] = ["test foo test", "test2 foo test2"]
-
-    @filter.filter(event)
-    assert_equal(["test bar test", "test2 bar test2"], event["test"])
-  end
-
-  test "gsub on an Array of non-Strings" do
-    config "gsub" => ["test", "foo", "bar"]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    test_data = [{"foo" => "test foo test"}]
-    event["test"] = test_data
-
-    @filter.filter(event)
-    assert_equal(test_data, event["test"])
-  end
-
-  test "gsub on multiple fields" do
-    config "gsub" => ["test", "foo", "bar",
-                      "test2", "foo", "bar",
-                     ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["test"] = "test foo test"
-    event["test2"] = "test2 foo test2"
-
-    @filter.filter(event)
-    assert_equal("test bar test", event["test"])
-    assert_equal("test2 bar test2", event["test2"])
-  end
-
-  test "uppercase"  do
-    config "uppercase" => [ "test", "test2" ]
-    event = LogStash::Event.new
-    event.type = @typename
-    event["test"] = [ "test foo test" ]
-    event["test2"] = "test2 foo test2"
-
-    @filter.filter(event)
-    assert_equal(event["test"].collect(&:upcase), event["test"])
-    assert_equal(event["test2"].upcase, event["test2"])
-  end
-
-  test "lowercase"  do
-    config "lowercase" => [ "test", "test2" ]
-    event = LogStash::Event.new
-    event.type = @typename
-    event["test"] = [ "TEST FOO TEST" ]
-    event["test2"] = "TEST2 FOO TEST2"
-
-    @filter.filter(event)
-    assert_equal(event["test"].collect(&:downcase), event["test"])
-    assert_equal(event["test2"].downcase, event["test2"])
-  end
-end # Test 'mutate' filter
diff --git a/test/logstash/filters/test_xml.rb b/test/logstash/filters/test_xml.rb
deleted file mode 100644
index aba2b2faedb..00000000000
--- a/test/logstash/filters/test_xml.rb
+++ /dev/null
@@ -1,103 +0,0 @@
-require "rubygems"
-require File.join(File.dirname(__FILE__), "..", "minitest")
-
-require "logstash/loadlibs"
-require "logstash"
-require "logstash/filters"
-require "logstash/filters/xml"
-require "logstash/event"
-
-describe LogStash::Filters::Xml do
-  before do
-    @filter = LogStash::Filters.from_name("xml", {})
-    @typename = "xml"
-  end
-
-  def config(cfg)
-    cfg["type"] = @typename
-    cfg.each_key do |key|
-      if cfg[key].is_a?(String)
-        cfg[key] = [cfg[key]]
-      end
-    end
-
-    @filter = LogStash::Filters::Xml.new(cfg)
-    @filter.register
-  end # def config
-
-  test "parse standard xml" do
-    config "raw" => "data"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = '<foo key="value"/>'
-    @filter.filter(event)
-    assert_equal(event["data"], {"key" => "value"})
-  end # parse standard xml
-
-  test "parse xml but do not store" do
-    config "raw" => "data",
-           "store_xml" => "false"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = '<foo key="value"/>'
-    @filter.filter(event)
-    assert_equal(event["data"], nil)
-  end # parse xml but do not store
-
-  test "parse xml with array as a value" do
-    config "raw" => "data"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = '<foo><key>value1</key><key>value2</key></foo>'
-    @filter.filter(event)
-    assert_equal(event["data"], {"key" => ["value1", "value2"]})
-  end # parse xml with array as a value
-
-  test "parse xml with hash as a value" do
-    config "raw" => "data"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = '<foo><key1><key2>value</key2></key1></foo>'
-    @filter.filter(event)
-    assert_equal(event["data"], {"key1" => [{"key2" => ["value"]}]})
-  end # parse xml with array as a value
-
-  test "bad xml" do
-    config "raw" => "data"
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = '<foo /'
-    @filter.filter(event)
-    assert_equal(event.tags, ["_xmlparsefailure"])
-  end # bad xml
-
-  test "parse xml and store single value with xpath" do
-    config "raw" => "data",
-           "xpath" => [ "/foo/key/text()", "xpath_field" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = '<foo><key>value</key></foo>'
-    @filter.filter(event)
-    assert_equal(event["xpath_field"].length, 1)
-    assert_equal(event["xpath_field"], ["value"])
-  end # parse xml and store single value with xpath
-
-  test "parse xml and store mulitple values with xpath" do
-    config "raw" => "data",
-           "xpath" => [ "/foo/key/text()", "xpath_field" ]
-
-    event = LogStash::Event.new
-    event.type = @typename
-    event["raw"] = '<foo><key>value1</key><key>value2</key></foo>'
-    @filter.filter(event)
-    assert_equal(event["xpath_field"].length, 2)
-    assert_equal(event["xpath_field"], ["value1","value2"])
-  end # parse xml and store mulitple values with xpath
-
-end # Test 'xml' filter
