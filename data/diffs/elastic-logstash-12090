diff --git a/logstash-core/lib/logstash/config/source/base.rb b/logstash-core/lib/logstash/config/source/base.rb
index 0db79bc474e..3f6a1213cbe 100644
--- a/logstash-core/lib/logstash/config/source/base.rb
+++ b/logstash-core/lib/logstash/config/source/base.rb
@@ -16,92 +16,10 @@
 # under the License.
 
 module LogStash module Config module Source
-  class Base
-    attr_reader :conflict_messages
-
-    def initialize(settings)
-      @settings = settings
-      @conflict_messages = []
-    end
-
-    def pipeline_configs
-      raise NotImplementedError, "`#pipeline_configs` must be implemented!"
-    end
-
-    def match?
-      raise NotImplementedError, "`match?` must be implemented!"
-    end
-
-    def config_conflict?
-      raise NotImplementedError, "`config_conflict?` must be implemented!"
-    end
-
-    def config_reload_automatic_setting
-      @settings.get_setting("config.reload.automatic")
-    end
-
-    def config_reload_automatic
-      config_reload_automatic_setting.value
-    end
-
-    def config_reload_automatic?
-      config_reload_automatic_setting.set?
-    end
-
-    def config_string_setting
-      @settings.get_setting("config.string")
-    end
-
-    def config_string
-      config_string_setting.value
-    end
-
-    def config_string?
-      !config_string.nil?
-    end
+  java_import org.logstash.config.source.Base
 
-    def config_path_setting
-      @settings.get_setting("path.config")
-    end
-
-    def config_path
-      config_path_setting.value
-    end
-
-    def config_path?
-      !(config_path.nil? || config_path.empty?)
-    end
-
-    def modules_cli_setting
-      @settings.get_setting("modules.cli")
-    end
-
-    def modules_cli
-      modules_cli_setting.value
-    end
-
-    def modules_cli?
-      !(modules_cli.nil? || modules_cli.empty?)
-    end
-
-    def modules_setting
-      @settings.get_setting("modules")
-    end
-
-    def modules
-      modules_setting.value
-    end
-
-    def modules?
-      !(modules.nil? || modules.empty?)
-    end
-
-    def both_module_configs?
-      modules_cli? && modules?
-    end
-
-    def modules_defined?
-      modules_cli? || modules?
-    end
+  class Base
+    field_accessor :conflictMessages => :conflict_messages
+    field_accessor :settings => :settings
   end
 end end end
diff --git a/logstash-core/lib/logstash/config/source/local.rb b/logstash-core/lib/logstash/config/source/local.rb
index e9601c2b5f5..6959f686122 100644
--- a/logstash-core/lib/logstash/config/source/local.rb
+++ b/logstash-core/lib/logstash/config/source/local.rb
@@ -31,114 +31,117 @@ module LogStash module Config module Source
   #  sorted alphabetically. Se `PipelineConfig` class for the sorting algorithm.
   #
   class Local < Base
-    class ConfigStringLoader
-      INPUT_BLOCK_RE = /input *{/
-      OUTPUT_BLOCK_RE = /output *{/
-      EMPTY_RE = /^\s*$/
-
-      def self.read(config_string)
-        config_parts = [org.logstash.common.SourceWithMetadata.new("string", "config_string", 0, 0, config_string)]
-
-        # Make sure we have an input and at least 1 output
-        # if its not the case we will add stdin and stdout
-        # this is for backward compatibility reason
-        if !INPUT_BLOCK_RE.match(config_string)
-          config_parts << org.logstash.common.SourceWithMetadata.new(self.class.name, "default input", 0, 0, LogStash::Config::Defaults.input)
-
-        end
-
-        # include a default stdout output if no outputs given
-        if !OUTPUT_BLOCK_RE.match(config_string)
-          config_parts << org.logstash.common.SourceWithMetadata.new(self.class.name, "default output", 0, 0, LogStash::Config::Defaults.output)
-        end
-
-        config_parts
-      end
-    end
-
-    class ConfigPathLoader
-      include LogStash::Util::Loggable
-
-      TEMPORARY_FILE_RE = /~$/
-      LOCAL_FILE_URI = /^file:\/\//i
-
-      def initialize(path)
-        @path = normalize_path(path)
-      end
-
-      def read
-        config_parts = []
-        encoding_issue_files = []
-
-        if logger.debug?
-          logger.debug("Skipping the following files while reading config since they don't match the specified glob pattern", :files => get_unmatched_files)
-        end
-
-        get_matched_files.each do |file|
-          next unless ::File.file?(file) or ::File.pipe?(file) # skip directory
-
-          logger.debug("Reading config file", :config_file => file)
-
-          if temporary_file?(file)
-            logger.warn("NOT reading config file because it is a temp file", :config_file => file)
-            next
-          end
-
-          config_string = ::File.read(file)
-          config_string.force_encoding("UTF-8")
-
-          if config_string.valid_encoding?
-            part = org.logstash.common.SourceWithMetadata.new("file", file, 0, 0, config_string)
-            config_parts << part
-          else
-            encoding_issue_files << file
-          end
-        end
-
-        if encoding_issue_files.any?
-          raise LogStash::ConfigLoadingError, "The following config files contains non-ascii characters but are not UTF-8 encoded #{encoding_issue_files}"
-        end
-
-        if config_parts.empty?
-          logger.info("No config files found in path", :path => path)
-        end
-
-        config_parts
-      end
-
-      def self.read(path)
-        ConfigPathLoader.new(path).read
-      end
-
-      private
-      def normalize_path(path)
-        path.gsub!(LOCAL_FILE_URI, "")
-        ::File.expand_path(path)
-      end
-
-      def get_matched_files
-        Dir.glob(path).sort
-      end
-
-      def path
-        if ::File.directory?(@path)
-          ::File.join(@path, "*")
-        else
-          @path
-        end
-      end
+#     class ConfigStringLoader
+#       INPUT_BLOCK_RE = /input *{/
+#       OUTPUT_BLOCK_RE = /output *{/
+#       EMPTY_RE = /^\s*$/
+#
+#       def self.read(config_string)
+#         config_parts = [org.logstash.common.SourceWithMetadata.new("string", "config_string", 0, 0, config_string)]
+#
+#         # Make sure we have an input and at least 1 output
+#         # if its not the case we will add stdin and stdout
+#         # this is for backward compatibility reason
+#         if !INPUT_BLOCK_RE.match(config_string)
+#           config_parts << org.logstash.common.SourceWithMetadata.new(self.class.name, "default input", 0, 0, LogStash::Config::Defaults.input)
+#
+#         end
+#
+#         # include a default stdout output if no outputs given
+#         if !OUTPUT_BLOCK_RE.match(config_string)
+#           config_parts << org.logstash.common.SourceWithMetadata.new(self.class.name, "default output", 0, 0, LogStash::Config::Defaults.output)
+#         end
+#
+#         config_parts
+#       end
+#     end
+    java_import org.logstash.config.source.ConfigStringLoader
 
-      def get_unmatched_files
-        # transform "/var/lib/*.conf" => /var/lib/*
-        t = ::File.split(@path)
-        all_files = Dir.glob(::File.join(t.first, "*")).sort
-        all_files - get_matched_files
-      end
+#     class ConfigPathLoader
+#       include LogStash::Util::Loggable
+#
+#       TEMPORARY_FILE_RE = /~$/
+#       LOCAL_FILE_URI = /^file:\/\//i
+#
+#       def initialize(path)
+#         @path = normalize_path(path)
+#       end
+#
+#       def read
+#         config_parts = []
+#         encoding_issue_files = []
+#
+#         if logger.debug?
+#           logger.debug("Skipping the following files while reading config since they don't match the specified glob pattern", :files => get_unmatched_files)
+#         end
+#
+#         get_matched_files.each do |file|
+#           next unless ::File.file?(file) or ::File.pipe?(file) # skip directory
+#
+#           logger.debug("Reading config file", :config_file => file)
+#
+#           if temporary_file?(file)
+#             logger.warn("NOT reading config file because it is a temp file", :config_file => file)
+#             next
+#           end
+#
+#           config_string = ::File.read(file)
+#           config_string.force_encoding("UTF-8")
+#
+#           if config_string.valid_encoding?
+#             part = org.logstash.common.SourceWithMetadata.new("file", file, 0, 0, config_string)
+#             config_parts << part
+#           else
+#             encoding_issue_files << file
+#           end
+#         end
+#
+#         if encoding_issue_files.any?
+#           raise LogStash::ConfigLoadingError, "The following config files contains non-ascii characters but are not UTF-8 encoded #{encoding_issue_files}"
+#         end
+#
+#         if config_parts.empty?
+#           logger.info("No config files found in path", :path => path)
+#         end
+#
+#         config_parts
+#       end
+#
+#       def self.read(path)
+#         ConfigPathLoader.new(path).read
+#       end
+#
+#       private
+#       def normalize_path(path)
+#         path.gsub!(LOCAL_FILE_URI, "")
+#         ::File.expand_path(path)
+#       end
+#
+#       def get_matched_files
+#         Dir.glob(path).sort
+#       end
+#
+#       def path
+#         if ::File.directory?(@path)
+#           ::File.join(@path, "*")
+#         else
+#           @path
+#         end
+#       end
+#
+#       def get_unmatched_files
+#         # transform "/var/lib/*.conf" => /var/lib/*
+#         t = ::File.split(@path)
+#         all_files = Dir.glob(::File.join(t.first, "*")).sort
+#         all_files - get_matched_files
+#       end
+#
+#       def temporary_file?(filepath)
+#         filepath.match(TEMPORARY_FILE_RE)
+#       end
+#     end
 
-      def temporary_file?(filepath)
-        filepath.match(TEMPORARY_FILE_RE)
-      end
-    end
+    java_import org.logstash.config.source.ConfigPathLoader
 
     class ConfigRemoteLoader
       def self.read(uri)
@@ -172,7 +175,7 @@ def self.read(uri)
 
     def pipeline_configs
       if config_conflict?
-        raise ConfigurationError, @conflict_messages.join(", ")
+        raise ConfigurationError, conflict_messages.join(", ")
       end
       local_pipeline_configs
     end
@@ -183,18 +186,18 @@ def match?
     end
 
     def config_conflict?
-      @conflict_messages.clear
+      conflict_messages.clear
 
       # Check if configuration auto-reload is used that -f is specified
       if automatic_reload_with_config_string?
-        @conflict_messages << I18n.t("logstash.runner.reload-with-config-string")
+        conflict_messages << I18n.t("logstash.runner.reload-with-config-string")
       end
       # Check if both -f and -e are present
       if config_string? && config_path?
-        @conflict_messages << I18n.t("logstash.runner.config-string-path-exclusive")
+        conflict_messages << I18n.t("logstash.runner.config-string-path-exclusive")
       end
 
-      @conflict_messages.any?
+      conflict_messages.any?
     end
 
     private
@@ -212,7 +215,7 @@ def local_pipeline_configs
 
       return [] if config_parts.empty?
 
-      [org.logstash.config.ir.PipelineConfig.new(self.class, @settings.get("pipeline.id").to_sym, config_parts, @settings)]
+      [org.logstash.config.ir.PipelineConfig.new(self.class, settings.get("pipeline.id").to_sym, config_parts, settings)]
     end
 
     def automatic_reload_with_config_string?
diff --git a/logstash-core/lib/logstash/config/source/modules.rb b/logstash-core/lib/logstash/config/source/modules.rb
index 47794465c54..392e32cda4e 100644
--- a/logstash-core/lib/logstash/config/source/modules.rb
+++ b/logstash-core/lib/logstash/config/source/modules.rb
@@ -23,10 +23,10 @@ class Modules < Base
     include LogStash::Util::Loggable
     def pipeline_configs
       if config_conflict? # double check
-        raise ConfigurationError, @conflict_messages.join(", ")
+        raise ConfigurationError, conflict_messages.join(", ")
       end
 
-      pipelines = LogStash::Config::ModulesCommon.pipeline_configs(@settings)
+      pipelines = LogStash::Config::ModulesCommon.pipeline_configs(settings)
       pipelines.map do |hash|
         org.logstash.config.ir.PipelineConfig.new(self.class, hash["pipeline_id"].to_sym,
           org.logstash.common.SourceWithMetadata.new("module", hash["alt_name"], 0, 0, hash["config_string"]),
@@ -40,7 +40,7 @@ def match?
     end
 
     def config_conflict?
-      @conflict_messages.clear
+      conflict_messages.clear
       # Make note that if modules are configured in both cli and logstash.yml that cli module
       # settings will overwrite the logstash.yml modules settings
       if modules_cli? && modules?
@@ -48,15 +48,15 @@ def config_conflict?
       end
 
       if automatic_reload_with_modules?
-        @conflict_messages << I18n.t("logstash.runner.reload-with-modules")
+        conflict_messages << I18n.t("logstash.runner.reload-with-modules")
       end
 
       # Check if config (-f or -e) and modules are configured
       if (modules_cli? || modules?) && (config_string? || config_path?)
-        @conflict_messages << I18n.t("logstash.runner.config-module-exclusive")
+        conflict_messages << I18n.t("logstash.runner.config-module-exclusive")
       end
 
-      @conflict_messages.any?
+      conflict_messages.any?
     end
 
     private
diff --git a/logstash-core/lib/logstash/config/source/multi_local.rb b/logstash-core/lib/logstash/config/source/multi_local.rb
index 39f72823463..d89b6544030 100644
--- a/logstash-core/lib/logstash/config/source/multi_local.rb
+++ b/logstash-core/lib/logstash/config/source/multi_local.rb
@@ -37,13 +37,13 @@ def pipeline_configs
       end
       detect_duplicate_pipelines(pipelines_settings)
       pipeline_configs = pipelines_settings.map do |pipeline_settings|
-        @settings = pipeline_settings
+        update_settings(pipeline_settings)
         # this relies on instance variable @settings and the parent class' pipeline_configs
         # method. The alternative is to refactor most of the Local source methods to accept
         # a settings object instead of relying on @settings.
         local_pipeline_configs # create a PipelineConfig object based on @settings
       end.flatten
-      @settings = @original_settings
+      settings = @original_settings
       pipeline_configs
     end
 
@@ -60,21 +60,21 @@ def invalid_pipelines_detected?
     end
 
     def config_conflict?
-      @conflict_messages.clear
+      conflict_messages.clear
       # are there any auto-reload conflicts?
       if !(modules_cli? || modules? || config_string? || config_path?)
         detect_pipelines if !@detect_pipelines_called
         if @detected_marker.nil?
-          @conflict_messages << I18n.t("logstash.runner.config-pipelines-failed-read", :path => pipelines_yaml_location)
+          conflict_messages << I18n.t("logstash.runner.config-pipelines-failed-read", :path => pipelines_yaml_location)
         elsif @detected_marker == false
-          @conflict_messages << I18n.t("logstash.runner.config-pipelines-empty", :path => pipelines_yaml_location)
+          conflict_messages << I18n.t("logstash.runner.config-pipelines-empty", :path => pipelines_yaml_location)
         elsif @detected_marker.is_a?(Class)
-          @conflict_messages << I18n.t("logstash.runner.config-pipelines-invalid", :invalid_class => @detected_marker, :path => pipelines_yaml_location)
+          conflict_messages << I18n.t("logstash.runner.config-pipelines-invalid", :invalid_class => @detected_marker, :path => pipelines_yaml_location)
         end
       else
         do_warning? && logger.warn("Ignoring the 'pipelines.yml' file because modules or command line options are specified")
       end
-      @conflict_messages.any?
+      conflict_messages.any?
     end
 
     def retrieve_yaml_pipelines
diff --git a/logstash-core/spec/logstash/config/source/local_spec.rb b/logstash-core/spec/logstash/config/source/local_spec.rb
index f44b35ab5a1..f2b1e2693bf 100644
--- a/logstash-core/spec/logstash/config/source/local_spec.rb
+++ b/logstash-core/spec/logstash/config/source/local_spec.rb
@@ -25,223 +25,223 @@
 require "spec_helper"
 require "webmock/rspec"
 
-describe LogStash::Config::Source::Local::ConfigStringLoader do
-  subject { described_class }
-  let(:config_string) { "input { generator {} } output { stdout {} }"}
-
-  it "returns one config_parts" do
-    expect(subject.read(config_string).size).to eq(1)
-  end
-
-  it "returns a valid config part" do
-    config_part = subject.read(config_string).first
-    expect(config_part).to be_a_source_with_metadata("string", "config_string", config_string)
-  end
-end
-
-describe LogStash::Config::Source::Local::ConfigPathLoader do
-  subject { described_class }
-
-  context "no configs" do
-    context "in the directory" do
-      let(:directory) do
-        p =  Stud::Temporary.pathname
-        FileUtils.mkdir_p(p)
-        p
-      end
-
-      it "returns an empty array" do
-        expect(subject.read(directory)).to be_empty
-      end
-    end
-
-    context "target file doesn't exist" do
-      let(:directory) do
-        p =  Stud::Temporary.pathname
-        FileUtils.mkdir_p(p)
-        ::File.join(p, "ls.conf")
-      end
-
-      it "returns an empty array" do
-        expect(subject.read(directory)).to be_empty
-      end
-    end
-  end
-
-  context "when it exist" do
-    shared_examples "read config from files" do
-      let(:directory) { Stud::Temporary.pathname }
-
-      before do
-        files.each do |file, content|
-          temporary_file(content, file, directory)
-        end
-
-        expect(files.size).to be >= 1
-        expect(Dir.glob(::File.join(directory, "*")).size).to eq(files.size)
-      end
-
-      it "returns a `config_parts` per file" do
-        expect(subject.read(reader_config).size).to eq(files.size)
-      end
-
-      it "returns alphabetically sorted parts" do
-        parts = subject.read(reader_config)
-        expect(parts.collect { |part| ::File.basename(part.id) }).to eq(files.keys.sort)
-      end
-
-      it "returns valid `config_parts`" do
-        parts = subject.read(reader_config)
-
-        parts.each do |part|
-          basename = ::File.basename(part.id)
-          file_path = ::File.expand_path(::File.join(directory, basename))
-          content = files[basename]
-          expect(part).to be_a_source_with_metadata("file", file_path, content)
-        end
-      end
-    end
-
-    context "when the files have invalid encoding" do
-      let(:config_string) { "\x80" }
-      let(:file_path) { Stud::Temporary.pathname }
-      let(:file) { ::File.join(file_path, "wrong_encoding.conf") }
-
-      before do
-        FileUtils.mkdir_p(file_path)
-        f = File.open(file, "wb") do |file|
-          file.write(config_string)
-        end
-      end
-
-      it "raises an exception" do
-        # check against base name because on Windows long paths are shrinked in the exception message
-        expect { subject.read(file_path) }.to raise_error LogStash::ConfigLoadingError, /.+#{::File.basename(file_path)}/
-      end
-    end
-
-    context "when we target one file" do
-      let(:reader_config) { ::File.join(directory, files.keys.first) }
-      let(:files) {
-        {
-          "config1.conf" => "input1",
-        }
-      }
-
-      include_examples "read config from files"
-    end
-
-    context "when we target a path with multiples files" do
-      let(:reader_config) { directory }
-
-      let(:files) {
-        {
-          "config1.conf" => "input1",
-          "config2.conf" => "input2",
-          "config3.conf" => "input3",
-          "config4.conf" => "input4"
-        }
-      }
-
-      include_examples "read config from files"
-    end
-
-    context "when there temporary files in the directory" do
-      let(:reader_config) { ::File.join(directory, "conf*.conf") }
-
-      let(:files) {
-        {
-          "config1.conf" => "input1",
-          "config2.conf" => "input2",
-          "config3.conf" => "input3",
-          "config4.conf" => "input4"
-        }
-      }
-
-      let(:other_files) do
-        {
-          "config1.conf~" => "input1",
-          "config2.conf~" => "input2",
-          "config3.conf~" => "input3",
-          "config4.conf~" => "input4"
-        }
-      end
-
-      include_examples "read config from files" do
-        before do
-          other_files.keys.shuffle.each do |file|
-            content = files[file]
-            temporary_file(content, file, directory)
-          end
-
-          # make sure we actually do some filtering
-          expect(Dir.glob(::File.join(directory, "*")).size).to eq(other_files.size + files.size)
-        end
-      end
-    end
-
-    context "when the path is a wildcard" do
-      let(:reader_config) { ::File.join(directory, "conf*.conf") }
-
-      let(:files) {
-        {
-          "config1.conf" => "input1",
-          "config2.conf" => "input2",
-          "config3.conf" => "input3",
-          "config4.conf" => "input4"
-        }
-      }
-
-      let(:other_files) do
-        {
-          "bad1.conf" => "input1",
-          "bad2.conf" => "input2",
-          "bad3.conf" => "input3",
-          "bad4.conf" => "input4"
-        }
-      end
-
-      include_examples "read config from files" do
-        before do
-          other_files.keys.shuffle.each do |file|
-            content = files[file]
-            temporary_file(content, file, directory)
-          end
-
-          # make sure we actually do some filtering
-          expect(Dir.glob(::File.join(directory, "*")).size).to eq(other_files.size + files.size)
-        end
-      end
-    end
-
-    context "URI defined path (file://..)" do
-      let(:reader_config) { "file://#{::File.join(directory, files.keys.first)}" }
-      let(:files) {
-        {
-          "config1.conf" => "input1",
-        }
-      }
-
-      include_examples "read config from files"
-    end
-
-    context "relative path" do
-      let(:reader_config) do
-        FileUtils.mkdir_p(::File.join(directory, "inside"))
-        ::File.join(directory, "inside", "../")
-      end
-
-      let(:files) {
-        {
-          "config2.conf" => "input1",
-          "config1.conf" => "input2",
-        }
-      }
-
-      include_examples "read config from files"
-    end
-  end
-end
+# describe LogStash::Config::Source::Local::ConfigStringLoader do
+#   subject { described_class }
+#   let(:config_string) { "input { generator {} } output { stdout {} }"}
+#
+#   it "returns one config_parts" do
+#     expect(subject.read(config_string).size).to eq(1)
+#   end
+#
+#   it "returns a valid config part" do
+#     config_part = subject.read(config_string).first
+#     expect(config_part).to be_a_source_with_metadata("string", "config_string", config_string)
+#   end
+# end
+
+# describe LogStash::Config::Source::Local::ConfigPathLoader do
+#   subject { described_class }
+#
+#   context "no configs" do
+#     context "in the directory" do
+#       let(:directory) do
+#         p =  Stud::Temporary.pathname
+#         FileUtils.mkdir_p(p)
+#         p
+#       end
+#
+#       it "returns an empty array" do
+#         expect(subject.read(directory)).to be_empty
+#       end
+#     end
+#
+#     context "target file doesn't exist" do
+#       let(:directory) do
+#         p =  Stud::Temporary.pathname
+#         FileUtils.mkdir_p(p)
+#         ::File.join(p, "ls.conf")
+#       end
+#
+#       it "returns an empty array" do
+#         expect(subject.read(directory)).to be_empty
+#       end
+#     end
+#   end
+#
+#   context "when it exist" do
+#     shared_examples "read config from files" do
+#       let(:directory) { Stud::Temporary.pathname }
+#
+#       before do
+#         files.each do |file, content|
+#           temporary_file(content, file, directory)
+#         end
+#
+#         expect(files.size).to be >= 1
+#         expect(Dir.glob(::File.join(directory, "*")).size).to eq(files.size)
+#       end
+#
+#       it "returns a `config_parts` per file" do
+#         expect(subject.read(reader_config).size).to eq(files.size)
+#       end
+#
+#       it "returns alphabetically sorted parts" do
+#         parts = subject.read(reader_config)
+#         expect(parts.collect { |part| ::File.basename(part.id) }).to eq(files.keys.sort)
+#       end
+#
+#       it "returns valid `config_parts`" do
+#         parts = subject.read(reader_config)
+#
+#         parts.each do |part|
+#           basename = ::File.basename(part.id)
+#           file_path = ::File.expand_path(::File.join(directory, basename))
+#           content = files[basename]
+#           expect(part).to be_a_source_with_metadata("file", file_path, content)
+#         end
+#       end
+#     end
+#
+#     context "when the files have invalid encoding" do
+#       let(:config_string) { "\x80" }
+#       let(:file_path) { Stud::Temporary.pathname }
+#       let(:file) { ::File.join(file_path, "wrong_encoding.conf") }
+#
+#       before do
+#         FileUtils.mkdir_p(file_path)
+#         f = File.open(file, "wb") do |file|
+#           file.write(config_string)
+#         end
+#       end
+#
+#       it "raises an exception" do
+#         # check against base name because on Windows long paths are shrinked in the exception message
+#         expect { subject.read(file_path) }.to raise_error Java.OrgLogstashConfigSource.ConfigLoadingException, /.+#{::File.basename(file_path)}/
+#       end
+#     end
+#
+#     context "when we target one file" do
+#       let(:reader_config) { ::File.join(directory, files.keys.first) }
+#       let(:files) {
+#         {
+#           "config1.conf" => "input1",
+#         }
+#       }
+#
+#       include_examples "read config from files"
+#     end
+#
+#     context "when we target a path with multiples files" do
+#       let(:reader_config) { directory }
+#
+#       let(:files) {
+#         {
+#           "config1.conf" => "input1",
+#           "config2.conf" => "input2",
+#           "config3.conf" => "input3",
+#           "config4.conf" => "input4"
+#         }
+#       }
+#
+#       include_examples "read config from files"
+#     end
+#
+#     context "when there temporary files in the directory" do
+#       let(:reader_config) { ::File.join(directory, "conf*.conf") }
+#
+#       let(:files) {
+#         {
+#           "config1.conf" => "input1",
+#           "config2.conf" => "input2",
+#           "config3.conf" => "input3",
+#           "config4.conf" => "input4"
+#         }
+#       }
+#
+#       let(:other_files) do
+#         {
+#           "config1.conf~" => "input1",
+#           "config2.conf~" => "input2",
+#           "config3.conf~" => "input3",
+#           "config4.conf~" => "input4"
+#         }
+#       end
+#
+#       include_examples "read config from files" do
+#         before do
+#           other_files.keys.shuffle.each do |file|
+#             content = files[file]
+#             temporary_file(content, file, directory)
+#           end
+#
+#           # make sure we actually do some filtering
+#           expect(Dir.glob(::File.join(directory, "*")).size).to eq(other_files.size + files.size)
+#         end
+#       end
+#     end
+#
+#     context "when the path is a wildcard" do
+#       let(:reader_config) { ::File.join(directory, "conf*.conf") }
+#
+#       let(:files) {
+#         {
+#           "config1.conf" => "input1",
+#           "config2.conf" => "input2",
+#           "config3.conf" => "input3",
+#           "config4.conf" => "input4"
+#         }
+#       }
+#
+#       let(:other_files) do
+#         {
+#           "bad1.conf" => "input1",
+#           "bad2.conf" => "input2",
+#           "bad3.conf" => "input3",
+#           "bad4.conf" => "input4"
+#         }
+#       end
+#
+#       include_examples "read config from files" do
+#         before do
+#           other_files.keys.shuffle.each do |file|
+#             content = files[file]
+#             temporary_file(content, file, directory)
+#           end
+#
+#           # make sure we actually do some filtering
+#           expect(Dir.glob(::File.join(directory, "*")).size).to eq(other_files.size + files.size)
+#         end
+#       end
+#     end
+#
+#     context "URI defined path (file://..)" do
+#       let(:reader_config) { "file://#{::File.join(directory, files.keys.first)}" }
+#       let(:files) {
+#         {
+#           "config1.conf" => "input1",
+#         }
+#       }
+#
+#       include_examples "read config from files"
+#     end
+#
+#     context "relative path" do
+#       let(:reader_config) do
+#         FileUtils.mkdir_p(::File.join(directory, "inside"))
+#         ::File.join(directory, "inside", "../")
+#       end
+#
+#       let(:files) {
+#         {
+#           "config2.conf" => "input1",
+#           "config1.conf" => "input2",
+#         }
+#       }
+#
+#       include_examples "read config from files"
+#     end
+#   end
+# end
 
 describe LogStash::Config::Source::Local::ConfigRemoteLoader do
   before :all do
diff --git a/logstash-core/spec/logstash/config/source_loader_spec.rb b/logstash-core/spec/logstash/config/source_loader_spec.rb
index 87d812d9f02..ea041c48848 100644
--- a/logstash-core/spec/logstash/config/source_loader_spec.rb
+++ b/logstash-core/spec/logstash/config/source_loader_spec.rb
@@ -30,7 +30,7 @@ def pipeline_configs
   end
 
   def match?
-    @settings.get("path.config") =~ /dummy/
+    settings.get("path.config") =~ /dummy/
   end
 end
 
@@ -40,7 +40,7 @@ def pipeline_configs
   end
 
   def match?
-    @settings.get("path.config") =~ /another/
+    settings.get("path.config") =~ /another/
   end
 end
 
@@ -50,7 +50,7 @@ def pipeline_configs
   end
 
   def match?
-    @settings.get("path.config") =~ /fail/
+    settings.get("path.config") =~ /fail/
   end
 end
 
diff --git a/logstash-core/src/main/java/org/logstash/config/Defaults.java b/logstash-core/src/main/java/org/logstash/config/Defaults.java
new file mode 100644
index 00000000000..273965627e3
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/Defaults.java
@@ -0,0 +1,16 @@
+package org.logstash.config;
+
+public final class Defaults {
+
+    public static String input() {
+        return "input { stdin { type => stdin } }";
+    }
+
+    public static String output() {
+        return "output { stdout { codec => rubydebug } }";
+    }
+
+    public static int cpuCores() {
+        return Runtime.getRuntime().availableProcessors();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/source/Base.java b/logstash-core/src/main/java/org/logstash/config/source/Base.java
new file mode 100644
index 00000000000..6e73f9518de
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/source/Base.java
@@ -0,0 +1,145 @@
+/*
+ * Licensed to Elasticsearch B.V. under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch B.V. licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.logstash.config.source;
+
+import org.jruby.RubyArray;
+import org.jruby.RubyObject;
+import org.jruby.RubyString;
+import org.jruby.runtime.builtin.IRubyObject;
+import org.logstash.config.ir.PipelineConfig;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.logstash.RubyUtil.RUBY;
+
+public class Base {
+    protected RubyObject settings;
+    protected List<String> conflictMessages = new ArrayList<>();
+
+    public Base(RubyObject logstashSettings) {
+        settings = logstashSettings;
+    }
+
+    public List<String> getConflictMessages() {
+        return conflictMessages;
+    }
+
+    // this must be used when in Ruby code was @settings = <new value>
+    public void updateSettings(RubyObject settings) {
+        this.settings = settings;
+    }
+
+    public List<PipelineConfig> pipelineConfigs() {
+        throw new UnsupportedOperationException("`pipelineConfigs` must be implemented!");
+    }
+
+    public boolean isMatch() {
+        throw new UnsupportedOperationException("`isMatch` must be implemented!");
+    }
+
+    public boolean isConfigConflict() {
+        throw new UnsupportedOperationException("`isConfigConflict` must be implemented!");
+    }
+
+    //return subclass of LogStash::Setting
+    public IRubyObject configReloadAutomaticSetting() {
+        return this.settings.callMethod(RUBY.getCurrentContext(), "get_setting",
+                RubyString.newString(RUBY, "config.reload.automatic"));
+    }
+
+    public boolean configReloadAutomatic() {
+        final IRubyObject value = configReloadAutomaticSetting().callMethod(RUBY.getCurrentContext(), "value");
+        return value.toJava(Boolean.class);
+    }
+
+    public boolean isConfigReloadAutomatic() {
+        final IRubyObject valueIsSet = configReloadAutomaticSetting().callMethod(RUBY.getCurrentContext(), "set?");
+        return valueIsSet.toJava(Boolean.class);
+    }
+
+    //return subclass of LogStash::Setting
+    public IRubyObject configStringSetting() {
+        return this.settings.callMethod(RUBY.getCurrentContext(), "get_setting",
+                RubyString.newString(RUBY, "config.string"));
+    }
+
+    public String configString() {
+        final IRubyObject setting = configStringSetting();
+        final IRubyObject value = setting.callMethod(RUBY.getCurrentContext(), "value");
+        return value.toJava(String.class);
+    }
+
+    public boolean isConfigString() {
+        return configString() != null;
+    }
+
+    // return subclass of LogStash::Setting
+    public IRubyObject configPathSetting() {
+        return this.settings.callMethod(RUBY.getCurrentContext(), "get_setting",
+                RubyString.newString(RUBY, "path.config"));
+    }
+
+    public String configPath() {
+        return configPathSetting().callMethod(RUBY.getCurrentContext(), "value").toJava(String.class);
+    }
+
+    public boolean isConfigPath() {
+        return !(configPath() == null || configPath().isEmpty());
+    }
+
+    // return subclass of LogStash::Setting
+    public IRubyObject modulesCliSetting() {
+        return this.settings.callMethod(RUBY.getCurrentContext(), "get_setting",
+                RubyString.newString(RUBY, "modules.cli"));
+    }
+
+    @SuppressWarnings("rawtypes")
+    public RubyArray modulesCli() {
+        return modulesCliSetting().callMethod(RUBY.getCurrentContext(), "value").convertToArray();
+    }
+
+    public boolean isModulesCli() {
+        return !(modulesCli() == null || modulesCli().isEmpty());
+    }
+
+    // return subclass of LogStash::Setting
+    public IRubyObject modulesSetting() {
+        return this.settings.callMethod(RUBY.getCurrentContext(), "get_setting",
+                RubyString.newString(RUBY, "modules"));
+    }
+
+    @SuppressWarnings("rawtypes")
+    public RubyArray modules() {
+        return (RubyArray) modulesSetting().callMethod(RUBY.getCurrentContext(), "value");
+    }
+
+    public boolean isModules() {
+        return !(modules() == null || modules().isEmpty());
+    }
+
+    public boolean isBothModuleConfigs() {
+        return isModulesCli() && isModules();
+    }
+
+    public boolean isModulesDefined() {
+        return isModulesCli() || isModules();
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/source/ConfigLoadingException.java b/logstash-core/src/main/java/org/logstash/config/source/ConfigLoadingException.java
new file mode 100644
index 00000000000..83b9924f671
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/source/ConfigLoadingException.java
@@ -0,0 +1,14 @@
+package org.logstash.config.source;
+
+public class ConfigLoadingException extends Exception {
+
+    private static final long serialVersionUID = 3043954726233024678L;
+
+    public ConfigLoadingException(String message) {
+        super(message);
+    }
+
+    public ConfigLoadingException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/source/ConfigPathLoader.java b/logstash-core/src/main/java/org/logstash/config/source/ConfigPathLoader.java
new file mode 100644
index 00000000000..090c2b44253
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/source/ConfigPathLoader.java
@@ -0,0 +1,115 @@
+package org.logstash.config.source;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.logstash.common.IncompleteSourceWithMetadataException;
+import org.logstash.common.SourceWithMetadata;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.charset.CharacterCodingException;
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.regex.Pattern;
+
+public class ConfigPathLoader {
+
+    private static final Logger logger = LogManager.getLogger(ConfigPathLoader.class);
+
+    private static Pattern LOCAL_FILE_URI = Pattern.compile("^file://", Pattern.CASE_INSENSITIVE);
+
+    private final Path path;
+
+    public static List<SourceWithMetadata> read(String path) throws IOException, ConfigLoadingException, IncompleteSourceWithMetadataException {
+        return new ConfigPathLoader(path).read();
+    }
+
+    public ConfigPathLoader(String path) {
+        this.path = normalizePath(path);
+    }
+
+    private Path normalizePath(String path) {
+        final String cleaned = LOCAL_FILE_URI.matcher(path).replaceAll("");
+        return Paths.get(cleaned);
+    }
+
+    public List<SourceWithMetadata> read() throws IOException, ConfigLoadingException, IncompleteSourceWithMetadataException {
+        if (logger.isDebugEnabled()) {
+            logger.debug("Skipping the following files while reading config since they don't match the specified glob pattern file: {}",
+                        getUnmatchedFiles());
+        }
+
+        final List<Path> encodingIssueFiles = new ArrayList<>();
+        final List<SourceWithMetadata> configParts = new ArrayList<>();
+        final List<Path> matchedFiles = getMatchedFiles();
+        for (Path file : matchedFiles) {
+            if (file.toFile().isDirectory()) {
+                continue;
+            }
+            logger.debug("Reading config file {}", file);
+            if (isTemporaryFile(file)) {
+                logger.warn("NOT reading config file because it is a temp file {}", file);
+                continue;
+            }
+            final byte[] rawContent = Files.readAllBytes(file);
+            if (verifyEncoding(rawContent, StandardCharsets.UTF_8))  {
+                final String configString = new String(rawContent, StandardCharsets.UTF_8);
+                SourceWithMetadata part = new SourceWithMetadata("file", file.toString(), 0, 0, configString);
+                configParts.add(part);
+            } else {
+                encodingIssueFiles.add(file);
+            }
+        }
+        if (!encodingIssueFiles.isEmpty()) {
+            throw new ConfigLoadingException("The following config files contains non-ascii characters but are not UTF-8 encoded " + encodingIssueFiles);
+        }
+        if (configParts.isEmpty()) {
+            logger.info("No config files found in path {}", path);
+        }
+        return configParts;
+    }
+
+    private boolean verifyEncoding(byte[] rawContent, Charset charset) {
+        CharsetDecoder decoder = charset.newDecoder();
+        try {
+            decoder.decode(ByteBuffer.wrap(rawContent));
+            return true;
+        } catch (CharacterCodingException ueex) {
+            return false;
+        }
+    }
+
+    private boolean isTemporaryFile(Path filepath) {
+        return filepath.getFileName().toString().endsWith("~");
+    }
+
+    private Path getPath() {
+        if (path.toFile().isDirectory()) {
+            return path.resolve("*");
+        }
+        return path;
+    }
+
+    private List<Path> getMatchedFiles() throws IOException {
+        List<Path> globMatchingPaths = GlobUtils.glob(getPath());
+        Collections.sort(globMatchingPaths);
+        return globMatchingPaths;
+    }
+
+    private List<Path> getUnmatchedFiles() throws IOException {
+//        transform "/var/lib/*.conf" => /var/lib/*
+        final Path t = path.subpath(0, path.getNameCount() - 1);
+        final List<Path> allFiles = GlobUtils.glob(t.resolve("*"));
+        Collections.sort(allFiles);
+        allFiles.removeAll(getMatchedFiles());
+        return allFiles;
+    }
+
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/source/ConfigStringLoader.java b/logstash-core/src/main/java/org/logstash/config/source/ConfigStringLoader.java
new file mode 100644
index 00000000000..873d3ce3f60
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/source/ConfigStringLoader.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to Elasticsearch B.V. under one or more contributor
+ * license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright
+ * ownership. Elasticsearch B.V. licenses this file to you under
+ * the Apache License, Version 2.0 (the "License"); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.logstash.config.source;
+
+import org.logstash.common.IncompleteSourceWithMetadataException;
+import org.logstash.common.SourceWithMetadata;
+import org.logstash.config.Defaults;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Pattern;
+
+public class ConfigStringLoader {
+
+    private static Pattern INPUT_BLOCK_RE = Pattern.compile("input\\s*\\{");
+    private static Pattern OUTPUT_BLOCK_RE = Pattern.compile("output\\s*\\{");
+    private static Pattern EMPTY_RE = Pattern.compile("^\\s*$");
+
+    public static List<SourceWithMetadata> read(String configString) throws IncompleteSourceWithMetadataException {
+        List<SourceWithMetadata> configParts = new ArrayList<>();
+        configParts.add(new SourceWithMetadata("string", "config_string", 0, 0, configString));
+
+//        Make sure we have an input and at least 1 output
+//        if its not the case we will add stdin and stdout
+//        this is for backward compatibility reason
+        if (!INPUT_BLOCK_RE.matcher(configString).find()) {
+            configParts.add(new SourceWithMetadata(ConfigStringLoader.class.getName(), "default input", 0, 0, Defaults.input()));
+        }
+//        include a default stdout output if no outputs given
+        if (!OUTPUT_BLOCK_RE.matcher(configString).find()) {
+            configParts.add(new SourceWithMetadata(ConfigStringLoader.class.getName(), "default output", 0, 0, Defaults.output()));
+        }
+        return configParts;
+    }
+}
diff --git a/logstash-core/src/main/java/org/logstash/config/source/GlobUtils.java b/logstash-core/src/main/java/org/logstash/config/source/GlobUtils.java
new file mode 100644
index 00000000000..192f54eb00f
--- /dev/null
+++ b/logstash-core/src/main/java/org/logstash/config/source/GlobUtils.java
@@ -0,0 +1,144 @@
+package org.logstash.config.source;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.io.IOException;
+import java.nio.file.FileSystemLoopException;
+import java.nio.file.FileSystems;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.PathMatcher;
+import java.nio.file.Paths;
+import java.nio.file.SimpleFileVisitor;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Optional;
+
+import static java.nio.file.FileVisitResult.CONTINUE;
+import static java.nio.file.FileVisitResult.TERMINATE;
+
+final class GlobUtils {
+
+    private static final Logger logger = LogManager.getLogger(GlobUtils.class);
+
+    static class BaseAndGlobPaths {
+        private Path basePart;
+        private Optional<Path> globPart = Optional.empty();
+
+        BaseAndGlobPaths(Path basePart, Path globPart) {
+            this.basePart = basePart;
+            this.globPart = Optional.of(globPart);
+        }
+
+        BaseAndGlobPaths(Path basePart) {
+            this.basePart = basePart;
+        }
+
+        void joinToBase(Path path) {
+            basePart = basePart.resolve(path);
+        }
+
+        void joinToGlob(Path path) {
+            if (globPart.isPresent()) {
+                globPart = Optional.of(globPart.get().resolve(path));
+            } else {
+                globPart = Optional.of(path);
+            }
+        }
+
+        public String globPattern() {
+            if (globPart.isPresent()) {
+                return "glob:" + base().toAbsolutePath().resolve(globPart.get()).toString();
+            } else {
+                return "glob:" + base().toAbsolutePath().toString();
+            }
+        }
+
+        public Path base() {
+            return basePart.normalize();
+        }
+
+        @Override
+        public String toString() {
+            return "BaseAndGlobPaths{" +
+                    "basePart=" + basePart +
+                    ", globPart=" + globPart +
+                    '}';
+        }
+    }
+
+    public static List<Path> glob(Path globPath) throws IOException {
+        BaseAndGlobPaths paths;
+        if (globPath.isAbsolute()) {
+            paths = splitBasePathAndGlobParts(globPath);
+        } else {
+            paths = new BaseAndGlobPaths(Paths.get(""), globPath); //current working dir
+        }
+        final PathMatcher pathMatcher = FileSystems.getDefault().getPathMatcher(paths.globPattern());
+
+        List<Path> globMatchingPaths = new ArrayList<>();
+        Files.walkFileTree(paths.base(), new SimpleFileVisitor<Path>() {
+            @Override
+            public FileVisitResult visitFile(Path file, BasicFileAttributes attr) {
+                if (pathMatcher.matches(file)) {
+                    globMatchingPaths.add(file);
+                }
+                return CONTINUE;
+            }
+
+            @Override
+            public FileVisitResult visitFileFailed(Path file, IOException ioex) {
+                if (ioex instanceof FileSystemLoopException) {
+                    logger.error("Cycle detected in symlinks for {}", file);
+                    return TERMINATE;
+                } else {
+                    logger.error("Error accessing file {}", file, ioex);
+                }
+                return CONTINUE;
+            }
+        });
+        return globMatchingPaths;
+    }
+
+    static BaseAndGlobPaths splitBasePathAndGlobParts(Path path) {
+        final BaseAndGlobPaths separated = new BaseAndGlobPaths(Paths.get("/"));
+        final Iterator<Path> iterator = path.iterator();
+        boolean globElementFound = false;
+        while (iterator.hasNext()) {
+            final Path pathElement = iterator.next();
+            if (!globElementFound) {
+                if (containsGlobPattern(pathElement)) {
+                    globElementFound = true;
+                    separated.joinToGlob(pathElement);
+                } else {
+                    separated.joinToBase(pathElement);
+                }
+            } else {
+                separated.joinToGlob(pathElement);
+            }
+        }
+
+        return separated;
+    }
+
+    private static final String globMetaChars = "\\*?[]{}-!";
+
+    private static boolean containsGlobPattern(Path path) {
+        final String str = path.toString();
+        for (int i = 0; i < str.length(); i++) {
+            if (globMetaChars.indexOf(str.charAt(i)) != -1) {
+                if (str.charAt(i) == '-') {
+                    // - is a glob pattern only if contained in squares
+                    return str.matches(".*\\[.+?-.+?\\]");
+                } else {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/source/ConfigPathLoaderTest.java b/logstash-core/src/test/java/org/logstash/config/source/ConfigPathLoaderTest.java
new file mode 100644
index 00000000000..b1ea1bbcadc
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/source/ConfigPathLoaderTest.java
@@ -0,0 +1,220 @@
+package org.logstash.config.source;
+
+import org.junit.Test;
+import org.logstash.common.IncompleteSourceWithMetadataException;
+import org.logstash.common.SourceWithMetadata;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import static org.junit.Assert.*;
+
+public class ConfigPathLoaderTest {
+
+    @Test //no configs in the directory
+    public void testNoConfigsInDirectory() throws IOException, ConfigLoadingException, IncompleteSourceWithMetadataException {
+        final Path tempDirectory = Files.createTempDirectory("studtmp-");
+
+        assertTrue("returns an empty array", ConfigPathLoader.read(tempDirectory.toString()).isEmpty());
+    }
+
+    @Test //no configs target file doesn't exist
+    public void testNoConfigsTargetFileDoesntExists() throws IOException, ConfigLoadingException, IncompleteSourceWithMetadataException {
+        final Path tempDirectory = Files.createTempDirectory("studtmp-");
+        final Path notExistingFilePath = tempDirectory.resolve("ls.conf");
+
+        assertTrue("returns an empty array", ConfigPathLoader.read(notExistingFilePath.toString()).isEmpty());
+    }
+
+    @Test //when it exist when the files have invalid encoding
+    public void testConfigExistsWithInvalidEncoding() throws IOException, IncompleteSourceWithMetadataException {
+        final Path tempDirectory = Files.createTempDirectory("studtmp-");
+        final Path file = tempDirectory.resolve("wrong_encoding.conf");
+        Files.write(file, new byte[]{(byte) 0x80});
+
+        //check against base name because on Windows long paths are shrinked in the exception message
+        try {
+            ConfigPathLoader.read(tempDirectory.toString());
+            fail("Must raise exception");
+        } catch (ConfigLoadingException ex) {
+            assertTrue("raises an exception", ex.getMessage().contains(tempDirectory.toString()));
+        }
+    }
+
+    static final class ConfigFileDefinition {
+        final String filename;
+        final String fileContent;
+
+        public ConfigFileDefinition(String filename, String fileContent) {
+            this.filename = filename;
+            this.fileContent = fileContent;
+        }
+
+        public String getFilename() {
+            return filename;
+        }
+
+        public String getFileContent() {
+            return fileContent;
+        }
+    }
+
+    @Test //when we target one file read config from files
+    public void testConfigInOneFile() throws IOException, ConfigLoadingException, IncompleteSourceWithMetadataException {
+        final Path tempDirectory = Files.createTempDirectory("studtmp-");
+
+        final ConfigFileDefinition configDefinition = new ConfigFileDefinition("config1.conf", "input1");
+        List<ConfigFileDefinition> files = Collections.singletonList(configDefinition);
+        Path readerConfig = tempDirectory.resolve(configDefinition.filename);
+
+        setupConfigFiles(tempDirectory, files);
+
+        verifyConfig(readerConfig, files, tempDirectory);
+    }
+
+    private void setupConfigFiles(Path tempDirectory, List<ConfigFileDefinition> files) throws IOException {
+        setupConfigFiles(tempDirectory, files, 0);
+    }
+
+    private void setupConfigFiles(Path tempDirectory, List<ConfigFileDefinition> files, int alreadyExistingFiles) throws IOException {
+        for (ConfigFileDefinition fileDef : files) {
+            final Path file = Files.createFile(tempDirectory.resolve(fileDef.filename));
+            Files.write(file, fileDef.fileContent.getBytes());
+        }
+        assertTrue(files.size() >= 1);
+        assertEquals(GlobUtils.glob(tempDirectory.resolve("*")).size(), files.size() + alreadyExistingFiles);
+    }
+
+    private void verifyConfig(Path readerConfig, List<ConfigFileDefinition> files, Path directory) throws ConfigLoadingException, IOException, IncompleteSourceWithMetadataException {
+        final String readerConfigStr = readerConfig.toString();
+
+        verifyConfig(readerConfigStr, files, directory);
+    }
+
+    private void verifyConfig(String readerConfig, List<ConfigFileDefinition> files, Path directory) throws IOException, ConfigLoadingException, IncompleteSourceWithMetadataException {
+        final List<SourceWithMetadata> parts = ConfigPathLoader.read(readerConfig);
+
+        assertEquals("returns a `config_parts` per file", files.size(), parts.size());
+
+        final List<String> partsNames = parts.stream()
+                .map(SourceWithMetadata::getId)
+                .map(id -> Paths.get(id))
+                .map(Path::getFileName)
+                .map(Path::toString)
+                .collect(Collectors.toList());
+        final List<String> filesNames = files.stream()
+                .map(ConfigFileDefinition::getFilename)
+                .sorted()
+                .collect(Collectors.toList());
+        assertEquals("returns alphabetically sorted parts", filesNames, partsNames);
+
+        for (SourceWithMetadata part : parts) {
+            final String basename = Paths.get(part.getId()).getFileName().toString();
+            final Path filePath = directory.resolve(basename).normalize();
+            final String fileContent = files.stream()
+                    .filter(f -> f.getFilename().equals(basename))
+                    .findFirst()
+                    .get()
+                    .getFileContent();
+            assertThat("returns valid `config_parts`", part, MatcherUtils.beSourceWithMetadata("file", filePath.toString(), fileContent));
+        }
+    }
+
+    @Test // when we target a path with multiples files
+    public void testConfigFromMultipleFiles() throws IOException, ConfigLoadingException, IncompleteSourceWithMetadataException {
+        final Path tempDirectory = Files.createTempDirectory("studtmp-");
+
+        List<ConfigFileDefinition> files = Arrays.asList(
+                new ConfigFileDefinition("config1.conf", "input1"),
+                new ConfigFileDefinition("config2.conf", "input2"),
+                new ConfigFileDefinition("config3.conf", "input3"),
+                new ConfigFileDefinition("config4.conf", "input4")
+        );
+        Path readerConfig = tempDirectory;
+
+        setupConfigFiles(tempDirectory, files);
+
+        verifyConfig(readerConfig, files, tempDirectory);
+    }
+
+    @Test // when there temporary files in the directory
+    public void testConfigMixedWithTemporaryFiles() throws IOException, ConfigLoadingException, IncompleteSourceWithMetadataException {
+        final Path tempDirectory = Files.createTempDirectory("studtmp-");
+
+        List<ConfigFileDefinition> files = Arrays.asList(
+                new ConfigFileDefinition("config1.conf", "input1"),
+                new ConfigFileDefinition("config2.conf", "input2"),
+                new ConfigFileDefinition("config3.conf", "input3"),
+                new ConfigFileDefinition("config4.conf", "input4")
+        );
+        setupConfigFiles(tempDirectory, files);
+
+        List<ConfigFileDefinition> otherFiles = Arrays.asList(
+                new ConfigFileDefinition("config1.conf~", "input1"),
+                new ConfigFileDefinition("config2.conf~", "input2"),
+                new ConfigFileDefinition("config3.conf~", "input3"),
+                new ConfigFileDefinition("config4.conf~", "input4")
+        );
+        setupConfigFiles(tempDirectory, otherFiles, files.size());
+
+        Path readerConfig = tempDirectory;
+        verifyConfig(readerConfig, files, tempDirectory);
+    }
+
+    @Test //when the path is a wildcard
+    public void testConfigWithWildcardPath() throws IOException, ConfigLoadingException, IncompleteSourceWithMetadataException {
+        final Path tempDirectory = Files.createTempDirectory("studtmp-");
+
+        List<ConfigFileDefinition> files = Arrays.asList(
+                new ConfigFileDefinition("config1.conf", "input1"),
+                new ConfigFileDefinition("config2.conf", "input2"),
+                new ConfigFileDefinition("config3.conf", "input3"),
+                new ConfigFileDefinition("config4.conf", "input4")
+        );
+        setupConfigFiles(tempDirectory, files);
+
+        List<ConfigFileDefinition> otherFiles = Arrays.asList(
+                new ConfigFileDefinition("bad1.conf", "input1"),
+                new ConfigFileDefinition("bad2.conf", "input2"),
+                new ConfigFileDefinition("bad3.conf", "input3"),
+                new ConfigFileDefinition("bad4.conf", "input4")
+        );
+        setupConfigFiles(tempDirectory, otherFiles, files.size());
+
+        Path readerConfig = tempDirectory.resolve("conf*.conf");
+        verifyConfig(readerConfig, files, tempDirectory);
+    }
+
+    @Test //URI defined path (file://..)
+    public void testConfigWithURLdefinedPath() throws IOException, ConfigLoadingException, IncompleteSourceWithMetadataException {
+        final Path tempDirectory = Files.createTempDirectory("studtmp-");
+
+        List<ConfigFileDefinition> files = Collections.singletonList(
+                new ConfigFileDefinition("config1.conf", "input1")
+        );
+        setupConfigFiles(tempDirectory, files);
+
+        String readerConfig = "file://"+ tempDirectory.resolve("config1.conf").toString();
+        verifyConfig(readerConfig, files, tempDirectory);
+    }
+
+    @Test //relative path
+    public void testConfigWithRelativePath() throws IOException, ConfigLoadingException, IncompleteSourceWithMetadataException {
+        final Path tempDirectory = Files.createTempDirectory("studtmp-");
+        Files.createDirectory(tempDirectory.resolve("inside"));
+
+        List<ConfigFileDefinition> files = Arrays.asList(
+                new ConfigFileDefinition("config2.conf", "input1"),
+                new ConfigFileDefinition("config1.conf", "input2")
+        );
+        setupConfigFiles(tempDirectory, files);
+        Path readerConfig = tempDirectory.resolve("inside").resolve("../");
+        verifyConfig(readerConfig, files, tempDirectory);
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/config/source/ConfigStringLoaderTest.java b/logstash-core/src/test/java/org/logstash/config/source/ConfigStringLoaderTest.java
new file mode 100644
index 00000000000..eb764de51e9
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/source/ConfigStringLoaderTest.java
@@ -0,0 +1,25 @@
+package org.logstash.config.source;
+
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.hamcrest.TypeSafeMatcher;
+import org.junit.Test;
+import org.logstash.common.IncompleteSourceWithMetadataException;
+import org.logstash.common.SourceWithMetadata;
+
+import java.util.List;
+
+import static org.junit.Assert.*;
+
+public class ConfigStringLoaderTest {
+
+    @Test
+    public void testRead() throws IncompleteSourceWithMetadataException {
+        String configString = "input { generator {} } output { stdout {} }";
+
+        final List<SourceWithMetadata> sut = ConfigStringLoader.read(configString);
+
+        assertEquals("returns one config_parts", 1, sut.size());
+        assertThat("returns a valid config part", sut.iterator().next(), MatcherUtils.beSourceWithMetadata("string", "config_string", configString));
+    }
+}
diff --git a/logstash-core/src/test/java/org/logstash/config/source/GlobUtilsTest.java b/logstash-core/src/test/java/org/logstash/config/source/GlobUtilsTest.java
new file mode 100644
index 00000000000..8e83c1a41bb
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/source/GlobUtilsTest.java
@@ -0,0 +1,30 @@
+package org.logstash.config.source;
+
+import org.junit.Test;
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+import static org.junit.Assert.*;
+
+public class GlobUtilsTest {
+
+    @Test
+    public void testSplitBaseAndGlobForAbsolutePlainPath() {
+        final Path path = Paths.get("/tmp/sub/test.conf");
+
+        final GlobUtils.BaseAndGlobPaths res = GlobUtils.splitBasePathAndGlobParts(path);
+
+        assertEquals("/tmp/sub/test.conf", res.base().toString());
+        assertEquals("glob:" + path.toString(), res.globPattern());
+    }
+
+    @Test
+    public void testSplitOnAbsoluteDirectoryPath() {
+        final Path path = Paths.get("/tmp/test-123/");
+
+        final GlobUtils.BaseAndGlobPaths res = GlobUtils.splitBasePathAndGlobParts(path);
+
+        assertEquals("/tmp/test-123", res.base().toString());
+    }
+}
\ No newline at end of file
diff --git a/logstash-core/src/test/java/org/logstash/config/source/MatcherUtils.java b/logstash-core/src/test/java/org/logstash/config/source/MatcherUtils.java
new file mode 100644
index 00000000000..4be8f37d38b
--- /dev/null
+++ b/logstash-core/src/test/java/org/logstash/config/source/MatcherUtils.java
@@ -0,0 +1,48 @@
+package org.logstash.config.source;
+
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.hamcrest.TypeSafeMatcher;
+import org.logstash.common.SourceWithMetadata;
+
+class MatcherUtils {
+
+    public static Matcher<SourceWithMetadata> beSourceWithMetadata(String protocol, String id, String text) {
+        return new SourceWithMetadataMatcher(protocol, id, text);
+    }
+
+    private static class SourceWithMetadataMatcher extends TypeSafeMatcher<SourceWithMetadata> {
+        private final String protocol;
+        private final String id;
+        private final String text;
+
+        public SourceWithMetadataMatcher(String protocol, String id) {
+            this(protocol, id, null);
+        }
+
+        public SourceWithMetadataMatcher(String protocol, String id, String text) {
+            this.protocol = protocol;
+            this.id = id;
+            this.text = text;
+        }
+
+        @Override
+        protected boolean matchesSafely(SourceWithMetadata swm) {
+            if (!protocol.equals(swm.getProtocol())) {
+                return false;
+            }
+            if (!id.equals(swm.getId())) {
+                return false;
+            }
+            if (text != null) {
+                return text.equals(swm.getText());
+            }
+            return true;
+        }
+
+        @Override
+        public void describeTo(Description description) {
+
+        }
+    }
+}
diff --git a/x-pack/lib/config_management/elasticsearch_source.rb b/x-pack/lib/config_management/elasticsearch_source.rb
index 9e04121fce5..289a6f6ac5c 100644
--- a/x-pack/lib/config_management/elasticsearch_source.rb
+++ b/x-pack/lib/config_management/elasticsearch_source.rb
@@ -43,7 +43,7 @@ def initialize(settings)
       end
 
       def match?
-        @settings.get("xpack.management.enabled")
+        settings.get("xpack.management.enabled")
       end
 
       def config_conflict?
@@ -96,7 +96,7 @@ def get_pipeline(response)
         config_part = org.logstash.common.SourceWithMetadata.new("x-pack-config-management", pipeline_id.to_s, config_string)
 
         # We don't support multiple pipelines, so use the global settings from the logstash.yml file
-        settings = @settings.clone
+        update_settings(settings.clone)
         settings.set("pipeline.id", pipeline_id)
 
         # override global settings with pipeline settings from ES, if any
@@ -186,7 +186,7 @@ def populate_license_state(xpack_info)
 
       private
       def pipeline_ids
-        @settings.get("xpack.management.pipeline.id")
+        settings.get("xpack.management.pipeline.id")
       end
 
       def client
