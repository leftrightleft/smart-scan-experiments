diff --git a/lib/pluginmanager/list.rb b/lib/pluginmanager/list.rb
index 65f28c31cc0..90c900d9d76 100644
--- a/lib/pluginmanager/list.rb
+++ b/lib/pluginmanager/list.rb
@@ -9,7 +9,7 @@ class LogStash::PluginManager::List < LogStash::PluginManager::Command
   option "--installed", :flag, "List only explicitly installed plugins using bin/logstash-plugin install ...", :default => false
   option "--verbose", :flag, "Also show plugin version number", :default => false
   option "--group", "NAME", "Filter plugins per group: input, output, filter or codec" do |arg|
-    raise(ArgumentError, "should be one of: input, output, filter or codec") unless ['input', 'output', 'filter', 'codec'].include?(arg)
+    raise(ArgumentError, "should be one of: input, output, filter or codec") unless ['input', 'output', 'filter', 'codec', 'pack'].include?(arg)
     arg
   end
 
diff --git a/logstash-core-event-java/lib/logstash-core-event-java_jars.rb b/logstash-core-event-java/lib/logstash-core-event-java_jars.rb
index 068f1826201..b7a36ce2937 100644
--- a/logstash-core-event-java/lib/logstash-core-event-java_jars.rb
+++ b/logstash-core-event-java/lib/logstash-core-event-java_jars.rb
@@ -1,20 +1,9 @@
 # this is a generated file, to avoid over-writing it just delete this comment
-begin
-  require 'jar_dependencies'
-rescue LoadError
-  require 'com/fasterxml/jackson/core/jackson-databind/2.7.3/jackson-databind-2.7.3.jar'
-  require 'org/apache/logging/log4j/log4j-api/2.6.2/log4j-api-2.6.2.jar'
-  require 'com/fasterxml/jackson/core/jackson-annotations/2.7.0/jackson-annotations-2.7.0.jar'
-  require 'com/fasterxml/jackson/module/jackson-module-afterburner/2.7.3/jackson-module-afterburner-2.7.3.jar'
-  require 'com/fasterxml/jackson/dataformat/jackson-dataformat-cbor/2.7.3/jackson-dataformat-cbor-2.7.3.jar'
-  require 'com/fasterxml/jackson/core/jackson-core/2.7.3/jackson-core-2.7.3.jar'
-end
+require 'jar_dependencies'
 
-if defined? Jars
-  require_jar( 'com.fasterxml.jackson.core', 'jackson-databind', '2.7.3' )
-  require_jar( 'org.apache.logging.log4j', 'log4j-api', '2.6.2' )
-  require_jar( 'com.fasterxml.jackson.core', 'jackson-annotations', '2.7.0' )
-  require_jar( 'com.fasterxml.jackson.module', 'jackson-module-afterburner', '2.7.3' )
-  require_jar( 'com.fasterxml.jackson.dataformat', 'jackson-dataformat-cbor', '2.7.3' )
-  require_jar( 'com.fasterxml.jackson.core', 'jackson-core', '2.7.3' )
-end
+require_jar( 'com.fasterxml.jackson.core', 'jackson-annotations', '2.7.0' )
+require_jar( 'com.fasterxml.jackson.core', 'jackson-databind', '2.7.3' )
+require_jar( 'org.apache.logging.log4j', 'log4j-api', '2.6.2' )
+require_jar( 'com.fasterxml.jackson.module', 'jackson-module-afterburner', '2.7.3' )
+require_jar( 'com.fasterxml.jackson.dataformat', 'jackson-dataformat-cbor', '2.7.3' )
+require_jar( 'com.fasterxml.jackson.core', 'jackson-core', '2.7.3' )
diff --git a/logstash-core/lib/logstash/agent.rb b/logstash-core/lib/logstash/agent.rb
index 4f2537b3fbd..a56cec9ee13 100644
--- a/logstash-core/lib/logstash/agent.rb
+++ b/logstash-core/lib/logstash/agent.rb
@@ -9,6 +9,7 @@
 require "logstash/instrument/metric"
 require "logstash/pipeline"
 require "logstash/webserver"
+require "logstash/event_dispatcher"
 require "stud/trap"
 require "logstash/config/loader"
 require "uri"
@@ -21,7 +22,7 @@ class LogStash::Agent
   include LogStash::Util::Loggable
   STARTED_AT = Time.now.freeze
 
-  attr_reader :metric, :name, :pipelines, :settings, :webserver
+  attr_reader :metric, :name, :pipelines, :settings, :webserver, :dispatcher
   attr_accessor :logger
 
   # initialize method for LogStash::Agent
@@ -52,6 +53,10 @@ def initialize(settings = LogStash::SETTINGS)
     configure_metrics_collectors
 
     @reload_metric = metric.namespace([:stats, :pipelines])
+
+    @dispatcher = LogStash::EventDispatcher.new(self)
+    LogStash::PLUGIN_REGISTRY.hooks.register_emitter(self.class, dispatcher)
+    dispatcher.fire(:after_initialize)
   end
 
   def execute
diff --git a/logstash-core/lib/logstash/config/file.rb b/logstash-core/lib/logstash/config/file.rb
index b0be8d0e81c..6b5ae954675 100644
--- a/logstash-core/lib/logstash/config/file.rb
+++ b/logstash-core/lib/logstash/config/file.rb
@@ -2,7 +2,6 @@
 require "logstash/namespace"
 require "logstash/config/grammar"
 require "logstash/config/config_ast"
-require "logstash/config/registry"
 require "logstash/errors"
 require "logger"
 
diff --git a/logstash-core/lib/logstash/config/mixin.rb b/logstash-core/lib/logstash/config/mixin.rb
index 70ad888c74c..09cbd7a019f 100644
--- a/logstash-core/lib/logstash/config/mixin.rb
+++ b/logstash-core/lib/logstash/config/mixin.rb
@@ -1,6 +1,5 @@
 # encoding: utf-8
 require "logstash/namespace"
-require "logstash/config/registry"
 require "logstash/plugins/registry"
 require "logstash/logging"
 require "logstash/util/password"
@@ -73,6 +72,7 @@ def config_init(params)
                      "in the future. #{extra} If you have any questions " +
                      "about this, please visit the #logstash channel " +
                      "on freenode irc.", :name => name, :plugin => self)
+
       end
       if opts && opts[:obsolete]
         extra = opts[:obsolete].is_a?(String) ? opts[:obsolete] : ""
@@ -181,11 +181,7 @@ module DSL
     # If no name given (nil), return the current name.
     def config_name(name = nil)
       @config_name = name if !name.nil?
-      LogStash::Config::Registry.registry[@config_name] = self
-      if self.respond_to?("plugin_type")
-        declare_plugin(self.plugin_type, @config_name)
-      end
-      return @config_name
+      @config_name
     end
     alias_method :config_plugin, :config_name
 
diff --git a/logstash-core/lib/logstash/config/registry.rb b/logstash-core/lib/logstash/config/registry.rb
deleted file mode 100644
index 8463716cf06..00000000000
--- a/logstash-core/lib/logstash/config/registry.rb
+++ /dev/null
@@ -1,13 +0,0 @@
-# encoding: utf-8
-require "logstash/namespace"
-
-# Global config registry.
-module LogStash::Config::Registry
-  @registry = Hash.new
-  class << self
-    attr_accessor :registry
-
-    # TODO(sissel): Add some helper methods here.
-  end
-end # module LogStash::Config::Registry
-  
diff --git a/logstash-core/lib/logstash/event_dispatcher.rb b/logstash-core/lib/logstash/event_dispatcher.rb
new file mode 100644
index 00000000000..34b92311ca5
--- /dev/null
+++ b/logstash-core/lib/logstash/event_dispatcher.rb
@@ -0,0 +1,40 @@
+# encoding: utf-8
+module LogStash
+  class EventDispatcher
+    java_import "java.util.concurrent.CopyOnWriteArrayList"
+
+    attr_reader :emitter
+
+    def initialize(emitter)
+      @emitter = emitter
+      @listeners = CopyOnWriteArrayList.new
+    end
+
+    # This operation is slow because we use a CopyOnWriteArrayList
+    # But the majority of the addition will be done at bootstrap time
+    # So add_listener shouldn't be called often at runtime.
+    #
+    # On the other hand the notification could be called really often.
+    def add_listener(listener)
+      @listeners.add(listener)
+    end
+
+    # This operation is slow because we use a `CopyOnWriteArrayList` as the backend, instead of a
+    # ConcurrentHashMap, but since we are mostly adding stuff and iterating the `CopyOnWriteArrayList`
+    # should provide a better performance.
+    #
+    # See note on add_listener, this method shouldn't be called really often.
+    def remove_listener(listener)
+      @listeners.remove(listener)
+    end
+
+    def fire(method_name, *arguments)
+      @listeners.each do |listener|
+        if listener.respond_to?(method_name)
+          listener.send(method_name, emitter, *arguments)
+        end
+      end
+    end
+    alias_method :execute, :fire
+  end
+end
diff --git a/logstash-core/lib/logstash/plugin.rb b/logstash-core/lib/logstash/plugin.rb
index 9d43f02c9e9..83dd76a2a79 100644
--- a/logstash-core/lib/logstash/plugin.rb
+++ b/logstash-core/lib/logstash/plugin.rb
@@ -5,7 +5,6 @@
 require "logstash/instrument/null_metric"
 require "concurrent"
 require "securerandom"
-require "logstash/plugins/registry"
 
 class LogStash::Plugin
   include LogStash::Util::Loggable
@@ -39,7 +38,6 @@ def hash
     self.class.name.hash
   end
 
-
   def eql?(other)
     self.class.name == other.class.name && @params == other.params
   end
@@ -120,50 +118,12 @@ def config_name
     self.class.config_name
   end
 
-
-  # Look up a plugin by type and name.
+  # This is keep for backward compatibility, the logic was moved into the registry class
+  # but some plugins use this method to return a specific instance on lookup
+  #
+  # Should I remove this now and make sure the pipeline invoke the Registry or I should wait for 6.0
+  # Its not really part of the public api but its used by the tests a lot to mock the plugins.
   def self.lookup(type, name)
-    path = "logstash/#{type}s/#{name}"
-    LogStash::Registry.instance.lookup(type ,name) do |plugin_klass, plugin_name|
-      is_a_plugin?(plugin_klass, plugin_name)
-    end
-    
-  rescue LoadError, NameError => e
-    logger.debug("Problems loading the plugin with", :type => type, :name => name, :path => path)
-    raise(LogStash::PluginLoadingError, I18n.t("logstash.pipeline.plugin-loading-error", :type => type, :name => name, :path => path, :error => e.to_s))
-  end
-
-  public
-  def self.declare_plugin(type, name)
-    path = "logstash/#{type}s/#{name}"
-    registry = LogStash::Registry.instance
-    registry.register(path, self)
-  end
-
-  private
-  # lookup a plugin by type and name in the existing LogStash module namespace
-  # ex.: namespace_lookup("filter", "grok") looks for LogStash::Filters::Grok
-  # @param type [String] plugin type, "input", "ouput", "filter"
-  # @param name [String] plugin name, ex.: "grok"
-  # @return [Class] the plugin class or raises NameError
-  # @raise NameError if plugin class does not exist or is invalid
-  def self.namespace_lookup(type, name)
-    type_const = "#{type.capitalize}s"
-    namespace = LogStash.const_get(type_const)
-    # the namespace can contain constants which are not for plugins classes (do not respond to :config_name)
-    # namespace.constants is the shallow collection of all constants symbols in namespace
-    # note that below namespace.const_get(c) should never result in a NameError since c is from the constants collection
-    klass_sym = namespace.constants.find { |c| is_a_plugin?(namespace.const_get(c), name) }
-    klass = klass_sym && namespace.const_get(klass_sym)
-    raise(NameError) unless klass
-    klass
-  end
-
-  # check if klass is a valid plugin for name
-  # @param klass [Class] plugin class
-  # @param name [String] plugin name
-  # @return [Boolean] true if klass is a valid plugin for name
-  def self.is_a_plugin?(klass, name)
-    klass.ancestors.include?(LogStash::Plugin) && klass.respond_to?(:config_name) && klass.config_name == name
+    LogStash::PLUGIN_REGISTRY.lookup_pipeline_plugin(type, name)
   end
 end # class LogStash::Plugin
diff --git a/logstash-core/lib/logstash/plugins/hooks_registry.rb b/logstash-core/lib/logstash/plugins/hooks_registry.rb
new file mode 100644
index 00000000000..1d917225669
--- /dev/null
+++ b/logstash-core/lib/logstash/plugins/hooks_registry.rb
@@ -0,0 +1,57 @@
+# encoding: utf-8
+module LogStash module Plugins
+  # This calls allow logstash to expose the endpoints for listeners
+  class HooksRegistry
+    java_import "java.util.concurrent.ConcurrentHashMap"
+    java_import "java.util.concurrent.CopyOnWriteArrayList"
+
+    def initialize
+      @registered_emmitters = ConcurrentHashMap.new
+      @registered_hooks = ConcurrentHashMap.new
+    end
+
+    def register_emitter(emitter_scope, dispatcher)
+      @registered_emmitters.put(emitter_scope, dispatcher)
+      sync_hooks
+    end
+
+    def remove_emitter(emitter_scope)
+      @registered_emmitters.remove(emitter_scope)
+    end
+
+    def register_hooks(emitter_scope, callback)
+      callbacks = @registered_hooks.computeIfAbsent(emitter_scope) do
+        CopyOnWriteArrayList.new
+      end
+
+      callbacks.add(callback)
+      sync_hooks
+    end
+
+    def emmitters_count
+      @registered_emmitters.size
+    end
+
+    def hooks_count(emitter_scope = nil)
+      if emitter_scope.nil?
+        @registered_hooks.elements().collect(&:size).reduce(0, :+)
+      else
+        callbacks = @registered_hooks.get(emitter_scope)
+        callbacks.nil? ? 0 : @registered_hooks.get(emitter_scope).size
+      end
+    end
+
+    private
+    def sync_hooks
+      @registered_emmitters.each do |emitter, dispatcher|
+        listeners = @registered_hooks.get(emitter)
+
+        unless listeners.nil?
+          listeners.each do |listener|
+            dispatcher.add_listener(listener)
+          end
+        end
+      end
+    end
+  end
+end end
diff --git a/logstash-core/lib/logstash/plugins/registry.rb b/logstash-core/lib/logstash/plugins/registry.rb
index cab0181f764..4b98068098c 100644
--- a/logstash-core/lib/logstash/plugins/registry.rb
+++ b/logstash-core/lib/logstash/plugins/registry.rb
@@ -1,86 +1,248 @@
 # encoding: utf-8
-require 'singleton'
 require "rubygems/package"
 require "logstash/util/loggable"
+require "logstash/plugin"
+require "logstash/plugins/hooks_registry"
 
-module LogStash
+module LogStash module Plugins
   class Registry
     include LogStash::Util::Loggable
 
-    ##
-    # Placeholder class for registered plugins
-    ##
-    class Plugin
-      attr_reader :type, :name
+    # Add a bit more sanity with when interacting with the rubygems'
+    # specifications database, most of out code interact directly with really low level
+    # components of bundler/rubygems we need to encapsulate that and this is a start.
+    class GemRegistry
+      LOGSTASH_METADATA_KEY = "logstash_plugin"
 
-      def initialize(type, name)
-        @type  = type
-        @name  = name
+      class << self
+        def installed_gems
+          ::Gem::Specification
+        end
+
+        def logstash_plugins
+          installed_gems
+            .select { |spec| spec.metadata && spec.metadata[LOGSTASH_METADATA_KEY] }
+            .collect { |spec| PluginRawContext.new(spec) }
+        end
+      end
+    end
+
+    class PluginRawContext
+      HOOK_FILE = "logstash_registry.rb"
+      NAME_DELIMITER = "-"
+
+      attr_reader :spec
+
+      def initialize(spec)
+        @spec = spec
+        @destructured_name = spec.name.split(NAME_DELIMITER)
+      end
+
+      def name
+        @destructured_name[2..-1].join(NAME_DELIMITER)
+      end
+
+      def type
+        @destructured_name[1]
       end
 
-      def path
-        "logstash/#{type}s/#{name}"
+      # In the context of the plugin, the hook file available  need to exist in any top level
+      # required paths.
+      #
+      # Example for the logstash-output-elasticsearch we have this line in the gemspec.
+      #
+      # s.require_paths = ["lib"], so the we will expect to have a `logstash_registry.rb` file in the `lib`
+      # directory.
+      def hooks_file
+        @hook_file ||= spec.full_require_paths.collect do |path|
+          f = ::File.join(path, HOOK_FILE)
+          ::File.exist?(f) ? f : nil
+        end.compact.first
       end
 
-      def cannonic_gem_name
-        "logstash-#{type}-#{name}"
+      def has_hooks?
+        !hooks_file.nil?
       end
 
-      def installed?
-        find_plugin_spec(cannonic_gem_name).any?
+      def execute_hooks!
+        require hooks_file
       end
+    end
 
-      private
+    class PluginSpecification
+      attr_reader :type, :name, :klass
 
-      def find_plugin_spec(name)
-        specs = ::Gem::Specification.find_all_by_name(name)
-        specs.select{|spec| logstash_plugin_spec?(spec)}
+      def initialize(type, name, klass)
+        @type  = type.to_sym
+        @name  = name
+        @klass = klass
       end
+    end
 
-      def logstash_plugin_spec?(spec)
-        spec.metadata && spec.metadata["logstash_plugin"] == "true"
+    class UniversalPluginSpecification < PluginSpecification
+      def initialize(type, name, klass)
+        super(type, name, klass)
+        @instance = klass.new
       end
 
+      def register(hooks, settings)
+        @instance.register_hooks(hooks)
+        @instance.additionals_settings(settings)
+      end
     end
 
-    include Singleton
+    attr_reader :hooks
 
     def initialize
       @registry = {}
-      @logger = self.logger
+      @hooks = HooksRegistry.new
+    end
+
+    def setup!
+      load_available_plugins
+      execute_universal_plugins
+    end
+
+    def execute_universal_plugins
+      @registry.values
+        .select { |specification| specification.is_a?(UniversalPluginSpecification) }
+        .each { |specification| specification.register(hooks, LogStash::SETTINGS) }
+    end
+
+    def load_available_plugins
+      GemRegistry.logstash_plugins.each do |plugin_context|
+        # When a plugin has a HOOK_FILE defined, its the responsability of the plugin
+        # to register itself to the registry of available plugins.
+        #
+        # Legacy plugin will lazy register themselves
+        if plugin_context.has_hooks?
+          begin
+            logger.debug("Executing hooks", :name => plugin_context.name, :type => plugin_context.type, :hooks_file => plugin_context.hooks_file)
+            plugin_context.execute_hooks!
+          rescue => e
+            logger.error("error occured when loading plugins hooks file", :name => plugin_context.name, :type => plugin_context.type, :exception => e.message, :stacktrace => e.backtrace )
+          end
+        end
+      end
     end
 
     def lookup(type, plugin_name, &block)
+      plugin = get(type, plugin_name)
+      # Assume that we have a legacy plugin
+      if plugin.nil?
+        plugin = legacy_lookup(type, plugin_name)
+      end
 
-      plugin = Plugin.new(type, plugin_name)
+      if block_given? # if provided pass a block to do validation
+        raise LoadError, "Block validation fails for plugin named #{plugin_name} of type #{type}," unless block.call(plugin.klass, plugin_name)
+      end
+
+      return plugin.klass
+    end
 
-      if plugin.installed?
-        return @registry[plugin.path] if registered?(plugin.path)
-        require plugin.path
-        klass = @registry[plugin.path]
-        if block_given? # if provided pass a block to do validation
-          raise LoadError unless block.call(klass, plugin_name)
+    # The legacy_lookup method uses the 1.5->5.0 file structure to find and match
+    # a plugin and will do a lookup on the namespace of the required class to find a matching
+    # plugin with the appropriate type.
+    def legacy_lookup(type, plugin_name)
+      begin
+        path = "logstash/#{type}s/#{plugin_name}"
+
+        begin
+          require path
+        rescue LoadError
+          # Plugin might be already defined in the current scope
+          # This scenario often happen in test when we write an adhoc class
         end
-        return klass
-      else
-        # The plugin was defined directly in the code, so there is no need to use the
-        # require way of loading classes
-        return @registry[plugin.path] if registered?(plugin.path)
-        raise LoadError
+
+        klass = namespace_lookup(type, plugin_name)
+        plugin = lazy_add(type, plugin_name, klass)
+      rescue => e
+        logger.error("Problems loading a plugin with",
+                    :type => type,
+                    :name => plugin_name,
+                    :path => path,
+                    :error_message => e.message,
+                    :error_class => e.class,
+                    :error_backtrace => e.backtrace)
+
+        raise LoadError, "Problems loading the requested plugin named #{plugin_name} of type #{type}. Error: #{e.class} #{e.message}"
       end
-    rescue => e
-      @logger.warn("Problems loading a plugin with", :type => type, :name => plugin, :path => plugin.path,
-                   :error_message => e.message, :error_class => e.class, :error_backtrace => e.backtrace)
-      raise LoadError, "Problems loading the requested plugin named #{plugin_name} of type #{type}. Error: #{e.class} #{e.message}"
+
+      plugin
+    end
+
+    def lookup_pipeline_plugin(type, name)
+      LogStash::PLUGIN_REGISTRY.lookup(type, name) do |plugin_klass, plugin_name|
+        is_a_plugin?(plugin_klass, plugin_name)
+      end
+    rescue LoadError, NameError => e
+      logger.debug("Problems loading the plugin with", :type => type, :name => name)
+      raise(LogStash::PluginLoadingError, I18n.t("logstash.pipeline.plugin-loading-error", :type => type, :name => name, :error => e.to_s))
+    end
+
+    def lazy_add(type, name, klass)
+      logger.debug("On demand adding plugin to the registry", :name => name, :type => type, :class => klass)
+      add_plugin(type, name, klass)
+    end
+
+    def add(type, name, klass)
+      logger.debug("Adding plugin to the registry", :name => name, :type => type, :class => klass)
+      add_plugin(type, name, klass)
     end
 
-    def register(path, klass)
-      @registry[path] = klass
+    def get(type, plugin_name)
+      @registry[key_for(type, plugin_name)]
+    end
+
+    def exists?(type, name)
+      @registry.include?(key_for(type, name))
+    end
+
+    def size
+      @registry.size
+    end
+
+    private
+    # lookup a plugin by type and name in the existing LogStash module namespace
+    # ex.: namespace_lookup("filter", "grok") looks for LogStash::Filters::Grok
+    # @param type [String] plugin type, "input", "ouput", "filter"
+    # @param name [String] plugin name, ex.: "grok"
+    # @return [Class] the plugin class or raises NameError
+    # @raise NameError if plugin class does not exist or is invalid
+    def namespace_lookup(type, name)
+      type_const = "#{type.capitalize}s"
+      namespace = LogStash.const_get(type_const)
+      # the namespace can contain constants which are not for plugins classes (do not respond to :config_name)
+      # namespace.constants is the shallow collection of all constants symbols in namespace
+      # note that below namespace.const_get(c) should never result in a NameError since c is from the constants collection
+      klass_sym = namespace.constants.find { |c| is_a_plugin?(namespace.const_get(c), name) }
+      klass = klass_sym && namespace.const_get(klass_sym)
+
+      raise(NameError) unless klass
+      klass
+    end
+
+    # check if klass is a valid plugin for name
+    # @param klass [Class] plugin class
+    # @param name [String] plugin name
+    # @return [Boolean] true if klass is a valid plugin for name
+    def is_a_plugin?(klass, name)
+      klass.ancestors.include?(LogStash::Plugin) && klass.respond_to?(:config_name) && klass.config_name == name
+    end
+
+    def add_plugin(type, name, klass)
+      if !exists?(type, name)
+        specification_klass = type == :universal ? UniversalPluginSpecification : PluginSpecification
+        @registry[key_for(type, name)] = specification_klass.new(type, name, klass)
+      else
+        logger.debug("Ignoring, plugin already added to the registry", :name => name, :type => type, :klass => klass)
+      end
     end
 
-    def registered?(path)
-      @registry.has_key?(path)
+    def key_for(type, plugin_name)
+      "#{type}-#{plugin_name}"
     end
+  end end
 
-  end
+  PLUGIN_REGISTRY = Plugins::Registry.new
 end
diff --git a/logstash-core/lib/logstash/runner.rb b/logstash-core/lib/logstash/runner.rb
index fb30d59e90a..eeed1eb6bcd 100644
--- a/logstash-core/lib/logstash/runner.rb
+++ b/logstash-core/lib/logstash/runner.rb
@@ -18,6 +18,7 @@
 require "logstash/patches/clamp"
 require "logstash/settings"
 require "logstash/version"
+require "logstash/plugins/registry"
 
 class LogStash::Runner < Clamp::StrictCommand
   include LogStash::Util::Loggable
@@ -198,6 +199,11 @@ def execute
       logger.warn("--config.debug was specified, but log.level was not set to \'debug\'! No config info will be logged.")
     end
 
+    # We configure the registry and load any plugin that can register hooks
+    # with logstash, this need to be done before any operation.
+    LogStash::PLUGIN_REGISTRY.setup!
+    @settings.validate_all
+
     LogStash::Util::set_thread_name(self.class.name)
 
     if RUBY_VERSION < "1.9.2"
@@ -223,8 +229,6 @@ def execute
 
     return start_shell(setting("interactive"), binding) if setting("interactive")
 
-    @settings.validate_all
-
     @settings.format_settings.each {|line| logger.debug(line) }
 
     if setting("config.string").nil? && setting("path.config").nil?
@@ -337,7 +341,6 @@ def create_agent(*args)
     LogStash::Agent.new(*args)
   end
 
-
   # Emit a failure message and abort.
   def fail(message)
     signal_usage_error(message)
diff --git a/logstash-core/lib/logstash/settings.rb b/logstash-core/lib/logstash/settings.rb
index 5bb1e649b56..20cf6bff9ed 100644
--- a/logstash-core/lib/logstash/settings.rb
+++ b/logstash-core/lib/logstash/settings.rb
@@ -9,6 +9,11 @@ class Settings
 
     def initialize
       @settings = {}
+      # Theses settings were loaded from the yaml file
+      # but we didn't find any settings to validate them,
+      # lets keep them around until we do `validate_all` at that
+      # time universal plugins could have added new settings.
+      @transient_settings = {}
     end
 
     def register(setting)
@@ -52,8 +57,14 @@ def get_value(setting_name)
     end
     alias_method :get, :get_value
 
-    def set_value(setting_name, value)
+    def set_value(setting_name, value, graceful = false)
       get_setting(setting_name).set(value)
+    rescue ArgumentError => e
+      if graceful
+        @transient_settings[setting_name] = value
+      else
+        raise e
+      end
     end
     alias_method :set, :set_value
 
@@ -65,8 +76,8 @@ def to_hash
       hash
     end
 
-    def merge(hash)
-      hash.each {|key, value| set_value(key, value) }
+    def merge(hash, graceful = false)
+      hash.each {|key, value| set_value(key, value, graceful) }
       self
     end
 
@@ -96,10 +107,13 @@ def reset
 
     def from_yaml(yaml_path)
       settings = read_yaml(::File.join(yaml_path, "logstash.yml"))
-      self.merge(flatten_hash(settings))
+      self.merge(flatten_hash(settings), true)
     end
 
     def validate_all
+      # lets merge the transient_settings again to see if new setting were added.
+      self.merge(@transient_settings)
+
       @settings.each do |name, setting|
         setting.validate_value
       end
diff --git a/logstash-core/lib/logstash/universal_plugin.rb b/logstash-core/lib/logstash/universal_plugin.rb
new file mode 100644
index 00000000000..3891bdc14d5
--- /dev/null
+++ b/logstash-core/lib/logstash/universal_plugin.rb
@@ -0,0 +1,13 @@
+# encoding: utf-8
+module LogStash
+  class UniversalPlugin
+    def initialize
+    end
+
+    def register_hooks(hookManager)
+    end
+
+    def additionals_settings(settings)
+    end
+  end
+end
diff --git a/logstash-core/spec/api/spec_helper.rb b/logstash-core/spec/api/spec_helper.rb
index 8e4912ddf84..31ec6f27113 100644
--- a/logstash-core/spec/api/spec_helper.rb
+++ b/logstash-core/spec/api/spec_helper.rb
@@ -5,6 +5,7 @@
 require "logstash/devutils/rspec/spec_helper"
 $LOAD_PATH.unshift(File.expand_path(File.dirname(__FILE__)))
 require "lib/api/support/resource_dsl_methods"
+require_relative "../support/mocks_classes"
 require 'rspec/expectations'
 require "logstash/settings"
 require 'rack/test'
diff --git a/logstash-core/spec/conditionals_spec.rb b/logstash-core/spec/conditionals_spec.rb
index d831513fbfb..52b2b4db53d 100644
--- a/logstash-core/spec/conditionals_spec.rb
+++ b/logstash-core/spec/conditionals_spec.rb
@@ -26,6 +26,8 @@ def conditional(expression, &block)
   extend ConditionalFanciness
 
   class DummyNullOutput < LogStash::Outputs::Base
+    config_name "dummynull"
+
     def register
     end
     def multi_receive(events)
@@ -33,7 +35,7 @@ def multi_receive(events)
   end
 
   before do
-    LogStash::Registry.instance.register("logstash/outputs/dummynull", DummyNullOutput)
+    LogStash::PLUGIN_REGISTRY.add(:output, "dummynull", DummyNullOutput)
   end
 
   describe "simple" do
@@ -436,5 +438,4 @@ def multi_receive(events)
       expect(subject[2].get("cond2")).to eq("true")
     end
   end
-
 end
diff --git a/logstash-core/spec/logstash/agent_spec.rb b/logstash-core/spec/logstash/agent_spec.rb
index 21b925c395d..1d6364c6ae6 100644
--- a/logstash-core/spec/logstash/agent_spec.rb
+++ b/logstash-core/spec/logstash/agent_spec.rb
@@ -411,7 +411,7 @@
     # We need to create theses dummy classes to know how many
     # events where actually generated by the pipeline and successfully send to the output.
     # Theses values are compared with what we store in the metric store.
-    class DummyOutput2 < DummyOutput; end
+    class DummyOutput2 < LogStash::Outputs::DummyOutput; end
 
     let!(:dummy_output) { DummyOutput.new }
     let!(:dummy_output2) { DummyOutput2.new }
diff --git a/logstash-core/spec/logstash/event_dispatcher_spec.rb b/logstash-core/spec/logstash/event_dispatcher_spec.rb
new file mode 100644
index 00000000000..263b3b23a5f
--- /dev/null
+++ b/logstash-core/spec/logstash/event_dispatcher_spec.rb
@@ -0,0 +1,76 @@
+# encoding: utf-8
+#
+require "logstash/event_dispatcher"
+
+describe LogStash::EventDispatcher do
+  class DummyEmitter
+    attr_reader :dispatcher
+
+    def initialize
+      @dispatcher = LogStash::EventDispatcher.new(self)
+    end
+
+    def method_exists
+      dispatcher.fire(:method_exists)
+    end
+
+    def method_exists_with_arguments(argument1, argument2, argument3)
+      dispatcher.fire(:method_exists_with_arguments, argument1, argument2, argument3)
+    end
+
+    def method_do_not_exist
+      dispatcher.fire(:method_do_not_exist)
+    end
+  end
+
+  class CustomSpy
+    def method_exists
+    end
+
+    def method_exists_with_arguments(argument1, argument2, argument3)
+    end
+  end
+
+  let(:listener) { CustomSpy }
+  subject(:emitter) { DummyEmitter.new }
+
+  describe "Emits events" do
+    before do
+      emitter.dispatcher.add_listener(listener)
+    end
+
+    context "when the method exist" do
+      it "calls the method without arguments" do
+        expect(listener).to receive(:method_exists).with(emitter)
+        emitter.method_exists
+      end
+
+      it "calls the method with arguments" do
+        expect(listener).to receive(:method_exists_with_arguments).with(emitter, 1, 2, 3)
+        emitter.method_exists_with_arguments(1, 2, 3)
+      end
+    end
+
+    context "when the method doesn't exist on the listener" do
+      it "should not raise an exception" do
+        expect { emitter.method_do_not_exist }.not_to raise_error
+      end
+    end
+  end
+
+  describe "Configuring listeners" do
+    it "adds a listener to an emitter" do
+      expect(listener).to receive(:method_exists).with(emitter)
+      emitter.dispatcher.add_listener(listener)
+      emitter.method_exists
+    end
+
+    it "allows to remove a listner to an emitter" do
+      expect(listener).to receive(:method_exists).with(emitter).once
+      emitter.dispatcher.add_listener(listener)
+      emitter.method_exists
+      emitter.dispatcher.remove_listener(listener)
+      emitter.method_exists
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/pipeline_spec.rb b/logstash-core/spec/logstash/pipeline_spec.rb
index 06007ecb1de..927eafeacb2 100644
--- a/logstash-core/spec/logstash/pipeline_spec.rb
+++ b/logstash-core/spec/logstash/pipeline_spec.rb
@@ -104,15 +104,15 @@ class TestPipeline < LogStash::Pipeline
   describe "event cancellation" do
     # test harness for https://github.com/elastic/logstash/issues/6055
 
-    let(:output) { DummyOutputWithEventsArray.new }
+    let(:output) { LogStash::Outputs::DummyOutputWithEventsArray.new }
 
     before do
       allow(LogStash::Plugin).to receive(:lookup).with("input", "generator").and_return(LogStash::Inputs::Generator)
-      allow(LogStash::Plugin).to receive(:lookup).with("output", "dummyoutputwitheventsarray").and_return(DummyOutputWithEventsArray)
+      allow(LogStash::Plugin).to receive(:lookup).with("output", "dummyoutputwitheventsarray").and_return(LogStash::Outputs::DummyOutputWithEventsArray)
       allow(LogStash::Plugin).to receive(:lookup).with("filter", "drop").and_call_original
       allow(LogStash::Plugin).to receive(:lookup).with("filter", "mutate").and_call_original
       allow(LogStash::Plugin).to receive(:lookup).with("codec", "plain").and_call_original
-      allow(DummyOutputWithEventsArray).to receive(:new).with(any_args).and_return(output)
+      allow(LogStash::Outputs::DummyOutputWithEventsArray).to receive(:new).with(any_args).and_return(output)
     end
 
     let(:config) do
diff --git a/logstash-core/spec/logstash/plugin_spec.rb b/logstash-core/spec/logstash/plugin_spec.rb
index 6ef3398b879..2313ca27d95 100644
--- a/logstash-core/spec/logstash/plugin_spec.rb
+++ b/logstash-core/spec/logstash/plugin_spec.rb
@@ -31,20 +31,8 @@
     class LogStash::Filters::LadyGaga < LogStash::Filters::Base
       config_name "lady_gaga"
     end
-    expect(LogStash::Plugin.lookup("filter", "lady_gaga")).to eq(LogStash::Filters::LadyGaga)
-  end
-
-  describe "plugin signup in the registry" do
-
-    let(:registry) { LogStash::Registry.instance }
 
-    it "should be present in the registry" do
-      class LogStash::Filters::MyPlugin < LogStash::Filters::Base
-        config_name "my_plugin"
-      end
-      path     = "logstash/filters/my_plugin"
-      expect(registry.registered?(path)).to eq(true)
-    end
+    expect(LogStash::Plugin.lookup("filter", "lady_gaga")).to eq(LogStash::Filters::LadyGaga)
   end
 
   describe "#inspect" do
diff --git a/logstash-core/spec/logstash/plugins/hooks_registry_spec.rb b/logstash-core/spec/logstash/plugins/hooks_registry_spec.rb
new file mode 100644
index 00000000000..c45a219dbee
--- /dev/null
+++ b/logstash-core/spec/logstash/plugins/hooks_registry_spec.rb
@@ -0,0 +1,60 @@
+# encoding: utf-8
+require "logstash/event_dispatcher"
+require "logstash/plugins/hooks_registry"
+
+describe LogStash::Plugins::HooksRegistry do
+  class DummyEmitter
+    attr_reader :dispatcher
+
+    def initialize
+      @dispatcher = LogStash::EventDispatcher.new(self)
+    end
+
+    def do_work
+      dispatcher.fire(:do_work)
+    end
+  end
+
+  class DummyListener
+    def initialize
+      @work = false
+    end
+
+    def do_work(emitter = nil)
+      @work = true
+    end
+
+    def work?
+      @work
+    end
+  end
+
+  subject { described_class.new }
+
+  let(:emitter) { DummyEmitter.new }
+  let(:listener) { DummyListener.new }
+
+  it "allow to register an emitter" do
+    expect { subject.register_emitter(emitter.class, emitter.dispatcher) }.to change { subject.emmitters_count }.by(1)
+  end
+
+  it "allow to remove an emitter" do
+    subject.register_emitter(emitter.class, emitter.dispatcher)
+    expect { subject.remove_emitter(emitter.class)}.to change { subject.emmitters_count }.by(-1)
+  end
+
+  it "allow to register hooks to emitters" do
+    expect { subject.register_hooks(emitter.class, listener) }.to change { subject.hooks_count }.by(1)
+    expect { subject.register_hooks(emitter.class, listener) }.to change { subject.hooks_count(emitter.class) }.by(1)
+  end
+
+  it "link the emitter class to the listener" do
+    subject.register_emitter(emitter.class, emitter.dispatcher)
+    subject.register_hooks(emitter.class, listener)
+
+    expect(listener.work?).to be_falsey
+    emitter.do_work
+
+    expect(listener.work?).to be_truthy
+  end
+end
diff --git a/logstash-core/spec/logstash/plugins/registry_spec.rb b/logstash-core/spec/logstash/plugins/registry_spec.rb
index f109f68653a..f26068ea5ab 100644
--- a/logstash-core/spec/logstash/plugins/registry_spec.rb
+++ b/logstash-core/spec/logstash/plugins/registry_spec.rb
@@ -8,15 +8,19 @@ class LogStash::Inputs::Dummy < LogStash::Inputs::Base
   config_name "dummy"
 
   def register; end
-
 end
 
-describe LogStash::Registry do
 
-  let(:registry) { described_class.instance }
+class LogStash::Inputs::NewPlugin < LogStash::Inputs::Base
+  config_name "new_plugin"
 
-  context "when loading installed plugins" do
+  def register; end
+end
+
+describe LogStash::Plugins::Registry do
+  let(:registry) { described_class.new }
 
+  context "when loading installed plugins" do
     let(:plugin) { double("plugin") }
 
     it "should return the expected class" do
@@ -25,18 +29,13 @@ def register; end
     end
 
     it "should raise an error if can not find the plugin class" do
-      expect(LogStash::Registry::Plugin).to receive(:new).with("input", "elastic").and_return(plugin)
-      expect(plugin).to receive(:path).and_return("logstash/input/elastic").twice
-      expect(plugin).to receive(:installed?).and_return(true)
-      expect { registry.lookup("input", "elastic") }.to raise_error(LoadError)
+      expect { registry.lookup("input", "do-not-exist-elastic") }.to raise_error(LoadError)
     end
 
     it "should load from registry is already load" do
-      registry.lookup("input", "stdin")
-      expect(registry).to receive(:registered?).and_return(true).once
-      registry.lookup("input", "stdin")
-      internal_registry = registry.instance_variable_get("@registry")
-      expect(internal_registry).to include("logstash/inputs/stdin" => LogStash::Inputs::Stdin)
+      expect(registry.exists?(:input, "stdin")).to be_falsey
+      expect { registry.lookup("input", "new_plugin") }.to change { registry.size }.by(1)
+      expect { registry.lookup("input", "new_plugin") }.not_to change { registry.size }
     end
   end
 
@@ -53,5 +52,14 @@ def register; end
     end
   end
 
-end
+  context "when loading plugin manually configured" do
+    it "should return the plugin" do
+      class SimplePlugin
+      end
 
+      expect { registry.lookup("filter", "simple_plugin") }.to raise_error(LoadError)
+      registry.add(:filter, "simple_plugin", SimplePlugin)
+      expect(registry.lookup("filter", "simple_plugin")).to eq(SimplePlugin)
+    end
+  end
+end
diff --git a/logstash-core/spec/logstash/settings_spec.rb b/logstash-core/spec/logstash/settings_spec.rb
index 138040fa62f..adfe3819f37 100644
--- a/logstash-core/spec/logstash/settings_spec.rb
+++ b/logstash-core/spec/logstash/settings_spec.rb
@@ -1,6 +1,7 @@
 # encoding: utf-8
 require "spec_helper"
 require "logstash/settings"
+require "fileutils"
 
 describe LogStash::Settings do
   let(:numeric_setting_name) { "number" }
@@ -86,4 +87,42 @@
       end
     end
   end
+
+  context "transient settings" do
+    subject do
+      settings = described_class.new
+      settings.register(LogStash::Setting::String.new("exist", "bonsoir"))
+      settings
+    end
+
+    let(:values) { { "do.not.exist.on.boot" => true, "exist" => "bonjour" } }
+    let(:yaml_path) do
+      p = Stud::Temporary.pathname
+      FileUtils.mkdir_p(p)
+
+      ::File.open(::File.join(p, "logstash.yml"), "w+") do |f|
+        f.write(YAML.dump(values))
+      end
+      p
+    end
+
+    it "allow to read yml file that contains unknown settings" do
+      expect { subject.from_yaml(yaml_path) }.not_to raise_error
+    end
+
+    context "when running #validate_all" do
+      it "merge and validate all the registered setting" do
+        subject.from_yaml(yaml_path)
+        subject.register(LogStash::Setting::Boolean.new("do.not.exist.on.boot", false))
+
+        expect { subject.validate_all }.not_to raise_error
+        expect(subject.get("do.not.exist.on.boot")).to be_truthy
+      end
+
+      it "raise an error when the settings doesn't exist" do
+        subject.from_yaml(yaml_path)
+        expect { subject.validate_all }.to raise_error(ArgumentError)
+      end
+    end
+  end
 end
diff --git a/logstash-core/spec/support/mocks_classes.rb b/logstash-core/spec/support/mocks_classes.rb
index d90318d5330..3cdf0a6dc01 100644
--- a/logstash-core/spec/support/mocks_classes.rb
+++ b/logstash-core/spec/support/mocks_classes.rb
@@ -2,48 +2,50 @@
 require "logstash/outputs/base"
 require "thread"
 
-class DummyOutput < LogStash::Outputs::Base
-  config_name "dummyoutput"
-  milestone 2
+module LogStash module Outputs
+  class DummyOutput < LogStash::Outputs::Base
+    config_name "dummyoutput"
+    milestone 2
 
-  attr_reader :num_closes, :events
+    attr_reader :num_closes, :events
 
-  def initialize(params={})
-    super
-    @num_closes = 0
-    @events = Queue.new
-  end
+    def initialize(params={})
+      super
+      @num_closes = 0
+      @events = Queue.new
+    end
 
-  def register
-  end
+    def register
+    end
 
-  def receive(event)
-    @events << event
-  end
+    def receive(event)
+      @events << event
+    end
 
-  def close
-    @num_closes = 1
+    def close
+      @num_closes = 1
+    end
   end
-end
 
-class DummyOutputWithEventsArray < LogStash::Outputs::Base
-  config_name "dummyoutput2"
-  milestone 2
+  class DummyOutputWithEventsArray < LogStash::Outputs::Base
+    config_name "dummyoutput2"
+    milestone 2
 
-  attr_reader :events
+    attr_reader :events
 
-  def initialize(params={})
-    super
-    @events = []
-  end
+    def initialize(params={})
+      super
+      @events = []
+    end
 
-  def register
-  end
+    def register
+    end
 
-  def receive(event)
-    @events << event
-  end
+    def receive(event)
+      @events << event
+    end
 
-  def close
+    def close
+    end
   end
-end
+end end
