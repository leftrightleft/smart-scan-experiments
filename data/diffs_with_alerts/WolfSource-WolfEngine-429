diff --git a/.github/workflows/msvc.yml b/.github/workflows/msvc.yml
index bc1dd1f49..254780e61 100644
--- a/.github/workflows/msvc.yml
+++ b/.github/workflows/msvc.yml
@@ -10,15 +10,15 @@ name: Microsoft C++ Code Analysis
 
 on:
   push:
-    branches: [ "main" ]
+    branches: ["main"]
   pull_request:
-    branches: [ "main" ]
+    branches: ["main"]
   schedule:
-    - cron: '41 16 * * 1'
+    - cron: "41 16 * * 1"
 
 env:
   # Path to the CMake build directory.
-  build: '${{ github.workspace }}/build'
+  build: "${{ github.workspace }}/build"
 
 permissions:
   contents: read
@@ -36,15 +36,23 @@ jobs:
       - name: Checkout repository
         uses: actions/checkout@v3
 
+      - name: Get SW
+        uses: egorpugin/sw-action@master
+
+      - name: SW setup and add to PATH
+        run: |
+          ./sw setup
+          echo "D:\a\WolfEngine\WolfEngine" >> $env:GITHUB_PATH
+
       - name: Setup OpenCppCoverage and add to PATh
         id: setup_opencppcoverage
         run: |
           choco install OpenCppCoverage -y
           echo "C:\Program Files\OpenCppCoverage" >> $env:GITHUB_PATH
-          
+
       - name: Configure CMake
         run: cmake -B ${{ env.build }}
-        
+
       # Build is not required for MSVC Code Analysis and will be used for Codecov
       - name: Build CMake
         run: cmake --build ${{ env.build }}
@@ -57,8 +65,8 @@ jobs:
           cmakeBuildDirectory: ${{ env.build }}
           # Ruleset file that will determine what checks will be run
           ruleset: NativeRecommendedRules.ruleset
-          ignoredPaths: build/_deps
-          
+          ignoredTargetPaths: ${{ env.build }}/_deps/boost_chrono-src;${{ env.build }}/_deps/boost_context-src;${{ env.build }}/_deps/boost_coroutine-src;${{ env.build }}/_deps/boost_date_time-src;${{ env.build }}/_deps/boost_exception-src;${{ env.build }}/_deps/fmt-src;${{ env.build }}/_deps/boost_container-src;${{ env.build }}/_deps/opencv-src;${{ env.build }}/_deps/rapidjson-src;${{ env.build }}/_deps/tesseract-src
+
       - name: Generate Codecov Report
         id: generate_test_report
         shell: cmd
@@ -69,7 +77,7 @@ jobs:
           files: ./WolfCov.xml
           fail_ci_if_error: true
           functionalities: fix
-          
+
       # Upload SARIF file to GitHub Code Scanning Alerts
       #- name: Upload SARIF to GitHub
       #  uses: github/codeql-action/upload-sarif@v2
@@ -80,5 +88,5 @@ jobs:
       - name: Upload SARIF as an Artifact
         uses: actions/upload-artifact@v3
         with:
-         name: sarif-file
-         path: ${{ steps.run-analysis.outputs.sarif }}
+          name: sarif-file
+          path: ${{ steps.run-analysis.outputs.sarif }}
diff --git a/wolf/CMakeLists.txt b/wolf/CMakeLists.txt
index 1bf5699a5..2f1f2a5d1 100644
--- a/wolf/CMakeLists.txt
+++ b/wolf/CMakeLists.txt
@@ -12,6 +12,9 @@ message("CXX Compiler ID is ${CMAKE_CXX_COMPILER_ID}")
 # set the options and enviroment variables
 set(WEBRTC_SRC $ENV{WEBRTC_ROOT} CACHE STRING "path to the root folder of webrtc folder")
 
+# set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${PROJECT_NAME})
+# set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/${PROJECT_NAME})
+
 # check the OS
 if(CMAKE_SIZEOF_VOID_P EQUAL 8)
     if (WIN32)
@@ -95,6 +98,10 @@ option(WOLF_SYSTEM_STACKTRACE "Enable boost stacktrace" OFF)
 #option(WOLF_SYSTEM_WASM3 "Enable WebAssembly interpreter" OFF)
 #option(WOLF_SYSTEM_ZLIB "Enable zlib for compression" OFF)
 
+# machine learing modules
+option(WOLF_ML_OCR "Enable machine learning referee ocr" ON)
+option(WOLF_ML_NUDITY_DETECTION "Enable machine learning nudity detection" OFF)
+
 #option(WOLF_ENABLE_LTO "Enable cross language linking time optimization" OFF)
 option(WOLF_TEST "Enable tests" ON)
 if (NOT MSVC)
@@ -185,6 +192,8 @@ include(cmake/media.cmake)
 include(cmake/rust.cmake)
 include(cmake/system.cmake)
 include(cmake/stream.cmake)
+include(cmake/ml.cmake)
+
 
 if (WOLF_ENABLE_ASAN)
     set(ENABLE_ASAN TRUE)
@@ -299,6 +308,9 @@ source_group("system" FILES ${WOLF_SYSTEM_SRC})
 source_group("media/test" FILES ${WOLF_MEDIA_TEST_SRC})
 source_group("media/ffmpeg" FILES ${WOLF_MEDIA_FFMPEG_SRC})
 source_group("media" FILES ${WOLF_MEDIA_OPENAL_SRC} ${WOLF_MEDIA_STB_SRC})
+source_group("ml/referee_ocr" FILES ${WOLF_ML_OCR_SRC})
+
+# file(COPY ${CMAKE_BINARY_DIR}/bin/${CMAKE_BUILD_TYPE} DESTINATION ${CMAKE_BINARY_DIR}/${PROJECT_NAME}/${CMAKE_BUILD_TYPE})
 
 # add compile options
 if (NOT WIN32)
@@ -320,3 +332,9 @@ if (WOLF_TEST)
         target_compile_options(${TEST_PROJECT_NAME} PRIVATE -std=c++2b)
     endif()
 endif()
+
+if(WOLF_ML_OCR AND WIN64)
+    add_custom_command(TARGET ${TEST_PROJECT_NAME} POST_BUILD
+        COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_BINARY_DIR}/bin/${CMAKE_BUILD_TYPE} ${CMAKE_BINARY_DIR}/${PROJECT_NAME}/${CMAKE_BUILD_TYPE}
+    )
+endif()
diff --git a/wolf/cmake/ml.cmake b/wolf/cmake/ml.cmake
new file mode 100644
index 000000000..eb31d9196
--- /dev/null
+++ b/wolf/cmake/ml.cmake
@@ -0,0 +1,157 @@
+if(WOLF_ML_OCR)
+
+    if(LINUX)
+        # fetch leptonica
+        message("fetching https://github.com/DanBloomberg/leptonica.git")
+        FetchContent_Declare(
+            leptonica
+            GIT_REPOSITORY https://github.com/DanBloomberg/leptonica.git
+            GIT_TAG 1.80.0
+            GIT_SHALLOW TRUE
+            GIT_PROGRESS TRUE
+        )
+        FetchContent_Populate(leptonica)
+
+        add_custom_command(OUTPUT lept_config.out COMMAND cmake -B ${leptonica_BINARY_DIR} -DBUILD_SHARED_LIBS=1 -DCMAKE_INSTALL_PREFIX:PATH=${leptonica_BINARY_DIR}/install ${leptonica_SOURCE_DIR} )
+        add_custom_target(lept_config ALL DEPENDS lept_config.out)
+        add_custom_command(OUTPUT lept_build.out COMMAND cmake --build ${leptonica_BINARY_DIR} --target install )
+        add_custom_target(lept_build ALL DEPENDS lept_build.out)
+    endif()
+
+    # fetch tesseract
+    message("fetching https://github.com/tesseract-ocr/tesseract.git")
+    FetchContent_Declare(
+        tesseract
+        GIT_REPOSITORY https://github.com/tesseract-ocr/tesseract.git
+        GIT_TAG main
+
+        GIT_SHALLOW TRUE
+        GIT_PROGRESS TRUE
+    )
+
+    if(WIN64)
+        set(FETCHCONTENT_QUIET OFF)
+
+        set(BUILD_TESTS OFF CACHE BOOL "BUILD_TESTS")
+        set(BUILD_TRAINING_TOOLS OFF CACHE BOOL "BUILD_TRAINING_TOOLS")
+        set(DISABLE_ARCHIVE ON CACHE BOOL "DISABLE_ARCHIVE")
+        set(DISABLE_CURL ON CACHE BOOL "DISABLE_CURL")
+        set(FAST_FLOAT ON CACHE BOOL "FAST_FLOAT")
+        set(GRAPHICS_DISABLED ON CACHE BOOL "GRAPHICS_DISABLED")
+        set(INSTALL_CONFIGS OFF CACHE BOOL "INSTALL_CONFIGS")
+        set(SW_BUILD ON CACHE BOOL "SW_BUILD")
+
+        FetchContent_MakeAvailable(tesseract)
+        list(APPEND INCLUDES
+            ${tesseract_SOURCE_DIR}/include
+            ${tesseract_BINARY_DIR}/include
+        )
+
+        if("${CMAKE_BUILD_TYPE}" STREQUAL "Debug")
+            set(DEBUG_LIB_EXTENTION "d")
+        else()
+            set(DEBUG_LIB_EXTENTION "")
+        endif()
+
+        list(APPEND LIBS
+            ${tesseract_BINARY_DIR}/${CMAKE_BUILD_TYPE}/tesseract53${DEBUG_LIB_EXTENTION}.lib
+        )
+    elseif(LINUX)
+        FetchContent_Populate(tesseract)
+
+        list(APPEND INCLUDES
+        ${tesseract_SOURCE_DIR}/include
+        ${tesseract_BINARY_DIR}/install/include
+        )
+
+        link_directories(${tesseract_BINARY_DIR}/install/lib)
+        list(APPEND LIBS
+            tesseract
+        )
+
+        add_custom_command(OUTPUT tess_config.out COMMAND cmake -B ${tesseract_BINARY_DIR} -DBUILD_TESTS=OFF -DBUILD_TRAINING_TOOLS=OFF -DDISABLE_ARCHIVE=ON -DDISABLE_CURL=ON -DFAST_FLOAT=ON -DGRAPHICS_DISABLED=ON -DINSTALL_CONFIGS=OFF -DLeptonica_DIR=${leptonica_BINARY_DIR} -DCMAKE_INSTALL_PREFIX:PATH=${tesseract_BINARY_DIR}/install ${tesseract_SOURCE_DIR} )
+        add_custom_target(tess_config ALL DEPENDS tess_config.out)
+        add_custom_command(OUTPUT tess_build.out COMMAND cmake --build ${tesseract_BINARY_DIR} --target install )
+        add_custom_target(tess_build ALL DEPENDS tess_build.out)
+    endif()
+
+    # fetch opencv
+    message("fetching https://github.com/opencv/opencv.git")
+    FetchContent_Declare(
+        opencv
+        GIT_REPOSITORY https://github.com/opencv/opencv.git
+        GIT_TAG 4.5.4
+        GIT_SHALLOW TRUE
+        GIT_PROGRESS TRUE
+    )
+
+    if(WIN64)
+        FetchContent_GetProperties(opencv)
+
+        set(BUILD_LIST core,highgui,videoio CACHE STRING "BUILD_LIST")
+        set(WITH_IPP OFF CACHE BOOL "WITH_IPP")
+        set(BUILD_EXAMPLES OFF CACHE BOOL "BUILD_EXAMPLES")
+        set(OPENCV_GENERATE_PKGCONFIG ON CACHE BOOL "OPENCV_GENERATE_PKGCONFIG")
+
+        FetchContent_MakeAvailable(opencv)
+
+        list(APPEND INCLUDES
+            ${CMAKE_BINARY_DIR}
+            ${opencv_SOURCE_DIR}/include
+            ${opencv_SOURCE_DIR}/modules/core/include
+            ${opencv_SOURCE_DIR}/modules/highgui/include
+            ${opencv_SOURCE_DIR}/modules/imgcodecs/include
+            ${opencv_SOURCE_DIR}/modules/imgproc/include
+            ${opencv_SOURCE_DIR}/modules/videoio/include
+        )
+        list(APPEND LIBS
+           ${opencv_BINARY_DIR}/lib/${CMAKE_BUILD_TYPE}/opencv_core454${DEBUG_LIB_EXTENTION}.lib
+           ${opencv_BINARY_DIR}/lib/${CMAKE_BUILD_TYPE}/opencv_highgui454${DEBUG_LIB_EXTENTION}.lib
+           ${opencv_BINARY_DIR}/lib/${CMAKE_BUILD_TYPE}/opencv_imgcodecs454${DEBUG_LIB_EXTENTION}.lib
+           ${opencv_BINARY_DIR}/lib/${CMAKE_BUILD_TYPE}/opencv_imgproc454${DEBUG_LIB_EXTENTION}.lib
+           ${opencv_BINARY_DIR}/lib/${CMAKE_BUILD_TYPE}/opencv_videoio454${DEBUG_LIB_EXTENTION}.lib
+        )
+    elseif(LINUX)
+        FetchContent_Populate(opencv)
+
+        list(APPEND INCLUDES
+            ${opencv_BINARY_DIR}/install/include/opencv4
+        )
+        list(APPEND LIBS
+            ${opencv_BINARY_DIR}/install/lib/libopencv_core.so
+            ${opencv_BINARY_DIR}/install/lib/libopencv_highgui.so
+            ${opencv_BINARY_DIR}/install/lib/libopencv_imgcodecs.so
+            ${opencv_BINARY_DIR}/install/lib/libopencv_imgproc.so
+            ${opencv_BINARY_DIR}/install/lib/libopencv_videoio.so
+        )
+
+        add_custom_command(OUTPUT opencv_config.out COMMAND cmake -B ${opencv_BINARY_DIR} -DBUILD_LIST=core,highgui,videoio -DBUILD_opencv_python3=OFF -DWITH_IPP=OFF -DBUILD_EXAMPLES=OFF -DOPENCV_GENERATE_PKGCONFIG=ON -DCMAKE_INSTALL_PREFIX:PATH=${opencv_BINARY_DIR}/install ${opencv_SOURCE_DIR} )
+        add_custom_target(opencv_config ALL DEPENDS opencv_config.out)
+        add_custom_command(OUTPUT opencv_build.out COMMAND cmake --build ${opencv_BINARY_DIR} --target install )
+        add_custom_target(opencv_build ALL DEPENDS opencv_build.out)
+    endif()
+
+    # fetch rapidjson
+    message("fetching  https://github.com/Tencent/rapidjson.git")
+    FetchContent_Declare(
+        rapidjson
+        GIT_REPOSITORY https://github.com/Tencent/rapidjson.git
+
+        GIT_SHALLOW TRUE
+        GIT_PROGRESS TRUE
+    )
+
+    FetchContent_Populate(rapidjson)
+
+    list(APPEND INCLUDES
+        ${rapidjson_SOURCE_DIR}/include
+    )
+
+    file(GLOB_RECURSE WOLF_ML_OCR_SRC
+        "${CMAKE_CURRENT_SOURCE_DIR}/ml/referee_ocr/*"
+    )
+
+    list(APPEND SRCS
+        ${WOLF_ML_OCR_SRC}
+    )
+endif()
\ No newline at end of file
diff --git a/wolf/ml/referee_ocr/salieri.h b/wolf/ml/referee_ocr/salieri.h
new file mode 100755
index 000000000..ab445f0ce
--- /dev/null
+++ b/wolf/ml/referee_ocr/salieri.h
@@ -0,0 +1,1563 @@
+/**
+ * Salieri
+ * v1
+ *
+ * Salieri is a header which contains definitions for the Microsoft
+ * source-code annotation language (SAL).  It is *not* an
+ * implementation of SAL; that's for compilers and static analyzers.
+ * For the most part we just define macros to nothing.
+ *
+ * The goal is to allow projects to use SAL without creating a hard
+ * dependency on it (i.e., you can still use compilers other than
+ * MSVC).  Simply include `salieri.h`, which you can/should distribute
+ * with your code, instead of `<sal.h>`.
+ *
+ * Multiple copies of Salieri can be included safely, even different
+ * versions.  Including a newer version will simiply replace older
+ * definitions with newer ones, and including older versions will have
+ * no effect.
+ *
+ * I don't think anything in here is copyrightable, but just in case:
+ *
+ *   To the extent possible under law, the author(s) have dedicated
+ *   all copyright and related and neighboring rights to this software
+ *   to the public domain worldwide. This software is distributed
+ *   without any warranty.
+ *
+ *   For details, see <http://creativecommons.org/publicdomain/zero/1.0/>.
+ */
+
+#if !defined(SALIERI_VERSION) || (SALIERI_VERSION < 1)
+
+/* TODO: figure out when <sal.h> first appeared. */
+#if defined(_MSC_VER)
+#include <sal.h>
+#elif defined(__has_include)
+#if __has_include(<sal.h>)
+#include <sal.h>
+#endif
+#endif
+
+/* The main concern for the implementation is that we don't want to
+ * replace annotations from <sal.h>, but we *do* want to replace
+ * annotations from older versions of Salieri.  To keep track of
+ * everything, when we (Salieri) define a SAL annotation, we also
+ * define SALIERI_DEFINED_${annotation} (with the leading and trailing
+ * '-' stripped).  Then, before redefining an annotation macro we
+ * check to make sure SALIERI_DEFINED_${annontation} is defined.
+ *
+ * This means you can safely use Salieri in a public header in your
+ * project.
+ */
+
+/* Function Parameters & Return Value
+ *
+ * https://msdn.microsoft.com/en-us/library/hh916382.aspx
+ *****/
+
+/*  Pointer Parameters */
+
+#if defined(_In_) && defined(SALIERI_DEFINED_In)
+#undef _In_
+#endif
+#if !defined(_In_)
+#define _In_
+#define SALIERI_DEFINED_In
+#endif
+
+#if defined(_Out_) && defined(SALIERI_DEFINED_Out)
+#undef _Out_
+#endif
+#if !defined(_Out_)
+#define _Out_
+#define SALIERI_DEFINED_Out
+#endif
+
+#if defined(_Inout_) && defined(SALIERI_DEFINED_Inout)
+#undef _Inout_
+#endif
+#if !defined(_Inout_)
+#define _Inout_
+#define SALIERI_DEFINED_Inout
+#endif
+
+#if defined(_In_z_) && defined(SALIERI_DEFINED_In_z)
+#undef _In_z_
+#endif
+#if !defined(_In_z_)
+#define _In_z_
+#define SALIERI_DEFINED_In_z
+#endif
+
+#if defined(_Inout_z_) && defined(SALIERI_DEFINED_Inout_z)
+#undef _Inout_z_
+#endif
+#if !defined(_Inout_z_)
+#define _Inout_z_
+#define SALIERI_DEFINED_Inout_z
+#endif
+
+#if defined(_In_reads_) && defined(SALIERI_DEFINED_In_reads)
+#undef _In_reads_
+#endif
+#if !defined(_In_reads_)
+#define _In_reads_(s)
+#define SALIERI_DEFINED_In_reads
+#endif
+
+#if defined(_In_reads_bytes_) && defined(SALIERI_DEFINED_In_reads_bytes)
+#undef _In_reads_bytes_
+#endif
+#if !defined(_In_reads_bytes_)
+#define _In_reads_bytes_(s)
+#define SALIERI_DEFINED_In_reads_bytes
+#endif
+
+#if defined(_In_reads_z_) && defined(SALIERI_DEFINED_In_reads_z)
+#undef _In_reads_z_
+#endif
+#if !defined(_In_reads_z_)
+#define _In_reads_z_(s)
+#define SALIERI_DEFINED_In_reads_z
+#endif
+
+#if defined(_In_reads_or_z_) && defined(SALIERI_DEFINED_In_reads_or_z)
+#undef _In_reads_or_z_
+#endif
+#if !defined(_In_reads_or_z_)
+#define _In_reads_or_z_(s)
+#define SALIERI_DEFINED_In_reads_or_z
+#endif
+
+#if defined(_Out_writes_) && defined(SALIERI_DEFINED_Out_writes)
+#undef _Out_writes_
+#endif
+#if !defined(_Out_writes_)
+#define _Out_writes_(s)
+#define SALIERI_DEFINED_Out_writes
+#endif
+
+#if defined(_Out_writes_bytes_) && defined(SALIERI_DEFINED_Out_writes_bytes)
+#undef _Out_writes_bytes_
+#endif
+#if !defined(_Out_writes_bytes_)
+#define _Out_writes_bytes_(s)
+#define SALIERI_DEFINED_Out_writes_bytes
+#endif
+
+#if defined(_Out_writes_z_) && defined(SALIERI_DEFINED_Out_writes_z)
+#undef _Out_writes_z_
+#endif
+#if !defined(_Out_writes_z_)
+#define _Out_writes_z_(s)
+#define SALIERI_DEFINED_Out_writes_z
+#endif
+
+#if defined(_Inout_updates_) && defined(SALIERI_DEFINED_Inout_updates)
+#undef _Inout_updates_
+#endif
+#if !defined(_Inout_updates_)
+#define _Inout_updates_(s)
+#define SALIERI_DEFINED_Inout_updates
+#endif
+
+#if defined(_Inout_updates_bytes_) && defined(SALIERI_DEFINED_Inout_updates_bytes)
+#undef _Inout_updates_bytes_
+#endif
+#if !defined(_Inout_updates_bytes_)
+#define _Inout_updates_bytes_(s)
+#define SALIERI_DEFINED_Inout_updates_bytes
+#endif
+
+#if defined(_Inout_updates_z_) && defined(SALIERI_DEFINED_Inout_updates_z)
+#undef _Inout_updates_z_
+#endif
+#if !defined(_Inout_updates_z_)
+#define _Inout_updates_z_(s)
+#define SALIERI_DEFINED_Inout_updates_z
+#endif
+
+#if defined(_Out_writes_to_) && defined(SALIERI_DEFINED_Out_writes_to)
+#undef _Out_writes_to_
+#endif
+#if !defined(_Out_writes_to_)
+#define _Out_writes_to_(s, c)
+#define SALIERI_DEFINED_Out_writes_to
+#endif
+
+#if defined(_Out_writes_bytes_to_) && defined(SALIERI_DEFINED_Out_writes_bytes_to)
+#undef _Out_writes_bytes_to_
+#endif
+#if !defined(_Out_writes_bytes_to_)
+#define _Out_writes_bytes_to_(s, c)
+#define SALIERI_DEFINED_Out_writes_bytes_to
+#endif
+
+#if defined(_Out_writes_all_) && defined(SALIERI_DEFINED_Out_writes_all)
+#undef _Out_writes_all_
+#endif
+#if !defined(_Out_writes_all_)
+#define _Out_writes_all_(s)
+#define SALIERI_DEFINED_Out_writes_all
+#endif
+
+#if defined(_Out_writes_bytes_all_) && defined(SALIERI_DEFINED_Out_writes_bytes_all)
+#undef _Out_writes_bytes_all_
+#endif
+#if !defined(_Out_writes_bytes_all_)
+#define _Out_writes_bytes_all_(s)
+#define SALIERI_DEFINED_Out_writes_bytes_all
+#endif
+
+#if defined(_In_updates_to_) && defined(SALIERI_DEFINED_In_updates_to)
+#undef _In_updates_to_
+#endif
+#if !defined(_In_updates_to_)
+#define _In_updates_to_(s, c)
+#define SALIERI_DEFINED_In_updates_to
+#endif
+
+#if defined(_In_updates_bytes_to_) && defined(SALIERI_DEFINED_In_updates_bytes_to)
+#undef _In_updates_bytes_to_
+#endif
+#if !defined(_In_updates_bytes_to_)
+#define _In_updates_bytes_to_(s, c)
+#define SALIERI_DEFINED_In_updates_bytes_to
+#endif
+
+#if defined(_Inout_updates_z_) && defined(SALIERI_DEFINED_Inout_updates_z)
+#undef _Inout_updates_z_
+#endif
+#if !defined(_Inout_updates_z_)
+#define _Inout_updates_z_(s)
+#define SALIERI_DEFINED_Inout_updates_z
+#endif
+
+#if defined(_Out_writes_to_) && defined(SALIERI_DEFINED_Out_writes_to)
+#undef _Out_writes_to_
+#endif
+#if !defined(_Out_writes_to_)
+#define _Out_writes_to_(s, c)
+#define SALIERI_DEFINED_Out_writes_to
+#endif
+
+#if defined(_Out_writes_bytes_to_) && defined(SALIERI_DEFINED_Out_writes_bytes_to)
+#undef _Out_writes_bytes_to_
+#endif
+#if !defined(_Out_writes_bytes_to_)
+#define _Out_writes_bytes_to_(s, c)
+#define SALIERI_DEFINED_Out_writes_bytes_to
+#endif
+
+#if defined(_Out_writes_all_) && defined(SALIERI_DEFINED_Out_writes_all)
+#undef _Out_writes_all_
+#endif
+#if !defined(_Out_writes_all_)
+#define _Out_writes_all_(s)
+#define SALIERI_DEFINED_Out_writes_all
+#endif
+
+#if defined(_Out_writes_bytes_all_) && defined(SALIERI_DEFINED_Out_writes_bytes_all)
+#undef _Out_writes_bytes_all_
+#endif
+#if !defined(_Out_writes_bytes_all_)
+#define _Out_writes_bytes_all_(s)
+#define SALIERI_DEFINED_Out_writes_bytes_all
+#endif
+
+#if defined(_Inout_updates_to_) && defined(SALIERI_DEFINED_Inout_updates_to)
+#undef _Inout_updates_to_
+#endif
+#if !defined(_Inout_updates_to_)
+#define _Inout_updates_to_(s, c)
+#define SALIERI_DEFINED_Inout_updates_to
+#endif
+
+#if defined(_Inout_updates_bytes_to_) && defined(SALIERI_DEFINED_Inout_updates_bytes_to)
+#undef _Inout_updates_bytes_to_
+#endif
+#if !defined(_Inout_updates_bytes_to_)
+#define _Inout_updates_bytes_to_(s, c)
+#define SALIERI_DEFINED_Inout_updates_bytes_to
+#endif
+
+#if defined(_Inout_updates_all_) && defined(SALIERI_DEFINED_Inout_updates_all)
+#undef _Inout_updates_all_
+#endif
+#if !defined(_Inout_updates_all_)
+#define _Inout_updates_all_(s)
+#define SALIERI_DEFINED_Inout_updates_all
+#endif
+
+#if defined(_Inout_updates_bytes_all_) && defined(SALIERI_DEFINED_Inout_updates_bytes_all)
+#undef _Inout_updates_bytes_all_
+#endif
+#if !defined(_Inout_updates_bytes_all_)
+#define _Inout_updates_bytes_all_(s)
+#define SALIERI_DEFINED_Inout_updates_bytes_all
+#endif
+
+#if defined(_In_reads_to_ptr_) && defined(SALIERI_DEFINED_In_reads_to_ptr)
+#undef _In_reads_to_ptr_
+#endif
+#if !defined(_In_reads_to_ptr_)
+#define _In_reads_to_ptr_(p)
+#define SALIERI_DEFINED_In_reads_to_ptr
+#endif
+
+#if defined(_In_reads_to_ptr_z_) && defined(SALIERI_DEFINED_In_reads_to_ptr_z)
+#undef _In_reads_to_ptr_z_
+#endif
+#if !defined(_In_reads_to_ptr_z_)
+#define _In_reads_to_ptr_z_(p)
+#define SALIERI_DEFINED_In_reads_to_ptr_z
+#endif
+
+#if defined(_Out_writes_to_ptr_) && defined(SALIERI_DEFINED_Out_writes_to_ptr)
+#undef _Out_writes_to_ptr_
+#endif
+#if !defined(_Out_writes_to_ptr_)
+#define _Out_writes_to_ptr_(p)
+#define SALIERI_DEFINED_Out_writes_to_ptr
+#endif
+
+#if defined(_Out_writes_to_ptr_z_) && defined(SALIERI_DEFINED_Out_writes_to_ptr_z)
+#undef _Out_writes_to_ptr_z_
+#endif
+#if !defined(_Out_writes_to_ptr_z_)
+#define _Out_writes_to_ptr_z_(p)
+#define SALIERI_DEFINED_Out_writes_to_ptr_z
+#endif
+
+/*  Optional Pointer Parameters */
+
+#if defined(_In_opt_) && defined(SALIERI_DEFINED_In_opt)
+#undef _In_opt_
+#endif
+#if !defined(_In_opt_)
+#define _In_opt_
+#define SALIERI_DEFINED_In_opt
+#endif
+
+#if defined(_Out_opt_) && defined(SALIERI_DEFINED_Out_opt)
+#undef _Out_opt_
+#endif
+#if !defined(_Out_opt_)
+#define _Out_opt_
+#define SALIERI_DEFINED_Out_opt
+#endif
+
+#if defined(_Inout_opt_) && defined(SALIERI_DEFINED_Inout_opt)
+#undef _Inout_opt_
+#endif
+#if !defined(_Inout_opt_)
+#define _Inout_opt_
+#define SALIERI_DEFINED_Inout_opt
+#endif
+
+#if defined(_In_opt_z_) && defined(SALIERI_DEFINED_In_opt_z)
+#undef _In_opt_z_
+#endif
+#if !defined(_In_opt_z_)
+#define _In_opt_z_
+#define SALIERI_DEFINED_In_opt_z
+#endif
+
+#if defined(_Inout_opt_z_) && defined(SALIERI_DEFINED_Inout_opt_z)
+#undef _Inout_opt_z_
+#endif
+#if !defined(_Inout_opt_z_)
+#define _Inout_opt_z_
+#define SALIERI_DEFINED_Inout_opt_z
+#endif
+
+#if defined(_In_reads_opt_) && defined(SALIERI_DEFINED_In_reads_opt)
+#undef _In_reads_opt_
+#endif
+#if !defined(_In_reads_opt_)
+#define _In_reads_opt_(s)
+#define SALIERI_DEFINED_In_reads_opt
+#endif
+
+#if defined(_In_reads_bytes_opt_) && defined(SALIERI_DEFINED_In_reads_bytes_opt)
+#undef _In_reads_bytes_opt_
+#endif
+#if !defined(_In_reads_bytes_opt_)
+#define _In_reads_bytes_opt_(s)
+#define SALIERI_DEFINED_In_reads_bytes_opt
+#endif
+
+#if defined(_In_reads_opt_z_) && defined(SALIERI_DEFINED_In_reads_opt_z)
+#undef _In_reads_opt_z_
+#endif
+#if !defined(_In_reads_opt_z_)
+#define _In_reads_opt_z_(s)
+#define SALIERI_DEFINED_In_reads_opt_z
+#endif
+
+#if defined(_Out_writes_opt_) && defined(SALIERI_DEFINED_Out_writes_opt)
+#undef _Out_writes_opt_
+#endif
+#if !defined(_Out_writes_opt_)
+#define _Out_writes_opt_(s)
+#define SALIERI_DEFINED_Out_writes_opt
+#endif
+
+#if defined(_Out_writes_bytes_) && defined(SALIERI_DEFINED_Out_writes_bytes)
+#undef _Out_writes_bytes_
+#endif
+#if !defined(_Out_writes_bytes_)
+#define _Out_writes_bytes_(s)
+#define SALIERI_DEFINED_Out_writes_bytes
+#endif
+
+#if defined(_Out_writes_opt_z_) && defined(SALIERI_DEFINED_Out_writes_opt_z)
+#undef _Out_writes_opt_z_
+#endif
+#if !defined(_Out_writes_opt_z_)
+#define _Out_writes_opt_z_(s)
+#define SALIERI_DEFINED_Out_writes_opt_z
+#endif
+
+#if defined(_Inout_updates_opt_) && defined(SALIERI_DEFINED_Inout_updates_opt)
+#undef _Inout_updates_opt_
+#endif
+#if !defined(_Inout_updates_opt_)
+#define _Inout_updates_opt_(s)
+#define SALIERI_DEFINED_Inout_updates_opt
+#endif
+
+#if defined(_Inout_updates_bytes_opt_) && defined(SALIERI_DEFINED_Inout_updates_bytes_opt)
+#undef _Inout_updates_bytes_opt_
+#endif
+#if !defined(_Inout_updates_bytes_opt_)
+#define _Inout_updates_bytes_opt_(s)
+#define SALIERI_DEFINED_Inout_updates_bytes_opt
+#endif
+
+#if defined(_Inout_updates_opt_z_) && defined(SALIERI_DEFINED_Inout_updates_opt_z)
+#undef _Inout_updates_opt_z_
+#endif
+#if !defined(_Inout_updates_opt_z_)
+#define _Inout_updates_opt_z_(s)
+#define SALIERI_DEFINED_Inout_updates_opt_z
+#endif
+
+#if defined(_Out_writes_to_opt_) && defined(SALIERI_DEFINED_Out_writes_to_opt)
+#undef _Out_writes_to_opt_
+#endif
+#if !defined(_Out_writes_to_opt_)
+#define _Out_writes_to_opt_(s, c)
+#define SALIERI_DEFINED_Out_writes_to_opt
+#endif
+
+#if defined(_Out_writes_bytes_to_opt_) && defined(SALIERI_DEFINED_Out_writes_bytes_to_opt)
+#undef _Out_writes_bytes_to_opt_
+#endif
+#if !defined(_Out_writes_bytes_to_opt_)
+#define _Out_writes_bytes_to_opt_(s, c)
+#define SALIERI_DEFINED_Out_writes_bytes_to_opt
+#endif
+
+#if defined(_Out_writes_all_opt_) && defined(SALIERI_DEFINED_Out_writes_all_opt)
+#undef _Out_writes_all_opt_
+#endif
+#if !defined(_Out_writes_all_opt_)
+#define _Out_writes_all_opt_(s)
+#define SALIERI_DEFINED_Out_writes_all_opt
+#endif
+
+#if defined(_Out_writes_bytes_all_opt_) && defined(SALIERI_DEFINED_Out_writes_bytes_all_opt)
+#undef _Out_writes_bytes_all_opt_
+#endif
+#if !defined(_Out_writes_bytes_all_opt_)
+#define _Out_writes_bytes_all_opt_(s)
+#define SALIERI_DEFINED_Out_writes_bytes_all_opt
+#endif
+
+#if defined(_In_updates_to_opt_) && defined(SALIERI_DEFINED_In_updates_to_opt)
+#undef _In_updates_to_opt_
+#endif
+#if !defined(_In_updates_to_opt_)
+#define _In_updates_to_opt_(s, c)
+#define SALIERI_DEFINED_In_updates_to_opt
+#endif
+
+#if defined(_In_updates_bytes_to_opt_) && defined(SALIERI_DEFINED_In_updates_bytes_to_opt)
+#undef _In_updates_bytes_to_opt_
+#endif
+#if !defined(_In_updates_bytes_to_opt_)
+#define _In_updates_bytes_to_opt_(s, c)
+#define SALIERI_DEFINED_In_updates_bytes_to_opt
+#endif
+
+#if defined(_Inout_updates_all_opt_) && defined(SALIERI_DEFINED_Inout_updates_all_opt)
+#undef _Inout_updates_all_opt_
+#endif
+#if !defined(_Inout_updates_all_opt_)
+#define _Inout_updates_all_opt_(s)
+#define SALIERI_DEFINED_Inout_updates_all_opt
+#endif
+
+#if defined(_Inout_updates_bytes_all_opt_) && defined(SALIERI_DEFINED_Inout_updates_bytes_all_opt)
+#undef _Inout_updates_bytes_all_opt_
+#endif
+#if !defined(_Inout_updates_bytes_all_opt_)
+#define _Inout_updates_bytes_all_opt_(s)
+#define SALIERI_DEFINED_Inout_updates_bytes_all_opt
+#endif
+
+#if defined(_In_reads_to_ptr_opt_) && defined(SALIERI_DEFINED_In_reads_to_ptr_opt)
+#undef _In_reads_to_ptr_opt_
+#endif
+#if !defined(_In_reads_to_ptr_opt_)
+#define _In_reads_to_ptr_opt_(p)
+#define SALIERI_DEFINED_In_reads_to_ptr_opt
+#endif
+
+#if defined(_In_reads_to_ptr_opt_z_) && defined(SALIERI_DEFINED_In_reads_to_ptr_opt_z)
+#undef _In_reads_to_ptr_opt_z_
+#endif
+#if !defined(_In_reads_to_ptr_opt_z_)
+#define _In_reads_to_ptr_opt_z_(p)
+#define SALIERI_DEFINED_In_reads_to_ptr_opt_z
+#endif
+
+#if defined(_Out_writes_to_ptr_opt_) && defined(SALIERI_DEFINED_Out_writes_to_ptr_opt)
+#undef _Out_writes_to_ptr_opt_
+#endif
+#if !defined(_Out_writes_to_ptr_opt_)
+#define _Out_writes_to_ptr_opt_(p)
+#define SALIERI_DEFINED_Out_writes_to_ptr_opt
+#endif
+
+#if defined(_Out_writes_to_ptr_opt_z_) && defined(SALIERI_DEFINED_Out_writes_to_ptr_opt_z)
+#undef _Out_writes_to_ptr_opt_z_
+#endif
+#if !defined(_Out_writes_to_ptr_opt_z_)
+#define _Out_writes_to_ptr_opt_z_(p)
+#define SALIERI_DEFINED_Out_writes_to_ptr_opt_z
+#endif
+
+/* Output Pointer Parameters */
+
+#if defined(_Outptr_) && defined(SALIERI_DEFINED_Outptr)
+#undef _Outptr_
+#endif
+#if !defined(_Outptr_)
+#define _Outptr_
+#define SALIERI_DEFINED_Outptr
+#endif
+
+#if defined(_Outptr_opt_) && defined(SALIERI_DEFINED_Outptr_opt)
+#undef _Outptr_opt_
+#endif
+#if !defined(_Outptr_opt_)
+#define _Outptr_opt_
+#define SALIERI_DEFINED_Outptr_opt
+#endif
+
+#if defined(_Outptr_result_maybenull_) && defined(SALIERI_DEFINED_Outptr_result_maybenull)
+#undef _Outptr_result_maybenull_
+#endif
+#if !defined(_Outptr_result_maybenull_)
+#define _Outptr_result_maybenull_
+#define SALIERI_DEFINED_Outptr_result_maybenull
+#endif
+
+#if defined(_Outptr_opt_result_maybenull_) && defined(SALIERI_DEFINED_Outptr_opt_result_maybenull)
+#undef _Outptr_opt_result_maybenull_
+#endif
+#if !defined(_Outptr_opt_result_maybenull_)
+#define _Outptr_opt_result_maybenull_
+#define SALIERI_DEFINED_Outptr_opt_result_maybenull
+#endif
+
+#if defined(_Outptr_result_z_) && defined(SALIERI_DEFINED_Outptr_result_z)
+#undef _Outptr_result_z_
+#endif
+#if !defined(_Outptr_result_z_)
+#define _Outptr_result_z_
+#define SALIERI_DEFINED_Outptr_result_z
+#endif
+
+#if defined(_Outptr_opt_result_z_) && defined(SALIERI_DEFINED_Outptr_opt_result_z)
+#undef _Outptr_opt_result_z_
+#endif
+#if !defined(_Outptr_opt_result_z_)
+#define _Outptr_opt_result_z_
+#define SALIERI_DEFINED_Outptr_opt_result_z
+#endif
+
+#if defined(_Outptr_result_maybenull_z_) && defined(SALIERI_DEFINED_Outptr_result_maybenull_z)
+#undef _Outptr_result_maybenull_z_
+#endif
+#if !defined(_Outptr_result_maybenull_z_)
+#define _Outptr_result_maybenull_z_
+#define SALIERI_DEFINED_Outptr_result_maybenull_z
+#endif
+
+#if defined(_Outptr_opt_result_maybenull_z_) && defined(SALIERI_DEFINED_Outptr_opt_result_maybenull_z)
+#undef _Outptr_opt_result_maybenull_z_
+#endif
+#if !defined(_Outptr_opt_result_maybenull_z_)
+#define _Outptr_opt_result_maybenull_z_
+#define SALIERI_DEFINED_Outptr_opt_result_maybenull_z
+#endif
+
+#if defined(_COM_Outptr_) && defined(SALIERI_DEFINED_COM_Outptr)
+#undef _COM_Outptr_
+#endif
+#if !defined(_COM_Outptr_)
+#define _COM_Outptr_
+#define SALIERI_DEFINED_COM_Outptr
+#endif
+
+#if defined(_COM_Outptr_opt_) && defined(SALIERI_DEFINED_COM_Outptr_opt)
+#undef _COM_Outptr_opt_
+#endif
+#if !defined(_COM_Outptr_opt_)
+#define _COM_Outptr_opt_
+#define SALIERI_DEFINED_COM_Outptr_opt
+#endif
+
+#if defined(_COM_Outptr_result_maybenull_) && defined(SALIERI_DEFINED_COM_Outptr_result_maybenull)
+#undef _COM_Outptr_result_maybenull_
+#endif
+#if !defined(_COM_Outptr_result_maybenull_)
+#define _COM_Outptr_result_maybenull_
+#define SALIERI_DEFINED_COM_Outptr_result_maybenull
+#endif
+
+#if defined(_Outptr_opt_result_maybenull_) && defined(SALIERI_DEFINED_Outptr_opt_result_maybenull)
+#undef _Outptr_opt_result_maybenull_
+#endif
+#if !defined(_Outptr_opt_result_maybenull_)
+#define _Outptr_opt_result_maybenull_
+#define SALIERI_DEFINED_Outptr_opt_result_maybenull
+#endif
+
+#if defined(_Outptr_result_buffer_) && defined(SALIERI_DEFINED_Outptr_result_buffer)
+#undef _Outptr_result_buffer_
+#endif
+#if !defined(_Outptr_result_buffer_)
+#define _Outptr_result_buffer_(s)
+#define SALIERI_DEFINED_Outptr_result_buffer
+#endif
+
+#if defined(_Outptr_result_bytebuffer_) && defined(SALIERI_DEFINED_Outptr_result_bytebuffer)
+#undef _Outptr_result_bytebuffer_
+#endif
+#if !defined(_Outptr_result_bytebuffer_)
+#define _Outptr_result_bytebuffer_(s)
+#define SALIERI_DEFINED_Outptr_result_bytebuffer
+#endif
+
+#if defined(_Outptr_opt_result_buffer_) && defined(SALIERI_DEFINED_Outptr_opt_result_buffer)
+#undef _Outptr_opt_result_buffer_
+#endif
+#if !defined(_Outptr_opt_result_buffer_)
+#define _Outptr_opt_result_buffer_(s)
+#define SALIERI_DEFINED_Outptr_opt_result_buffer
+#endif
+
+#if defined(_Outptr_opt_result_bytebuffer_) && defined(SALIERI_DEFINED_Outptr_opt_result_bytebuffer)
+#undef _Outptr_opt_result_bytebuffer_
+#endif
+#if !defined(_Outptr_opt_result_bytebuffer_)
+#define _Outptr_opt_result_bytebuffer_(s)
+#define SALIERI_DEFINED_Outptr_opt_result_bytebuffer
+#endif
+
+#if defined(_Outptr_result_buffer_to_) && defined(SALIERI_DEFINED_Outptr_result_buffer_to)
+#undef _Outptr_result_buffer_to_
+#endif
+#if !defined(_Outptr_result_buffer_to_)
+#define _Outptr_result_buffer_to_(s, c)
+#define SALIERI_DEFINED_Outptr_result_buffer_to
+#endif
+
+#if defined(_Outptr_result_bytebuffer_to_) && defined(SALIERI_DEFINED_Outptr_result_bytebuffer_to)
+#undef _Outptr_result_bytebuffer_to_
+#endif
+#if !defined(_Outptr_result_bytebuffer_to_)
+#define _Outptr_result_bytebuffer_to_(s, c)
+#define SALIERI_DEFINED_Outptr_result_bytebuffer_to
+#endif
+
+#if defined(_Outptr_opt_result_buffer_to_) && defined(SALIERI_DEFINED_Outptr_opt_result_buffer_to)
+#undef _Outptr_opt_result_buffer_to_
+#endif
+#if !defined(_Outptr_opt_result_buffer_to_)
+#define _Outptr_opt_result_buffer_to_(s, c)
+#define SALIERI_DEFINED_Outptr_opt_result_buffer_to
+#endif
+
+#if defined(_Outptr_opt_result_bytebuffer_to_) && defined(SALIERI_DEFINED_Outptr_opt_result_bytebuffer_to)
+#undef _Outptr_opt_result_bytebuffer_to_
+#endif
+#if !defined(_Outptr_opt_result_bytebuffer_to_)
+#define _Outptr_opt_result_bytebuffer_to_(s, c)
+#define SALIERI_DEFINED_Outptr_opt_result_bytebuffer_to
+#endif
+
+#if defined(_Result_nullonfailure_) && defined(SALIERI_DEFINED_Result_nullonfailure)
+#undef _Result_nullonfailure_
+#endif
+#if !defined(_Result_nullonfailure_)
+#define _Result_nullonfailure_
+#define SALIERI_DEFINED_Result_nullonfailure
+#endif
+
+#if defined(_Result_zeroonfailure_) && defined(SALIERI_DEFINED_Result_zeroonfailure)
+#undef _Result_zeroonfailure_
+#endif
+#if !defined(_Result_zeroonfailure_)
+#define _Result_zeroonfailure_
+#define SALIERI_DEFINED_Result_zeroonfailure
+#endif
+
+#if defined(_Outptr_result_nullonfailure_) && defined(SALIERI_DEFINED_Outptr_result_nullonfailure)
+#undef _Outptr_result_nullonfailure_
+#endif
+#if !defined(_Outptr_result_nullonfailure_)
+#define _Outptr_result_nullonfailure_
+#define SALIERI_DEFINED_Outptr_result_nullonfailure
+#endif
+
+#if defined(_Outptr_opt_result_nullonfailure_) && defined(SALIERI_DEFINED_Outptr_opt_result_nullonfailure)
+#undef _Outptr_opt_result_nullonfailure_
+#endif
+#if !defined(_Outptr_opt_result_nullonfailure_)
+#define _Outptr_opt_result_nullonfailure_
+#define SALIERI_DEFINED_Outptr_opt_result_nullonfailure
+#endif
+
+#if defined(_Outref_result_nullonfailure_) && defined(SALIERI_DEFINED_Outref_result_nullonfailure)
+#undef _Outref_result_nullonfailure_
+#endif
+#if !defined(_Outref_result_nullonfailure_)
+#define _Outref_result_nullonfailure_
+#define SALIERI_DEFINED_Outref_result_nullonfailure
+#endif
+
+/* Output Reference Parameters */
+
+#if defined(_Outref_) && defined(SALIERI_DEFINED_Outref)
+#undef _Outref_
+#endif
+#if !defined(_Outref_)
+#define _Outref_
+#define SALIERI_DEFINED_Outref
+#endif
+
+#if defined(_Outref_result_maybenull_) && defined(SALIERI_DEFINED_Outref_result_maybenull)
+#undef _Outref_result_maybenull_
+#endif
+#if !defined(_Outref_result_maybenull_)
+#define _Outref_result_maybenull_
+#define SALIERI_DEFINED_Outref_result_maybenull
+#endif
+
+#if defined(_Outref_result_buffer_) && defined(SALIERI_DEFINED_Outref_result_buffer)
+#undef _Outref_result_buffer_
+#endif
+#if !defined(_Outref_result_buffer_)
+#define _Outref_result_buffer_(s)
+#define SALIERI_DEFINED_Outref_result_buffer
+#endif
+
+#if defined(_Outref_result_bytebuffer_) && defined(SALIERI_DEFINED_Outref_result_bytebuffer)
+#undef _Outref_result_bytebuffer_
+#endif
+#if !defined(_Outref_result_bytebuffer_)
+#define _Outref_result_bytebuffer_(s)
+#define SALIERI_DEFINED_Outref_result_bytebuffer
+#endif
+
+#if defined(_Outref_result_buffer_to_) && defined(SALIERI_DEFINED_Outref_result_buffer_to)
+#undef _Outref_result_buffer_to_
+#endif
+#if !defined(_Outref_result_buffer_to_)
+#define _Outref_result_buffer_to_(s, c)
+#define SALIERI_DEFINED_Outref_result_buffer_to
+#endif
+
+#if defined(_Outref_result_bytebuffer_to_) && defined(SALIERI_DEFINED_Outref_result_bytebuffer_to)
+#undef _Outref_result_bytebuffer_to_
+#endif
+#if !defined(_Outref_result_bytebuffer_to_)
+#define _Outref_result_bytebuffer_to_(s, c)
+#define SALIERI_DEFINED_Outref_result_bytebuffer_to
+#endif
+
+#if defined(_Outref_result_buffer_all_) && defined(SALIERI_DEFINED_Outref_result_buffer_all)
+#undef _Outref_result_buffer_all_
+#endif
+#if !defined(_Outref_result_buffer_all_)
+#define _Outref_result_buffer_all_(s)
+#define SALIERI_DEFINED_Outref_result_buffer_all
+#endif
+
+#if defined(_Outref_result_bytebuffer_all_) && defined(SALIERI_DEFINED_Outref_result_bytebuffer_all)
+#undef _Outref_result_bytebuffer_all_
+#endif
+#if !defined(_Outref_result_bytebuffer_all_)
+#define _Outref_result_bytebuffer_all_(s)
+#define SALIERI_DEFINED_Outref_result_bytebuffer_all
+#endif
+
+#if defined(_Outref_result_buffer_maybenull_) && defined(SALIERI_DEFINED_Outref_result_buffer_maybenull)
+#undef _Outref_result_buffer_maybenull_
+#endif
+#if !defined(_Outref_result_buffer_maybenull_)
+#define _Outref_result_buffer_maybenull_(s)
+#define SALIERI_DEFINED_Outref_result_buffer_maybenull
+#endif
+
+#if defined(_Outref_result_bytebuffer_maybenull_) && defined(SALIERI_DEFINED_Outref_result_bytebuffer_maybenull)
+#undef _Outref_result_bytebuffer_maybenull_
+#endif
+#if !defined(_Outref_result_bytebuffer_maybenull_)
+#define _Outref_result_bytebuffer_maybenull_(s)
+#define SALIERI_DEFINED_Outref_result_bytebuffer_maybenull
+#endif
+
+#if defined(_Outref_result_buffer_to_maybenull_) && defined(SALIERI_DEFINED_Outref_result_buffer_to_maybenull)
+#undef _Outref_result_buffer_to_maybenull_
+#endif
+#if !defined(_Outref_result_buffer_to_maybenull_)
+#define _Outref_result_buffer_to_maybenull_(s, c)
+#define SALIERI_DEFINED_Outref_result_buffer_to_maybenull
+#endif
+
+#if defined(_Outref_result_bytebuffer_to_maybenull_) && defined(SALIERI_DEFINED_Outref_result_bytebuffer_to_maybenull)
+#undef _Outref_result_bytebuffer_to_maybenull_
+#endif
+#if !defined(_Outref_result_bytebuffer_to_maybenull_)
+#define _Outref_result_bytebuffer_to_maybenull_(s, c)
+#define SALIERI_DEFINED_Outref_result_bytebuffer_to_maybenull
+#endif
+
+#if defined(_Outref_result_buffer_all_maybenull_) && defined(SALIERI_DEFINED_Outref_result_buffer_all_maybenull)
+#undef _Outref_result_buffer_all_maybenull_
+#endif
+#if !defined(_Outref_result_buffer_all_maybenull_)
+#define _Outref_result_buffer_all_maybenull_(s)
+#define SALIERI_DEFINED_Outref_result_buffer_all_maybenull
+#endif
+
+#if defined(_Outref_result_bytebuffer_all_maybenull_) && defined(SALIERI_DEFINED_Outref_result_bytebuffer_all_maybenull)
+#undef _Outref_result_bytebuffer_all_maybenull_
+#endif
+#if !defined(_Outref_result_bytebuffer_all_maybenull_)
+#define _Outref_result_bytebuffer_all_maybenull_(s)
+#define SALIERI_DEFINED_Outref_result_bytebuffer_all_maybenull
+#endif
+
+/* Return Values */
+
+#if defined(_Ret_z_) && defined(SALIERI_DEFINED_Ret_z)
+#undef _Ret_z_
+#endif
+#if !defined(_Ret_z_)
+#define _Ret_z_
+#define SALIERI_DEFINED_Ret_z
+#endif
+
+#if defined(_Ret_writes_) && defined(SALIERI_DEFINED_Ret_writes)
+#undef _Ret_writes_
+#endif
+#if !defined(_Ret_writes_)
+#define _Ret_writes_(s)
+#define SALIERI_DEFINED_Ret_writes
+#endif
+
+#if defined(_Ret_writes_bytes_) && defined(SALIERI_DEFINED_Ret_writes_bytes)
+#undef _Ret_writes_bytes_
+#endif
+#if !defined(_Ret_writes_bytes_)
+#define _Ret_writes_bytes_(s)
+#define SALIERI_DEFINED_Ret_writes_bytes
+#endif
+
+#if defined(_Ret_writes_z_) && defined(SALIERI_DEFINED_Ret_writes_z)
+#undef _Ret_writes_z_
+#endif
+#if !defined(_Ret_writes_z_)
+#define _Ret_writes_z_(s)
+#define SALIERI_DEFINED_Ret_writes_z
+#endif
+
+#if defined(_Ret_writes_to_) && defined(SALIERI_DEFINED_Ret_writes_to)
+#undef _Ret_writes_to_
+#endif
+#if !defined(_Ret_writes_to_)
+#define _Ret_writes_to_(s, c)
+#define SALIERI_DEFINED_Ret_writes_to
+#endif
+
+#if defined(_Ret_writes_maybenull_) && defined(SALIERI_DEFINED_Ret_writes_maybenull)
+#undef _Ret_writes_maybenull_
+#endif
+#if !defined(_Ret_writes_maybenull_)
+#define _Ret_writes_maybenull_(s)
+#define SALIERI_DEFINED_Ret_writes_maybenull
+#endif
+
+#if defined(_Ret_writes_to_maybenull_) && defined(SALIERI_DEFINED_Ret_writes_to_maybenull)
+#undef _Ret_writes_to_maybenull_
+#endif
+#if !defined(_Ret_writes_to_maybenull_)
+#define _Ret_writes_to_maybenull_(s)
+#define SALIERI_DEFINED_Ret_writes_to_maybenull
+#endif
+
+#if defined(_Ret_writes_maybenull_z_) && defined(SALIERI_DEFINED_Ret_writes_maybenull_z)
+#undef _Ret_writes_maybenull_z_
+#endif
+#if !defined(_Ret_writes_maybenull_z_)
+#define _Ret_writes_maybenull_z_(s)
+#define SALIERI_DEFINED_Ret_writes_maybenull_z
+#endif
+
+#if defined(_Ret_maybenull_) && defined(SALIERI_DEFINED_Ret_maybenull)
+#undef _Ret_maybenull_
+#endif
+#if !defined(_Ret_maybenull_)
+#define _Ret_maybenull_
+#define SALIERI_DEFINED_Ret_maybenull
+#endif
+
+#if defined(_Ret_maybenull_z_) && defined(SALIERI_DEFINED_Ret_maybenull_z)
+#undef _Ret_maybenull_z_
+#endif
+#if !defined(_Ret_maybenull_z_)
+#define _Ret_maybenull_z_
+#define SALIERI_DEFINED_Ret_maybenull_z
+#endif
+
+#if defined(_Ret_null_) && defined(SALIERI_DEFINED_Ret_null)
+#undef _Ret_null_
+#endif
+#if !defined(_Ret_null_)
+#define _Ret_null_
+#define SALIERI_DEFINED_Ret_null
+#endif
+
+#if defined(_Ret_notnull_) && defined(SALIERI_DEFINED_Ret_notnull)
+#undef _Ret_notnull_
+#endif
+#if !defined(_Ret_notnull_)
+#define _Ret_notnull_
+#define SALIERI_DEFINED_Ret_notnull
+#endif
+
+#if defined(_Ret_writes_bytes_to_) && defined(SALIERI_DEFINED_Ret_writes_bytes_to)
+#undef _Ret_writes_bytes_to_
+#endif
+#if !defined(_Ret_writes_bytes_to_)
+#define _Ret_writes_bytes_to_
+#define SALIERI_DEFINED_Ret_writes_bytes_to
+#endif
+
+#if defined(_Ret_writes_bytes_to_) && defined(SALIERI_DEFINED_Ret_writes_bytes_to)
+#undef _Ret_writes_bytes_to_
+#endif
+#if !defined(_Ret_writes_bytes_to_)
+#define _Ret_writes_bytes_to_
+#define SALIERI_DEFINED_Ret_writes_bytes_to
+#endif
+
+#if defined(_Ret_writes_bytes_maybenull_) && defined(SALIERI_DEFINED_Ret_writes_bytes_maybenull)
+#undef _Ret_writes_bytes_maybenull_
+#endif
+#if !defined(_Ret_writes_bytes_maybenull_)
+#define _Ret_writes_bytes_maybenull_
+#define SALIERI_DEFINED_Ret_writes_bytes_maybenull
+#endif
+
+#if defined(_Ret_writes_bytes_to_maybenull_) && defined(SALIERI_DEFINED_Ret_writes_bytes_to_maybenull)
+#undef _Ret_writes_bytes_to_maybenull_
+#endif
+#if !defined(_Ret_writes_bytes_to_maybenull_)
+#define _Ret_writes_bytes_to_maybenull_
+#define SALIERI_DEFINED_Ret_writes_bytes_to_maybenull
+#endif
+
+/* Other Common Annotations */
+
+#if defined(_In_range_) && defined(SALIERI_DEFINED_In_range)
+#undef _In_range_
+#endif
+#if !defined(_In_range_)
+#define _In_range_(low, hi)
+#define SALIERI_DEFINED_In_range
+#endif
+
+#if defined(_Out_range_) && defined(SALIERI_DEFINED_Out_range)
+#undef _Out_range_
+#endif
+#if !defined(_Out_range_)
+#define _Out_range_(low, hi)
+#define SALIERI_DEFINED_Out_range
+#endif
+
+#if defined(_Ret_range_) && defined(SALIERI_DEFINED_Ret_range)
+#undef _Ret_range_
+#endif
+#if !defined(_Ret_range_)
+#define _Ret_range_(low, hi)
+#define SALIERI_DEFINED_Ret_range
+#endif
+
+#if defined(_Deref_in_range_) && defined(SALIERI_DEFINED_Deref_in_range)
+#undef _Deref_in_range_
+#endif
+#if !defined(_Deref_in_range_)
+#define _Deref_in_range_(low, hi)
+#define SALIERI_DEFINED_Deref_in_range
+#endif
+
+#if defined(_Deref_out_range_) && defined(SALIERI_DEFINED_Deref_out_range)
+#undef _Deref_out_range_
+#endif
+#if !defined(_Deref_out_range_)
+#define _Deref_out_range_(low, hi)
+#define SALIERI_DEFINED_Deref_out_range
+#endif
+
+#if defined(_Deref_inout_range_) && defined(SALIERI_DEFINED_Deref_inout_range)
+#undef _Deref_inout_range_
+#endif
+#if !defined(_Deref_inout_range_)
+#define _Deref_inout_range_(low, hi)
+#define SALIERI_DEFINED_Deref_inout_range
+#endif
+
+#if defined(_Field_range_) && defined(SALIERI_DEFINED_Field_range)
+#undef _Field_range_
+#endif
+#if !defined(_Field_range_)
+#define _Field_range_(low, hi)
+#define SALIERI_DEFINED_Field_range
+#endif
+
+#if defined(_Pre_equal_to_) && defined(SALIERI_DEFINED_Pre_equal_to)
+#undef _Pre_equal_to_
+#endif
+#if !defined(_Pre_equal_to_)
+#define _Pre_equal_to_(expr)
+#define SALIERI_DEFINED_Pre_equal_to
+#endif
+
+#if defined(_Post_equal_to_) && defined(SALIERI_DEFINED_Post_equal_to)
+#undef _Post_equal_to_
+#endif
+#if !defined(_Post_equal_to_)
+#define _Post_equal_to_(expr)
+#define SALIERI_DEFINED_Post_equal_to
+#endif
+
+#if defined(_Struct_size_bytes_) && defined(SALIERI_DEFINED_Struct_size_bytes)
+#undef _Struct_size_bytes_
+#endif
+#if !defined(_Struct_size_bytes_)
+#define _Struct_size_bytes_(size)
+#define SALIERI_DEFINED_Struct_size_bytes
+#endif
+
+/* Annotating Function Behavior
+ *
+ * https://msdn.microsoft.com/en-us/library/jj159529.aspx
+ *****/
+
+#if defined(_Called_from_function_class_) && defined(SALIERI_DEFINED_Called_from_function_class)
+#undef _Called_from_function_class_
+#endif
+#if !defined(_Called_from_function_class_)
+#define _Called_from_function_class_(name)
+#define SALIERI_DEFINED_Called_from_function_class
+#endif
+
+#if defined(_Check_return_) && defined(SALIERI_DEFINED_Check_return)
+#undef _Check_return_
+#endif
+#if !defined(_Check_return_)
+#define _Check_return_
+#define SALIERI_DEFINED_Check_return
+#endif
+
+#if defined(_Function_class_) && defined(SALIERI_DEFINED_Function_class)
+#undef _Function_class_
+#endif
+#if !defined(_Function_class_)
+#define _Function_class_(name)
+#define SALIERI_DEFINED_Function_class
+#endif
+
+#if defined(_Raises_SEH_exception_) && defined(SALIERI_DEFINED_Raises_SEH_exception)
+#undef _Raises_SEH_exception_
+#endif
+#if !defined(_Raises_SEH_exception_)
+#define _Raises_SEH_exception_
+#define SALIERI_DEFINED_Raises_SEH_exception
+#endif
+
+#if defined(_Must_inspect_result_) && defined(SALIERI_DEFINED_Must_inspect_result)
+#undef _Must_inspect_result_
+#endif
+#if !defined(_Must_inspect_result_)
+#define _Must_inspect_result_
+#define SALIERI_DEFINED_Must_inspect_result
+#endif
+
+#if defined(_Use_decl_annotations_) && defined(SALIERI_DEFINED_Use_decl_annotations)
+#undef _Use_decl_annotations_
+#endif
+#if !defined(_Use_decl_annotations_)
+#define _Use_decl_annotations_
+#define SALIERI_DEFINED_Use_decl_annotations
+#endif
+
+#if defined(_Always_) && defined(SALIERI_DEFINED_Always)
+#undef _Always_
+#endif
+#if !defined(_Always_)
+#define _Always_(anno_list)
+#define SALIERI_DEFINED_Always
+#endif
+
+#if defined(_On_failure_) && defined(SALIERI_DEFINED_On_failure)
+#undef _On_failure_
+#endif
+#if !defined(_On_failure_)
+#define _On_failure_(anno_list)
+#define SALIERI_DEFINED_On_failure
+#endif
+
+#if defined(_Return_type_success_) && defined(SALIERI_DEFINED_Return_type_success)
+#undef _Return_type_success_
+#endif
+#if !defined(_Return_type_success_)
+#define _Return_type_success_(expr)
+#define SALIERI_DEFINED_Return_type_success
+#endif
+
+#if defined(_Success_) && defined(SALIERI_DEFINED_Success)
+#undef _Success_
+#endif
+#if !defined(_Success_)
+#define _Success_(expr)
+#define SALIERI_DEFINED_Success
+#endif
+
+/* Annotating Structs and Classes
+ *
+ * https://msdn.microsoft.com/en-us/library/jj159528.aspx
+ *****/
+
+#if defined(_Field_range_) && defined(SALIERI_DEFINED_Field_range)
+#undef _Field_range_
+#endif
+#if !defined(_Field_range_)
+#define _Field_range_(low, high)
+#define SALIERI_DEFINED_Field_range
+#endif
+
+#if defined(_Field_size_) && defined(SALIERI_DEFINED_Field_size)
+#undef _Field_size_
+#endif
+#if !defined(_Field_size_)
+#define _Field_size_(size)
+#define SALIERI_DEFINED_Field_size
+#endif
+
+#if defined(_Field_size_part_) && defined(SALIERI_DEFINED_Field_size_part)
+#undef _Field_size_part_
+#endif
+#if !defined(_Field_size_part_)
+#define _Field_size_part_(size)
+#define SALIERI_DEFINED_Field_size_part
+#endif
+
+#if defined(_Field_size_opt_) && defined(SALIERI_DEFINED_Field_size_opt)
+#undef _Field_size_opt_
+#endif
+#if !defined(_Field_size_opt_)
+#define _Field_size_opt_(size)
+#define SALIERI_DEFINED_Field_size_opt
+#endif
+
+#if defined(_Field_size_bytes_) && defined(SALIERI_DEFINED_Field_size_bytes)
+#undef _Field_size_bytes_
+#endif
+#if !defined(_Field_size_bytes_)
+#define _Field_size_bytes_(size)
+#define SALIERI_DEFINED_Field_size_bytes
+#endif
+
+#if defined(_Field_size_bytes_opt_) && defined(SALIERI_DEFINED_Field_size_bytes_opt)
+#undef _Field_size_bytes_opt_
+#endif
+#if !defined(_Field_size_bytes_opt_)
+#define _Field_size_bytes_opt_(size)
+#define SALIERI_DEFINED_Field_size_bytes_opt
+#endif
+
+#if defined(_Field_size_part_) && defined(SALIERI_DEFINED_Field_size_part)
+#undef _Field_size_part_
+#endif
+#if !defined(_Field_size_part_)
+#define _Field_size_part_(size, count)
+#define SALIERI_DEFINED_Field_size_part
+#endif
+
+#if defined(_Field_size_part_opt_) && defined(SALIERI_DEFINED_Field_size_part_opt)
+#undef _Field_size_part_opt_
+#endif
+#if !defined(_Field_size_part_opt_)
+#define _Field_size_part_opt_(size, count)
+#define SALIERI_DEFINED_Field_size_part_opt
+#endif
+
+#if defined(_Field_size_bytes_part_) && defined(SALIERI_DEFINED_Field_size_bytes_part)
+#undef _Field_size_bytes_part_
+#endif
+#if !defined(_Field_size_bytes_part_)
+#define _Field_size_bytes_part_(size, count)
+#define SALIERI_DEFINED_Field_size_bytes_part
+#endif
+
+#if defined(_Field_size_bytes_part_opt_) && defined(SALIERI_DEFINED_Field_size_bytes_part_opt)
+#undef _Field_size_bytes_part_opt_
+#endif
+#if !defined(_Field_size_bytes_part_opt_)
+#define _Field_size_bytes_part_opt_(size, count)
+#define SALIERI_DEFINED_Field_size_bytes_part_opt
+#endif
+
+#if defined(_Field_size_full_) && defined(SALIERI_DEFINED_Field_size_full)
+#undef _Field_size_full_
+#endif
+#if !defined(_Field_size_full_)
+#define _Field_size_full_(size)
+#define SALIERI_DEFINED_Field_size_full
+#endif
+
+#if defined(_Field_size_full_opt_) && defined(SALIERI_DEFINED_Field_size_full_opt)
+#undef _Field_size_full_opt_
+#endif
+#if !defined(_Field_size_full_opt_)
+#define _Field_size_full_opt_(size)
+#define SALIERI_DEFINED_Field_size_full_opt
+#endif
+
+#if defined(_Field_size_bytes_full_) && defined(SALIERI_DEFINED_Field_size_bytes_full)
+#undef _Field_size_bytes_full_
+#endif
+#if !defined(_Field_size_bytes_full_)
+#define _Field_size_bytes_full_(size)
+#define SALIERI_DEFINED_Field_size_bytes_full
+#endif
+
+#if defined(_Field_size_bytes_full_opt_) && defined(SALIERI_DEFINED_Field_size_bytes_full_opt)
+#undef _Field_size_bytes_full_opt_
+#endif
+#if !defined(_Field_size_bytes_full_opt_)
+#define _Field_size_bytes_full_opt_(size)
+#define SALIERI_DEFINED_Field_size_bytes_full_opt
+#endif
+
+#if defined(_Struct_size_bytes_) && defined(SALIERI_DEFINED_Struct_size_bytes)
+#undef _Struct_size_bytes_
+#endif
+#if !defined(_Struct_size_bytes_)
+#define _Struct_size_bytes_(size)
+#define SALIERI_DEFINED_Struct_size_bytes
+#endif
+
+/* Annotating Locking Behavior
+ *
+ * https://msdn.microsoft.com/en-us/library/hh916381.aspx
+ *****/
+
+#if defined(_Acquires_exclusive_lock_) && defined(SALIERI_DEFINED_Acquires_exclusive_lock)
+#undef _Acquires_exclusive_lock_
+#endif
+#if !defined(_Acquires_exclusive_lock_)
+#define _Acquires_exclusive_lock_(expr)
+#define SALIERI_DEFINED_Acquires_exclusive_lock
+#endif
+
+#if defined(_Acquires_lock_) && defined(SALIERI_DEFINED_Acquires_lock)
+#undef _Acquires_lock_
+#endif
+#if !defined(_Acquires_lock_)
+#define _Acquires_lock_(expr)
+#define SALIERI_DEFINED_Acquires_lock
+#endif
+
+#if defined(_Acquires_nonreentrant_lock_) && defined(SALIERI_DEFINED_Acquires_nonreentrant_lock)
+#undef _Acquires_nonreentrant_lock_
+#endif
+#if !defined(_Acquires_nonreentrant_lock_)
+#define _Acquires_nonreentrant_lock_(expr)
+#define SALIERI_DEFINED_Acquires_nonreentrant_lock
+#endif
+
+#if defined(_Acquires_shared_lock_) && defined(SALIERI_DEFINED_Acquires_shared_lock)
+#undef _Acquires_shared_lock_
+#endif
+#if !defined(_Acquires_shared_lock_)
+#define _Acquires_shared_lock_(expr)
+#define SALIERI_DEFINED_Acquires_shared_lock
+#endif
+
+#if defined(_Create_lock_level_) && defined(SALIERI_DEFINED_Create_lock_level)
+#undef _Create_lock_level_
+#endif
+#if !defined(_Create_lock_level_)
+#define _Create_lock_level_(name)
+#define SALIERI_DEFINED_Create_lock_level
+#endif
+
+#if defined(_Has_lock_kind_) && defined(SALIERI_DEFINED_Has_lock_kind)
+#undef _Has_lock_kind_
+#endif
+#if !defined(_Has_lock_kind_)
+#define _Has_lock_kind_(kind)
+#define SALIERI_DEFINED_Has_lock_kind
+#endif
+
+#if defined(_Has_lock_level_) && defined(SALIERI_DEFINED_Has_lock_level)
+#undef _Has_lock_level_
+#endif
+#if !defined(_Has_lock_level_)
+#define _Has_lock_level_(name)
+#define SALIERI_DEFINED_Has_lock_level
+#endif
+
+#if defined(_Lock_level_order_) && defined(SALIERI_DEFINED_Lock_level_order)
+#undef _Lock_level_order_
+#endif
+#if !defined(_Lock_level_order_)
+#define _Lock_level_order_(name1, name2)
+#define SALIERI_DEFINED_Lock_level_order
+#endif
+
+#if defined(_Post_same_lock_) && defined(SALIERI_DEFINED_Post_same_lock)
+#undef _Post_same_lock_
+#endif
+#if !defined(_Post_same_lock_)
+#define _Post_same_lock_(expr1, expr2)
+#define SALIERI_DEFINED_Post_same_lock
+#endif
+
+#if defined(_Releases_exclusive_lock_) && defined(SALIERI_DEFINED_Releases_exclusive_lock)
+#undef _Releases_exclusive_lock_
+#endif
+#if !defined(_Releases_exclusive_lock_)
+#define _Releases_exclusive_lock_(expr)
+#define SALIERI_DEFINED_Releases_exclusive_lock
+#endif
+
+#if defined(_Releases_lock_) && defined(SALIERI_DEFINED_Releases_lock)
+#undef _Releases_lock_
+#endif
+#if !defined(_Releases_lock_)
+#define _Releases_lock_(expr)
+#define SALIERI_DEFINED_Releases_lock
+#endif
+
+#if defined(_Releases_nonreentrant_lock_) && defined(SALIERI_DEFINED_Releases_nonreentrant_lock)
+#undef _Releases_nonreentrant_lock_
+#endif
+#if !defined(_Releases_nonreentrant_lock_)
+#define _Releases_nonreentrant_lock_(expr)
+#define SALIERI_DEFINED_Releases_nonreentrant_lock
+#endif
+
+#if defined(_Releases_shared_lock_) && defined(SALIERI_DEFINED_Releases_shared_lock)
+#undef _Releases_shared_lock_
+#endif
+#if !defined(_Releases_shared_lock_)
+#define _Releases_shared_lock_(expr)
+#define SALIERI_DEFINED_Releases_shared_lock
+#endif
+
+#if defined(_Requires_lock_held_) && defined(SALIERI_DEFINED_Requires_lock_held)
+#undef _Requires_lock_held_
+#endif
+#if !defined(_Requires_lock_held_)
+#define _Requires_lock_held_(expr)
+#define SALIERI_DEFINED_Requires_lock_held
+#endif
+
+#if defined(_Requires_lock_not_held_) && defined(SALIERI_DEFINED_Requires_lock_not_held)
+#undef _Requires_lock_not_held_
+#endif
+#if !defined(_Requires_lock_not_held_)
+#define _Requires_lock_not_held_(expr)
+#define SALIERI_DEFINED_Requires_lock_not_held
+#endif
+
+#if defined(_Requires_no_locks_held_) && defined(SALIERI_DEFINED_Requires_no_locks_held)
+#undef _Requires_no_locks_held_
+#endif
+#if !defined(_Requires_no_locks_held_)
+#define _Requires_no_locks_held_
+#define SALIERI_DEFINED_Requires_no_locks_held
+#endif
+
+#if defined(_Requires_shared_lock_held_) && defined(SALIERI_DEFINED_Requires_shared_lock_held)
+#undef _Requires_shared_lock_held_
+#endif
+#if !defined(_Requires_shared_lock_held_)
+#define _Requires_shared_lock_held_(expr)
+#define SALIERI_DEFINED_Requires_shared_lock_held
+#endif
+
+#if defined(_Requires_exclusive_lock_held_) && defined(SALIERI_DEFINED_Requires_exclusive_lock_held)
+#undef _Requires_exclusive_lock_held_
+#endif
+#if !defined(_Requires_exclusive_lock_held_)
+#define _Requires_exclusive_lock_held_(expr)
+#define SALIERI_DEFINED_Requires_exclusive_lock_held
+#endif
+
+/* Shared Data Access Annotations */
+
+#if defined(_Guarded_by_) && defined(SALIERI_DEFINED_Guarded_by)
+#undef _Guarded_by_
+#endif
+#if !defined(_Guarded_by_)
+#define _Guarded_by_(expr)
+#define SALIERI_DEFINED_Guarded_by
+#endif
+
+#if defined(_Interlocked_) && defined(SALIERI_DEFINED_Interlocked)
+#undef _Interlocked_
+#endif
+#if !defined(_Interlocked_)
+#define _Interlocked_
+#define SALIERI_DEFINED_Interlocked
+#endif
+
+#if defined(_Interlocked_operand_) && defined(SALIERI_DEFINED_Interlocked_operand)
+#undef _Interlocked_operand_
+#endif
+#if !defined(_Interlocked_operand_)
+#define _Interlocked_operand_
+#define SALIERI_DEFINED_Interlocked_operand
+#endif
+
+#if defined(_Write_guarded_by_) && defined(SALIERI_DEFINED_Write_guarded_by)
+#undef _Write_guarded_by_
+#endif
+#if !defined(_Write_guarded_by_)
+#define _Write_guarded_by_(expr)
+#define SALIERI_DEFINED_Write_guarded_by
+#endif
+
+/* Specifying When and Where an Annotation Applies
+ *
+ * https://msdn.microsoft.com/en-us/library/jj159526.aspx
+ *****/
+
+#if defined(_At_) && defined(SALIERI_DEFINED_At)
+#undef _At_
+#endif
+#if !defined(_At_)
+#define _At_(expr, anno_list)
+#define SALIERI_DEFINED_At
+#endif
+
+#if defined(_At_buffer_) && defined(SALIERI_DEFINED_At_buffer)
+#undef _At_buffer_
+#endif
+#if !defined(_At_buffer_)
+#define _At_buffer_(expr, iter, elem_count, anno_list)
+#define SALIERI_DEFINED_At_buffer
+#endif
+
+#if defined(_Group_) && defined(SALIERI_DEFINED_Group)
+#undef _Group_
+#endif
+#if !defined(_Group_)
+#define _Group_(anno_list)
+#define SALIERI_DEFINED_Group
+#endif
+
+#if defined(_When_) && defined(SALIERI_DEFINED_When)
+#undef _When_
+#endif
+#if !defined(_When_)
+#define _When_(expr, anno_list)
+#define SALIERI_DEFINED_When
+#endif
+
+/* Intrinsic Functions
+ *
+ * https://msdn.microsoft.com/en-us/library/jj159527.aspx
+ *****/
+
+/* General Purpose */
+
+#if defined(_Curr_) && defined(SALIERI_DEFINED_Curr)
+#undef _Curr_
+#endif
+#if !defined(_Curr_)
+#define _Curr_
+#define SALIERI_DEFINED_Curr
+#endif
+
+#if defined(_Inexpressible_) && defined(SALIERI_DEFINED_Inexpressible)
+#undef _Inexpressible_
+#endif
+#if !defined(_Inexpressible_)
+#define _Inexpressible_(expr)
+#define SALIERI_DEFINED_Inexpressible
+#endif
+
+#if defined(_Nullterm_length_) && defined(SALIERI_DEFINED_Nullterm_length)
+#undef _Nullterm_length_
+#endif
+#if !defined(_Nullterm_length_)
+#define _Nullterm_length_(param)
+#define SALIERI_DEFINED_Nullterm_length
+#endif
+
+#if defined(_Old_) && defined(SALIERI_DEFINED_Old)
+#undef _Old_
+#endif
+#if !defined(_Old_)
+#define _Old_(expr)
+#define SALIERI_DEFINED_Old
+#endif
+
+#if defined(_Param_) && defined(SALIERI_DEFINED_Param)
+#undef _Param_
+#endif
+#if !defined(_Param_)
+#define _Param_(n)
+#define SALIERI_DEFINED_Param
+#endif
+
+/* String Specific */
+
+#if defined(_String_length_) && defined(SALIERI_DEFINED_String_length)
+#undef _String_length_
+#endif
+#if !defined(_String_length_)
+#define _String_length_(param)
+#define SALIERI_DEFINED_String_length
+#endif
+
+#if defined(SALIERI_VERSION)
+#undef SALIERI_VERSION
+#endif
+
+#define SALIERI_VERSION 1
+
+#endif /* !defined(SALIERI_VERSION) || (SALIERI_VERSION < X) */
diff --git a/wolf/ml/referee_ocr/w_image_processor.cpp b/wolf/ml/referee_ocr/w_image_processor.cpp
new file mode 100644
index 000000000..8ec55dc17
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_image_processor.cpp
@@ -0,0 +1,171 @@
+#include "w_image_processor.hpp"
+
+#include "salieri.h"
+
+// using config_for_ocr_struct = wolf::ml::ocr::config_for_ocr_struct;
+// using gaussian_blur = wolf::ml::ocr::gaussian_blur;
+// using make_contour_white_background =
+//     wolf::ml::ocr::make_contour_white_background;
+// using negative_image = wolf::ml::ocr::negative_image;
+// using prepare_image_for_contour_detection =
+//     wolf::ml::ocr::prepare_image_for_contour_detection;
+// using resize_image = wolf::ml::ocr::resize_image;
+// using threshold_image = wolf::ml::ocr::threshold_image;
+// using config_for_ocr_struct = wolf::ml::ocr::config_for_ocr_struct;
+// using namespace wolf::ml::ocr;
+
+namespace wolf::ml::ocr {
+
+std::vector<std::vector<cv::Point>>
+find_all_countors(_In_ cv::Mat &filtered_image) {
+  std::vector<std::vector<cv::Point>> contours;
+  std::vector<cv::Vec4i> hierarchy;
+
+  cv::findContours(filtered_image, contours, hierarchy, cv::RETR_TREE,
+                   cv::CHAIN_APPROX_SIMPLE, cv::Point(0, 0));
+
+  return contours;
+}
+
+void gaussian_blur(_Inout_ cv::Mat &frame_box,
+                   _In_ config_for_ocr_struct &ocr_config) {
+  int kernel_size = ocr_config.gaussian_blur_win_size;
+  cv::GaussianBlur(frame_box, frame_box, cv::Size(kernel_size, kernel_size), 0,
+                   0);
+}
+
+void make_contour_white_background(_Inout_ cv::Mat &contour_image,
+                                   _In_ config_for_ocr_struct &ocr_config) {
+  int height = contour_image.rows;
+  int width = contour_image.cols;
+  int n_channels = contour_image.channels();
+
+  if (ocr_config.make_white_background) {
+    if (n_channels == 1) {
+      for (int i = 0; i < height; i++) {
+        for (int j = 0; j < width; j++) {
+          if (contour_image.at<uchar>(i, j) >
+              ocr_config.white_background_threshold) {
+            contour_image.at<uchar>(i, j) = 180;
+          }
+        }
+      }
+    } else if (n_channels == 3) {
+      for (int i = 0; i < height; i++) {
+        for (int j = 0; j < width; j++) {
+          cv::Vec3b &color_pixel = contour_image.at<cv::Vec3b>(i, j);
+          int count = 0, combine = 0;
+          for (int i = 0; i < 3; i++) {
+            if (color_pixel[i] > ocr_config.white_background_threshold) {
+              count++;
+              combine += color_pixel[i];
+            }
+          }
+          if (count > 2 ||
+              combine > ocr_config.white_background_threshold * 2 + 100) {
+            color_pixel[0] =
+                255; // (color_pixel[0]*2 > 255) ? 255:color_pixel[0];
+            color_pixel[1] =
+                255; // (color_pixel[1]*2 > 255) ? 255:color_pixel[1];
+            color_pixel[2] =
+                255; // (color_pixel[2]*2 > 255) ? 255:color_pixel[2];
+          }
+        }
+      }
+    }
+  }
+}
+
+void negative_image(_Inout_ cv::Mat &contour_image) {
+  int height = contour_image.rows;
+  int width = contour_image.cols;
+  int n_channels = contour_image.channels();
+
+  if (n_channels == 1) {
+    for (int i = 0; i < height; i++) {
+      for (int j = 0; j < width; j++) {
+        contour_image.at<uchar>(i, j) = 255 - contour_image.at<uchar>(i, j);
+      }
+    }
+  } else if (n_channels == 3) {
+    for (int i = 0; i < height; i++) {
+      for (int j = 0; j < width; j++) {
+        cv::Vec3b &color_pixel = contour_image.at<cv::Vec3b>(i, j);
+        color_pixel[0] = 255 - color_pixel[0];
+        color_pixel[1] = 255 - color_pixel[1];
+        color_pixel[2] = 255 - color_pixel[2];
+      }
+    }
+  }
+}
+
+cv::Mat
+prepare_image_for_contour_detection(_In_ cv::Mat &image,
+                                    _In_ config_for_ocr_struct &ocr_config) {
+  cv::Mat filtered_image = image.clone();
+  if (ocr_config.do_resize) {
+    int dist_height = ocr_config.resized_height;
+    resize_image(filtered_image, dist_height);
+  }
+
+  if (ocr_config.do_blur) {
+    gaussian_blur(filtered_image, ocr_config);
+  }
+
+  if (ocr_config.do_threshold) {
+    threshold_image(filtered_image, ocr_config);
+  }
+  return filtered_image;
+}
+
+void resize_image(_Inout_ cv::Mat &frame_box, _In_ int dest_height,
+                  _In_ int dest_width) {
+  /*!<fraction = 1.0*/
+  float ratio;
+  cv::Size dim;
+
+  int frame_height = frame_box.rows;
+  int frame_width = frame_box.cols;
+
+  if (dest_width == -1 && dest_height == -1) {
+    return;
+  }
+
+  if (dest_width == -1) {
+    ratio = float(dest_height) / float(frame_height);
+    dim.width = int(frame_width * ratio);
+    dim.height = dest_height;
+    // fraction = r;
+  } else {
+    ratio = float(dest_width) / float(frame_width);
+    dim.width = dest_width;
+    dim.height = int(frame_height * ratio);
+    // fraction = r;
+  }
+  cv::resize(frame_box, frame_box, dim);
+}
+
+void threshold_image(_Inout_ cv::Mat &frame_box,
+                     _In_ config_for_ocr_struct &ocr_config) {
+  if (frame_box.channels() == 3) {
+    if (ocr_config.binary) {
+      cv::cvtColor(frame_box, frame_box, cv::COLOR_BGR2GRAY);
+      cv::threshold(frame_box, frame_box, 0, 255, cv::THRESH_OTSU);
+      cv::Mat kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3),
+                                                 cv::Point(0, 0));
+
+      cv::morphologyEx(frame_box, frame_box, cv::MORPH_CLOSE, kernel);
+    } else {
+      cv::inRange(frame_box,
+                  cv::Scalar(ocr_config.threshold_value,
+                             ocr_config.threshold_value,
+                             ocr_config.threshold_value),
+                  cv::Scalar(255, 255, 255), frame_box);
+    }
+  } else if (frame_box.channels() == 1) {
+    cv::threshold(frame_box, frame_box, ocr_config.threshold_value, 255,
+                  cv::THRESH_BINARY);
+  }
+  // return image;
+}
+} // namespace wolf::ml::ocr
diff --git a/wolf/ml/referee_ocr/w_image_processor.hpp b/wolf/ml/referee_ocr/w_image_processor.hpp
new file mode 100644
index 000000000..557152ac1
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_image_processor.hpp
@@ -0,0 +1,153 @@
+/*
+    Project: Wolf Engine. Copyright © 2014-2023 Pooya Eimandar
+    https://github.com/WolfEngine/WolfEngine
+*/
+
+#pragma once
+
+#include <opencv2/opencv.hpp>
+#include <string>
+#include <vector>
+
+#include "salieri.h"
+
+/*! \brief This class is responsible for image processing tasks.
+
+        This class contains functions, structures, and variables that use for
+   image processing purposes. In the project, in other classes, in the case of
+   processing image, one must create an object of the ImageProcessing class.
+*/
+
+namespace wolf::ml::ocr {
+
+//! Restriction struct.
+/*!
+                Characters must satisfy the struct restrictions.
+        */
+struct restrictions_struct {
+  int min_area;
+  int max_area;
+  int min_height;
+  int max_height;
+  int min_width;
+  int max_width;
+};
+
+//! OCR configuration struct.
+/*!
+                The necessary configurations for processing optical characters.
+        */
+struct config_for_ocr_struct {
+  /*!<If true, then the input image box change to the binary form.*/
+  bool binary = false;
+  /*!<The best height for processing. depend on the model.*/
+  int desired_contour_height = 32;
+  /*!<If true, it means the frame should be blurred.*/
+  bool do_blur = true;
+  /*!<The image box would be resized by the factor.*/
+  bool do_resize = false;
+  /*!<If true, it means the contour should be resized.*/
+  bool do_resize_contour = false;
+  /*!<If true, it means the frame should be thresholded.*/
+  bool do_threshold = true;
+  /*!<This fraction applies to finding out the space between two characters.*/
+  double fraction = 0.9;
+  /*!<Gaussian kernel size. the size must be positive and odd.*/
+  int gaussian_blur_win_size = 3;
+  /*!<If true, we are storing the image boxes*/
+  bool if_store_image_boxes = false;
+  /*!<If the character is white, then set it true.*/
+  bool is_white = true;
+  /*!<If the character is number, then set it true.*/
+  bool is_digit = true;
+  /*!<If the background needs to be white, then set it true.*/
+  bool make_white_background = false;
+  /*!<The margin between a character contour and the image window box.*/
+  int margin = 6;
+  /*!<The debugging path*/
+  std::string ocr_debug_path = "../../database/ocr_debug_data";
+  /*!<The contours with overlap more than this threshold would be combined.*/
+  double overlapped_threshold = 0.2;
+  /*!<Apply to resizing the image boxes.*/
+  double resized_fraction = 1.0;
+  /*!<The maximum height for an image window.*/
+  int resized_height = 40;
+  /*!<The maximum height for an image window.*/
+  int resized_width = 40;
+  /*!<The pixels with a value greater than the threshold change to 255.*/
+  int threshold_value = 110;
+  /*!<If true, then image converts to grayscale*/
+  bool to_gray = true;
+  /*!<If true, during the code execution some extra log would be shown.*/
+  bool verbose = false;
+  /*!<The character's background should be white.*/
+  int white_background_threshold = 150;
+  /*!<Characters must satisfy the struct restrictions.*/
+  restrictions_struct restrictions;
+};
+
+/*!
+        Find all contours in filtered image.
+        \param  filtered_image    The image needs to be processed.
+        \return vector of contours..
+        */
+std::vector<std::vector<cv::Point>>
+find_all_countors(_In_ cv::Mat &filtered_image);
+
+/*!
+        blur image by specified configuration
+        \param  frame_box    The image needs to be processed.
+        \param  ocr_config    The necessary configurations for processing
+   optical characters.
+        */
+void gaussian_blur(_Inout_ cv::Mat &frame_box,
+                   _In_ config_for_ocr_struct &ocr_config);
+
+/*!
+        takes an image and makes the background white. this function uses a
+   threshold to find background points \param  contour_image    The image needs
+   to be processed. \param  ocr_config    The necessary configurations for
+   processing optical characters.
+        */
+void make_contour_white_background(_Inout_ cv::Mat &contour_image,
+                                   _In_ config_for_ocr_struct &ocr_config);
+
+/*!
+          The negative_image function changed the pixels' value. The new value
+   is obtained by 255 - the previous value.
+
+          \param  contour_image    contour_image is a cropped part of the
+   original image that contains one of the contours.
+        */
+void negative_image(_Inout_ cv::Mat &contour_image);
+
+/*!
+          apply some filters to better find contours.
+
+          \param  image    The image needs to be processed.
+          \param  ocr_config    The necessary configurations for processing
+   optical characters.
+        */
+cv::Mat
+prepare_image_for_contour_detection(_In_ cv::Mat &image,
+                                    _In_ config_for_ocr_struct &ocr_config);
+
+/*!
+          resize image to specified size.
+          \param  frame_box    The image needs to be processed.
+          \param  dest_height    The height of destination image.
+          \param  dest_width    The width of destination image.
+        */
+void resize_image(_Inout_ cv::Mat &frame_box, _In_ int dest_height = -1,
+                  _In_ int dest_width = -1);
+
+/*!
+        The initial_filtering function prepares the input image for processing.
+        \param  frame_box     The image needs to be processed.
+        \param  ocr_config    The necessary configurations for processing
+   optical characters.
+        */
+void threshold_image(_Inout_ cv::Mat &frame_box,
+                     _In_ config_for_ocr_struct &ocr_config);
+
+} // namespace wolf::ml::ocr
\ No newline at end of file
diff --git a/wolf/ml/referee_ocr/w_ocr_engine.cpp b/wolf/ml/referee_ocr/w_ocr_engine.cpp
new file mode 100644
index 000000000..d13839db4
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_ocr_engine.cpp
@@ -0,0 +1,960 @@
+#include "w_ocr_engine.hpp"
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#include <cctype>
+#include <cstring>
+#include <filesystem>
+
+#include "w_utilities.hpp"
+
+namespace fs = std::filesystem;
+
+#ifdef __TELEMETRY
+#include "opentelemetry/sdk/version/version.h"
+#include "opentelemetry/trace/provider.h"
+
+namespace trace = opentelemetry::trace;
+namespace nostd = opentelemetry::nostd;
+
+namespace {
+nostd::shared_ptr<trace::Tracer> get_tracer() {
+  auto provider = trace::Provider::GetTracerProvider();
+  return provider->GetTracer("pes_21", OPENTELEMETRY_SDK_VERSION);
+}
+} // namespace
+#endif
+
+using w_ocr_engine = wolf::ml::ocr::w_ocr_engine;
+using config_for_ocr_struct = wolf::ml::ocr::config_for_ocr_struct;
+
+w_ocr_engine::w_ocr_engine() {
+  std::string key = "TESSERACT_LOG";
+  std::string tesseract_log = get_env_string(key.c_str());
+
+  digit_api->Init(nullptr, "eng", tesseract::OEM_LSTM_ONLY);
+  digit_api->SetPageSegMode(tesseract::PSM_SINGLE_CHAR);
+  digit_api->SetVariable("tessedit_char_whitelist", "0123456789");
+  digit_api->SetVariable("user_defined_dpi", "70");
+  digit_api->SetVariable("debug_file", tesseract_log.c_str());
+
+  word_api->Init(nullptr, "eng", tesseract::OEM_LSTM_ONLY);
+  word_api->SetPageSegMode(tesseract::PSM_SINGLE_CHAR);
+  word_api->SetVariable(
+      "tessedit_char_whitelist",
+      "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"); //	,"ABCDEFGHIJKLMNOPQRSTUVWXYZ");
+                                                               //// ,
+  word_api->SetVariable("user_defined_dpi", "70");
+  word_api->SetVariable("debug_file", tesseract_log.c_str());
+}
+
+w_ocr_engine::~w_ocr_engine() {
+  digit_api->End();
+  word_api->End();
+}
+
+bool w_ocr_engine::check_if_overlapped(_In_ cv::Rect box_1, _In_ cv::Rect box_2,
+                                       _In_ config_for_ocr_struct &ocr_config) {
+  bool if_overlapped = false;
+  int area_1, area_2, overlapped_area;
+
+  int dx = std::min(box_1.x + box_1.width, box_2.x + box_2.width) -
+           std::max(box_1.x, box_2.x);
+  int dy = std::min(box_1.y + box_1.height, box_2.y + box_2.height) -
+           std::max(box_1.y, box_2.y);
+
+  if (dx > 0 && dy > 0) {
+    area_1 = box_1.width * box_1.height;
+    area_2 = box_2.width * box_2.height;
+
+    overlapped_area = dx * dy;
+
+    if (double(overlapped_area) / double(area_1) >
+            ocr_config.overlapped_threshold ||
+        double(overlapped_area) / double(area_2) >
+            ocr_config.overlapped_threshold) {
+      if_overlapped = true;
+    }
+  }
+
+  return if_overlapped;
+}
+
+// this function is related to cluster_char_structs function
+bool compare_char_by_x_position(
+    const w_ocr_engine::characters_struct &first_charactor,
+    const w_ocr_engine::characters_struct &second_charactor) {
+  return first_charactor.center.x < second_charactor.center.x;
+}
+
+std::vector<w_ocr_engine::characters_struct>
+w_ocr_engine::contours_to_char_structs(
+    _In_ std::vector<std::vector<cv::Point>> contours) {
+  std::vector<characters_struct> modified_contours;
+  size_t number_of_contours = contours.size();
+
+  for (size_t i = 0; i < number_of_contours; i++) {
+    std::vector<cv::Point> contour_poly;
+    characters_struct temp_modified_contour;
+    temp_modified_contour.contour = contours[i];
+
+    double epsilon = 3;
+    bool closed = true;
+    cv::approxPolyDP(cv::Mat(contours[i]), contour_poly, epsilon, closed);
+
+    temp_modified_contour.bound_rect = cv::boundingRect(cv::Mat(contour_poly));
+
+    contour_poly.clear();
+    temp_modified_contour.center.x = temp_modified_contour.bound_rect.x +
+                                     temp_modified_contour.bound_rect.width / 2;
+
+    temp_modified_contour.center.y =
+        temp_modified_contour.bound_rect.y +
+        temp_modified_contour.bound_rect.height / 2;
+
+    temp_modified_contour.height = temp_modified_contour.bound_rect.height;
+
+    modified_contours.push_back(temp_modified_contour);
+  }
+  return modified_contours;
+}
+
+void w_ocr_engine::enhance_contour_image_for_model(
+    _Inout_ cv::Mat &contour_image, _In_ config_for_ocr_struct &ocr_config) {
+  if (!(ocr_config.make_white_background || ocr_config.do_resize_contour)) {
+    return;
+  }
+
+  if (ocr_config.make_white_background) {
+    make_contour_white_background(contour_image, ocr_config);
+  }
+
+  if (ocr_config.do_resize_contour) {
+    // float resize_fraction =
+    // float(ocr_config.desired_contour_height)/float(height);
+    int dist_height = ocr_config.desired_contour_height;
+    int dist_width = 24; // int(resize_fraction*width);
+
+    cv::resize(contour_image, contour_image, cv::Size(dist_width, dist_height),
+               0.0, 0.0, cv::InterpolationFlags::INTER_AREA);
+  }
+
+  return;
+}
+
+double w_ocr_engine::euclidean_distance(characters_struct &first_character,
+                                        characters_struct &second_character) {
+  double dist_x = std::pow(
+      float(first_character.center.x - second_character.center.x), 2.0);
+  double dist_y = std::pow(
+      float(first_character.center.y - second_character.center.y), 2.0);
+  double dist = std::pow(dist_x + dist_y, 0.5);
+
+  return dist;
+}
+
+auto w_ocr_engine::euclidean_distance(int x1, int x2, int y1, int y2)
+    -> double {
+  double dist_x = std::pow(float(x1 - x2), 2.0);
+  double dist_y = std::pow(float(y1 - y2), 2.0);
+  double dist = std::pow(dist_x + dist_y, 0.5);
+
+  return dist;
+}
+
+auto w_ocr_engine::spaces_between_two_chars(characters_struct left_char,
+                                            characters_struct right_char,
+                                            float height_to_dist_ratio)
+    -> std::string {
+  std::string temp_spaces = "";
+
+  int left_char_right_corner =
+      left_char.bound_rect.x + left_char.bound_rect.width;
+  int right_char_left_corner = right_char.bound_rect.x;
+
+  if (right_char_left_corner - left_char_right_corner > 0) {
+    if (float(right_char_left_corner - left_char_right_corner) >
+        float(left_char.bound_rect.height) * height_to_dist_ratio) {
+      temp_spaces = "  ";
+    } else {
+      temp_spaces = " ";
+    }
+  }
+
+  return temp_spaces;
+}
+
+std::vector<w_ocr_engine::character_and_center>
+w_ocr_engine::char_clusters_to_text(
+    std::vector<std::vector<characters_struct>> clustered_characters) {
+  std::vector<w_ocr_engine::character_and_center> words;
+
+  for (size_t i = 0; i < clustered_characters.size(); i++) {
+    std::sort(clustered_characters[i].begin(), clustered_characters[i].end());
+    character_and_center temp;
+    temp.center = clustered_characters[i][0].center;
+
+    std::string spaces = "";
+    float height_to_dist_ratio =
+        get_env_float("SOCCER_GLOBAL_HEIGHT_TO_DIST_RATIO");
+
+    for (size_t j = 0; j < clustered_characters[i].size(); j++) {
+      std::string temp_string =
+          split_string(clustered_characters[i][j].text, '\n')[0];
+      if (j < clustered_characters[i].size() - 1) {
+        spaces = spaces_between_two_chars(clustered_characters[i][j],
+                                          clustered_characters[i][j + 1],
+                                          height_to_dist_ratio);
+      }
+      temp_string += spaces;
+      temp.text.append(temp_string);
+    }
+
+    std::transform(temp.text.begin(), temp.text.end(), temp.text.begin(),
+                   ::toupper);
+
+    words.push_back(temp);
+  }
+
+  clustered_characters.clear();
+
+  std::sort(words.begin(), words.end());
+  return words;
+}
+
+std::vector<w_ocr_engine::characters_struct>
+w_ocr_engine::filter_chars_by_contour_size(
+    _Inout_ std::vector<characters_struct> &character,
+    _In_ config_for_ocr_struct &ocr_config) {
+  std::vector<characters_struct> filtered_characters;
+  for (int i = 0; i < character.size(); i++) {
+    double area = cv::contourArea(character[i].contour);
+    if (area < ocr_config.restrictions.min_area ||
+        area > ocr_config.restrictions.max_area) {
+      continue;
+    }
+    if (character[i].bound_rect.height < ocr_config.restrictions.min_height ||
+        character[i].bound_rect.height > ocr_config.restrictions.max_height ||
+        character[i].bound_rect.width < ocr_config.restrictions.min_width ||
+        character[i].bound_rect.width > ocr_config.restrictions.max_width) {
+      continue;
+    }
+    filtered_characters.push_back(character[i]);
+  }
+  return filtered_characters;
+}
+
+std::vector<w_ocr_engine::characters_struct>
+w_ocr_engine::image_to_char_structs(_In_ cv::Mat &image_box,
+                                    _In_ config_for_ocr_struct &ocr_config) {
+  cv::Mat filtered_image =
+      prepare_image_for_contour_detection(image_box, ocr_config);
+
+  std::vector<std::vector<cv::Point>> contours =
+      find_all_countors(filtered_image);
+  std::vector<characters_struct> characters =
+      contours_to_char_structs(contours);
+
+  std::vector<characters_struct> filtered_characters =
+      filter_chars_by_contour_size(characters, ocr_config);
+
+  merge_overlapped_contours(filtered_characters, ocr_config);
+
+  for (size_t i = 0; i < filtered_characters.size(); i++) {
+    margin_bounding_rect(filtered_characters[i].bound_rect, ocr_config.margin,
+                         filtered_image);
+  }
+
+  // TODO add this log "This code has not been optimized for color image, yet"
+  // << std::endl;
+  return filtered_characters;
+}
+
+auto w_ocr_engine::char_vec_to_string(
+    _In_ std::vector<w_ocr_engine::characters_struct> char_vector,
+    _In_ cv::Mat &frame, _In_ config_for_ocr_struct &ocr_config)
+    -> std::vector<character_and_center> {
+  std::vector<w_ocr_engine::characters_struct> labeled_characters =
+      label_chars_in_char_structs(char_vector, frame, ocr_config);
+  std::vector<std::vector<w_ocr_engine::characters_struct>>
+      clustered_characters =
+          cluster_char_structs(labeled_characters, ocr_config);
+  std::vector<w_ocr_engine::character_and_center> string =
+      char_clusters_to_text(clustered_characters);
+
+  return string;
+}
+
+std::vector<w_ocr_engine::character_and_center>
+w_ocr_engine::image_to_string(_In_ cv::Mat &image,
+                              _In_ config_for_ocr_struct &ocr_config) {
+  std::vector<characters_struct> characters =
+      image_to_char_structs(image, ocr_config);
+  std::vector<characters_struct> labeled_characters =
+      label_chars_in_char_structs(characters, image, ocr_config);
+  std::vector<std::vector<characters_struct>> clustered_characters =
+      cluster_char_structs(labeled_characters, ocr_config);
+  std::vector<character_and_center> string =
+      char_clusters_to_text(clustered_characters);
+
+  return string;
+}
+
+std::vector<w_ocr_engine::characters_struct>
+w_ocr_engine::label_chars_in_char_structs(
+    _In_ std::vector<w_ocr_engine::characters_struct> &characters,
+    _In_ cv::Mat &image_box, _In_ config_for_ocr_struct &ocr_config) {
+  std::vector<characters_struct> labeled_chars;
+  tesseract::TessBaseAPI *tess_api;
+  if (ocr_config.is_digit) {
+    tess_api = digit_api;
+  } else {
+    tess_api = word_api;
+  }
+
+  for (size_t i = 0; i < characters.size(); i++) {
+    cv::Mat temp_contour_image;
+    cv::Mat contour_image;
+    // Sometimes it is better to use the original image for w_ocr_engine
+    if (ocr_config.binary) {
+      cv::Mat filtered_image =
+          prepare_image_for_contour_detection(image_box, ocr_config);
+      filtered_image(characters[i].bound_rect).copyTo(contour_image);
+    } else {
+      // original_image(modified_bounding_rects[i].bound_rect).copyTo(contour_image);
+      contour_image = mask_contour(image_box, characters[i]);
+    }
+
+    if (ocr_config.is_white) {
+      negative_image(contour_image);
+    }
+
+    if (ocr_config.verbose) {
+      temp_contour_image = contour_image.clone();
+    }
+
+    enhance_contour_image_for_model(contour_image, ocr_config);
+    tess_api->SetImage(contour_image.data, contour_image.cols,
+                       contour_image.rows, 3, int(contour_image.step));
+
+    std::string text_data = tess_api->GetUTF8Text();
+
+    if (std::strcmp(text_data.c_str(), "") != 0) {
+      characters_struct temp_character;
+      temp_character = characters[i];
+      temp_character.text = split_string(text_data, '\n')[0];
+
+      if (!temp_character.text.empty()) {
+        temp_character.text = temp_character.text.substr(0, 1);
+      }
+
+      labeled_chars.push_back(temp_character);
+    }
+    contour_image.release();
+    temp_contour_image.release();
+  }
+  return labeled_chars;
+}
+
+void w_ocr_engine::margin_bounding_rect(_Inout_ cv::Rect &bounding_rect,
+                                        _In_ int margin,
+                                        _In_ cv::Mat &filtered_image) {
+  int height = filtered_image.rows;
+  int width = filtered_image.cols;
+  int temp;
+  int temp_margin_width = int(std::ceil(float(margin) / 2));
+  int temp_margin_height = int(std::ceil(float(margin) / 2));
+
+  if (bounding_rect.width < 1 && margin > 0) {
+    temp_margin_width = 2;
+  }
+
+  if (bounding_rect.width < bounding_rect.height / 5) {
+    // temp = (bounding_rect.x - 1 * bounding_rect.width);
+    // bounding_rect.x = temp > 0 ? temp : 0;
+    // temp = (bounding_rect.x + 4 * bounding_rect.width);
+    // bounding_rect.width = temp < width ? 4 * bounding_rect.width : (width -
+    // bounding_rect.x - 1);
+    temp = (bounding_rect.x - 1 * bounding_rect.height / 6);
+    bounding_rect.x = temp > 0 ? temp : 0;
+    temp = (bounding_rect.x + bounding_rect.height);
+    bounding_rect.width =
+        temp < width ? bounding_rect.height / 2 : (width - bounding_rect.x - 1);
+  } else {
+    temp = (bounding_rect.x - temp_margin_width);
+    bounding_rect.x = temp > 0 ? temp : 0;
+    temp = (bounding_rect.x + bounding_rect.width + 3 * temp_margin_width);
+    bounding_rect.width = temp < width
+                              ? bounding_rect.width + 3 * temp_margin_width
+                              : (width - bounding_rect.x - 1);
+  }
+
+  temp = (bounding_rect.y - temp_margin_height);
+  bounding_rect.y = temp > 0 ? temp : 0;
+  temp = (bounding_rect.y + bounding_rect.height + 2 * temp_margin_height);
+  bounding_rect.height = temp < height
+                             ? bounding_rect.height + 2 * temp_margin_height
+                             : (height - bounding_rect.y - 1);
+}
+
+cv::Mat w_ocr_engine::mask_contour(_In_ cv::Mat &image,
+                                   _In_ characters_struct &contour_info) {
+  cv::Mat temp_plane_image =
+      cv::Mat(cv::Size(image.cols, image.rows), CV_8UC1, cv::Scalar(0));
+  cv::Mat mask_image;
+  cv::Mat contour_image;
+
+  std::vector<std::vector<cv::Point>> temp_contours;
+  temp_contours.push_back(contour_info.contour);
+  std::vector<std::vector<cv::Point>> hull(temp_contours.size());
+  for (unsigned int i = 0, n = temp_contours.size(); i < n; ++i) {
+    cv::convexHull(cv::Mat(temp_contours[i]), hull[i], false);
+  }
+  cv::drawContours(temp_plane_image, temp_contours, 0, cv::Scalar(255), 3);
+  cv::fillPoly(temp_plane_image, temp_contours, cv::Scalar(255));
+
+  temp_plane_image(contour_info.bound_rect).copyTo(mask_image);
+  image(contour_info.bound_rect).copyTo(contour_image, mask_image);
+
+  temp_plane_image.release();
+  mask_image.release();
+  return contour_image;
+}
+
+void w_ocr_engine::merge_overlapped_contours(
+    _Inout_ std::vector<characters_struct> &character,
+    _In_ config_for_ocr_struct &ocr_config) {
+  cv::Rect ref_box;
+  int index;
+  std::vector<int> overlapped_boxes_index;
+  // int width, height;
+
+  bool flag;
+  if (character.size() > 0) {
+    flag = true;
+  } else {
+    flag = false;
+  }
+
+  index = 0;
+  while (flag) {
+    ref_box = character[index].bound_rect;
+
+    overlapped_boxes_index.clear();
+    for (int i = 0; i < character.size(); i++) {
+      if (i == index) {
+        continue;
+      }
+      if (check_if_overlapped(ref_box, character[i].bound_rect, ocr_config)) {
+        overlapped_boxes_index.push_back(i);
+      }
+    }
+
+    for (int j = overlapped_boxes_index.size() - 1; j >= 0; j--) {
+      character[index].bound_rect.x =
+          std::min(character[index].bound_rect.x,
+                   character[overlapped_boxes_index[j]].bound_rect.x);
+      character[index].bound_rect.y =
+          std::min(character[index].bound_rect.y,
+                   character[overlapped_boxes_index[j]].bound_rect.y);
+      character[index].bound_rect.width =
+          std::max(character[index].bound_rect.x +
+                       character[index].bound_rect.width,
+                   character[overlapped_boxes_index[j]].bound_rect.x +
+                       character[overlapped_boxes_index[j]].bound_rect.width) -
+          character[index].bound_rect.x;
+      character[index].bound_rect.height =
+          std::max(character[index].bound_rect.y +
+                       character[index].bound_rect.height,
+                   character[overlapped_boxes_index[j]].bound_rect.y +
+                       character[overlapped_boxes_index[j]].bound_rect.height) -
+          character[index].bound_rect.y;
+      character.erase(character.begin() + int(overlapped_boxes_index[j]));
+    }
+
+    overlapped_boxes_index.clear();
+    if (index >= character.size() - 1) {
+      flag = false;
+    }
+
+    index++;
+  }
+}
+
+std::vector<std::vector<w_ocr_engine::characters_struct>>
+w_ocr_engine::cluster_char_structs(
+    std::vector<w_ocr_engine::characters_struct> characters,
+    config_for_ocr_struct &ocr_config) {
+  std::vector<std::vector<characters_struct>> clustered_characters;
+
+  if (characters.size() == 0) {
+    return clustered_characters;
+  }
+
+  std::vector<characters_struct> temp_char_cluster;
+  std::vector<size_t> temp_index_list;
+  bool is_clustering;
+
+  temp_char_cluster.push_back(characters.back());
+  characters.pop_back();
+
+  if (characters.size() > 0) {
+    is_clustering = true;
+
+    while (is_clustering) {
+      for (size_t index = 0; index < characters.size(); index++) {
+        for (size_t i = 0; i < temp_char_cluster.size(); i++) {
+          if (~temp_char_cluster[i].processed) {
+            // double temp_dist = euclidean_distance(temp_char_cluster[i],
+            // characters[index]);
+
+            double temp_dist_1 =
+                euclidean_distance(temp_char_cluster[i].bound_rect.x,
+                                   characters[index].bound_rect.x +
+                                       characters[index].bound_rect.width,
+                                   temp_char_cluster[i].bound_rect.y +
+                                       temp_char_cluster[i].bound_rect.height,
+                                   characters[index].bound_rect.y +
+                                       characters[index].bound_rect.height);
+            double temp_dist_2 =
+                euclidean_distance(temp_char_cluster[i].bound_rect.x +
+                                       temp_char_cluster[i].bound_rect.width,
+                                   characters[index].bound_rect.x,
+                                   temp_char_cluster[i].bound_rect.y +
+                                       temp_char_cluster[i].bound_rect.height,
+                                   characters[index].bound_rect.y +
+                                       characters[index].bound_rect.height);
+
+            int temp_y_dist = std::abs(temp_char_cluster[i].bound_rect.y -
+                                       characters[index].bound_rect.y);
+
+            if ((temp_dist_1 < 0.8 * double(temp_char_cluster[i].height) ||
+                 temp_dist_2 < 0.8 * double(temp_char_cluster[i].height)) &&
+                temp_y_dist < temp_char_cluster[i].height) {
+              temp_index_list.push_back(index);
+              break;
+            }
+          }
+        }
+      }
+
+      for (size_t i = 0; i < temp_char_cluster.size(); i++) {
+        temp_char_cluster[i].processed = true;
+      }
+
+      if (temp_index_list.size() > 0) {
+        std::reverse(temp_index_list.begin(), temp_index_list.end());
+
+        for (size_t i = 0; i < temp_index_list.size(); i++) {
+          temp_char_cluster.push_back(characters[temp_index_list[i]]);
+          characters.erase(characters.begin() + int(temp_index_list[i]));
+        }
+
+        if (characters.size() == 0) {
+          clustered_characters.push_back(temp_char_cluster);
+          temp_char_cluster.clear();
+        }
+      } else {
+        clustered_characters.push_back(temp_char_cluster);
+        temp_char_cluster.clear();
+
+        temp_char_cluster.push_back(characters.back());
+        characters.pop_back();
+        if (characters.size() == 0) {
+          clustered_characters.push_back(temp_char_cluster);
+          temp_char_cluster.clear();
+        }
+      }
+
+      if (characters.size() == 0) {
+        is_clustering = false;
+      }
+
+      temp_index_list.clear();
+    }
+  } else {
+    clustered_characters.push_back(temp_char_cluster);
+    temp_char_cluster.clear();
+    // return;
+  }
+  return clustered_characters;
+}
+
+cv::Mat w_ocr_engine::show_in_better_way(cv::Mat &input_image,
+                                         int out_put_image_height,
+                                         float resize_factor) {
+  int height = out_put_image_height;
+  int width = height * 4 / 3;
+  cv::Mat temp_image;
+  if (resize_factor * input_image.rows > height) {
+    resize_factor = float(height / input_image.rows);
+  }
+  if (resize_factor * input_image.cols > width) {
+    resize_factor = float(width / input_image.cols);
+  }
+  if (input_image.channels() == 3) {
+    temp_image = cv::Mat(cv::Size(width, height), CV_8UC3, cv::Scalar(0, 0, 0));
+  } else {
+    temp_image = cv::Mat(cv::Size(width, height), CV_8UC1, cv::Scalar(0));
+  }
+
+  cv::Mat temp_contour = input_image.clone();
+  cv::resize(temp_contour, temp_contour,
+             cv::Size(input_image.cols * resize_factor,
+                      input_image.rows * resize_factor));
+  temp_contour.copyTo(
+      temp_image(cv::Rect(0, 0, input_image.cols * resize_factor,
+                          input_image.rows * resize_factor)));
+
+  temp_contour.release();
+  return temp_image;
+}
+
+std::vector<std::string> w_ocr_engine::split_string(std::string input_string,
+                                                    char reference) {
+  std::stringstream test(input_string);
+  std::string segment;
+  std::vector<std::string> seglist;
+
+  while (std::getline(test, segment, reference)) {
+    seglist.push_back(segment);
+  }
+
+  return seglist;
+}
+
+auto w_ocr_engine::same_height(
+    _In_ std::vector<characters_struct> pClusteredChars) -> bool {
+  bool result = true;
+  int average_height = 0;
+
+  for (int i = 0; i < pClusteredChars.size(); i++) {
+    average_height += pClusteredChars[i].height;
+  }
+  average_height /= pClusteredChars.size();
+  int min_height = average_height - average_height / 5;
+  int max_height = average_height + average_height / 5;
+
+  for (int i = 0; i < pClusteredChars.size(); i++) {
+    if (pClusteredChars[i].height > max_height ||
+        pClusteredChars[i].height < min_height) {
+      result = false;
+    }
+  }
+
+  return result;
+}
+
+auto w_ocr_engine::same_level(
+    _In_ std::vector<characters_struct> pClusteredChars) -> bool {
+  bool result = true;
+  int average_height = 0;
+  int average_level = 0;
+
+  for (int i = 0; i < pClusteredChars.size(); i++) {
+    average_height += pClusteredChars[i].height;
+    average_level +=
+        pClusteredChars[i].bound_rect.y + pClusteredChars[i].bound_rect.height;
+  }
+  average_height /= pClusteredChars.size();
+  average_level /= pClusteredChars.size();
+  int min_level = average_level - average_height / 10;
+  int max_level = average_level + average_height / 10;
+
+  for (int i = 0; i < pClusteredChars.size(); i++) {
+    if (pClusteredChars[i].bound_rect.y + pClusteredChars[i].bound_rect.height >
+            max_level ||
+        pClusteredChars[i].bound_rect.y + pClusteredChars[i].bound_rect.height <
+            min_level) {
+      result = false;
+    }
+  }
+
+  return result;
+}
+
+auto w_ocr_engine::show_contours(
+    _Inout_ cv::Mat &pImage,
+    _In_ std::vector<characters_struct> pClusteredChars,
+    _In_ std::string pWindowName, _In_ bool pShow) -> void {
+  cv::Mat mask_image;
+
+  for (int i = 0; i < pClusteredChars.size(); i++) {
+    std::vector<std::vector<cv::Point>> temp_contours;
+    temp_contours.push_back(pClusteredChars[i].contour);
+    std::vector<std::vector<cv::Point>> hull(temp_contours.size());
+    for (unsigned int i = 0, n = temp_contours.size(); i < n; ++i) {
+      cv::convexHull(cv::Mat(temp_contours[i]), hull[i], false);
+    }
+    cv::drawContours(pImage, temp_contours, 0, cv::Scalar(255), 3);
+    cv::fillPoly(pImage, temp_contours, cv::Scalar(255));
+  }
+
+  if (pShow) {
+    cv::imshow(pWindowName, pImage);
+    cv::waitKey();
+  }
+
+  return;
+}
+
+auto w_ocr_engine::fill_cluster_features(
+    _Inout_ std::vector<characters_struct> &pClusteredChar,
+    _In_ int pImageWidth, _In_ int pIndex) -> cluster_features {
+  cluster_features features;
+
+  features.index_in_parent_vector = pIndex;
+
+  features.min_x = pClusteredChar[0].bound_rect.x;
+  features.max_x =
+      pClusteredChar[0].bound_rect.x + pClusteredChar[0].bound_rect.width;
+  features.min_y = pClusteredChar[0].bound_rect.y;
+  features.average_y = pClusteredChar[0].bound_rect.y;
+  features.average_height = pClusteredChar[0].bound_rect.height;
+
+  for (int i = 1; i < pClusteredChar.size(); i++) {
+    features.min_x = (features.min_x > pClusteredChar[i].bound_rect.x)
+                         ? pClusteredChar[i].bound_rect.x
+                         : features.min_x;
+    features.max_x = (features.max_x > pClusteredChar[i].bound_rect.x +
+                                           pClusteredChar[i].bound_rect.width)
+                         ? features.max_x
+                         : pClusteredChar[i].bound_rect.x +
+                               pClusteredChar[i].bound_rect.width;
+    features.min_y = (features.min_y > pClusteredChar[i].bound_rect.y)
+                         ? pClusteredChar[i].bound_rect.y
+                         : features.min_y;
+    features.average_y += pClusteredChar[0].bound_rect.y;
+    features.average_height += pClusteredChar[0].bound_rect.height;
+  }
+
+  features.average_y /= pClusteredChar.size();
+  features.average_height /= pClusteredChar.size();
+
+  int mid = pImageWidth / 2;
+  int temp1 = mid - features.min_x;
+  int temp2 = mid - features.max_x;
+
+  if (temp1 >= 0) {
+    if (temp2 > 0) {
+      features.position = cluster_position::left;
+      features.symmetric_x1 = temp2;
+      features.symmetric_x2 = temp1;
+    } else {
+      features.position = cluster_position::middle;
+      features.symmetric_x1 = 0;
+      features.symmetric_x2 = 0;
+    }
+  } else {
+    if (temp2 >= 0) {
+      features.position = cluster_position::middle;
+      features.symmetric_x1 = 0;
+      features.symmetric_x2 = 0;
+    } else {
+      features.position = cluster_position::right;
+      features.symmetric_x1 = abs(temp1);
+      features.symmetric_x2 = abs(temp2);
+    }
+  }
+
+  return features;
+}
+
+auto w_ocr_engine::check_twin_clusters(_In_ cluster_features &pFirstInput,
+                                       _In_ cluster_features &pSecondInput,
+                                       _In_ float pThreshold) -> bool {
+  bool result = false;
+
+  float Y_diff_ration =
+      float(std::abs(pFirstInput.average_y - pSecondInput.average_y)) /
+      float((pFirstInput.average_height + pSecondInput.average_height) / 2);
+  float a, b, overlapped_ratio;
+
+  float height_diff_ratio =
+      (pFirstInput.average_height > pSecondInput.average_height)
+          ? float(pFirstInput.average_height - pSecondInput.average_height) /
+                float(pFirstInput.average_height)
+          : float(pSecondInput.average_height - pFirstInput.average_height) /
+                float(pSecondInput.average_height);
+
+  if (Y_diff_ration < 0.05 && height_diff_ratio < 0.05) {
+    a = (pFirstInput.symmetric_x1 < pSecondInput.symmetric_x1)
+            ? float(pSecondInput.symmetric_x1)
+            : float(pFirstInput.symmetric_x1);
+    b = (pFirstInput.symmetric_x2 < pSecondInput.symmetric_x2)
+            ? float(pFirstInput.symmetric_x2)
+            : float(pSecondInput.symmetric_x2);
+
+    overlapped_ratio =
+        (b - a) / float(pFirstInput.symmetric_x2 - pFirstInput.symmetric_x1);
+    float temp =
+        (b - a) / float(pSecondInput.symmetric_x2 - pSecondInput.symmetric_x1);
+
+    overlapped_ratio = (overlapped_ratio > temp) ? overlapped_ratio : temp;
+
+    if (overlapped_ratio > pThreshold) {
+      result = true;
+    }
+  }
+
+  return result;
+}
+
+auto w_ocr_engine::keep_twins(
+    _Inout_ std::vector<std::vector<characters_struct>> &pClusteredChar,
+    _In_ int pImageWidth, _In_ int pImageHeight, _In_ bool pWord) -> void {
+  std::vector<cluster_features> cluster_features_vector;
+  int n_cluster = pClusteredChar.size();
+
+  for (int i = 0; i < n_cluster; i++) {
+    cluster_features_vector.push_back(
+        fill_cluster_features(pClusteredChar[i], pImageWidth, i));
+  }
+
+  for (int i = 0; i < n_cluster - 1; i++) {
+    if (cluster_features_vector[i].matched) {
+      continue;
+    }
+    for (int j = i + 1; j < n_cluster; j++) {
+      if (cluster_features_vector[j].matched) {
+        continue;
+      }
+      if (check_twin_clusters(cluster_features_vector[i],
+                              cluster_features_vector[j], 0.6)) {
+        cluster_features_vector[i].matched = true;
+        cluster_features_vector[j].matched = true;
+
+        cluster_features_vector[i].twin_index_in_parent_vector =
+            cluster_features_vector[j].index_in_parent_vector;
+        cluster_features_vector[j].twin_index_in_parent_vector =
+            cluster_features_vector[i].index_in_parent_vector;
+      }
+    }
+  }
+
+  if (pWord) {
+    for (int i = 1; i < n_cluster; i++) {
+      if (!cluster_features_vector[i].matched) {
+        continue;
+      }
+
+      if (cluster_features_vector[i].average_y > pImageHeight * 4 / 5) {
+        cluster_features_vector[i].matched = false;
+        cluster_features_vector[cluster_features_vector[i]
+                                    .twin_index_in_parent_vector]
+            .matched = false;
+      }
+    }
+
+    int more = -1;
+
+    for (int i = 1; i < n_cluster; i++) {
+      if (!cluster_features_vector[i].matched) {
+        continue;
+      }
+      if (more == -1) {
+        more = pClusteredChar[i].size();
+      }
+
+      if (more < pClusteredChar[i].size()) {
+        more = pClusteredChar[i].size();
+      }
+    }
+
+    for (int i = 1; i < n_cluster; i++) {
+      if (!cluster_features_vector[i].matched) {
+        continue;
+      }
+
+      if (more > pClusteredChar[i].size() &&
+          more > pClusteredChar[cluster_features_vector[i]
+                                    .twin_index_in_parent_vector]
+                     .size()) {
+        cluster_features_vector[i].matched = false;
+        cluster_features_vector[cluster_features_vector[i]
+                                    .twin_index_in_parent_vector]
+            .matched = false;
+      }
+    }
+  } else {
+    int largest = -1;
+
+    for (int i = 1; i < n_cluster; i++) {
+      if (!cluster_features_vector[i].matched) {
+        continue;
+      }
+      if (largest == -1) {
+        largest = cluster_features_vector[i].average_height;
+      }
+
+      if (largest < cluster_features_vector[i].average_height) {
+        largest = cluster_features_vector[i].average_height;
+      }
+    }
+
+    for (int i = 1; i < n_cluster; i++) {
+      if (!cluster_features_vector[i].matched) {
+        continue;
+      }
+      if (largest == -1) {
+        largest = cluster_features_vector[i].average_height;
+      }
+
+      if (largest > cluster_features_vector[i].average_height &&
+          largest > cluster_features_vector[cluster_features_vector[i]
+                                                .twin_index_in_parent_vector]
+                        .average_height) {
+        cluster_features_vector[i].matched = false;
+        cluster_features_vector[cluster_features_vector[i]
+                                    .twin_index_in_parent_vector]
+            .matched = false;
+      } else {
+        largest = cluster_features_vector[i].average_height;
+      }
+    }
+  }
+
+  for (int i = 0; i < n_cluster; i++) {
+    int index = n_cluster - (i + 1);
+    if (!cluster_features_vector[index].matched) {
+      pClusteredChar.erase(pClusteredChar.begin() + index);
+    }
+  }
+
+  return;
+}
+
+auto w_ocr_engine::keep_time(
+    _Inout_ std::vector<std::vector<characters_struct>> &pClusteredChar)
+    -> void {
+  int n_cluster = pClusteredChar.size();
+  if (n_cluster == 0) {
+    return;
+  }
+  int height = pClusteredChar[n_cluster - 1][0].bound_rect.y;
+
+  for (int i = 1; i < n_cluster; i++) {
+    int index = n_cluster - (i + 1);
+    if (height < pClusteredChar[index][0].bound_rect.y) {
+      pClusteredChar.erase(pClusteredChar.begin() + index);
+    } else {
+      height = pClusteredChar[index][0].bound_rect.y;
+      pClusteredChar.pop_back();
+    }
+  }
+}
+
+auto w_ocr_engine::add_text_to_original_image(
+    _Inout_ cv::Mat &pImage,
+    _In_ std::vector<characters_struct> &pClusteredChar) -> void {
+  for (int i = 0; i < pClusteredChar.size(); i++) {
+    cv::putText(pImage, pClusteredChar[i].text,
+                cv::Point(pClusteredChar[i].bound_rect.x,
+                          pClusteredChar[i].bound_rect.y + 100),
+                cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(0, 255, 0), false);
+  }
+
+  return;
+}
diff --git a/wolf/ml/referee_ocr/w_ocr_engine.hpp b/wolf/ml/referee_ocr/w_ocr_engine.hpp
new file mode 100644
index 000000000..6e20db4ae
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_ocr_engine.hpp
@@ -0,0 +1,448 @@
+/*
+    Project: Wolf Engine. Copyright © 2014-2023 Pooya Eimandar
+    https://github.com/WolfEngine/WolfEngine
+*/
+
+#pragma once
+
+#include <tesseract/baseapi.h>
+
+#include <algorithm>
+#include <cmath>
+#include <iostream>
+#include <opencv2/opencv.hpp>
+#include <sstream>
+#include <string>
+#include <vector>
+
+#include "w_image_processor.hpp"
+
+namespace wolf::ml::ocr {
+
+//! optical character reader class.
+/*! \brief This class is responsible for manipulating the OCR tasks.
+
+        This class contains functions, structures, and variables that use
+   for optical character reading purposes. In the project, in other classes,
+   in the case of reading an optical character, one must create an object of
+   the OCR class.
+*/
+class w_ocr_engine {
+public:
+  //! The enum shows the position of the cluster in the whole image.
+  enum cluster_position { left, right, middle };
+  //! The struct contains the features related to a cluster.
+  struct cluster_features {
+    /*!<The minimum amount of x value on the x-axis between all characters in
+     * the cluster.*/
+    int min_x;
+    /*!<The maximum amount of x value on the x-axis between all characters in
+     * the cluster.*/
+    int max_x;
+    /*!<The minimum amount of y value on the y-axis between all characters in
+     * the cluster.*/
+    int min_y;
+    /*!<The average amount of y value of all characters.*/
+    int average_y;
+    /*!<The average height of all characters in pixel.*/
+    int average_height;
+    /*!<The distance between min_x and the middle of the frame.*/
+    int symmetric_x1;
+    /*!<The distance between max_x and the middle of the frame.*/
+    int symmetric_x2;
+    /*!<The position of the cluster in the frame.*/
+    cluster_position position;
+    /*!<The index of the current array in the parent vector.*/
+    int index_in_parent_vector;
+    /*!<The index of the twin array in the parent vector.*/
+    int twin_index_in_parent_vector;
+
+    /*!<If the cluster has a twin this variable should set true.*/
+    bool matched = false;
+  };
+  //! Struct of the character information.
+  struct characters_struct {
+    /*!<Change to true after processing the character.*/
+    bool processed = false;
+    /*!<This variable shows the height of the character in pixel.*/
+    int height;
+    /*!<This variable contains the coordination of the character.*/
+    cv::Point center;
+    /*!<Show the character bounding box corners.*/
+    cv::Rect bound_rect;
+    /*!<The character text.*/
+    std::string text;
+    /*!<The character contour area.*/
+    std::vector<cv::Point> contour;
+    /*!<The operator is added to the struct to make it sortable.*/
+    bool operator<(const characters_struct &rhs) const {
+      return center.x < rhs.center.x;
+    }
+  };
+  //! Struct of the character information.
+  struct result_boxes {
+    bool got_result = false;
+
+    characters_struct home_name;
+    characters_struct away_name;
+    characters_struct home_result;
+    characters_struct away_result;
+  };
+  //! Struct of the character value and position.
+  struct character_and_center {
+    std::string text = "";
+    cv::Point center;
+    /*!<The operator is added to the struct to make it sortable.*/
+    bool operator<(const character_and_center &rhs) const {
+      return center.x < rhs.center.x;
+    }
+  };
+  // config_for_ocr_struct config_for_ocr_struct2;
+
+  //! All configurations need for w_ocr_engine.
+  /*!
+          The necessary configurations use for creating w_ocr_engine class
+     objects.
+  */
+  struct config_struct {
+    /*!<Set a name for each window area.*/
+    std::string name;
+    /*!<If is time then true.*/
+    bool is_time = false;
+    bool relative = false;
+    bool is_result = false;
+    /*!<Show if the area has been checked.*/
+    bool if_checked = false;
+    /*!<Show the window corners.*/
+    cv::Rect window;
+    float fraction = 1.0;
+    /*!<OCR configuration struct.*/
+    config_for_ocr_struct config_for_ocr;
+  };
+
+  //! Result struct.
+  struct result {
+    int home_result;
+    int away_result;
+    std::string home_name;
+    std::string away_name;
+  };
+
+  /*!
+          The constructor of the class.
+
+          Tesseract objects are initialized in the constructor.
+  */
+  w_ocr_engine();
+  /*!
+          The deconstructor of the class.
+
+          Tesseract objects are ended in the deconstructor.
+  */
+  ~w_ocr_engine();
+
+  /*!
+          The char_vec_to_string function converts the input vector to the
+     related strings.
+
+          \param  frame    The image needs to be processed.
+          \param  frame_number    The current image is the nth image of the
+     video. frame_number contains the value of n. \param  ocr_config    The
+     necessary configurations for processing optical characters. \return returns
+     the text of the game scene
+  */
+  auto char_vec_to_string(
+      _In_ std::vector<w_ocr_engine::characters_struct> char_vector,
+      _In_ cv::Mat &frame, _In_ config_for_ocr_struct &ocr_config)
+      -> std::vector<character_and_center>;
+
+  /*!
+          The image_to_string function gets an image and returns the text of the
+     box.
+
+          \param  frame_box    The image needs to be processed.
+          \param  ocr_config    The necessary configurations for processing
+     optical characters. \return    returns the text of frame_box
+  */
+  std::vector<character_and_center>
+  image_to_string(_In_ cv::Mat &frame_box,
+                  _In_ config_for_ocr_struct &ocr_config);
+
+  /*!
+          The check_if_overlapped checks the input rect of boxes to decide if
+     two rects overlapped.
+
+          \param  box_1    The rect information of the first box.
+          \param  box_2    The rect information of the second box.
+          \param  ocr_config    The necessary configurations for processing
+     optical characters. \return    True, if two boxes overlapped.
+  */
+  bool check_if_overlapped(_In_ cv::Rect box_1, _In_ cv::Rect box_2,
+                           _In_ config_for_ocr_struct &ocr_config);
+
+  /*!
+          Get vector of contours and create a vector of char structs. this
+     structs does not have text.
+
+          \param  contours    a vector contains contours.
+          \return    a vector contains character structs
+  */
+  std::vector<w_ocr_engine::characters_struct>
+  contours_to_char_structs(_In_ std::vector<std::vector<cv::Point>> contours);
+
+  /*!
+          The enchance_contour_image function modifies the background of the
+     contour, makes the background white. The function also resizes the contour
+     image to reach a better w_ocr_engine result.
+
+          \param  contour_image    The modified contour image. The output image
+     of the function. \param  ocr_config    The necessary configurations for
+     processing optical characters.
+  */
+  void enhance_contour_image_for_model(_Inout_ cv::Mat &contour_image,
+                                       _In_ config_for_ocr_struct &ocr_config);
+
+  /*!
+          The euclidean_distance function calculates the euclidean distance of
+     two input characters.
+
+          \param  first_character    The first character.
+          \param  second_character    The second character.
+          \return    The calculated distance of two input characters.
+  */
+  double euclidean_distance(characters_struct &first_character,
+                            characters_struct &second_character);
+
+  auto euclidean_distance(int x1, int x2, int y1, int y2) -> double;
+
+  /*!
+          The spaces_between_two_chars function returns a string containing the
+     spaces that should be placed between characters.
+
+          \param  left_char    The left hand side character.
+          \param  right_char   The right hand side character.
+          \param  height_to_dist_ratio The ratio of the character height and
+     distance. \return    The spaces that should be placed between characters.
+  */
+  auto spaces_between_two_chars(_In_ characters_struct left_char,
+                                _In_ characters_struct right_char,
+                                _In_ float height_to_dist_ratio) -> std::string;
+
+  /*!
+          The char_clusters_to_text puts the clustered characters together to
+     create the word. This function uses one of the class variables as input and
+     stores the result in another variable of the class.
+  */
+  std::vector<character_and_center> char_clusters_to_text(
+      _In_ std::vector<std::vector<characters_struct>> clustered_characters);
+
+  /*!
+          The filter_chars_by_contour_size function eliminates abnormal contours
+     from the char struct vector and returns new vector.
+
+          \param  contours    A vector of all contours.
+          \param  ocr_config   The necessary configurations for processing
+     optical characters. \return    a vector of char structs.
+  */
+  std::vector<characters_struct>
+  filter_chars_by_contour_size(_In_ std::vector<characters_struct> &character,
+                               _In_ config_for_ocr_struct &ocr_config);
+
+  /*!
+          the image_to_char_structs takes an image and returns a vector of char
+     struct.
+
+          \param  frame_box    image contains characters.
+          \param  ocr_config   The necessary configurations for processing
+     optical characters. \return    a vector of char structs.
+  */
+  std::vector<characters_struct>
+  image_to_char_structs(_In_ cv::Mat &frame_box,
+                        _In_ config_for_ocr_struct &ocr_config);
+
+  /*!
+          Takes vector of char structs and recognize text in each struct.
+
+          \param  characters    vector of char structs
+          \param  frame_box    image contains characters.
+          \param  ocr_config   The necessary configurations for processing
+     optical characters. \return    a vector of char structs.
+  */
+  std::vector<characters_struct>
+  label_chars_in_char_structs(_In_ std::vector<characters_struct> &characters,
+                              _In_ cv::Mat &frame_box,
+                              _In_ config_for_ocr_struct &ocr_config);
+
+  /*!
+          The margin_bounding_rect function margins the contours. It is
+     necessary for obtaining better results.
+
+          \param  bounding_rect    A vector of the bounding rect of the
+     contours. \param  margin    The margin value. \param  filtered_image image
+     contains characters.
+
+  */
+  void margin_bounding_rect(_Inout_ cv::Rect &bounding_rect, _In_ int margin,
+                            _In_ cv::Mat &filtered_image);
+
+  /*!
+          The mask_contour function applies the mask of the contour area to the
+     input image. The resulting image should contain the contour.
+
+          \param  image    The input image. A window of the original image. The
+     window contains all characters of one property. \param  contour_info
+     Information of the desired contour. \return  The modified contour image.
+     The output image of the function.
+  */
+  cv::Mat mask_contour(_In_ cv::Mat &image,
+                       _In_ characters_struct &contour_info);
+
+  /*!
+          The merge_overlapped_contours function merges the overlapped contours.
+
+          \param  bound_rect    A vector of the bounding rect of the contours.
+          \param  ocr_config    The necessary configurations for processing
+     optical characters.
+  */
+  void
+  merge_overlapped_contours(_Inout_ std::vector<characters_struct> &bound_rect,
+                            _In_ config_for_ocr_struct &ocr_config);
+
+  /*!
+          The cluster_char_structs function puts related characters togethter.
+
+          \param  ocr_config    The necessary configurations for processing
+     optical characters.
+  */
+  std::vector<std::vector<characters_struct>>
+  cluster_char_structs(std::vector<w_ocr_engine::characters_struct> characters,
+                       config_for_ocr_struct &ocr_config);
+
+  /*!
+          The function resizes the input image and maps it in the output image.
+     It helps the programmers to check their algorithm's influence on the input
+     image in a better way.
+
+          \param  input_image    The input image.
+          \param  out_put_image_height    The height of output image.
+          \param  resize_factor    The resize factor.
+          \return    returns resized image
+  */
+  cv::Mat show_in_better_way(cv::Mat &input_image,
+                             int out_put_image_height = 400,
+                             float resize_factor = 5);
+
+  /*!
+          The split_string function uses for splitting input strings based on
+     the reference character.
+
+          \param  input_string    The input string.
+          \param  reference    The strings that are located between two
+     references would be placed in a string. \return    A vector of split
+     string.
+  */
+  std::vector<std::string> split_string(std::string input_string,
+                                        char reference);
+
+  /*!
+          The same_height function returns true if all characters in the cluster
+     share the same height.
+
+          \param  pClusteredChars    The cluster contains many characters.
+          \return    The result would be true if all characters in the cluster
+     share the same height.
+  */
+  auto same_height(_In_ std::vector<characters_struct> pClusteredChars) -> bool;
+
+  /*!
+          The same_level function returns true if all characters in the cluster
+     share the same y-position.
+
+          \param  pClusteredChars    The cluster contains many characters.
+          \return    The result would be true if all characters in the cluster
+     share the same y-position.
+  */
+  auto same_level(_In_ std::vector<characters_struct> pClusteredChars) -> bool;
+
+  /*!
+          The same_level function returns true if all characters in the cluster
+     share the same y-position.
+
+          \param  image    A frame of the game.
+          \param  pClusteredChars    The cluster contains many characters.
+          \param  pWindowName    The cv::imshow image name.
+          \param  pShow
+          \return    The output would be a cv image containing the clusters.
+  */
+  static auto show_contours(_Inout_ cv::Mat &pImage,
+                            _In_ std::vector<characters_struct> pClusteredChars,
+                            _In_ std::string pWindowName,
+                            _In_ bool pShow = true) -> void;
+
+  /*!
+          The fill_cluster_features function extracts all feature of the input
+     cluster.
+
+          \param  pClusteredChars    The cluster contains many characters.
+          \param  pImageWidth    The width of input image in pixel.
+          \param  pIndex    The index of the array in the vector.
+          \return    An structure of the cluster features.
+  */
+  auto
+  fill_cluster_features(_Inout_ std::vector<characters_struct> &pClusteredChar,
+                        _In_ int pImageWidth, _In_ int pIndex)
+      -> cluster_features;
+
+  /*!
+          The check_twin_clusters function checks the input cluster features and
+     decides whether two input clusters are twins.
+
+          \param  pFirstInput    The first cluster features.
+          \param  pSecondInput    The second cluster features.
+          \param  pThreshold    The threshold for decision-making.
+          \return    The result would be true if the input clusters are twins.
+  */
+  auto check_twin_clusters(_In_ cluster_features &pFirstInput,
+                           _In_ cluster_features &pSecondInput,
+                           _In_ float pThreshold) -> bool;
+
+  /*!
+          The keep_twins function eliminates the single clusters.
+
+          \param  pClusteredChars    The cluster contains many characters.
+          \param  pImageWidth    The width of input image in pixel.
+          \param	pWord    The value would be "true" if it is a word
+     cluster. \return
+  */
+  auto keep_twins(
+      _Inout_ std::vector<std::vector<characters_struct>> &pClusteredChar,
+      _In_ int pImageWidth, _In_ int pImageHeight, _In_ bool pWord) -> void;
+
+  /*!
+          The keep_time function keeps the time cluster.
+
+          \param  pClusteredChars    The cluster contains many characters.
+          \return
+  */
+  auto
+  keep_time(_Inout_ std::vector<std::vector<characters_struct>> &pClusteredChar)
+      -> void;
+
+  /*!
+          The add_text_to_original_image adds texts to the input image.
+
+          \param  pImage    The input image.
+          \param  pClusteredChars    The cluster contains many characters.
+          \return
+  */
+  auto add_text_to_original_image(
+      _Inout_ cv::Mat &pImage,
+      _In_ std::vector<characters_struct> &pClusteredChar) -> void;
+
+private:
+  /*!<An object of tesseract library (to recognize digits)..*/
+  tesseract::TessBaseAPI *digit_api = new tesseract::TessBaseAPI();
+  /*!<An object of tesseract library (to recognize words).*/
+  tesseract::TessBaseAPI *word_api = new tesseract::TessBaseAPI();
+};
+} // namespace wolf::ml::ocr
diff --git a/wolf/ml/referee_ocr/w_read_video_frames.cpp b/wolf/ml/referee_ocr/w_read_video_frames.cpp
new file mode 100644
index 000000000..6b3c945b1
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_read_video_frames.cpp
@@ -0,0 +1,120 @@
+#include "w_read_video_frames.hpp"
+#ifdef __TELEMETRY
+#include "opentelemetry/logs/provider.h"
+#include "opentelemetry/sdk/version/version.h"
+#include "opentelemetry/trace/provider.h"
+
+namespace trace = opentelemetry::trace;
+namespace nostd = opentelemetry::nostd;
+
+namespace {
+nostd::shared_ptr<trace::Tracer> get_tracer() {
+  auto provider = trace::Provider::GetTracerProvider();
+  return provider->GetTracer("pes_21", OPENTELEMETRY_SDK_VERSION);
+}
+
+} // namespace
+#endif
+
+using w_read_video_frames = wolf::ml::ocr::w_read_video_frames;
+
+w_read_video_frames::w_read_video_frames(std::string video_path) {
+  path = video_path;
+
+  cap = cv::VideoCapture(path.c_str(), cv::CAP_ANY);
+  if (!cap.isOpened()) {
+    std::cout << "Error opening video stream or file" << std::endl;
+  }
+  frame_count = cap.get(cv::CAP_PROP_FRAME_COUNT);
+}
+
+cv::Mat w_read_video_frames::read_video_frame_by_frame() {
+  cv::Mat frame;
+  if (!cap.read(frame)) {
+    release();
+    return frame;
+  }
+  frame_number += 1;
+  return frame;
+}
+
+void w_read_video_frames::write_image_to_video(std::string out_video_path) {
+#ifdef __TELEMETRY
+  auto scoped_span =
+      trace::Scope(get_tracer()->StartSpan("write_image_to_video"));
+#endif
+  cv::Mat frame;
+
+  frame = read_video_frame_by_frame();
+  if (frame.empty()) {
+    std::cout << "Error opening video stream" << std::endl;
+    return;
+  }
+  int frame_width = frame.cols;
+  int frame_height = frame.rows;
+
+  // Define the codec and create VideoWriter object.The output is stored in
+  // 'outcpp.avi' file.
+  cv::VideoWriter video(out_video_path,
+                        cv::VideoWriter::fourcc('M', 'J', 'P', 'G'), 60.0,
+                        cv::Size(frame_width, frame_height));
+
+  while (true) {
+    frame = read_video_frame_by_frame();
+    if (frame.empty())
+      break;
+
+    // Write the frame into the file 'outcpp.avi'
+    video.write(frame);
+    cv::waitKey(10);
+  }
+
+  video.release();
+  frame.release();
+
+  return;
+}
+
+void w_read_video_frames::release() { cap.release(); }
+
+cv::Mat w_read_video_frames::read_specific_frame(int input_frame_number) {
+  frame_number = input_frame_number;
+
+  cv::Mat frame;
+  if (frame_number > int(frame_count)) {
+    release();
+    return frame;
+  }
+  cap.set(1, frame_number);
+
+  if (!cap.read(frame)) {
+    return frame;
+  }
+
+  return frame;
+}
+
+int w_read_video_frames::get_current_frame_number() { return frame_number; }
+
+double w_read_video_frames::get_frame_amount() { return frame_count; }
+
+void w_read_video_frames::video_player() {
+  w_read_video_frames player(path);
+
+  int skip = 100;
+  int frame_number = 52000 - skip;
+
+  while (true) {
+    frame_number += skip;
+
+    cv::Mat frame = player.read_specific_frame(frame_number);
+    cv::imshow("video player", frame);
+    std::cout << frame_number << std::endl;
+    int key = cv::waitKey();
+    //        std::cout << key << std::endl;
+
+    if (key == 1113937 || key == 1113940) {
+      frame_number -= 2 * skip;
+    }
+  }
+}
diff --git a/wolf/ml/referee_ocr/w_read_video_frames.hpp b/wolf/ml/referee_ocr/w_read_video_frames.hpp
new file mode 100644
index 000000000..6c571acf1
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_read_video_frames.hpp
@@ -0,0 +1,82 @@
+/*
+    Project: Wolf Engine. Copyright © 2014-2023 Pooya Eimandar
+    https://github.com/WolfEngine/WolfEngine
+*/
+
+#pragma once
+
+#include <iostream>
+#include <opencv2/opencv.hpp>
+
+#include "wolf.hpp"
+
+namespace wolf::ml::ocr {
+
+//! read frames of the video class.
+/*! \brief This class is responsible for reading the frame of the input
+   video.
+
+        This class contains functions, structures, and variables that use
+   for reading the frames of the input video.
+*/
+class w_read_video_frames {
+public:
+  /*!<The path of the video.*/
+  std::string path;
+  /*!<Video Capture APIs.*/
+  cv::VideoCapture cap;
+  /*!<The frame number in the video frames.*/
+  int frame_number = 0;
+  /*!<Number of frames of the video.*/
+  double frame_count;
+
+  /*!
+  The constructor of the class.
+
+  \param  video_path    The path of video.
+  */
+  W_API w_read_video_frames(std::string video_path);
+
+  /*!
+  The read_video_frame_by_frame function extracts frames of the input video one
+  by one in order.
+
+  \return    The next frame of video
+  */
+  W_API cv::Mat read_video_frame_by_frame();
+  /*!
+  The write_image_to_video function puts related images next to each other for
+  creating a video.
+
+  \param  out_video_path    The path of output video.
+*/
+  W_API void write_image_to_video(std::string out_video_path);
+  /*!
+  The read_specific_frame function reads a specific frame of the video.
+
+  \param  input_frame_number     Frame number of desired frame in the video
+  frames. \return    Specific frame of the video
+*/
+  W_API cv::Mat read_specific_frame(int input_frame_number);
+  /*!
+  The get_current_frame_number function returns the current frame number.
+
+  \return    Current frame number.
+*/
+  W_API int get_current_frame_number();
+  /*!
+  The get_frame_amount function returns the number of frames of the video.
+
+  \return    Number of frames of the video.
+*/
+  W_API double get_frame_amount();
+  /*!
+  The video_player function implements a simple video player based on OpenCV.
+*/
+  [[noreturn]] void video_player();
+  /*!
+  The release function call cv::VideoCapture::release() function.
+*/
+  void release();
+}; // namespace wolf::ml::ocr
+} // namespace wolf::ml::ocr
\ No newline at end of file
diff --git a/wolf/ml/referee_ocr/w_referee.cpp b/wolf/ml/referee_ocr/w_referee.cpp
new file mode 100644
index 000000000..3b01207e5
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_referee.cpp
@@ -0,0 +1,115 @@
+#include "w_referee.hpp"
+
+#include <chrono>
+#include <opencv2/opencv.hpp>
+
+using w_referee = wolf::ml::ocr::w_referee;
+using w_ocr_engine = wolf::ml::ocr::w_ocr_engine;
+
+w_referee::w_referee() {}
+
+void w_referee::match_result_struct::release() {
+  match_result_struct::result_image.release();
+}
+
+w_ocr_engine::character_and_center w_referee::concatenate_name_result(
+    std::vector<w_ocr_engine::character_and_center> &result) {
+  w_ocr_engine::character_and_center temp_concatenated_result = result[0];
+
+  for (size_t i = 1; i < result.size(); i++) {
+    temp_concatenated_result.text =
+        temp_concatenated_result.text + " " + result[i].text;
+  }
+
+  return temp_concatenated_result;
+}
+
+auto w_referee::if_the_string_is_in_the_vector(
+    w_ocr_engine::character_and_center the_character,
+    std::vector<vote_over_string_vector> &the_vector) -> bool {
+  bool is_in_the_vector = false;
+
+  for (size_t i = 0; i < the_vector.size(); i++) {
+    // std::cout << the_string.c_str() << " : " << the_vector[i].str.c_str() <<
+    // "  " << std::strcmp(the_string.c_str(), the_vector[i].str.c_str()) <<
+    // std::endl;
+    if (std::strcmp(the_character.text.c_str(), the_vector[i].str.c_str()) ==
+        0) {
+      is_in_the_vector = true;
+      the_vector[i].already_voted++;
+      break;
+    }
+  }
+
+  if (!is_in_the_vector) {
+    vote_over_string_vector temp;
+    temp.str = the_character.text;
+    temp.center = the_character.center;
+    the_vector.push_back(temp);
+  }
+
+  return is_in_the_vector;
+}
+
+auto w_referee::voting_over_results_and_names(
+    frame_result_struct &voted_results,
+    std::vector<frame_result_struct> &all_results) -> void {
+  std::vector<vote_over_string_vector> home_result{};
+  std::vector<vote_over_string_vector> away_result{};
+  std::vector<vote_over_string_vector> home_name{};
+  std::vector<vote_over_string_vector> away_name{};
+  std::vector<vote_over_string_vector> home_penalty_result{};
+  std::vector<vote_over_string_vector> away_penalty_result{};
+
+  home_result.clear();
+  away_result.clear();
+  home_name.clear();
+  away_name.clear();
+
+  for (int j = 0; j < all_results.size(); j++) {
+    if_the_string_is_in_the_vector(all_results[size_t(j)].home_result,
+                                   home_result);
+    if_the_string_is_in_the_vector(all_results[size_t(j)].away_result,
+                                   away_result);
+    if_the_string_is_in_the_vector(all_results[size_t(j)].home_name, home_name);
+    if_the_string_is_in_the_vector(all_results[size_t(j)].away_name, away_name);
+    if (all_results[size_t(j)].home_penalty_result.text.compare("") != 0) {
+      if_the_string_is_in_the_vector(all_results[size_t(j)].home_penalty_result,
+                                     home_penalty_result);
+    }
+    if (all_results[size_t(j)].away_penalty_result.text.compare("") != 0) {
+      if_the_string_is_in_the_vector(all_results[size_t(j)].away_penalty_result,
+                                     away_penalty_result);
+    }
+  }
+
+  std::sort(home_result.begin(), home_result.end());
+  std::sort(away_result.begin(), away_result.end());
+  std::sort(home_name.begin(), home_name.end());
+  std::sort(away_name.begin(), away_name.end());
+  if (home_penalty_result.size() != 0 && away_penalty_result.size() != 0) {
+    std::sort(home_penalty_result.begin(), home_penalty_result.end());
+    std::sort(away_penalty_result.begin(), away_penalty_result.end());
+    voted_results.home_penalty_result.text =
+        home_penalty_result[home_penalty_result.size() - 1].str;
+    voted_results.home_penalty_result.center =
+        home_penalty_result[home_penalty_result.size() - 1].center;
+    voted_results.away_penalty_result.text =
+        away_penalty_result[away_penalty_result.size() - 1].str;
+    voted_results.away_penalty_result.center =
+        away_penalty_result[away_penalty_result.size() - 1].center;
+  }
+  voted_results.home_result.text = home_result[home_result.size() - 1].str;
+  voted_results.home_result.center = home_result[home_result.size() - 1].center;
+  voted_results.away_result.text = away_result[away_result.size() - 1].str;
+  voted_results.away_result.center = away_result[away_result.size() - 1].center;
+  voted_results.home_name.text = home_name[home_name.size() - 1].str;
+  voted_results.home_name.center = home_name[home_name.size() - 1].center;
+  voted_results.away_name.text = away_name[away_name.size() - 1].str;
+  voted_results.away_name.center = away_name[away_name.size() - 1].center;
+
+  voted_results.frame_number = all_results[0].frame_number;
+  voted_results.stat = all_results[0].stat;
+
+  return;
+}
diff --git a/wolf/ml/referee_ocr/w_referee.hpp b/wolf/ml/referee_ocr/w_referee.hpp
new file mode 100644
index 000000000..f84f0c933
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_referee.hpp
@@ -0,0 +1,198 @@
+/*
+    Project: Wolf Engine. Copyright © 2014-2023 Pooya Eimandar
+    https://github.com/WolfEngine/WolfEngine
+*/
+
+#pragma once
+
+#include <iostream>
+#include <opencv2/opencv.hpp>
+
+#include "w_ocr_engine.hpp"
+#include "w_read_video_frames.hpp"
+#include "wolf.hpp"
+
+namespace wolf::ml::ocr {
+
+//! w_referee class.
+/*! \brief This class is a bridge between the w_ocr_engine class and the referee
+   task.
+
+        This class contains functions, structures, and variables that use the
+   w_ocr_engine class for doing referee purposes.
+*/
+class w_referee {
+public:
+  //! The result_type enum shows the state of the result.
+  /*!
+          The result of the game would be stored in the database based on this
+     enum and each stat has own properties.
+  */
+  enum result_type {
+    first_half,
+    second_half,
+    extra_first_half,
+    extra_second_half,
+    penalty,
+    final_result
+  };
+
+  //! A structure for the frame result.
+  /*!
+    The structure will be filled after the end of each frame processing and
+    contain the frame necessary results.
+  */
+  struct frame_result_struct {
+    /*!<The home team scores(left).*/
+    w_ocr_engine::character_and_center home_result;
+    /*!<The away team scores.*/
+    w_ocr_engine::character_and_center away_result;
+    /*!<The home team name.*/
+    w_ocr_engine::character_and_center home_name;
+    /*!<The away team name.*/
+    w_ocr_engine::character_and_center away_name;
+    /*!<The home team penalty scores(left).*/
+    w_ocr_engine::character_and_center home_penalty_result;
+    /*!<The away team penalty scores.*/
+    w_ocr_engine::character_and_center away_penalty_result;
+    /*!<The frame number of the result image.*/
+    int frame_number;
+    /*!<The stat of the game.*/
+    std::string stat;
+    /*!<The operator is added to the struct to make it sortable.*/
+    bool operator<(const frame_result_struct &rhs) const {
+      return frame_number < rhs.frame_number;
+    }
+  };
+
+  //! A structure for the match result.
+  /*!
+    The structure will be filled after the end of each game processing and
+    contain the match necessary results.
+  */
+  struct match_result_struct {
+    /*!<The results of frames share the same stat.*/
+    std::vector<frame_result_struct> all_frames_results;
+    /*!<The home team scores(left).*/
+    w_ocr_engine::character_and_center home_result;
+    /*!<The away team scores.*/
+    w_ocr_engine::character_and_center away_result;
+    /*!<The home team name.*/
+    w_ocr_engine::character_and_center home_name;
+    /*!<The away team name.*/
+    w_ocr_engine::character_and_center away_name;
+    /*!<The home team penalty scores(left).*/
+    w_ocr_engine::character_and_center home_penalty_result;
+    /*!<The away team penalty scores.*/
+    w_ocr_engine::character_and_center away_penalty_result;
+
+    /*!<The frame number.*/
+    int frame_number;
+    /*!<The stat of the game.*/
+    std::string stat;
+    /*!<This image is related to the extracted result.*/
+    cv::Mat result_image;
+
+    /*!<The ready variable shows the match result is ready.*/
+    bool ready = false;
+    /*!<The ready variable shows the match result is extracted..*/
+    bool extracted = false;
+    /*!<The ready variable shows the match result is applied.*/
+    bool applied = false;
+
+  public:
+    /*!
+      Release the memory.
+
+      This function frees the allocated memory.
+    */
+    void release();
+  };
+
+  /*!
+          The constructor of the class.
+
+          The function is empty.
+    */
+  W_API w_referee();
+
+public:
+  //! Contain the text and its repetition in the results.
+  /*!
+    The final result is extracted from a series of results. This struct contains
+    its vote throw the process.
+  */
+  struct vote_over_string_vector {
+    /*!<The candidate text.*/
+    std::string str;
+    /*!<The center coordination of the characters.*/
+    cv::Point center;
+    /*!<The text vote number.*/
+    int already_voted = 1;
+    /*!<The operator is added to the struct to make it sortable.*/
+    bool operator<(const vote_over_string_vector &rhs) const {
+      return already_voted < rhs.already_voted;
+    }
+  };
+
+  //! Start and End of each match.
+  /*!
+    The input video may contain multiple matches. It is a way to track the start
+    and end frame of each game.
+  */
+  struct related_results {
+    /*!<The frame number of the first image of the game.*/
+    int start;
+    /*!<The frame number of the last image of the game.*/
+    int end;
+    /*!<The operator is added to the struct to make it sortable.*/
+    bool operator<(const related_results &rhs) const {
+      return start < rhs.start;
+    }
+  };
+  /*!<This config helps to avoid processing of the frames which does not contain
+   * the game result.*/
+  w_ocr_engine::config_struct if_extract_game_result;
+  /*!<The config for part of the image contains the score of the home team.*/
+  w_ocr_engine::config_struct extract_game_result_home;
+  /*!<The config for part of the image contains the name of the home team.*/
+  w_ocr_engine::config_struct extract_home_name;
+  /*!<The config for part of the image contains the score of the away team.*/
+  w_ocr_engine::config_struct extract_game_result_away;
+  /*!<The config for part of the image contains the name of the away team.*/
+  w_ocr_engine::config_struct extract_away_name;
+  /*!
+          The function concatenates the separated alphabet of the team name.
+
+          \param result A vector of alphabets.
+          \return return the whole word of the team name.
+  */
+  w_ocr_engine::character_and_center concatenate_name_result(
+      std::vector<w_ocr_engine::character_and_center> &result);
+
+  /*!
+          The function updates the vector of voting.
+
+          First, it checks if the input string is in the vector. If true, then
+     the voting value would be incremented. Otherwise, a new variable would be
+     added to the vector.
+
+          \param the_character the input string and the related information
+     related to the string. \param the_vector vector of string with theirs
+     repetition number. \return is the string in the vector?
+  */
+  W_API auto if_the_string_is_in_the_vector(
+      w_ocr_engine::character_and_center the_character,
+      std::vector<vote_over_string_vector> &the_vector) -> bool;
+
+  /*!
+          The voting function.
+
+          \param voted_results The voted results.
+          \param all_results All results.
+  */
+  W_API void
+  voting_over_results_and_names(frame_result_struct &voted_results,
+                                std::vector<frame_result_struct> &all_results);
+};
+} // namespace wolf::ml::ocr
\ No newline at end of file
diff --git a/wolf/ml/referee_ocr/w_soccer.cpp b/wolf/ml/referee_ocr/w_soccer.cpp
new file mode 100644
index 000000000..46534b84f
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_soccer.cpp
@@ -0,0 +1,606 @@
+#include "w_soccer.hpp"
+
+#include <chrono>
+#include <cstdint>
+#include <filesystem>
+#include <fstream>
+#include <opencv2/opencv.hpp>
+#include <string>
+
+#include "w_referee.hpp"
+#include "w_utilities.hpp"
+
+using w_soccer = wolf::ml::ocr::w_soccer;
+using w_ocr_engine = wolf::ml::ocr::w_ocr_engine;
+using config_for_ocr_struct = wolf::ml::ocr::config_for_ocr_struct;
+using w_referee = wolf::ml::ocr::w_referee;
+
+w_soccer::w_soccer() {
+  // LOG_P(w_log_type::W_LOG_INFO, "creating w_soccer object ...");
+
+  char *type_1 = new char[30];
+  snprintf(type_1, 30, "SOCCER_SCREEN_IDENTITY");
+  screen_identity = set_config(type_1);
+
+  char *type_2 = new char[30];
+  snprintf(type_2, 30, "SOCCER_RESULT_HOME");
+  result_home = set_config(type_2);
+  char *type_3 = new char[30];
+  snprintf(type_3, 30, "SOCCER_RESULT_AWAY");
+  result_away = set_config(type_3);
+
+  char *type_4 = new char[30];
+  snprintf(type_4, 30, "SOCCER_NAME_HOME");
+  name_home = set_config(type_4);
+  char *type_5 = new char[30];
+  snprintf(type_5, 30, "SOCCER_NAME_AWAY");
+  name_away = set_config(type_5);
+
+  char *type_6 = new char[30];
+  snprintf(type_6, 30, "SOCCER_PLATFORM_FREE");
+  platform_free = set_config_for_ocr(type_6);
+
+  char *type_7 = new char[30];
+  snprintf(type_7, 30, "SOCCER_PENALTY");
+  penalty = set_config_for_ocr(type_7);
+
+  delete[] type_1;
+  delete[] type_2;
+  delete[] type_3;
+  delete[] type_4;
+  delete[] type_5;
+  delete[] type_6;
+  delete[] type_7;
+
+  fill_stat_map();
+}
+
+w_soccer::~w_soccer() {}
+
+auto w_soccer::set_config(_In_ char *pType) -> w_ocr_engine::config_struct {
+  std::string type(pType);
+
+  w_ocr_engine::config_struct config;
+
+  config.name = get_env_string((type + "_WINDOW_NAME").c_str());
+  config.window = get_env_cv_rect((type + "_WINDOW").c_str());
+  config.is_time = get_env_boolean((type + "_IS_TIME").c_str());
+  config.config_for_ocr.do_resize_contour =
+      get_env_boolean((type + "_DO_RESIZE_CONTOUR").c_str());
+  config.config_for_ocr.gaussian_blur_win_size =
+      get_env_int((type + "_GAUSSIAN_BLUR_WIN_SIZE").c_str());
+  config.config_for_ocr.if_store_image_boxes =
+      get_env_boolean((type + "_IF_STORE_IMAGE_BOXES").c_str());
+  config.config_for_ocr.is_white =
+      get_env_boolean((type + "_IS_WHITE").c_str());
+  config.config_for_ocr.is_digit =
+      get_env_boolean((type + "_IS_DIGIT").c_str());
+  config.config_for_ocr.make_white_background =
+      get_env_boolean((type + "_MAKE_WHITE_BACKGROUND").c_str());
+  config.config_for_ocr.margin = get_env_int((type + "_MARGIN").c_str());
+  config.config_for_ocr.verbose = get_env_boolean((type + "_VERBOSE").c_str());
+  config.config_for_ocr.threshold_value =
+      get_env_int((type + "_THRESHOLD").c_str());
+  config.config_for_ocr.white_background_threshold =
+      get_env_int((type + "_WHITE_BACKGROUND_THRESHOLD").c_str());
+  config.config_for_ocr.restrictions.max_area =
+      get_env_int((type + "_RESTRICTIONS_MAX_AREA").c_str());
+  config.config_for_ocr.restrictions.min_area =
+      get_env_int((type + "_RESTRICTIONS_MIN_AREA").c_str());
+  config.config_for_ocr.restrictions.max_width =
+      get_env_int((type + "_RESTRICTIONS_MAX_WIDTH").c_str());
+  config.config_for_ocr.restrictions.min_width =
+      get_env_int((type + "_RESTRICTIONS_MIN_WIDTH").c_str());
+  config.config_for_ocr.restrictions.max_height =
+      get_env_int((type + "_RESTRICTIONS_MAX_HEIGHT").c_str());
+  config.config_for_ocr.restrictions.min_height =
+      get_env_int((type + "_RESTRICTIONS_MIN_HEIGHT").c_str());
+
+  return config;
+}
+
+auto w_soccer::set_config_for_ocr(_In_ char *pType) -> config_for_ocr_struct {
+  std::string type(pType);
+  config_for_ocr_struct config;
+
+  config.restrictions.max_area =
+      get_env_int((type + "_RESTRICTIONS_MAX_AREA").c_str());
+  config.restrictions.min_area =
+      get_env_int((type + "_RESTRICTIONS_MIN_AREA").c_str());
+  config.restrictions.max_width =
+      get_env_int((type + "_RESTRICTIONS_MAX_WIDTH").c_str());
+  config.restrictions.min_width =
+      get_env_int((type + "_RESTRICTIONS_MIN_WIDTH").c_str());
+  config.restrictions.max_height =
+      get_env_int((type + "_RESTRICTIONS_MAX_HEIGHT").c_str());
+  config.restrictions.min_height =
+      get_env_int((type + "_RESTRICTIONS_MIN_HEIGHT").c_str());
+  config.fraction = get_env_float((type + "_FRACTION").c_str());
+
+  return config;
+}
+
+auto w_soccer::fill_stat_map() -> void {
+  stat_first_half = get_env_string("SOCCER_STAT_FIRST_HALF_STRING");
+  stat_second_half = get_env_string("SOCCER_STAT_SECOND_HALF_STRING");
+  stat_extra_first_half = get_env_string("SOCCER_STAT_EXTRA_FIRST_HALF_STRING");
+  stat_extra_second_half =
+      get_env_string("SOCCER_STAT_EXTRA_SECOND_HALF_STRING");
+  stat_penalty = get_env_string("SOCCER_STAT_PENALTY_STRING");
+
+  bool is_platform_free = get_env_boolean("SOCCER_GLOBAL_PLATFORM_FREE");
+
+  stat_map.insert(std::pair<std::string, std::string>(
+      get_first_character_of_string(stat_first_half, is_platform_free),
+      "first_half"));
+  stat_map.insert(std::pair<std::string, std::string>(
+      get_first_character_of_string(stat_second_half, is_platform_free),
+      "second_half"));
+  stat_map.insert(std::pair<std::string, std::string>(
+      get_first_character_of_string(stat_extra_first_half, is_platform_free),
+      "extra_first_half"));
+  stat_map.insert(std::pair<std::string, std::string>(
+      get_first_character_of_string(stat_extra_second_half, is_platform_free),
+      "extra_second_half"));
+  stat_map.insert(std::pair<std::string, std::string>(
+      get_first_character_of_string(stat_penalty, is_platform_free),
+      "penalty"));
+}
+
+auto w_soccer::extract_result_from_frame_boxes(
+    _In_ cv::Mat &frame, _Inout_ frame_result_struct &frame_data) -> void {
+  std::vector<w_ocr_engine::character_and_center> temp_words, temp_team_names;
+
+  cv::Mat frame_box = frame(screen_identity.window);
+  temp_words =
+      ocr_object.image_to_string(frame_box, screen_identity.config_for_ocr);
+
+  if (temp_words.size() == 1) {
+    if (temp_words[0].text.c_str()[0] == stat_first_half.c_str()[0] ||
+        temp_words[0].text.c_str()[0] == stat_second_half.c_str()[0]) {
+      frame_data.stat = stat_map[temp_words[0].text];
+      temp_words.clear();
+
+      frame_box = frame(result_home.window);
+      temp_words =
+          ocr_object.image_to_string(frame_box, result_home.config_for_ocr);
+      if (temp_words.size() != 0) {
+        frame_data.home_result = temp_words[0];
+
+        frame_box = frame(result_away.window);
+        temp_words =
+            ocr_object.image_to_string(frame_box, result_away.config_for_ocr);
+        if (temp_words.size() != 0) {
+          frame_data.away_result = temp_words[0];
+
+          temp_team_names.clear();
+
+          frame_box = frame(name_home.window);
+          temp_team_names =
+              ocr_object.image_to_string(frame_box, name_home.config_for_ocr);
+          if (temp_team_names.size() == 0) {
+            frame_box.release();
+            return;
+          }
+          frame_data.home_name = concatenate_name_result(temp_team_names);
+
+          frame_box = frame(name_away.window);
+          temp_team_names =
+              ocr_object.image_to_string(frame_box, name_away.config_for_ocr);
+          if (temp_team_names.size() == 0) {
+            frame_box.release();
+            return;
+          }
+          frame_data.away_name = concatenate_name_result(temp_team_names);
+        }
+      }
+    }
+  }
+  frame_box.release();
+}
+
+auto w_soccer::extract_result_based_on_clusters_symmetricity(
+    _In_ cv::Mat &frame, _Inout_ frame_result_struct &frame_data) -> void {
+  cv::Mat cloned_image = frame.clone();
+  int image_width = frame.cols;
+
+  if (get_env_boolean("CONFIG_STORE_LATEST_FRAME")) {
+    std::string image_data_file_name =
+        get_env_string("SOCCER_GLOBAL_LOG_FILE") + "_" +
+        std::to_string(frame_number % 10);
+    std::ofstream ofs(image_data_file_name.c_str(), std::ofstream::out);
+    ofs.write((char *)frame.data,
+              frame.total() * frame.channels() * sizeof(uint8_t));
+    ofs.close();
+  }
+
+  std::vector<std::vector<w_ocr_engine::characters_struct>> digits_candidates;
+  std::vector<std::vector<w_ocr_engine::characters_struct>> words_candidates;
+  std::vector<std::vector<w_ocr_engine::characters_struct>> time_candidates;
+
+  extract_all_image_char_clusters(cloned_image, digits_candidates,
+                                  words_candidates, time_candidates);
+
+  if (digits_candidates.size() == 2 && words_candidates.size() == 2 &&
+      time_candidates.size() == 1) {
+    for (int i = 0; i < words_candidates.size(); i++) {
+      std::vector<w_ocr_engine::character_and_center> text_of_cluster =
+          ocr_object.char_vec_to_string(words_candidates[i], frame,
+                                        name_home.config_for_ocr);
+
+      if (text_of_cluster.size() > 0) {
+        if (text_of_cluster[0].center.x < image_width / 2) {
+          frame_data.home_name = text_of_cluster[0];
+        } else {
+          frame_data.away_name = text_of_cluster[0];
+        }
+      }
+    }
+    for (int i = 0; i < digits_candidates.size(); i++) {
+      std::vector<w_ocr_engine::character_and_center> text_of_cluster =
+          ocr_object.char_vec_to_string(digits_candidates[i], frame,
+                                        result_home.config_for_ocr);
+      if (text_of_cluster.size() > 0) {
+        if (text_of_cluster[0].center.x < image_width / 2) {
+          frame_data.home_result = text_of_cluster[0];
+        } else {
+          frame_data.away_result = text_of_cluster[0];
+        }
+      }
+    }
+    for (int i = 0; i < time_candidates.size(); i++) {
+      std::vector<w_ocr_engine::character_and_center> text_of_cluster =
+          ocr_object.char_vec_to_string(time_candidates[i], frame,
+                                        screen_identity.config_for_ocr);
+      if (text_of_cluster.size() > 0) {
+        frame_data.stat = get_nearest_string(text_of_cluster[0].text, stat_map);
+        if (frame_data.stat.compare("") == 0) {
+          w_ocr_engine::config_struct temp_screen_identity = screen_identity;
+          temp_screen_identity.config_for_ocr.is_digit = false;
+          text_of_cluster = ocr_object.char_vec_to_string(
+              time_candidates[i], frame, temp_screen_identity.config_for_ocr);
+          std::vector<std::string> temp_result =
+              split_string(text_of_cluster[0].text, ' ');
+          if (temp_result.size() > 1) {
+            frame_data.stat = get_nearest_string(temp_result[1], stat_map);
+          }
+        }
+        if (frame_data.stat.compare("") != 0) {
+          extract_penalty_result_symmetricity(frame, digits_candidates,
+                                              words_candidates, time_candidates,
+                                              frame_data);
+          // frame_data.stat = stat_map[frame_data.stat];
+        }
+      }
+    }
+  }
+  cloned_image.release();
+}
+
+auto w_soccer::extract_penalty_result_symmetricity(
+    _In_ cv::Mat &frame,
+    _In_ std::vector<std::vector<w_ocr_engine::characters_struct>>
+        digits_candidates,
+    _In_ std::vector<std::vector<w_ocr_engine::characters_struct>>
+        words_candidates,
+    _In_ std::vector<std::vector<w_ocr_engine::characters_struct>>
+        time_candidates,
+    _Inout_ frame_result_struct &frame_data) -> void {
+  if (frame_data.stat.compare(get_env_string("SOCCER_STAT_CHECK_PENALTY")) !=
+          0 ||
+      digits_candidates.size() != 2 || time_candidates.size() != 1) {
+    return;
+  }
+  cv::Rect result_box_bound_rect;
+
+  if (stat_second_half.compare(get_env_string("SOCCER_STAT_CHECK_PENALTY")) ==
+      0) {
+    w_ocr_engine::characters_struct left, right;
+    left = (digits_candidates[0][0].bound_rect.x >
+            digits_candidates[1][0].bound_rect.x)
+               ? digits_candidates[1][digits_candidates[1].size() - 1]
+               : digits_candidates[0][digits_candidates[0].size() - 1];
+    right = (digits_candidates[0][0].bound_rect.x >
+             digits_candidates[1][0].bound_rect.x)
+                ? digits_candidates[0][0]
+                : digits_candidates[1][0];
+
+    result_box_bound_rect.x = left.bound_rect.x + left.bound_rect.width;
+    result_box_bound_rect.width = right.bound_rect.x - result_box_bound_rect.x;
+
+    if (result_box_bound_rect.width < 0) {
+      std::cout << "something went wrong!!!" << std::endl;
+      return;
+    }
+
+    if (result_box_bound_rect.width > frame.cols / 3) {
+      return;
+    }
+
+    result_box_bound_rect.y =
+        left.bound_rect.y + left.bound_rect.height / 2 + 4;
+    result_box_bound_rect.height = left.bound_rect.height / 2;
+  } else if (stat_penalty.compare(
+                 get_env_string("SOCCER_STAT_CHECK_PENALTY")) == 0) {
+    result_box_bound_rect.x = time_candidates[0][0].bound_rect.x - 50;
+    result_box_bound_rect.width = 50 + 10;
+    // (time_candidates[0][time_candidates[0].size() - 1].bound_rect.x +
+    //  time_candidates[0][time_candidates[0].size() - 1].bound_rect.width -
+    //  result_box_bound_rect.x) /
+    // 2;
+    result_box_bound_rect.y = time_candidates[0][0].bound_rect.y;
+    result_box_bound_rect.height = time_candidates[0][0].bound_rect.height;
+  }
+
+  cv::Mat result_box;
+  frame(result_box_bound_rect).copyTo(result_box);
+
+  // cv::imshow("image", result_box);
+  // cv::waitKey();
+
+  std::vector<w_ocr_engine::character_and_center> temp_words;
+
+  temp_words =
+      ocr_object.image_to_string(result_box, result_away.config_for_ocr);
+
+  if (temp_words.size() == 2 && stat_second_half.compare(get_env_string(
+                                    "SOCCER_STAT_CHECK_PENALTY")) == 0) {
+    frame_data.home_penalty_result =
+        (temp_words[0].center.x < temp_words[1].center.x) ? temp_words[0]
+                                                          : temp_words[1];
+    frame_data.away_penalty_result =
+        (temp_words[0].center.x < temp_words[1].center.x) ? temp_words[1]
+                                                          : temp_words[0];
+  } else if (temp_words.size() == 1 && stat_penalty.compare(get_env_string(
+                                           "SOCCER_STAT_CHECK_PENALTY")) == 0) {
+    std::vector<std::string> temp_result =
+        split_string(temp_words[0].text, ' ');
+    frame_data.home_penalty_result.text = temp_result[0];
+    frame_data.away_penalty_result.text = temp_result[1];
+  }
+
+  return;
+}
+
+auto w_soccer::single_image_result_extraction(_In_ uint8_t *pRawImage,
+                                              _In_ int height, _In_ int width,
+                                              _In_ ocr_callback *callback)
+    -> int {
+  int desired_height = get_env_int("SOCCER_GLOBAL_FRAME_HEIGHT");
+  int desired_width = get_env_int("SOCCER_GLOBAL_FRAME_WIDTH");
+  if (!pRawImage || height != desired_height || width != desired_width) {
+    return 1;
+  }
+  cv::Mat original_image = cv::Mat(height, width, CV_8UC3, pRawImage);
+
+  frame_result_struct temp_frame_data;
+
+  if (get_env_boolean("SOCCER_GLOBAL_PLATFORM_FREE")) {
+    extract_result_based_on_clusters_symmetricity(original_image,
+                                                  temp_frame_data);
+  } else {
+    extract_result_from_frame_boxes(original_image, temp_frame_data);
+  }
+
+  if (temp_frame_data.stat.compare("") != 0 &&
+      temp_frame_data.home_result.text.compare("") != 0 &&
+      temp_frame_data.away_result.text.compare("") != 0 &&
+      temp_frame_data.home_name.text.compare("") != 0 &&
+      temp_frame_data.away_name.text.compare("") != 0) {
+    temp_frame_data.frame_number = frame_number;
+    cv::Mat temp_image = original_image.clone();
+    update_match_data(temp_frame_data, temp_image);
+    temp_image.release();
+  }
+
+  // update the frame number
+  frame_number += 1;
+  for (int i = 0; i < matches_data.size(); i++) {
+    if (i == 0 && frame_number < matches_data[i].frame_number + 10) {
+      continue;
+    }
+    matches_data[i].ready = true;
+  }
+
+  extract_game_results();
+
+  if (callback) {
+    for (int i = 0; i < matches_data.size(); i++) {
+      if (matches_data[i].extracted && !matches_data[i].applied) {
+        std::string str_result = matches_data[i].stat + "," +
+                                 matches_data[i].home_name.text + "," +
+                                 matches_data[i].home_result.text + "," +
+                                 matches_data[i].away_name.text + "," +
+                                 matches_data[i].away_result.text;
+        if (matches_data[i].home_penalty_result.text.compare("") != 0 &&
+            matches_data[i].away_penalty_result.text.compare("") != 0) {
+          str_result = str_result + "," +
+                       matches_data[i].home_penalty_result.text + "," +
+                       matches_data[i].away_penalty_result.text;
+        }
+        char *char_result = new char[256];
+        strcpy(char_result, str_result.c_str());
+
+        callback(char_result, 256, matches_data[i].result_image.data,
+                 matches_data[i].result_image.cols,
+                 matches_data[i].result_image.rows);
+        the_last_result_message = str_result;
+
+        matches_data[i].applied = true;
+      }
+    }
+  }
+
+  return 0;
+}
+
+auto w_soccer::extract_all_image_char_clusters(
+    cv::Mat &image,
+    std::vector<std::vector<w_ocr_engine::characters_struct>>
+        &digits_candidates,
+    std::vector<std::vector<w_ocr_engine::characters_struct>> &words_candidates,
+    std::vector<std::vector<w_ocr_engine::characters_struct>> &time_candidates)
+    -> void {
+  cv::cvtColor(image, image, cv::COLOR_BGR2GRAY);
+  int global_threshold = get_env_int("SOCCER_GLOBAL_THRESHOLD");
+  cv::threshold(image, image, global_threshold, 255,
+                cv::THRESH_BINARY); // cv::THRESH_OTSU);
+
+  std::vector<std::vector<cv::Point>> contours;
+  std::vector<cv::Vec4i> hierarchy;
+
+  cv::findContours(image, contours, hierarchy, cv::RETR_TREE,
+                   cv::CHAIN_APPROX_SIMPLE, cv::Point(0, 0));
+  std::vector<w_ocr_engine::characters_struct> modified_bounding_rects =
+      ocr_object.contours_to_char_structs(contours);
+
+  modified_bounding_rects = ocr_object.filter_chars_by_contour_size(
+      modified_bounding_rects, platform_free);
+  contours.clear();
+  hierarchy.clear();
+
+  ocr_object.merge_overlapped_contours(modified_bounding_rects, platform_free);
+
+  std::vector<std::vector<w_ocr_engine::characters_struct>>
+      clustered_characters = ocr_object.cluster_char_structs(
+          modified_bounding_rects, platform_free);
+
+  int ref_index = clustered_characters.size();
+  for (int i = 0; i < ref_index; i++) {
+    int index = ref_index - (i + 1);
+    if (clustered_characters[index].size() < 3 &&
+        ocr_object.same_level(clustered_characters[index])) {
+      digits_candidates.push_back(clustered_characters[index]);
+    }
+    if (clustered_characters[index].size() >= 3 &&
+        ocr_object.same_level(clustered_characters[index])) {
+      words_candidates.push_back(clustered_characters[index]);
+    }
+    if (clustered_characters[index][0].bound_rect.x < image.cols / 2 &&
+        clustered_characters[index][clustered_characters[index].size() - 1]
+                .bound_rect.x > image.cols / 2 &&
+        clustered_characters[index].size() < 16 &&
+        clustered_characters[index].size() > 1) {
+      time_candidates.push_back(clustered_characters[index]);
+    }
+  }
+  // cv::Mat temp_image = cv::Mat(image.rows, image.cols, CV_8UC1,
+  // cv::Scalar(0)); for (int i = 0; i < clustered_characters.size(); i++)
+  // {
+  // 	ocr_object.show_contours(temp_image, clustered_characters[i], "Hello",
+  // true);
+  // }
+
+  clustered_characters.clear();
+
+  ocr_object.keep_twins(words_candidates, image.cols, image.rows, true);
+  ocr_object.keep_twins(digits_candidates, image.cols, image.rows, false);
+  ocr_object.keep_time(time_candidates);
+
+  for (int i = 0; i < digits_candidates.size(); i++) {
+    for (size_t j = 0; j < digits_candidates[i].size(); j++) {
+      ocr_object.margin_bounding_rect(digits_candidates[i][j].bound_rect,
+                                      platform_free.margin, image);
+    }
+  }
+
+  for (int i = 0; i < words_candidates.size(); i++) {
+    for (size_t j = 0; j < words_candidates[i].size(); j++) {
+      ocr_object.margin_bounding_rect(words_candidates[i][j].bound_rect,
+                                      platform_free.margin, image);
+    }
+  }
+
+  for (int i = 0; i < time_candidates.size(); i++) {
+    for (size_t j = 0; j < time_candidates[i].size(); j++) {
+      ocr_object.margin_bounding_rect(time_candidates[i][j].bound_rect,
+                                      platform_free.margin, image);
+    }
+  }
+
+  return;
+}
+
+auto w_soccer::replace_team_names_with_most_similar_string(
+    _Inout_ std::vector<w_referee::match_result_struct> &result) -> void {
+  for (int i = 0; i < int(result.size()); i++) {
+    // LOG_P(w_log_type::W_LOG_INFO, "recognized home name : %s",
+    // result[i].home_name.text); LOG_P(w_log_type::W_LOG_INFO, "recognized away
+    // name : %s", result[i].away_name.text);
+    std::string path = get_env_string("SIMILAR_STRINGS_FILE_PATH");
+    result[i].home_name.text =
+        get_nearest_string(result[i].home_name.text, path);
+    result[i].away_name.text =
+        get_nearest_string(result[i].away_name.text, path);
+    // LOG_P(w_log_type::W_LOG_INFO, "recognized home name after replace with
+    // most similar: %s", result[i].home_name.text);
+    // LOG_P(w_log_type::W_LOG_INFO, "recognized away name after replace with
+    // most similar: %s", result[i].away_name.text);
+  }
+}
+
+auto w_soccer::initial_match_result_struct(
+    w_referee::frame_result_struct frame_data, cv::Mat &image)
+    -> w_referee::match_result_struct {
+  w_referee::match_result_struct temp_match_data;
+  temp_match_data.all_frames_results.push_back(frame_data);
+  temp_match_data.stat = frame_data.stat;
+  temp_match_data.result_image = image;
+  temp_match_data.frame_number = frame_data.frame_number;
+
+  return temp_match_data;
+}
+
+auto w_soccer::update_match_data(_In_ w_referee::frame_result_struct frame_data,
+                                 _In_ cv::Mat &image) -> void {
+  if (matches_data.size() == 0 ||
+      frame_data.frame_number >
+          matches_data[matches_data.size() - 1].frame_number + 10) {
+    matches_data.push_back(initial_match_result_struct(frame_data, image));
+  } else {
+    matches_data[matches_data.size() - 1].frame_number =
+        frame_data.frame_number;
+    matches_data[matches_data.size() - 1].all_frames_results.push_back(
+        frame_data);
+  }
+}
+
+auto w_soccer::extract_game_results() -> void {
+  w_referee ocr_object;
+
+  for (int i = 0; i < matches_data.size(); i++) {
+    int min_frames = get_env_int("SOCCER_GLOBAL_MIN_FRAMES");
+    if (!matches_data[i].ready || matches_data[i].extracted ||
+        matches_data[i].all_frames_results.size() < min_frames) {
+      continue;
+    }
+    w_referee::frame_result_struct temp_frame_result;
+    ocr_object.voting_over_results_and_names(
+        temp_frame_result, matches_data[i].all_frames_results);
+
+    if (get_env_boolean("SIMILARITY_USE_FOR_TEAM_NAMES")) {
+      std::string path = get_env_string("SIMILAR_STRINGS_FILE_PATH");
+      temp_frame_result.away_name.text =
+          get_nearest_string(temp_frame_result.away_name.text, path);
+      temp_frame_result.home_name.text =
+          get_nearest_string(temp_frame_result.home_name.text, path);
+    }
+
+    matches_data[i].extracted = true;
+    matches_data[i].away_name = temp_frame_result.away_name;
+    matches_data[i].away_result = temp_frame_result.away_result;
+    matches_data[i].home_name = temp_frame_result.home_name;
+    matches_data[i].home_result = temp_frame_result.home_result;
+    matches_data[i].home_penalty_result = temp_frame_result.home_penalty_result;
+    matches_data[i].away_penalty_result = temp_frame_result.away_penalty_result;
+  }
+}
+
+auto w_soccer::get_matches_data()
+    -> std::vector<w_referee::match_result_struct> {
+  return matches_data;
+}
+
+auto w_soccer::get_stat_map() -> std::map<std::string, std::string> {
+  return stat_map;
+}
diff --git a/wolf/ml/referee_ocr/w_soccer.hpp b/wolf/ml/referee_ocr/w_soccer.hpp
new file mode 100644
index 000000000..a9be89466
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_soccer.hpp
@@ -0,0 +1,225 @@
+/*
+    Project: Wolf Engine. Copyright © 2014-2023 Pooya Eimandar
+    https://github.com/WolfEngine/WolfEngine
+*/
+
+#pragma once
+
+#include <fstream>
+#include <iostream>
+#include <map>
+
+#include "salieri.h"
+#include "w_image_processor.hpp"
+#include "w_ocr_engine.hpp"
+#include "w_referee.hpp"
+#include "wolf.hpp"
+
+typedef void ocr_callback(char *result_buffer, int result_buffer_size,
+                          uint8_t *image_buffer, int image_width,
+                          int image_height);
+
+namespace wolf::ml::ocr {
+
+//! w_soccer class.
+/*! \brief It is extract the soccer game result.
+
+        This class contains functions, structures, and variables that use the
+   w_soccer class for doing referee purposes.
+*/
+class w_soccer : public w_referee {
+public:
+  /*!
+          The constructor of the class.
+          In the constructor the configs are set.
+
+          \return
+  */
+  W_API w_soccer();
+
+  /*!
+          The deconstructor of the class.
+
+          The function is empty.
+  */
+  W_API ~w_soccer();
+
+  /*!
+  The function return the config of desired image window.
+
+          \param pType The type of box
+          \return
+  */
+  W_API static auto set_config(_In_ char *pType) -> w_ocr_engine::config_struct;
+
+  /*!
+          The function set the stat map global variable by dotenvs information.
+  */
+  auto fill_stat_map() -> void;
+
+  W_API auto set_config_for_ocr(_In_ char *pType) -> config_for_ocr_struct;
+
+  /*!
+          The function returns frame results, the results are extracted from
+     pre-defined frame boxes.
+
+          \param frame The input frame image.
+          \param frame_data The frame result would be stored in the frame_date.
+          \return Void
+  */
+  W_API auto extract_result_from_frame_boxes(
+      _In_ cv::Mat &frame, _Inout_ frame_result_struct &frame_data) -> void;
+
+  /*!
+          The function returns frame results, the results are extracted based on
+     the character clusters' symmetricity.
+
+          \param frame The input frame image.
+          \param frame_data The frame result would be stored in the frame_date.
+          \return Void
+  */
+  W_API auto extract_result_based_on_clusters_symmetricity(
+      _In_ cv::Mat &frame, _Inout_ frame_result_struct &frame_data) -> void;
+
+  /*!
+          The function checks for penalty results and if the scene contains the
+     penalty results the results would be extracted.
+
+          \param frame The input frame image.
+          \param digits_candidates The cluster of digits characters.
+          \param words_candidates The cluster of words characters.
+          \param time_candidates The cluster of time stat related characters.
+          \param frame_data The frame result would be stored in the frame_date.
+          \return Void
+  */
+  W_API auto extract_penalty_result_symmetricity(
+      _In_ cv::Mat &frame,
+      _In_ std::vector<std::vector<w_ocr_engine::characters_struct>>
+          digits_candidates,
+      _In_ std::vector<std::vector<w_ocr_engine::characters_struct>>
+          words_candidates,
+      _In_ std::vector<std::vector<w_ocr_engine::characters_struct>>
+          time_candidates,
+      _Inout_ frame_result_struct &frame_data) -> void;
+
+  /*!
+  The function returns the game results, if the image contain the game final
+  result.
+
+          \param pRawImage The sequence of the input image pixels array in BGR
+  format. \param height The image height. \param width The image width. \param
+  pStr The image result. \return Void
+  */
+  W_API auto single_image_result_extraction(_In_ uint8_t *pRawImage,
+                                            _In_ int height, _In_ int width,
+                                            _In_ ocr_callback *callback) -> int;
+
+  /*!
+  The extract_all_image_char_clusters function returns the character cluster
+  related to the frame result.
+
+          \param pImage The input image.
+          \param pDdigitsCandidates The character clusters of the result texts.
+          \param pWordsCandidates The character clusters of the team name texts.
+          \param pTimeCandidates The character cluster of the stat texts.
+          \return Void
+  */
+  W_API auto extract_all_image_char_clusters(
+      cv::Mat &pImage,
+      std::vector<std::vector<w_ocr_engine::characters_struct>>
+          &pDigitsCandidates,
+      std::vector<std::vector<w_ocr_engine::characters_struct>>
+          &pWordsCandidates,
+      std::vector<std::vector<w_ocr_engine::characters_struct>>
+          &pTimeCandidates) -> void;
+
+  /*!
+  replace team names stored in match_result_struct using string similarity
+  algorithms.
+
+          \param result input struct
+          \return
+  */
+  W_API static auto replace_team_names_with_most_similar_string(
+      _Inout_ std::vector<w_referee::match_result_struct> &result) -> void;
+
+  /*!
+  The initial_match_result_struct function fills a match_result_struct with the
+  initial values.
+
+          \param frame_data input struct
+          \param image input struct
+          \return An initialed variable of match data structure.
+  */
+  W_API auto
+  initial_match_result_struct(w_referee::frame_result_struct frame_data,
+                              cv::Mat &image) -> w_referee::match_result_struct;
+
+  /*!
+  The update_match_data function store frames data in the match_date variable.
+
+          \param frame_data input struct
+          \param image input struct
+          \return
+  */
+  W_API auto update_match_data(_In_ w_referee::frame_result_struct frame_data,
+                               _In_ cv::Mat &image) -> void;
+
+  /*!
+  The extract_game_results function extracts the game results from the
+  match_data and stores the results in the match_data.
+
+          \return
+  */
+  W_API auto extract_game_results() -> void;
+
+  /*!
+  The get_matches_data function returns the private match_data variable.
+
+          \return The private match_data variable.
+  */
+  W_API auto get_matches_data() -> std::vector<w_referee::match_result_struct>;
+
+  /*!
+          The get_stat_map function returns the private stat_map variable.
+
+          \return The private stat_map variable.
+  */
+  W_API auto get_stat_map() -> std::map<std::string, std::string>;
+
+private:
+  /*!<The number of frame.*/
+  int frame_number = 0;
+  /*!<The configuration of the screen_identity window.*/
+  w_ocr_engine::config_struct screen_identity;
+  /*!<The configuration of the result_home window.*/
+  w_ocr_engine::config_struct result_home;
+  /*!<The configuration of the result_away window.*/
+  w_ocr_engine::config_struct result_away;
+  /*!<The configuration of the name_home window.*/
+  w_ocr_engine::config_struct name_home;
+  /*!<The configuration of the name_away window.*/
+  w_ocr_engine::config_struct name_away;
+  /*!<The configuration of the platform_free.*/
+  config_for_ocr_struct platform_free;
+  /*!<The configuration of the penalty.*/
+  config_for_ocr_struct penalty;
+
+  /*!<The matches data contains the results of the games.*/
+  std::vector<w_referee::match_result_struct> matches_data;
+
+  /*!<Game stat like first-half, second-half, and ... .*/
+  std::string stat_first_half;
+  std::string stat_second_half;
+  std::string stat_extra_first_half;
+  std::string stat_extra_second_half;
+  std::string stat_penalty;
+
+  std::map<std::string, std::string> stat_map;
+
+  std::string the_last_result_message = "";
+
+  /*!<An object of w_ocr_engine class.*/
+  w_ocr_engine ocr_object;
+};
+} // namespace wolf::ml::ocr
\ No newline at end of file
diff --git a/wolf/ml/referee_ocr/w_utilities.cpp b/wolf/ml/referee_ocr/w_utilities.cpp
new file mode 100644
index 000000000..bd32c6e89
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_utilities.cpp
@@ -0,0 +1,465 @@
+#include "w_utilities.hpp"
+
+#include <rapidjson/document.h>
+#include <rapidjson/istreamwrapper.h>
+#include <rapidjson/ostreamwrapper.h>
+#include <rapidjson/stringbuffer.h>
+#include <rapidjson/writer.h>
+
+#include <algorithm>
+#include <cctype>
+#include <cstdlib>
+#include <filesystem>
+#include <fstream>
+#include <iomanip>
+#include <iostream>
+#include <numeric>
+#include <opencv2/opencv.hpp>
+#include <sstream>
+#include <string>
+#include <vector>
+
+// #include "spdlog/sinks/basic_file_sink.h"
+// #include "spdlog/sinks/stdout_color_sinks.h"
+// #include "spdlog/spdlog.h"
+namespace fs = std::filesystem;
+#ifdef __TELEMETRY
+#include "opentelemetry/sdk/version/version.h"
+#include "opentelemetry/trace/provider.h"
+
+namespace trace = opentelemetry::trace;
+namespace nostd = opentelemetry::nostd;
+
+namespace {
+nostd::shared_ptr<trace::Tracer> get_tracer() {
+  auto provider = trace::Provider::GetTracerProvider();
+  return provider->GetTracer("pes_21", OPENTELEMETRY_SDK_VERSION);
+}
+} // namespace
+#endif
+
+namespace wolf::ml::ocr {
+
+auto get_nearest_string(_In_ std::string pInput, std::string pFilePath)
+    -> std::string {
+  // LOG_P(w_log_type::W_LOG_INFO, "path to similar strings file: %s",
+  // pFilePath);
+  std::ifstream similar_strings(pFilePath);
+  float threshold = get_env_float("SIMILARITY_THRESHOLD");
+  // LOG_P(w_log_type::W_LOG_INFO, "similarity threshold: %f", threshold);
+  std::string candidate_string;
+  float best_similarity = 0;
+  std::string most_similar;
+
+  if (pInput.length() == 0) {
+    return pInput;
+  }
+
+  while (std::getline(similar_strings, candidate_string)) {
+    float similarity =
+        normalized_levenshtein_similarity(pInput, candidate_string);
+    if (similarity > best_similarity) {
+      most_similar = candidate_string;
+      best_similarity = similarity;
+    }
+  }
+
+  if (best_similarity > threshold) {
+    return most_similar;
+  } else {
+    return pInput;
+  }
+}
+
+auto get_nearest_string(_In_ std::string pInput,
+                        _In_ std::map<std::string, std::string> pMap)
+    -> std::string
+
+{
+  float threshold = get_env_float("SIMILARITY_THRESHOLD_STAT");
+  // LOG_P(w_log_type::W_LOG_INFO, "similarity threshold: %f", threshold);
+  std::string candidate_string;
+  float best_similarity = 0;
+  std::string most_similar;
+
+  if (pInput.length() == 0) {
+    return pInput;
+  }
+
+  for (auto it = pMap.begin(); it != pMap.end(); it++) {
+    candidate_string = it->first;
+    float similarity =
+        normalized_levenshtein_similarity(pInput, candidate_string);
+    if (similarity > best_similarity) {
+      most_similar = candidate_string;
+      best_similarity = similarity;
+    }
+  }
+
+  if (best_similarity > threshold) {
+    return most_similar;
+  } else {
+    return "";
+  }
+}
+
+std::string get_value_from_json_file_by_key(std::string pJsonFilePath,
+                                            std::string pKey) {
+#ifdef __TELEMETRY
+  auto span = get_tracer()->StartSpan("get_value_from_json_file_by_key");
+#endif
+  using namespace rapidjson;
+
+  std::ifstream ifs{pJsonFilePath};
+  if (!ifs.is_open()) {
+    fs::path cwd = fs::current_path();
+    // spdlog::error("current path {}", cwd.string());
+    // spdlog::error("Could not open {} file for reading!", pJsonFilePath);
+    std::exit(ENOENT);
+  }
+
+  IStreamWrapper isw{ifs};
+
+  Document doc{};
+  doc.ParseStream(isw);
+  std::string out = doc[pKey.c_str()].GetString();
+
+  return out;
+}
+
+std::vector<int>
+line_of_numbers_in_string_to_vector_of_integers(std::string pVariable) {
+#ifdef __TELEMETRY
+  auto span = get_tracer()->StartSpan(
+      "line_of_numbers_in_string_to_vector_of_integers");
+#endif
+  std::vector<int> result;
+
+  std::vector<std::string> temp = split_string(pVariable, ',');
+  for (int i = 0; i < temp.size(); i++) {
+    result.push_back(std::stoi(temp[i]));
+  }
+
+  return result;
+}
+
+auto normalized_levenshtein_similarity(_In_ const std::string &s1,
+                                       _In_ const std::string &s2) -> float {
+  const size_t m = s1.size();
+  const size_t n = s2.size();
+  int distance;
+  if (m == 0 && n == 0)
+    return 0;
+  else if (m == 0)
+    distance = n;
+  else if (n == 0)
+    distance = m;
+  else {
+    std::vector<size_t> costs(n + 1);
+    std::iota(costs.begin(), costs.end(), 0);
+    size_t i = 0;
+    for (auto c1 : s1) {
+      costs[0] = i + 1;
+      size_t corner = i;
+      size_t j = 0;
+      for (auto c2 : s2) {
+        size_t upper = costs[j + 1];
+        costs[j + 1] = (c1 == c2)
+                           ? corner
+                           : 1 + std::min(std::min(upper, corner), costs[j]);
+        corner = upper;
+        ++j;
+      }
+      ++i;
+    }
+    distance = costs[n];
+  }
+  float max = std::max(s1.length(), s2.length());
+  float normalized_distance = distance / max;
+  return 1 - normalized_distance;
+}
+
+auto read_text_file_line_by_line(_In_ std::string pFilePath)
+    -> std::vector<std::string> {
+#ifdef __TELEMETRY
+  auto span =
+      trace::Scope(get_tracer()->StartSpan("read_text_file_line_by_line"));
+#endif
+  std::vector<std::string> lines;
+  std::string line;
+
+  std::ifstream input_file(pFilePath);
+  if (!input_file.is_open()) {
+    std::cerr << "Could not open the file - '" << pFilePath << "'" << std::endl;
+    return lines;
+  }
+
+  while (std::getline(input_file, line)) {
+    lines.push_back(line);
+  }
+
+  input_file.close();
+  return lines;
+}
+
+bool replace_string(std::string &str, const std::string &from,
+                    const std::string &to) {
+  size_t start_pos = str.find(from);
+  if (start_pos == std::string::npos)
+    return false;
+  str.replace(start_pos, from.length(), to);
+  return true;
+}
+
+std::vector<std::string> split_string(std::string input_string,
+                                      char reference) {
+#ifdef __TELEMETRY
+  auto scoped_span = trace::Scope(get_tracer()->StartSpan("split_string"));
+  // auto scoped_span = get_tracer()->StartSpan("split_string");
+#endif
+  std::stringstream test(input_string);
+  std::string segment;
+  std::vector<std::string> seglist;
+
+  while (std::getline(test, segment, reference)) {
+    seglist.push_back(segment);
+  }
+
+  return seglist;
+}
+
+bool string_2_boolean(std::string pVariable) {
+#ifdef __TELEMETRY
+  auto span = get_tracer()->StartSpan("string_2_boolean");
+#endif
+  bool result;
+  std::transform(pVariable.begin(), pVariable.end(), pVariable.begin(),
+                 ::tolower);
+
+  if (pVariable.compare("true") == 0 || pVariable.compare("false") == 0) {
+    std::istringstream is(pVariable);
+    is >> std::boolalpha >> result;
+  } else {
+    throw std::runtime_error(
+        "Invalid input, the input must be 'true' or 'false' not " + pVariable);
+  }
+
+  return result;
+}
+
+auto store_image_in_folder(
+    _In_ std::vector<w_referee::match_result_struct> &pVideoResult,
+    _In_ std::string pOutputImageFolderPath, _In_ std::string pVideoPath)
+    -> void {
+#ifdef __TELEMETRY
+  auto span = get_tracer()->StartSpan("store_image_in_folder");
+#endif
+  fs::path temp_video_path = pVideoPath;
+  std::string temp_name = temp_video_path.filename().string();
+  std::string video_name = split_string(temp_name, '.')[0];
+
+  for (size_t i = 0; i < pVideoResult.size(); i++) {
+    fs::path out_path = pOutputImageFolderPath + "/" + video_name + "_" +
+                        std::to_string(i) + ".png";
+    std::cout << out_path.string() << std::endl;
+    cv::imwrite(out_path.string().c_str(), pVideoResult[i].result_image);
+    cv::waitKey(300);
+    pVideoResult[i].release();
+  }
+
+  return;
+}
+
+void write_in_file_append(std::string file_path, std::string content) {
+#ifdef __TELEMETRY
+  auto scoped_span =
+      trace::Scope(get_tracer()->StartSpan("write_in_file_append"));
+  // auto scoped_span = get_tracer()->StartSpan("write_in_file_append");
+#endif
+
+  std::ofstream file;
+
+  file.open(file_path, std::ios_base::app); // append instead of overwrite
+  file << content << std::endl;
+
+  file.close();
+  return;
+}
+
+void write_in_file(std::string file_path, std::string content) {
+#ifdef __TELEMETRY
+  auto scoped_span =
+      trace::Scope(get_tracer()->StartSpan("write_in_file_append"));
+  // auto scoped_span = get_tracer()->StartSpan("write_in_file_append");
+#endif
+
+  std::ofstream file;
+
+  file.open(file_path); // overwrite
+  file << content << std::endl;
+
+  file.close();
+  return;
+}
+
+auto write_results_in_file(
+    _In_ std::vector<w_referee::match_result_struct> &pVideoResult,
+    _In_ std::string pOutputTextPath) -> void {
+#ifdef __TELEMETRY
+  auto span = trace::Scope(get_tracer()->StartSpan("write_results_in_file"));
+#endif
+  for (size_t i = 0; i < pVideoResult.size(); i++) {
+    if (pVideoResult[i].home_penalty_result.text.compare("") != 0 &&
+        pVideoResult[i].away_penalty_result.text.compare("") != 0) {
+      write_in_file_append(pOutputTextPath,
+                           pVideoResult[i].stat + "," +
+                               pVideoResult[i].home_name.text + "," +
+                               pVideoResult[i].home_result.text + "," +
+                               pVideoResult[i].away_name.text + "," +
+                               pVideoResult[i].away_result.text + "," +
+                               pVideoResult[i].home_penalty_result.text + "," +
+                               pVideoResult[i].away_penalty_result.text + "," +
+                               std::to_string(pVideoResult[i].frame_number));
+    } else {
+      write_in_file_append(pOutputTextPath,
+                           pVideoResult[i].stat + "," +
+                               pVideoResult[i].home_name.text + "," +
+                               pVideoResult[i].home_result.text + "," +
+                               pVideoResult[i].away_name.text + "," +
+                               pVideoResult[i].away_result.text + "," +
+                               std::to_string(pVideoResult[i].frame_number));
+    }
+  }
+
+  return;
+}
+
+auto is_line_contains_variable(const std::string pStr) -> bool {
+#ifdef __TELEMETRY
+  auto span =
+      trace::Scope(get_tracer()->StartSpan("is_line_contains_variable"));
+#endif
+  bool decision = false;
+  if (pStr.size() > 0) {
+    if (pStr.at(0) != '#' && pStr.size() > 2) {
+      decision = true;
+    }
+  }
+  return decision;
+}
+
+auto set_env(_In_ const char *pDotEnvFilePath) -> void {
+#ifdef __TELEMETRY
+  auto span = trace::Scope(get_tracer()->StartSpan("set_env"));
+#endif
+  std::string env_file_path(pDotEnvFilePath);
+  auto lines = read_text_file_line_by_line(env_file_path);
+
+  std::vector<std::vector<std::string>> env_vector;
+  for (int i = 0; i < lines.size(); i++) {
+    if (is_line_contains_variable(lines[i])) {
+      env_vector.push_back(split_string(lines[i], '='));
+    }
+  }
+
+  for (int i = 0; i < env_vector.size(); i++) {
+#ifdef _WIN32
+    _putenv_s(env_vector[i][0].c_str(), env_vector[i][1].c_str());
+#else
+    setenv(env_vector[i][0].c_str(), env_vector[i][1].c_str(), 1);
+#endif
+  }
+}
+
+auto get_env_int(_In_ const char *pKey) -> int {
+  int value = -1;
+  if (const char *env_p = getenv(pKey)) {
+    std::string temp(env_p);
+    value = std::stoi(temp);
+  } else {
+    // TODO add log
+  }
+
+  return value;
+}
+
+auto get_env_float(_In_ const char *pKey) -> float {
+  float value = -1;
+  if (const char *env_p = getenv(pKey)) {
+    std::string temp(env_p);
+    value = std::stof(temp);
+  } else {
+    // TODO add log
+  }
+
+  return value;
+}
+
+auto get_env_boolean(_In_ const char *pKey) -> bool {
+  bool value = false;
+  if (const char *env_p = getenv(pKey)) {
+    std::string temp(env_p);
+    value = string_2_boolean(temp);
+  } else {
+    // TODO add log
+  }
+
+  return value;
+}
+
+auto get_env_string(_In_ const char *pKey) -> std::string {
+  std::string value;
+  if (const char *env_p = getenv(pKey)) {
+    value = std::string(env_p);
+  } else {
+    // TODO add log
+  }
+
+  return value;
+}
+
+auto get_env_cv_rect(_In_ const char *pKey) -> cv::Rect {
+  cv::Rect value = cv::Rect(0, 0, 0, 0);
+  if (const char *env_p = getenv(pKey)) {
+    std::string temp(env_p);
+    std::vector<int> int_vect =
+        line_of_numbers_in_string_to_vector_of_integers(temp);
+    value = cv::Rect(int_vect[0], int_vect[1], int_vect[2], int_vect[3]);
+  } else {
+    // TODO add log
+  }
+
+  return value;
+}
+
+auto get_relative_path_to_root() -> std::string {
+  fs::path cwd = fs::current_path();
+  fs::path dot_env_file_path;
+  if (cwd.parent_path().filename().compare("build") == 0) {
+    dot_env_file_path = "../../";
+  } else if (cwd.filename().compare("build") == 0 ||
+             cwd.filename().compare("ocr") == 0) {
+    dot_env_file_path = "../";
+  } else if (cwd.parent_path().parent_path().filename().compare("build") == 0) {
+    dot_env_file_path = "../../../";
+  } else {
+    dot_env_file_path = "";
+  }
+
+  std::string temp = dot_env_file_path.string();
+
+  return temp;
+}
+
+auto get_first_character_of_string(_In_ std::string pStr, _In_ bool pEscape)
+    -> std::string {
+  if (pEscape || pStr.length() == 0) {
+    return pStr;
+  }
+
+  char first_char = pStr[0];
+  std::string result(1, first_char);
+
+  return result;
+}
+} // namespace wolf::ml::ocr
diff --git a/wolf/ml/referee_ocr/w_utilities.hpp b/wolf/ml/referee_ocr/w_utilities.hpp
new file mode 100644
index 000000000..a0dd8e597
--- /dev/null
+++ b/wolf/ml/referee_ocr/w_utilities.hpp
@@ -0,0 +1,226 @@
+/*
+    Project: Wolf Engine. Copyright © 2014-2023 Pooya Eimandar
+    https://github.com/WolfEngine/WolfEngine
+*/
+
+#pragma once
+
+#include <cstdlib>
+#include <fstream>
+#include <iostream>
+#include <map>
+#include <opencv2/opencv.hpp>
+#include <vector>
+
+#include "w_referee.hpp"
+#include "wolf.hpp"
+
+namespace wolf::ml::ocr {
+
+/*!
+        The get_nearest_string returns the nearest string to input among strings
+   stored to the file specified by pFilePath environment variable. when the most
+   similar string is found, its similarity is compared to SIMILARITY_THRESHOLD
+   environment variable and if greater than it, the similar string is returned.
+   otherwise, the input string is returned.
+
+        \param pInput The input string.
+        \param pFilePath The file path contains target strings.
+        \return The most similar string to input string.
+*/
+W_API auto get_nearest_string(_In_ std::string pInput,
+                              _In_ std::string pFilePath) -> std::string;
+
+/*!
+        return the nearest string to input among strings stored in the input
+   pMap. when the most similar string is found, its similarity is compared to
+   SIMILARITY_THRESHOLD environment variable and if greater than it, the similar
+   string is returned. otherwise, the input string is returned.
+
+        \param pInput The input string.
+        \param pMap A map contains the target strings.
+        \return most similar string to input string.
+*/
+W_API auto get_nearest_string(_In_ std::string pInput,
+                              _In_ std::map<std::string, std::string> pMap)
+    -> std::string;
+
+/*!
+        The function gets the specific value by it's key and return the value in
+   string format.
+
+        \param pJsonFilePath the path of json file.
+        \param pKey the corresponding key that related to the desired value.
+        \return desired value.
+*/
+W_API std::string get_value_from_json_file_by_key(std::string pJsonFilePath,
+                                                  std::string pKey);
+
+/*!
+        The function gets a string as input, the string contains numbers of int
+   numbers separated by spaces and split them and return them in a vector of
+   integers.
+
+        \param pVariable string of integers number.
+        \return a vector of integers.
+*/
+W_API std::vector<int>
+line_of_numbers_in_string_to_vector_of_integers(std::string pVariable);
+
+/*!
+        compute the normalized similarity between input strings using the
+   Levenshtein metric. output is a number between 0 and 1. 1 shows high
+   similarity and 0 shows low similarity.
+
+        \param s1 first string.
+        \param s2 second string.
+        \return normalized similarity metric.
+*/
+W_API auto normalized_levenshtein_similarity(_In_ const std::string &s1,
+                                             _In_ const std::string &s2)
+    -> float;
+
+/*!
+        replace the specified phrase with another specified phrase in string.
+
+        \param str input string.
+        \param from first phrase.
+        \param to second phrase.
+        \return boolean parameter show success or failure of function
+*/
+W_API bool replace_string(std::string &str, const std::string &from,
+                          const std::string &to);
+
+/*!
+        The function gets a string as input and return the boolean
+   representation of the input.
+
+        \param pVariable the string input.
+        \return the boolean representain of the input string.
+*/
+W_API bool string_2_boolean(std::string pVariable);
+
+/*!
+        The function gets a string as input, the string contains numbers of int
+   numbers separated by spaces and split them and return them in a vector of
+   integers.
+
+        \param pVideoResult The result of the video.
+        \param pOutputImageFolderPath The path for the output image folder.
+        \param pVideoPath The path of the game video.
+        \return
+*/
+W_API auto store_image_in_folder(
+    _In_ std::vector<w_referee::match_result_struct> &pVideoResult,
+    _In_ std::string pOutputImageFolderPath, _In_ std::string pVideoPath)
+    -> void;
+
+W_API void write_in_file_append(std::string file_path, std::string content);
+
+W_API void write_in_file(std::string file_path, std::string content);
+W_API std::vector<std::string> split_string(std::string input_string,
+                                            char reference);
+
+/*!
+        The function stores the video output text result in the pOutputTextPath
+   file path.
+
+        \param pVideoResult The result of the video.
+        \param pOutputTextPath The path for the output text file.
+        \return
+*/
+W_API auto write_results_in_file(
+    _In_ std::vector<w_referee::match_result_struct> &pVideoResult,
+    _In_ std::string pOutputTextPath) -> void;
+
+/*!
+        The function reads all lines of the input file and returns them in a
+   string vector.
+
+        \param pFilePath The path of the input file.
+        \return a vector of strings.
+*/
+W_API auto read_text_file_line_by_line(_In_ std::string pFilePath)
+    -> std::vector<std::string>;
+
+/*!
+        The .env file may have empty or commented lines. The
+   is_line_contains_variable functions use to detect these lines.
+
+        \param pStr The input string.
+        \return False, if the input string contains # or is empty.
+*/
+W_API auto is_line_contains_variable(const std::string pStr) -> bool;
+
+/*!
+        The function reads environment variables from the .env file and set them
+   in the environment by using the putenv function.
+
+        \param pDotEnvFilePath The path of the .env file.
+        \return
+*/
+W_API auto set_env(_In_ const char *pDotEnvFilePath) -> void;
+
+/*!
+        The function return the value of an environment variable based on the
+   input key.
+
+        \param pKey The path of the .env file.
+        \return the value of the variable in int.
+*/
+W_API auto get_env_int(_In_ const char *pKey) -> int;
+
+/*!
+        The function return the value of an environment variable based on the
+   input key.
+
+        \param pKey The path of the .env file.
+        \return the value of the variable in float.
+*/
+W_API auto get_env_float(_In_ const char *pKey) -> float;
+
+/*!
+        The function return the value of an environment variable based on the
+   input key.
+
+        \param pKey The path of the .env file.
+        \return the value of the variable in boolean.
+*/
+W_API auto get_env_boolean(_In_ const char *pKey) -> bool;
+
+/*!
+        The function return the value of an environment variable based on the
+   input key.
+
+        \param pKey The path of the .env file.
+        \return the value of the variable in string.
+*/
+W_API auto get_env_string(_In_ const char *pKey) -> std::string;
+
+/*!
+        The function return the value of an environment variable based on the
+   input key.
+
+        \param pKey The path of the .env file.
+        \return The value of the variable in cv::Rect.
+*/
+W_API auto get_env_cv_rect(_In_ const char *pKey) -> cv::Rect;
+
+/*!
+        The function returns the related root path compared to the current path.
+
+        \return The related root path compared to the current path.
+*/
+W_API auto get_relative_path_to_root() -> std::string;
+
+/*!
+        The get_first_character_of_string function returns the first character
+   of the string.
+
+        \param pStr The input string.
+        \param pScape if true then return input string without any change.
+        \return The first character of input string.
+*/
+W_API auto get_first_character_of_string(_In_ std::string pStr,
+                                         _In_ bool pEscape) -> std::string;
+} // namespace wolf::ml::ocr
diff --git a/wolf/ml/test/w_image_processor_test.cpp b/wolf/ml/test/w_image_processor_test.cpp
new file mode 100644
index 000000000..d2f66e917
--- /dev/null
+++ b/wolf/ml/test/w_image_processor_test.cpp
@@ -0,0 +1,168 @@
+#include "w_image_processor.h"
+
+#include <catch2/catch_all.hpp>
+#include <filesystem>
+#include <opencv2/opencv.hpp>
+
+namespace fs = std::filesystem;
+fs::path image_processor_path =
+    "../../../ocr/common_test_asset/image_processor";
+
+TEST_CASE("prepare_image_for_contour_detection with default arguments",
+          "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  fs::path desired_image_path =
+      image_processor_path / "prepare_image_for_contour_detection_default.png";
+  cv::Mat desired_image_temp = cv::imread(desired_image_path.string());
+  cv::Mat desired_image;
+  cv::cvtColor(desired_image_temp, desired_image, cv::COLOR_BGR2GRAY);
+  config_for_ocr_struct config_for_ocr_struct;
+  cv::Mat processed_image =
+      prepare_image_for_contour_detection(source_image, config_for_ocr_struct);
+  cv::Mat diff = processed_image != desired_image;
+  CHECK(cv::countNonZero(diff) == 0);
+}
+
+TEST_CASE("negative_image with default arguments",
+          "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  fs::path desired_image_path =
+      image_processor_path / "negative_image_default.png";
+  cv::Mat desired_image = cv::imread(desired_image_path.string());
+  negative_image(source_image);
+  CHECK((sum(source_image != desired_image) == cv::Scalar(0, 0, 0, 0)));
+}
+
+TEST_CASE("make_white_background with default arguments",
+          "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  fs::path desired_image_temp =
+      image_processor_path / "make_white_background_default.png";
+  cv::Mat desired_image = cv::imread(desired_image_temp.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.make_white_background = true;
+  make_contour_white_background(source_image, config_for_ocr_struct);
+  CHECK((sum(source_image != desired_image) == cv::Scalar(0, 0, 0, 0)));
+}
+
+TEST_CASE("make_white_background with threshold 50",
+          "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  fs::path desired_image_temp =
+      image_processor_path / "make_white_background_50.png";
+  cv::Mat desired_image = cv::imread(desired_image_temp.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.make_white_background = true;
+  config_for_ocr_struct.white_background_threshold = 50;
+  make_contour_white_background(source_image, config_for_ocr_struct);
+  CHECK((sum(source_image != desired_image) == cv::Scalar(0, 0, 0, 0)));
+}
+
+TEST_CASE("find_all_contours on image with contours",
+          "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  cv::Mat filtered_image =
+      prepare_image_for_contour_detection(source_image, config_for_ocr_struct);
+  std::vector<std::vector<cv::Point>> contours =
+      find_all_countors(filtered_image);
+  CHECK(contours.size() == 475);
+}
+
+TEST_CASE("find_all_contours on image without contours",
+          "[w_image_processor_test.cpp]") {
+  fs::path source_image_path =
+      image_processor_path / "find_all_contours_solid_black.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  cv::Mat filtered_image =
+      prepare_image_for_contour_detection(source_image, config_for_ocr_struct);
+  std::vector<std::vector<cv::Point>> contours =
+      find_all_countors(filtered_image);
+  CHECK(contours.size() == 0);
+}
+
+TEST_CASE("resize_function with only height argument",
+          "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  resize_image(source_image, 40);
+  CHECK(source_image.rows == 40);
+}
+
+TEST_CASE("resize_function with only width argument",
+          "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  resize_image(source_image, -1, 60);
+  CHECK(source_image.cols == 60);
+}
+
+TEST_CASE("resize_function without argument", "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  int cols = source_image.cols;
+  int rows = source_image.rows;
+  resize_image(source_image);
+  CHECK(source_image.cols == cols);
+  CHECK(source_image.rows == rows);
+}
+
+TEST_CASE("gaussian_filter with default argument",
+          "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  fs::path desired_image_path =
+      image_processor_path / "gaussian_filter_default.png";
+  cv::Mat desired_image = cv::imread(desired_image_path.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  gaussian_blur(source_image, config_for_ocr_struct);
+  CHECK((sum(source_image != desired_image) == cv::Scalar(0, 0, 0, 0)));
+}
+
+TEST_CASE("gaussian_filter with win size 7", "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  fs::path desired_image_path = image_processor_path / "gaussian_filter_7.png";
+  cv::Mat desired_image = cv::imread(desired_image_path.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.gaussian_blur_win_size = 7;
+  gaussian_blur(source_image, config_for_ocr_struct);
+  CHECK((sum(source_image != desired_image) == cv::Scalar(0, 0, 0, 0)));
+}
+
+TEST_CASE("threshold_filter with default argument ",
+          "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  fs::path desired_image_path =
+      image_processor_path / "threshold_filter_default.png";
+  cv::Mat desired_image_temp = cv::imread(desired_image_path.string());
+  cv::Mat desired_image;
+  cv::cvtColor(desired_image_temp, desired_image, cv::COLOR_BGR2GRAY);
+  config_for_ocr_struct config_for_ocr_struct;
+  threshold_image(source_image, config_for_ocr_struct);
+  cv::Mat diff = source_image != desired_image;
+  CHECK(cv::countNonZero(diff) == 0);
+}
+
+TEST_CASE("threshold_filter with threshold value 180 ",
+          "[w_image_processor_test.cpp]") {
+  fs::path source_image_path = image_processor_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  fs::path desired_image_path =
+      image_processor_path / "threshold_filter_180.png";
+  cv::Mat desired_image_temp = cv::imread(desired_image_path.string());
+  cv::Mat desired_image;
+  cv::cvtColor(desired_image_temp, desired_image, cv::COLOR_BGR2GRAY);
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.threshold_value = 180;
+  threshold_image(source_image, config_for_ocr_struct);
+  cv::Mat diff = desired_image != desired_image;
+  CHECK(cv::countNonZero(diff) == 0);
+}
diff --git a/wolf/ml/test/w_ocr_engine_test.cpp b/wolf/ml/test/w_ocr_engine_test.cpp
new file mode 100644
index 000000000..d723d0a34
--- /dev/null
+++ b/wolf/ml/test/w_ocr_engine_test.cpp
@@ -0,0 +1,276 @@
+#include "w_ocr_engine.h"
+
+#include <catch2/catch_all.hpp>
+#include <filesystem>
+#include <opencv2/opencv.hpp>
+
+#include "w_image_processor.h"
+namespace fs = std::filesystem;
+OCR ocr_object;
+fs::path ocr_engine_asset_path = "../../../ocr/common_test_asset/ocr_engine";
+
+TEST_CASE("check_if_overlapped with default arguments on overlapped rects",
+          "[w_ocr_engine_test.cpp]") {
+  cv::Rect rect1(0, 0, 10, 10);
+  cv::Rect rect2(0, 0, 10, 10);
+  config_for_ocr_struct config_for_ocr_struct;
+  CHECK(ocr_object.check_if_overlapped(rect1, rect2, config_for_ocr_struct) ==
+        true);
+}
+
+TEST_CASE("check_if_overlapped with default arguments on non overlapped rects",
+          "[w_ocr_engine_test.cpp]") {
+  cv::Rect rect1(0, 0, 10, 10);
+  cv::Rect rect2(10, 10, 10, 10);
+  config_for_ocr_struct config_for_ocr_struct;
+  CHECK(ocr_object.check_if_overlapped(rect1, rect2, config_for_ocr_struct) ==
+        false);
+}
+
+TEST_CASE("check_if_overlapped with threshold 0.01 ",
+          "[w_ocr_engine_test.cpp]") {
+  cv::Rect rect1(0, 0, 10, 10);
+  cv::Rect rect2(9, 9, 10, 10);
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.overlapped_threshold = 0.01;
+  CHECK(ocr_object.check_if_overlapped(rect1, rect2, config_for_ocr_struct) ==
+        false);
+}
+
+TEST_CASE("check_if_overlapped with threshold 0.009 ",
+          "[w_ocr_engine_test.cpp]") {
+  cv::Rect rect1(0, 0, 10, 10);
+  cv::Rect rect2(9, 9, 10, 10);
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.overlapped_threshold = 0.009;
+  CHECK(ocr_object.check_if_overlapped(rect1, rect2, config_for_ocr_struct) ==
+        true);
+}
+
+TEST_CASE("contours_to_char_structs with default arguments ",
+          "[w_ocr_engine_test.cpp]") {
+  fs::path desired_image_path =
+      ocr_engine_asset_path / "contours_to_char_structs_default.png";
+  cv::Mat desired_image_temp = cv::imread(desired_image_path.string());
+  cv::Mat desired_image;
+  cv::cvtColor(desired_image_temp, desired_image, cv::COLOR_BGR2GRAY);
+  std::vector<std::vector<cv::Point>> contours =
+      find_all_countors(desired_image);
+  std::vector<OCR::characters_struct> characters =
+      ocr_object.contours_to_char_structs(contours);
+  CHECK(characters.size() == 475);
+}
+
+TEST_CASE(
+    "contours_to_char_structs with default arguments on empty contour vector ",
+    "[w_ocr_engine_test.cpp]") {
+  fs::path desired_image_path =
+      ocr_engine_asset_path / "contours_to_char_structs_Solid_black.png";
+  cv::Mat desired_image_temp = cv::imread(desired_image_path.string());
+  cv::Mat desired_image;
+  cv::cvtColor(desired_image_temp, desired_image, cv::COLOR_BGR2GRAY);
+  std::vector<std::vector<cv::Point>> contours =
+      find_all_countors(desired_image);
+  std::vector<OCR::characters_struct> characters =
+      ocr_object.contours_to_char_structs(contours);
+  CHECK(characters.size() == 0);
+}
+
+TEST_CASE("enhance_contour_image_for_model with default arguments ",
+          "[w_ocr_engine_test.cpp]") {
+  fs::path source_image_path = ocr_engine_asset_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  cv::Mat processed_image = source_image.clone();
+  config_for_ocr_struct config_for_ocr_struct;
+  ocr_object.enhance_contour_image_for_model(processed_image,
+                                             config_for_ocr_struct);
+  CHECK((sum(source_image != processed_image) == cv::Scalar(0, 0, 0, 0)));
+}
+
+TEST_CASE("enhance_contour_image_for_model with resize ",
+          "[w_ocr_engine_test.cpp]") {
+  fs::path source_image_path = ocr_engine_asset_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  fs::path desired_image_path =
+      ocr_engine_asset_path / "enhance_contour_image_for_model_resize.png";
+  cv::Mat desired_image = cv::imread(desired_image_path.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.do_resize_contour = true;
+  ocr_object.enhance_contour_image_for_model(source_image,
+                                             config_for_ocr_struct);
+  CHECK((sum(source_image != desired_image) == cv::Scalar(0, 0, 0, 0)));
+}
+
+TEST_CASE("enhance_contour_image_for_model with make_white ",
+          "[w_ocr_engine_test.cpp]") {
+  fs::path source_image_path = ocr_engine_asset_path / "test_image.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  fs::path desired_image_path =
+      ocr_engine_asset_path / "enhance_contour_image_for_model_make_white.png";
+  cv::Mat desired_image = cv::imread(desired_image_path.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.make_white_background = true;
+  ocr_object.enhance_contour_image_for_model(source_image,
+                                             config_for_ocr_struct);
+  CHECK((sum(source_image != desired_image) == cv::Scalar(0, 0, 0, 0)));
+}
+
+TEST_CASE("euclidean_distance with two non overlapped chars ",
+          "[w_ocr_engine_test.cpp]") {
+  OCR::characters_struct char1;
+  OCR::characters_struct char2;
+  char1.center.x = 1;
+  char1.center.y = 1;
+  char2.center.x = 1;
+  char2.center.y = 2;
+  double distance = ocr_object.euclidean_distance(char1, char2);
+  CHECK(distance == 1);
+}
+
+TEST_CASE("euclidean_distance with two overlapped chars ",
+          "[w_ocr_engine_test.cpp]") {
+  OCR::characters_struct char1;
+  OCR::characters_struct char2;
+  char1.center.x = 1;
+  char1.center.y = 1;
+  char2.center.x = 1;
+  char2.center.y = 1;
+  double distance = ocr_object.euclidean_distance(char1, char2);
+  CHECK(distance == 0);
+}
+
+TEST_CASE("euclidean_distance with two empty chars ",
+          "[w_ocr_engine_test.cpp]") {
+  OCR::characters_struct char1;
+  OCR::characters_struct char2;
+  double distance = ocr_object.euclidean_distance(char1, char2);
+  CHECK(distance == 0);
+}
+
+TEST_CASE("filter_chars_by_contour_size without restriction ",
+          "[w_ocr_engine_test.cpp]") {
+  fs::path source_image_path =
+      ocr_engine_asset_path / "filter_chars_by_contour_size.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.restrictions.max_area = 99999999;
+  config_for_ocr_struct.restrictions.min_area = 1;
+  config_for_ocr_struct.restrictions.max_height = 99999999;
+  config_for_ocr_struct.restrictions.min_height = 1;
+  config_for_ocr_struct.restrictions.max_width = 99999999;
+  config_for_ocr_struct.restrictions.min_width = 1;
+  cv::Mat prepared =
+      prepare_image_for_contour_detection(source_image, config_for_ocr_struct);
+  std::vector<std::vector<cv::Point>> contours = find_all_countors(prepared);
+  std::vector<OCR::characters_struct> characters =
+      ocr_object.contours_to_char_structs(contours);
+  std::vector<OCR::characters_struct> filtered_characters =
+      ocr_object.filter_chars_by_contour_size(characters,
+                                              config_for_ocr_struct);
+  CHECK(filtered_characters.size() == 3);
+}
+
+TEST_CASE("filter_chars_by_contour_size by area restriction ",
+          "[w_ocr_engine_test.cpp]") {
+  fs::path source_image_path =
+      ocr_engine_asset_path / "filter_chars_by_contour_size.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.restrictions.max_area = 500000;
+  config_for_ocr_struct.restrictions.min_area = 1;
+  config_for_ocr_struct.restrictions.max_height = 99999999;
+  config_for_ocr_struct.restrictions.min_height = 1;
+  config_for_ocr_struct.restrictions.max_width = 99999999;
+  config_for_ocr_struct.restrictions.min_width = 1;
+  cv::Mat prepared =
+      prepare_image_for_contour_detection(source_image, config_for_ocr_struct);
+  std::vector<std::vector<cv::Point>> contours = find_all_countors(prepared);
+  std::vector<OCR::characters_struct> characters =
+      ocr_object.contours_to_char_structs(contours);
+  std::vector<OCR::characters_struct> filtered_characters =
+      ocr_object.filter_chars_by_contour_size(characters,
+                                              config_for_ocr_struct);
+  CHECK(filtered_characters.size() == 2);
+}
+
+TEST_CASE("filter_chars_by_contour_size by width restriction ",
+          "[w_ocr_engine_test.cpp]") {
+  fs::path source_image_path =
+      ocr_engine_asset_path / "filter_chars_by_contour_size.png";
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.restrictions.max_area = 500000;
+  config_for_ocr_struct.restrictions.min_area = 1;
+  config_for_ocr_struct.restrictions.max_height = 99999999;
+  config_for_ocr_struct.restrictions.min_height = 1;
+  config_for_ocr_struct.restrictions.max_width = 300;
+  config_for_ocr_struct.restrictions.min_width = 1;
+  cv::Mat prepared =
+      prepare_image_for_contour_detection(source_image, config_for_ocr_struct);
+  std::vector<std::vector<cv::Point>> contours = find_all_countors(prepared);
+  std::vector<OCR::characters_struct> characters =
+      ocr_object.contours_to_char_structs(contours);
+  std::vector<OCR::characters_struct> filtered_characters =
+      ocr_object.filter_chars_by_contour_size(characters,
+                                              config_for_ocr_struct);
+  CHECK(filtered_characters.size() == 1);
+}
+
+TEST_CASE("merge_overlapped_contours on two overlapped contours ",
+          "[w_ocr_engine_test.cpp]") {
+  config_for_ocr_struct config_for_ocr_struct;
+  OCR::characters_struct char1;
+  char1.bound_rect.x = 0;
+  char1.bound_rect.y = 0;
+  char1.bound_rect.width = 10;
+  char1.bound_rect.height = 10;
+  OCR::characters_struct char2;
+  char2.bound_rect.x = 0;
+  char2.bound_rect.y = 0;
+  char2.bound_rect.width = 10;
+  char2.bound_rect.height = 10;
+  std::vector<OCR::characters_struct> characters;
+  characters.push_back(char1);
+  characters.push_back(char2);
+  ocr_object.merge_overlapped_contours(characters, config_for_ocr_struct);
+  CHECK(characters.size() == 1);
+}
+
+TEST_CASE("merge_overlapped_contours on two non overlapped contours ",
+          "[w_ocr_engine_test.cpp]") {
+  config_for_ocr_struct config_for_ocr_struct;
+  OCR::characters_struct char1;
+  char1.bound_rect.x = 0;
+  char1.bound_rect.y = 0;
+  char1.bound_rect.width = 10;
+  char1.bound_rect.height = 10;
+  OCR::characters_struct char2;
+  char2.bound_rect.x = 0;
+  char2.bound_rect.y = 10;
+  char2.bound_rect.width = 10;
+  char2.bound_rect.height = 10;
+  std::vector<OCR::characters_struct> characters;
+  characters.push_back(char1);
+  characters.push_back(char2);
+  ocr_object.merge_overlapped_contours(characters, config_for_ocr_struct);
+  CHECK(characters.size() == 2);
+}
+
+TEST_CASE("mask_contour works", "[w_ocr_engine_test.cpp]") {
+  fs::path contours_image_path =
+      ocr_engine_asset_path / "filter_chars_by_contour_size.png";
+  fs::path source_image_path = ocr_engine_asset_path / "test_image.png";
+  fs::path desired_image_path = ocr_engine_asset_path / "mask_contour.png";
+  cv::Mat contours_image = cv::imread(contours_image_path.string());
+  cv::Mat source_image = cv::imread(source_image_path.string());
+  cv::Mat desired_image = cv::imread(desired_image_path.string());
+  config_for_ocr_struct config_for_ocr_struct;
+  config_for_ocr_struct.restrictions.max_area = 500000;
+  cv::Mat prepared = prepare_image_for_contour_detection(contours_image,
+                                                         config_for_ocr_struct);
+  std::vector<std::vector<cv::Point>> contours = find_all_countors(prepared);
+  std::vector<OCR::characters_struct> characters =
+      ocr_object.contours_to_char_structs(contours);
+  cv::Mat processed = ocr_object.mask_contour(source_image, characters[1]);
+  CHECK((sum(processed != desired_image) == cv::Scalar(0, 0, 0, 0)));
+}
diff --git a/wolf/ml/test/w_referee_test.cpp b/wolf/ml/test/w_referee_test.cpp
new file mode 100644
index 000000000..11a8405bc
--- /dev/null
+++ b/wolf/ml/test/w_referee_test.cpp
@@ -0,0 +1,95 @@
+#include "w_referee.h"
+
+#include <catch2/catch_all.hpp>
+#include <filesystem>
+#include <opencv2/opencv.hpp>
+
+#include "w_ocr_engine.h"
+
+namespace fs = std::filesystem;
+fs::path ocr_referee_class_path =
+    "../../../ocr/common_test_asset/ocr_referee_class";
+
+TEST_CASE("concatenate_name_result function", "[w_referee_test.cpp]") {
+  ocr_referee_class ocr_referee_object;
+
+  std::vector<OCR::character_and_center> cluster_temp;
+
+  OCR::character_and_center char_center_temp;
+  char_center_temp.text = "T";
+  char_center_temp.center = cv::Point(5, 20);
+  cluster_temp.push_back(char_center_temp);
+  char_center_temp.text = "e";
+  char_center_temp.center = cv::Point(10, 20);
+  cluster_temp.push_back(char_center_temp);
+  char_center_temp.text = "s";
+  char_center_temp.center = cv::Point(15, 20);
+  cluster_temp.push_back(char_center_temp);
+  char_center_temp.text = "t";
+  char_center_temp.center = cv::Point(20, 20);
+  cluster_temp.push_back(char_center_temp);
+
+  OCR::character_and_center temp_result =
+      ocr_referee_object.concatenate_name_result(cluster_temp);
+
+  REQUIRE(temp_result.text.compare("T e s t") == 0);
+}
+
+TEST_CASE("if_the_string_is_in_the_vector function", "[w_referee_test.cpp]") {
+  ocr_referee_class ocr_referee_object;
+
+  std::vector<ocr_referee_class::vote_over_string_vector> vote_vector_temp;
+  ocr_referee_class::vote_over_string_vector vote_var_temp;
+  vote_var_temp.already_voted = false;
+  vote_var_temp.center = cv::Point(70, 77);
+  vote_var_temp.str = "Test";
+  vote_vector_temp.push_back(vote_var_temp);
+
+  OCR::character_and_center char_temp;
+  char_temp.center = cv::Point(70, 77);
+  char_temp.text = "Test";
+
+  REQUIRE(ocr_referee_object.if_the_string_is_in_the_vector(char_temp,
+                                                            vote_vector_temp));
+}
+
+TEST_CASE("voting_over_results_and_names function", "[w_referee_test.cpp]") {
+  ocr_referee_class ocr_referee_object;
+
+  std::vector<ocr_referee_class::frame_result_struct> all_results_temp;
+  ocr_referee_class::frame_result_struct frame_date_temp;
+
+  frame_date_temp.frame_number = 110;
+  frame_date_temp.away_name.text = "ENGLAND";
+  frame_date_temp.away_result.text = "1";
+  frame_date_temp.home_name.text = "IRAN";
+  frame_date_temp.home_result.text = "2";
+  frame_date_temp.stat = ocr_referee_class::final_result;
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  frame_date_temp.away_result.text = "3";
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+  all_results_temp.push_back(frame_date_temp);
+
+  ocr_referee_class::frame_result_struct frame_date_result;
+
+  ocr_referee_object.voting_over_results_and_names(frame_date_result,
+                                                   all_results_temp);
+
+  REQUIRE(frame_date_result.away_result.text.compare("1") == 0);
+}
diff --git a/wolf/ml/test/w_soccer_test.cpp b/wolf/ml/test/w_soccer_test.cpp
new file mode 100644
index 000000000..91b2ad637
--- /dev/null
+++ b/wolf/ml/test/w_soccer_test.cpp
@@ -0,0 +1,235 @@
+#include "w_soccer.h"
+
+#include <catch2/catch_all.hpp>
+#include <filesystem>
+#include <new>
+#include <opencv2/opencv.hpp>
+
+#include "w_ocr_engine.h"
+#include "w_read_video_frames.h"
+#include "w_referee.h"
+#include "w_utilities.h"
+
+namespace fs = std::filesystem;
+fs::path soccer_asset_path = "../../../ocr/common_test_asset/soccer";
+
+TEST_CASE("set_config function", "[w_soccer_test.cpp]") {
+  fs::path env_file_path = soccer_asset_path / ".set_config";
+
+  set_env(env_file_path.string().c_str());
+
+  char *type = new char[50];
+  snprintf(type, 50, "SOCCER_SCREEN_IDENTITY");
+  OCR::config_struct screen_identity = w_soccer::set_config(type);
+
+  delete[] type;
+
+  REQUIRE(!screen_identity.config_for_ocr.verbose);
+  REQUIRE(screen_identity.config_for_ocr.restrictions.max_area == 105);
+  REQUIRE(screen_identity.name.compare("window_name_test") == 0);
+}
+
+std::vector<ocr_referee_class::match_result_struct> video_result;
+typedef void ocr_callback(char *, int, uint8_t *, int, int);
+
+void ocr_result(char *pResultBuffer, int pResultBufferSize,
+                uint8_t *pImageBuffer, int pImageWidth, int pImageHeight) {
+  ocr_referee_class::match_result_struct match_result_temp;
+  std::string temp(pResultBuffer);
+  std::vector<std::string> result_vec = split_string(temp, ',');
+
+  match_result_temp.stat = result_vec[0];
+  match_result_temp.home_name.text = result_vec[1];
+  match_result_temp.home_result.text = result_vec[2];
+  match_result_temp.away_name.text = result_vec[3];
+  match_result_temp.away_result.text = result_vec[4];
+
+  cv::Mat image = cv::Mat(pImageHeight, pImageWidth, CV_8UC3, pImageBuffer);
+
+  match_result_temp.result_image = image;
+  video_result.push_back(match_result_temp);
+}
+
+TEST_CASE("single_image_result_extraction function", "[w_soccer_test.cpp]") {
+  fs::path json_file_path =
+      soccer_asset_path / ".single_image_result_extraction";
+  fs::path video_path =
+      soccer_asset_path / "single_image_result_extraction.mp4";
+
+  set_env(json_file_path.string().c_str());
+
+  ocr_callback *_callback = &ocr_result;
+
+  w_soccer *referee_obj = new w_soccer();
+
+  // This is an example of using the Project
+  read_video_frames player(video_path.string());
+  int number_of_frames = int(player.get_frame_amount());
+
+  cv::Mat frame;
+  for (int i = 0; i < number_of_frames; i++) {
+    frame = player.read_video_frame_by_frame();
+    if (frame.empty()) {
+      break;
+    }
+
+    char *res_str = new char[256];
+    referee_obj->single_image_result_extraction(frame.data, frame.rows,
+                                                frame.cols, _callback);
+  }
+  frame.release();
+
+  std::cout << "Results: " << video_result[0].stat << " "
+            << video_result[0].home_name.text << " "
+            << video_result[0].away_name.text << " "
+            << video_result[0].home_result.text << " "
+            << video_result[0].away_result.text << std::endl;
+
+  REQUIRE(video_result[0].stat.compare("90 00") == 0);
+  REQUIRE(video_result[0].home_name.text.compare("ARSENAL") == 0);
+  REQUIRE(video_result[0].away_name.text.compare("FC BAYERN") == 0);
+  REQUIRE(video_result[0].home_result.text.compare("0") == 0);
+  REQUIRE(video_result[0].away_result.text.compare("8") == 0);
+}
+
+TEST_CASE("fill_stat_map function", "[w_soccer_test.cpp]") {
+  fs::path json_file_path = soccer_asset_path / ".fill_stat_map";
+
+  set_env(json_file_path.string().c_str());
+
+  w_soccer referee_obj;
+
+  std::map<std::string, std::string> stat_map = referee_obj.get_stat_map();
+
+  REQUIRE(stat_map["45 00"].compare("first_half") == 0);
+  REQUIRE(stat_map["90 00"].compare("second_half") == 0);
+  // REQUIRE(referee_obj->stat_extra_first_half.compare("105 00") == 0);
+  // REQUIRE(referee_obj->stat_extra_second_half.compare("120 00") == 0);
+  // REQUIRE(referee_obj->stat_penalty.compare("penalty") == 0);
+}
+
+TEST_CASE("replace_team_names_with_most_similar_string finds similar team to "
+          "REALMDRD",
+          "[w_soccer_test.cpp]") {
+  std::vector<ocr_referee_class::match_result_struct> results;
+  ocr_referee_class::match_result_struct result;
+
+  fs::path similar_strings_path =
+      soccer_asset_path / ".replace_team_names_with_most_similar_string";
+
+  set_env(similar_strings_path.string().c_str());
+
+  result.away_name.text = "REALMDRD";
+  results.push_back(result);
+
+  w_soccer::replace_team_names_with_most_similar_string(results);
+
+  REQUIRE(results[0].away_name.text.compare("REAL MADRID") == 0);
+}
+
+TEST_CASE("initial_match_result_struct function", "[w_soccer_test.cpp]") {
+  fs::path json_file_path = soccer_asset_path / ".initial_match_result_struct";
+
+  set_env(json_file_path.string().c_str());
+
+  ocr_referee_class::frame_result_struct frame_data;
+  frame_data.away_name.text = "IRAN";
+  frame_data.away_result.text = "3";
+  frame_data.home_name.text = "ENGLAND";
+  frame_data.home_result.text = "3";
+  frame_data.frame_number = 114;
+  frame_data.stat = "first_half";
+  cv::Mat image = cv::Mat::zeros(50, 50, CV_8UC3);
+
+  w_soccer soccer_object;
+
+  ocr_referee_class::match_result_struct match_struct_temp;
+  match_struct_temp =
+      soccer_object.initial_match_result_struct(frame_data, image);
+
+  image.release();
+  REQUIRE(match_struct_temp.all_frames_results[0].away_name.text.compare(
+              "IRAN") == 0);
+  REQUIRE(match_struct_temp.stat.compare("first_half") == 0);
+  REQUIRE(match_struct_temp.all_frames_results[0].away_result.text.compare(
+              "3") == 0);
+}
+
+TEST_CASE("update_match_data function", "[w_soccer_test.cpp]") {
+  fs::path json_file_path = soccer_asset_path / ".update_match_data";
+
+  set_env(json_file_path.string().c_str());
+
+  ocr_referee_class::frame_result_struct frame_data;
+  frame_data.away_name.text = "IRAN";
+  frame_data.away_result.text = "3";
+  frame_data.home_name.text = "ENGLAND";
+  frame_data.home_result.text = "3";
+  frame_data.frame_number = 114;
+  frame_data.stat = "first_half";
+  cv::Mat image = cv::Mat::zeros(50, 50, CV_8UC3);
+
+  w_soccer soccer_object;
+
+  std::vector<ocr_referee_class::match_result_struct> match_data_temp;
+  match_data_temp = soccer_object.get_matches_data();
+  REQUIRE(match_data_temp.size() == 0);
+
+  soccer_object.update_match_data(frame_data, image);
+  frame_data.frame_number = 116;
+  soccer_object.update_match_data(frame_data, image);
+  frame_data.frame_number = 117;
+  soccer_object.update_match_data(frame_data, image);
+
+  match_data_temp = soccer_object.get_matches_data();
+  REQUIRE(match_data_temp.size() == 1);
+
+  frame_data.frame_number = 210;
+  soccer_object.update_match_data(frame_data, image);
+
+  match_data_temp = soccer_object.get_matches_data();
+  REQUIRE(match_data_temp.size() == 2);
+  REQUIRE(match_data_temp[1].all_frames_results[0].frame_number == 210);
+}
+
+TEST_CASE("get_matches_data function", "[w_soccer_test.cpp]") {
+  fs::path json_file_path = soccer_asset_path / ".update_match_data";
+
+  set_env(json_file_path.string().c_str());
+
+  ocr_referee_class::frame_result_struct frame_data;
+  frame_data.away_name.text = "IRAN";
+  frame_data.away_result.text = "3";
+  frame_data.home_name.text = "ENGLAND";
+  frame_data.home_result.text = "3";
+  frame_data.frame_number = 114;
+  frame_data.stat = "first_half";
+  cv::Mat image = cv::Mat::zeros(50, 50, CV_8UC3);
+
+  w_soccer soccer_object;
+
+  std::vector<ocr_referee_class::match_result_struct> match_data_temp;
+  soccer_object.update_match_data(frame_data, image);
+  match_data_temp = soccer_object.get_matches_data();
+  REQUIRE(match_data_temp.size() == 1);
+  REQUIRE(match_data_temp[0].all_frames_results[0].frame_number == 114);
+}
+
+TEST_CASE("replace_team_names_with_most_similar_string finds similar team to "
+          "empty string",
+          "[w_soccer_test.cpp]") {
+  std::vector<ocr_referee_class::match_result_struct> results;
+  ocr_referee_class::match_result_struct result;
+
+  fs::path similar_strings_path =
+      soccer_asset_path / ".replace_team_names_with_most_similar_string";
+
+  set_env(similar_strings_path.string().c_str());
+
+  result.away_name.text = "";
+  results.push_back(result);
+
+  w_soccer::replace_team_names_with_most_similar_string(results);
+
+  REQUIRE(results[0].away_name.text.compare("") == 0);
+}
diff --git a/wolf/ml/test/w_utilities_test.cpp b/wolf/ml/test/w_utilities_test.cpp
new file mode 100644
index 000000000..6687f2b46
--- /dev/null
+++ b/wolf/ml/test/w_utilities_test.cpp
@@ -0,0 +1,321 @@
+#include "w_utilities.h"
+
+#include <catch2/catch_all.hpp>
+#include <filesystem>
+#include <opencv2/opencv.hpp>
+
+namespace fs = std::filesystem;
+
+fs::path utilities_asset_path = "../../../ocr/common_test_asset/utilities";
+
+TEST_CASE("get_value_from_json_file_by_key gives value by key",
+          "[w_utilities_test.cpp]") {
+  fs::path json_file_path =
+      utilities_asset_path / "get_value_from_json_file_by_key.json";
+  std::string key = "cpp-test-json";
+  std::string value =
+      get_value_from_json_file_by_key(json_file_path.string(), key);
+  REQUIRE(value.compare("ready") == 0);
+}
+
+TEST_CASE("string_2_boolean on capitalized characters",
+          "[w_utilities_test.cpp]") {
+  std::vector<std::string> list_string;
+  list_string.push_back("true");
+  list_string.push_back("FalSe");
+  bool temp;
+  temp = string_2_boolean(list_string[0]);
+  REQUIRE(temp);
+  temp = string_2_boolean(list_string[1]);
+  REQUIRE(!temp);
+}
+
+TEST_CASE("line_of_numbers_in_string_to_vector_of_integers function",
+          "[w_utilities_test.cpp]") {
+  std::string temp = "100,200,300,400";
+  std::vector<int> integer_list =
+      line_of_numbers_in_string_to_vector_of_integers(temp);
+  REQUIRE(integer_list[0] == 100);
+  REQUIRE(integer_list[1] == 200);
+  REQUIRE(integer_list[2] == 300);
+  REQUIRE(integer_list[3] == 400);
+}
+
+TEST_CASE("store_image_in_folder function", "[w_utilities_test.cpp]") {
+  std::vector<ocr_referee_class::match_result_struct> temp_video_result;
+  ocr_referee_class::match_result_struct temp;
+  ocr_referee_class::frame_result_struct frame_result;
+
+  frame_result.home_name.text = "Home";
+  frame_result.home_result.text = "2";
+  frame_result.away_name.text = "Away";
+  frame_result.away_result.text = "1";
+  frame_result.frame_number = 3;
+  frame_result.stat = "first_half";
+  int height = 50;
+  int width = 50;
+  temp.result_image = cv::Mat::zeros(height, width, CV_8UC3);
+  temp.all_frames_results.push_back(frame_result);
+  temp_video_result.push_back(temp);
+
+  std::string output_folder_path = ".";
+  fs::path temp_video_path = "../test/123.mp4";
+  store_image_in_folder(temp_video_result, output_folder_path,
+                        temp_video_path.string());
+
+  fs::path file_path = "./123_0.png";
+
+  bool is_file_exist = false;
+  if (std::filesystem::remove(file_path.string())) {
+    is_file_exist = true;
+  }
+  REQUIRE(is_file_exist);
+}
+
+TEST_CASE("write_results_in_file function", "[w_utilities_test.cpp]") {
+  std::vector<ocr_referee_class::match_result_struct> temp_video_result;
+  ocr_referee_class::match_result_struct temp;
+  ocr_referee_class::frame_result_struct frame_result;
+
+  frame_result.home_name.text = "Home";
+  frame_result.home_result.text = "2";
+  frame_result.away_name.text = "Away";
+  frame_result.away_result.text = "1";
+  frame_result.frame_number = 3;
+  frame_result.stat = "first_half";
+  int height = 50;
+  int width = 50;
+  temp.result_image = cv::Mat::zeros(height, width, CV_8UC3);
+  temp.all_frames_results.push_back(frame_result);
+  temp_video_result.push_back(temp);
+
+  fs::path temp_output_text_file = "./test_write_results_in_file.txt";
+
+  write_results_in_file(temp_video_result, temp_output_text_file.string());
+
+  std::vector<std::string> lines =
+      read_text_file_line_by_line(temp_output_text_file.string());
+
+  if (!std::filesystem::remove(temp_output_text_file.string())) {
+    REQUIRE(false);
+  }
+
+  REQUIRE(lines[0].compare(temp_video_result[0].stat + "," +
+                           temp_video_result[0].home_name.text + "," +
+                           temp_video_result[0].home_result.text + "," +
+                           temp_video_result[0].away_name.text + "," +
+                           temp_video_result[0].away_result.text + "," +
+                           std::to_string(temp_video_result[0].frame_number)) ==
+          0);
+}
+
+TEST_CASE("read_text_file_line_by_line function", "[w_utilities_test.cpp]") {
+  fs::path file_path = "./test_read_text_file_line_by_line.txt";
+  std::string content = "This is a test!";
+
+  write_in_file_append(file_path.string(), content);
+  std::vector<std::string> lines =
+      read_text_file_line_by_line(file_path.string());
+
+  if (!std::filesystem::remove(file_path.string())) {
+    REQUIRE(false);
+  }
+
+  REQUIRE(lines[0].compare(content) == 0);
+}
+
+TEST_CASE("normalized_levenshtein_similarity on one empty argument",
+          "[w_utilities_test.cpp]") {
+  float similarity = normalized_levenshtein_similarity("", "text");
+  REQUIRE(similarity == 0);
+}
+
+TEST_CASE("normalized_levenshtein_similarity on two empty argument",
+          "[w_utilities_test.cpp]") {
+  float similarity = normalized_levenshtein_similarity("", "");
+  REQUIRE(similarity == 0);
+}
+
+TEST_CASE("normalized_levenshtein_similarity on two equal string",
+          "[w_utilities_test.cpp]") {
+  float similarity = normalized_levenshtein_similarity("test", "test");
+  REQUIRE(similarity == 1);
+}
+
+TEST_CASE("normalized_levenshtein_similarity with similarity 0.5 on strings",
+          "[w_utilities_test.cpp]") {
+  float similarity = normalized_levenshtein_similarity("test", "mast");
+  REQUIRE(similarity == 0.5);
+}
+
+TEST_CASE("normalized_levenshtein_similarity on same numbers",
+          "[w_utilities_test.cpp]") {
+  float similarity = normalized_levenshtein_similarity("1234", "1234");
+  REQUIRE(similarity == 1);
+}
+
+TEST_CASE("normalized_levenshtein_similarity on strings with different length",
+          "[w_utilities_test.cpp]") {
+  float similarity = normalized_levenshtein_similarity("test", "tst");
+  REQUIRE(similarity == 0.75);
+}
+
+TEST_CASE("get_nearest_string with threshold 0.5 returns similar string",
+          "[w_utilities_test.cpp]") {
+  fs::path similar_strings_path =
+      utilities_asset_path / ".get_nearest_string_0_5";
+
+  set_env(similar_strings_path.string().c_str());
+
+  std::string path = get_env_string("SIMILAR_STRINGS_FILE_PATH");
+  std::string output = get_nearest_string("tst1", path);
+  REQUIRE(output.compare("test1") == 0);
+}
+
+TEST_CASE("get_nearest_string with threshold 0.9 returns input",
+          "[w_utilities_test.cpp]") {
+  fs::path similar_strings_path =
+      utilities_asset_path / ".get_nearest_string_0_9";
+
+  set_env(similar_strings_path.string().c_str());
+
+  std::string path = get_env_string("SIMILAR_STRINGS_FILE_PATH");
+  std::string output = get_nearest_string("tst1", path);
+  REQUIRE(output.compare("tst1") == 0);
+}
+
+TEST_CASE("get_nearest_string on empty string returns empty string",
+          "[w_utilities_test.cpp]") {
+  fs::path similar_strings_path =
+      utilities_asset_path / ".get_nearest_string_0_5";
+
+  set_env(similar_strings_path.string().c_str());
+
+  std::string path = get_env_string("SIMILAR_STRINGS_FILE_PATH");
+  std::string output = get_nearest_string("", path);
+  REQUIRE(output.compare("") == 0);
+}
+
+TEST_CASE("replace_string first phrase exists in text",
+          "[w_utilities_test.cpp]") {
+  std::string text = "hello hamed";
+  replace_string(text, "hamed", "bagher");
+  REQUIRE(text.compare("hello bagher") == 0);
+}
+
+TEST_CASE("replace_string returns text if first phrase not exists in text",
+          "[w_utilities_test.cpp]") {
+  std::string text = "hello hamed";
+  replace_string(text, "shahoo", "bagher");
+  REQUIRE(text.compare("hello hamed") == 0);
+}
+
+TEST_CASE("replace_string returns empty text if input text was empty",
+          "[w_utilities_test.cpp]") {
+  std::string text = "";
+  replace_string(text, "shahoo", "bagher");
+  REQUIRE(text.compare("") == 0);
+}
+
+TEST_CASE("is_line_contains_variable function find empty line",
+          "[w_utilities_test.cpp]") {
+  const std::string content = "";
+
+  REQUIRE(!is_line_contains_variable(content));
+}
+
+TEST_CASE("is_line_contains_variable function find line started by #",
+          "[w_utilities_test.cpp]") {
+  const std::string content = "# This is a commented line!";
+
+  REQUIRE(!is_line_contains_variable(content));
+}
+
+TEST_CASE("set_env function", "[w_utilities_test.cpp]") {
+  fs::path dot_env_file_path = utilities_asset_path / ".set_env";
+
+  set_env(dot_env_file_path.string().c_str());
+
+  if (const char *env_p1 = getenv("V1")) {
+    std::string temp(env_p1);
+    REQUIRE(temp.compare("v1") == 0);
+  }
+  if (const char *env_p2 = getenv("V2")) {
+    std::string temp(env_p2);
+    REQUIRE(temp.compare("v2") == 0);
+  }
+  if (const char *env_p3 = getenv("V3")) {
+    std::string temp(env_p3);
+    REQUIRE(temp.compare("v3") == 0);
+  }
+  if (const char *env_p4 = getenv("V4")) {
+    std::string temp(env_p4);
+    REQUIRE(temp.compare("v4") == 0);
+  }
+}
+
+TEST_CASE("get_env_int function", "[w_utilities_test.cpp]") {
+  fs::path dot_env_file_path = utilities_asset_path / ".get_env_int";
+
+  set_env(dot_env_file_path.string().c_str());
+
+  std::string key = "INT_VALUE";
+  int value = get_env_int(key.c_str());
+
+  REQUIRE(value == 7);
+}
+
+TEST_CASE("get_env_float function", "[w_utilities_test.cpp]") {
+  fs::path dot_env_file_path = utilities_asset_path / ".get_env_float";
+
+  set_env(dot_env_file_path.string().c_str());
+
+  std::string key = "FLOAT_VALUE";
+  float value = get_env_float(key.c_str());
+
+  REQUIRE(value == 4.5);
+}
+
+TEST_CASE("get_env_boolean function", "[w_utilities_test.cpp]") {
+  fs::path dot_env_file_path = utilities_asset_path / ".get_env_boolean";
+
+  set_env(dot_env_file_path.string().c_str());
+
+  std::string key = "BOOLEAN_VALUE";
+  bool value = get_env_boolean(key.c_str());
+
+  REQUIRE(value);
+}
+
+TEST_CASE("get_env_string function", "[w_utilities_test.cpp]") {
+  fs::path dot_env_file_path = utilities_asset_path / ".get_env_string";
+
+  set_env(dot_env_file_path.string().c_str());
+
+  std::string key = "STRING_VALUE";
+  std::string value = get_env_string(key.c_str());
+
+  REQUIRE(value.compare("this is a test! == 0"));
+}
+
+TEST_CASE("get_env_cv_rect function", "[w_utilities_test.cpp]") {
+  fs::path dot_env_file_path = utilities_asset_path / ".get_env_cv_rect";
+
+  set_env(dot_env_file_path.string().c_str());
+
+  std::string key = "CV_RECT_VALUE";
+  cv::Rect value = get_env_cv_rect(key.c_str());
+
+  REQUIRE(value.x == 313);
+  REQUIRE(value.y == 110);
+  REQUIRE(value.width == 72);
+  REQUIRE(value.height == 14);
+}
+
+TEST_CASE("get_relative_path_to_root function", "[w_utilities_test.cpp]") {
+  std::string temp = get_relative_path_to_root();
+
+  bool result = (temp.compare("../") == 0 || temp.compare("../../../") == 0);
+
+  REQUIRE(result);
+}
